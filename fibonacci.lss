
fibonacci.avr-atmega128rfa1:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000dda  00800200  0000a164  0000a258  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000a164  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001e07  00800fda  00800fda  0000b032  2**0
                  ALLOC
  3 .eeprom       00000029  00810000  00810000  0000b032  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fuse         00000003  00820000  00820000  0000b05b  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .signature    00000003  00840000  00840000  0000b05e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .stab         000032dc  00000000  00000000  0000b064  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .stabstr      000010e3  00000000  00000000  0000e340  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000005c0  00000000  00000000  0000f423  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000020a8  00000000  00000000  0000f9e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000df6e  00000000  00000000  00011a8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00004888  00000000  00000000  0001f9f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00009a9d  00000000  00000000  00024281  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000018b0  00000000  00000000  0002dd20  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003b0a  00000000  00000000  0002f5d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00006d74  00000000  00000000  000330da  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_pubtypes 00001789  00000000  00000000  00039e4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000090  00000000  00000000  0003b5d7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b2 01 	jmp	0x364	; 0x364 <__ctors_end>
       4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
       8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
       c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      10:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      14:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      18:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      1c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      20:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      24:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      28:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      2c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      30:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      34:	0c 94 84 38 	jmp	0x7108	; 0x7108 <__vector_13>
      38:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      3c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      40:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      44:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      48:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      4c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      50:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      54:	0c 94 0b 1d 	jmp	0x3a16	; 0x3a16 <__vector_21>
      58:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      5c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      60:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      64:	0c 94 80 1d 	jmp	0x3b00	; 0x3b00 <__vector_25>
      68:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      6c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      70:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      74:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      78:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      7c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      80:	0c 94 21 37 	jmp	0x6e42	; 0x6e42 <__vector_32>
      84:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      88:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      8c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      90:	0c 94 af 1d 	jmp	0x3b5e	; 0x3b5e <__vector_36>
      94:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      98:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      9c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      a0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      a4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      a8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      ac:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      b0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      b4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      b8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      bc:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      c0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      c4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      c8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      cc:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      d0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      d4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      d8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      dc:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      e0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      e4:	0c 94 c7 25 	jmp	0x4b8e	; 0x4b8e <__vector_57>
      e8:	0c 94 d1 25 	jmp	0x4ba2	; 0x4ba2 <__vector_58>
      ec:	0c 94 bd 25 	jmp	0x4b7a	; 0x4b7a <__vector_59>
      f0:	0c 94 77 25 	jmp	0x4aee	; 0x4aee <__vector_60>
      f4:	0c 94 fd 25 	jmp	0x4bfa	; 0x4bfa <__vector_61>
      f8:	0c 94 f3 25 	jmp	0x4be6	; 0x4be6 <__vector_62>
      fc:	0c 94 e7 25 	jmp	0x4bce	; 0x4bce <__vector_63>
     100:	0c 94 db 25 	jmp	0x4bb6	; 0x4bb6 <__vector_64>
     104:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     108:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     10c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     110:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     114:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     118:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     11c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>

00000120 <__c.4587>:
     120:	25 73 25 73 0a 00                                   %s%s..

00000126 <__c.4577>:
     126:	4e 65 76 65 72 2d 75 73 65 64 20 73 74 61 63 6b     Never-used stack
     136:	20 3e 20 25 64 20 62 79 74 65 73 0a 00               > %d bytes..

00000143 <__c.4567>:
     143:	4f 6e 6c 69 6e 65 0a 00                             Online..

0000014b <__c.4565>:
     14b:	25 73 20 25 73 2c 20 63 68 61 6e 6e 65 6c 20 25     %s %s, channel %
     15b:	75 20 2c 20 63 68 65 63 6b 20 72 61 74 65 20 25     u , check rate %
     16b:	75 20 48 7a 20 74 78 20 70 6f 77 65 72 20 25 75     u Hz tx power %u
     17b:	0a 00                                               ..

0000017d <__c.4563>:
     17d:	0a 00                                               ..

0000017f <__c.4558>:
     17f:	25 78 3a 00                                         %x:.

00000183 <__c.4555>:
     183:	4d 41 43 20 61 64 64 72 65 73 73 20 00              MAC address .

00000190 <__c.4553>:
     190:	52 61 6e 64 6f 6d 20 45 55 49 36 34 20 61 64 64     Random EUI64 add
     1a0:	72 65 73 73 20 67 65 6e 65 72 61 74 65 64 0a 00     ress generated..

000001b0 <__c.4550>:
     1b0:	0a 2a 2a 2a 2a 2a 2a 2a 42 6f 6f 74 69 6e 67 20     .*******Booting 
     1c0:	25 73 2a 2a 2a 2a 2a 2a 2a 0a 00                    %s*******..

000001cb <default_mac_address>:
     1cb:	02 00 00 ff fe 00 00 01                             ........

000001d3 <default_server_name>:
     1d3:	41 54 4d 45 47 41 31 32 38 72 66 61 31 00           ATMEGA128rfa1.

000001e1 <default_domain_name>:
     1e1:	6c 6f 63 61 6c 68 6f 73 74 00                       localhost.

000001eb <__c.4341>:
     1eb:	45 45 50 52 4f 4d 20 69 73 20 63 6f 72 72 75 70     EEPROM is corrup
     1fb:	74 2c 20 72 65 77 72 69 74 69 6e 67 20 77 69 74     t, rewriting wit
     20b:	68 20 64 65 66 61 75 6c 74 73 2e 0a 00              h defaults...

00000218 <__c.3462>:
     218:	45 20 25 64 2e 25 64 20 63 6c 6f 63 6b 20 25 6c     E %d.%d clock %l
     228:	75 20 63 70 75 20 25 6c 75 20 6c 70 6d 20 25 6c     u cpu %lu lpm %l
     238:	75 20 69 72 71 20 25 6c 75 20 67 6c 65 64 20 25     u irq %lu gled %
     248:	6c 75 20 79 6c 65 64 20 25 6c 75 20 72 6c 65 64     lu yled %lu rled
     258:	20 25 6c 75 20 74 78 20 25 6c 75 20 6c 69 73 74      %lu tx %lu list
     268:	65 6e 20 25 6c 75 20 73 65 6e 73 6f 72 73 20 25     en %lu sensors %
     278:	6c 75 20 73 65 72 69 61 6c 20 25 6c 75 0a 00        lu serial %lu..

00000287 <__c.3460>:
     287:	53 20 25 64 2e 25 64 20 63 6c 6f 63 6b 20 25 6c     S %d.%d clock %l
     297:	75 20 74 78 20 25 6c 75 20 72 78 20 25 6c 75 20     u tx %lu rx %lu 
     2a7:	72 74 78 20 25 6c 75 20 72 72 78 20 25 6c 75 20     rtx %lu rrx %lu 
     2b7:	72 65 78 6d 69 74 20 25 6c 75 20 61 63 6b 74 78     rexmit %lu acktx
     2c7:	20 25 6c 75 20 6e 6f 61 63 6b 74 78 20 25 6c 75      %lu noacktx %lu
     2d7:	20 61 63 6b 72 78 20 25 6c 75 20 74 69 6d 65 64      ackrx %lu timed
     2e7:	6f 75 74 20 25 6c 75 20 62 61 64 61 63 6b 72 78     out %lu badackrx
     2f7:	20 25 6c 75 20 74 6f 6f 6c 6f 6e 67 20 25 6c 75      %lu toolong %lu
     307:	20 74 6f 6f 73 68 6f 72 74 20 25 6c 75 20 62 61      tooshort %lu ba
     317:	64 73 79 6e 63 68 20 25 6c 75 20 62 61 64 63 72     dsynch %lu badcr
     327:	63 20 25 6c 75 20 63 6f 6e 74 65 6e 74 69 6f 6e     c %lu contention
     337:	64 72 6f 70 20 25 6c 75 20 73 65 6e 64 69 6e 67     drop %lu sending
     347:	64 72 6f 70 20 25 6c 75 20 6c 6c 74 78 20 25 6c     drop %lu lltx %l
     357:	75 20 6c 6c 72 78 20 25 6c 75 0a 00 00              u llrx %lu...

00000364 <__ctors_end>:
     364:	11 24       	eor	r1, r1
     366:	1f be       	out	0x3f, r1	; 63
     368:	cf ef       	ldi	r28, 0xFF	; 255
     36a:	d1 e4       	ldi	r29, 0x41	; 65
     36c:	de bf       	out	0x3e, r29	; 62
     36e:	cd bf       	out	0x3d, r28	; 61

00000370 <__do_copy_data>:
     370:	1f e0       	ldi	r17, 0x0F	; 15
     372:	a0 e0       	ldi	r26, 0x00	; 0
     374:	b2 e0       	ldi	r27, 0x02	; 2
     376:	e4 e6       	ldi	r30, 0x64	; 100
     378:	f1 ea       	ldi	r31, 0xA1	; 161
     37a:	00 e0       	ldi	r16, 0x00	; 0
     37c:	0b bf       	out	0x3b, r16	; 59
     37e:	02 c0       	rjmp	.+4      	; 0x384 <__do_copy_data+0x14>
     380:	07 90       	elpm	r0, Z+
     382:	0d 92       	st	X+, r0
     384:	aa 3d       	cpi	r26, 0xDA	; 218
     386:	b1 07       	cpc	r27, r17
     388:	d9 f7       	brne	.-10     	; 0x380 <__do_copy_data+0x10>

0000038a <__do_clear_bss>:
     38a:	1d e2       	ldi	r17, 0x2D	; 45
     38c:	aa ed       	ldi	r26, 0xDA	; 218
     38e:	bf e0       	ldi	r27, 0x0F	; 15
     390:	01 c0       	rjmp	.+2      	; 0x394 <.do_clear_bss_start>

00000392 <.do_clear_bss_loop>:
     392:	1d 92       	st	X+, r1

00000394 <.do_clear_bss_start>:
     394:	a1 3e       	cpi	r26, 0xE1	; 225
     396:	b1 07       	cpc	r27, r17
     398:	e1 f7       	brne	.-8      	; 0x392 <.do_clear_bss_loop>
     39a:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <main>
     39e:	0c 94 b0 50 	jmp	0xa160	; 0xa160 <_exit>

000003a2 <__bad_interrupt>:
     3a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a6 <process_thread_measurement_process>:

PROCESS(measurement_process, "Measurement Process");
AUTOSTART_PROCESSES(&measurement_process, &radiotftp_process);

PROCESS_THREAD(measurement_process, ev, data)
{
     3a6:	7f 92       	push	r7
     3a8:	8f 92       	push	r8
     3aa:	9f 92       	push	r9
     3ac:	af 92       	push	r10
     3ae:	bf 92       	push	r11
     3b0:	cf 92       	push	r12
     3b2:	df 92       	push	r13
     3b4:	ef 92       	push	r14
     3b6:	ff 92       	push	r15
     3b8:	0f 93       	push	r16
     3ba:	1f 93       	push	r17
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	6c 01       	movw	r12, r24
	static uint32_t counter=0;
	static uint16_t numBytes=0;
	static uint64_t fibo[3] = {0, 1, 1};
	static struct etimer measurement_timer;
	static uint8_t fake_measurement_string[450];
	PROCESS_BEGIN();
     3c2:	dc 01       	movw	r26, r24
     3c4:	8d 91       	ld	r24, X+
     3c6:	9c 91       	ld	r25, X
     3c8:	11 97       	sbiw	r26, 0x01	; 1
     3ca:	00 97       	sbiw	r24, 0x00	; 0
     3cc:	29 f0       	breq	.+10     	; 0x3d8 <process_thread_measurement_process+0x32>
     3ce:	84 32       	cpi	r24, 0x24	; 36
     3d0:	91 05       	cpc	r25, r1
     3d2:	09 f0       	breq	.+2      	; 0x3d6 <process_thread_measurement_process+0x30>
     3d4:	5e c1       	rjmp	.+700    	; 0x692 <process_thread_measurement_process+0x2ec>
     3d6:	0d c0       	rjmp	.+26     	; 0x3f2 <process_thread_measurement_process+0x4c>

	etimer_set(&measurement_timer, CLOCK_SECOND*2);
     3d8:	8c e9       	ldi	r24, 0x9C	; 156
     3da:	91 e1       	ldi	r25, 0x11	; 17
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	71 e0       	ldi	r23, 0x01	; 1
     3e0:	0e 94 d7 17 	call	0x2fae	; 0x2fae <etimer_set>
	while(1)
	{
		PROCESS_WAIT_EVENT();
     3e4:	84 e2       	ldi	r24, 0x24	; 36
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	f6 01       	movw	r30, r12
     3ea:	91 83       	std	Z+1, r25	; 0x01
     3ec:	80 83       	st	Z, r24
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	54 c1       	rjmp	.+680    	; 0x69a <process_thread_measurement_process+0x2f4>
		counter++;
     3f2:	80 91 a6 11 	lds	r24, 0x11A6
     3f6:	90 91 a7 11 	lds	r25, 0x11A7
     3fa:	a0 91 a8 11 	lds	r26, 0x11A8
     3fe:	b0 91 a9 11 	lds	r27, 0x11A9
     402:	01 96       	adiw	r24, 0x01	; 1
     404:	a1 1d       	adc	r26, r1
     406:	b1 1d       	adc	r27, r1
     408:	80 93 a6 11 	sts	0x11A6, r24
     40c:	90 93 a7 11 	sts	0x11A7, r25
     410:	a0 93 a8 11 	sts	0x11A8, r26
     414:	b0 93 a9 11 	sts	0x11A9, r27
		fibo[2]=fibo[1]+fibo[0];
     418:	30 91 74 02 	lds	r19, 0x0274
     41c:	e0 90 75 02 	lds	r14, 0x0275
     420:	00 91 76 02 	lds	r16, 0x0276
     424:	80 90 77 02 	lds	r8, 0x0277
     428:	90 90 78 02 	lds	r9, 0x0278
     42c:	a0 90 79 02 	lds	r10, 0x0279
     430:	b0 90 7a 02 	lds	r11, 0x027A
     434:	f0 90 7b 02 	lds	r15, 0x027B
     438:	20 91 7c 02 	lds	r18, 0x027C
     43c:	40 91 7d 02 	lds	r20, 0x027D
     440:	f0 91 7e 02 	lds	r31, 0x027E
     444:	70 90 7f 02 	lds	r7, 0x027F
     448:	70 91 80 02 	lds	r23, 0x0280
     44c:	50 91 81 02 	lds	r21, 0x0281
     450:	60 91 82 02 	lds	r22, 0x0282
     454:	10 91 83 02 	lds	r17, 0x0283
     458:	23 0f       	add	r18, r19
     45a:	e1 e0       	ldi	r30, 0x01	; 1
     45c:	23 17       	cp	r18, r19
     45e:	08 f0       	brcs	.+2      	; 0x462 <process_thread_measurement_process+0xbc>
     460:	e0 e0       	ldi	r30, 0x00	; 0
     462:	4e 0d       	add	r20, r14
     464:	31 e0       	ldi	r19, 0x01	; 1
     466:	4e 15       	cp	r20, r14
     468:	08 f0       	brcs	.+2      	; 0x46c <process_thread_measurement_process+0xc6>
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	ee 2e       	mov	r14, r30
     46e:	e4 0e       	add	r14, r20
     470:	e1 e0       	ldi	r30, 0x01	; 1
     472:	e4 16       	cp	r14, r20
     474:	08 f0       	brcs	.+2      	; 0x478 <process_thread_measurement_process+0xd2>
     476:	e0 e0       	ldi	r30, 0x00	; 0
     478:	3e 2b       	or	r19, r30
     47a:	f0 0f       	add	r31, r16
     47c:	41 e0       	ldi	r20, 0x01	; 1
     47e:	f0 17       	cp	r31, r16
     480:	08 f0       	brcs	.+2      	; 0x484 <process_thread_measurement_process+0xde>
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	03 2f       	mov	r16, r19
     486:	0f 0f       	add	r16, r31
     488:	31 e0       	ldi	r19, 0x01	; 1
     48a:	0f 17       	cp	r16, r31
     48c:	08 f0       	brcs	.+2      	; 0x490 <process_thread_measurement_process+0xea>
     48e:	30 e0       	ldi	r19, 0x00	; 0
     490:	43 2b       	or	r20, r19
     492:	e8 2d       	mov	r30, r8
     494:	e7 0d       	add	r30, r7
     496:	31 e0       	ldi	r19, 0x01	; 1
     498:	e8 15       	cp	r30, r8
     49a:	08 f0       	brcs	.+2      	; 0x49e <process_thread_measurement_process+0xf8>
     49c:	30 e0       	ldi	r19, 0x00	; 0
     49e:	f4 2f       	mov	r31, r20
     4a0:	fe 0f       	add	r31, r30
     4a2:	41 e0       	ldi	r20, 0x01	; 1
     4a4:	fe 17       	cp	r31, r30
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <process_thread_measurement_process+0x104>
     4a8:	40 e0       	ldi	r20, 0x00	; 0
     4aa:	34 2b       	or	r19, r20
     4ac:	79 0d       	add	r23, r9
     4ae:	41 e0       	ldi	r20, 0x01	; 1
     4b0:	79 15       	cp	r23, r9
     4b2:	08 f0       	brcs	.+2      	; 0x4b6 <process_thread_measurement_process+0x110>
     4b4:	40 e0       	ldi	r20, 0x00	; 0
     4b6:	e3 2f       	mov	r30, r19
     4b8:	e7 0f       	add	r30, r23
     4ba:	31 e0       	ldi	r19, 0x01	; 1
     4bc:	e7 17       	cp	r30, r23
     4be:	08 f0       	brcs	.+2      	; 0x4c2 <process_thread_measurement_process+0x11c>
     4c0:	30 e0       	ldi	r19, 0x00	; 0
     4c2:	43 2b       	or	r20, r19
     4c4:	5a 0d       	add	r21, r10
     4c6:	31 e0       	ldi	r19, 0x01	; 1
     4c8:	5a 15       	cp	r21, r10
     4ca:	08 f0       	brcs	.+2      	; 0x4ce <process_thread_measurement_process+0x128>
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	45 0f       	add	r20, r21
     4d0:	71 e0       	ldi	r23, 0x01	; 1
     4d2:	45 17       	cp	r20, r21
     4d4:	08 f0       	brcs	.+2      	; 0x4d8 <process_thread_measurement_process+0x132>
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	37 2b       	or	r19, r23
     4da:	6b 0d       	add	r22, r11
     4dc:	51 e0       	ldi	r21, 0x01	; 1
     4de:	6b 15       	cp	r22, r11
     4e0:	08 f0       	brcs	.+2      	; 0x4e4 <process_thread_measurement_process+0x13e>
     4e2:	50 e0       	ldi	r21, 0x00	; 0
     4e4:	73 2f       	mov	r23, r19
     4e6:	76 0f       	add	r23, r22
     4e8:	31 e0       	ldi	r19, 0x01	; 1
     4ea:	76 17       	cp	r23, r22
     4ec:	08 f0       	brcs	.+2      	; 0x4f0 <process_thread_measurement_process+0x14a>
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	53 2b       	or	r21, r19
     4f2:	1f 0d       	add	r17, r15
     4f4:	51 0f       	add	r21, r17
     4f6:	20 93 84 02 	sts	0x0284, r18
     4fa:	e0 92 85 02 	sts	0x0285, r14
     4fe:	00 93 86 02 	sts	0x0286, r16
     502:	f0 93 87 02 	sts	0x0287, r31
     506:	e0 93 88 02 	sts	0x0288, r30
     50a:	40 93 89 02 	sts	0x0289, r20
     50e:	70 93 8a 02 	sts	0x028A, r23
     512:	50 93 8b 02 	sts	0x028B, r21
		numBytes=sprintf(fake_measurement_string, "Some Data: fibonacci(%d)=", counter);
     516:	ca ed       	ldi	r28, 0xDA	; 218
     518:	df e0       	ldi	r29, 0x0F	; 15
     51a:	2d b7       	in	r18, 0x3d	; 61
     51c:	3e b7       	in	r19, 0x3e	; 62
     51e:	28 50       	subi	r18, 0x08	; 8
     520:	30 40       	sbci	r19, 0x00	; 0
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	3e bf       	out	0x3e, r19	; 62
     528:	0f be       	out	0x3f, r0	; 63
     52a:	2d bf       	out	0x3d, r18	; 61
     52c:	4d b7       	in	r20, 0x3d	; 61
     52e:	5e b7       	in	r21, 0x3e	; 62
     530:	4f 5f       	subi	r20, 0xFF	; 255
     532:	5f 4f       	sbci	r21, 0xFF	; 255
     534:	ed b7       	in	r30, 0x3d	; 61
     536:	fe b7       	in	r31, 0x3e	; 62
     538:	d2 83       	std	Z+2, r29	; 0x02
     53a:	c1 83       	std	Z+1, r28	; 0x01
     53c:	20 e0       	ldi	r18, 0x00	; 0
     53e:	32 e0       	ldi	r19, 0x02	; 2
     540:	fa 01       	movw	r30, r20
     542:	33 83       	std	Z+3, r19	; 0x03
     544:	22 83       	std	Z+2, r18	; 0x02
     546:	84 83       	std	Z+4, r24	; 0x04
     548:	95 83       	std	Z+5, r25	; 0x05
     54a:	a6 83       	std	Z+6, r26	; 0x06
     54c:	b7 83       	std	Z+7, r27	; 0x07
     54e:	0e 94 50 4d 	call	0x9aa0	; 0x9aa0 <sprintf>
     552:	7c 01       	movw	r14, r24
     554:	90 93 a5 11 	sts	0x11A5, r25
     558:	80 93 a4 11 	sts	0x11A4, r24
		numBytes+=sprintf(fake_measurement_string+numBytes, "%u [Alp Sayin, KTH Royal Institute of Technology]\n", fibo[0]);
     55c:	00 d0       	rcall	.+0      	; 0x55e <process_thread_measurement_process+0x1b8>
     55e:	00 d0       	rcall	.+0      	; 0x560 <process_thread_measurement_process+0x1ba>
     560:	ed b7       	in	r30, 0x3d	; 61
     562:	fe b7       	in	r31, 0x3e	; 62
     564:	31 96       	adiw	r30, 0x01	; 1
     566:	8c 0f       	add	r24, r28
     568:	9d 1f       	adc	r25, r29
     56a:	ad b7       	in	r26, 0x3d	; 61
     56c:	be b7       	in	r27, 0x3e	; 62
     56e:	12 96       	adiw	r26, 0x02	; 2
     570:	9c 93       	st	X, r25
     572:	8e 93       	st	-X, r24
     574:	11 97       	sbiw	r26, 0x01	; 1
     576:	8a e1       	ldi	r24, 0x1A	; 26
     578:	92 e0       	ldi	r25, 0x02	; 2
     57a:	93 83       	std	Z+3, r25	; 0x03
     57c:	82 83       	std	Z+2, r24	; 0x02
     57e:	04 e7       	ldi	r16, 0x74	; 116
     580:	12 e0       	ldi	r17, 0x02	; 2
     582:	80 91 74 02 	lds	r24, 0x0274
     586:	84 83       	std	Z+4, r24	; 0x04
     588:	80 91 75 02 	lds	r24, 0x0275
     58c:	85 83       	std	Z+5, r24	; 0x05
     58e:	80 91 76 02 	lds	r24, 0x0276
     592:	86 83       	std	Z+6, r24	; 0x06
     594:	80 91 77 02 	lds	r24, 0x0277
     598:	87 83       	std	Z+7, r24	; 0x07
     59a:	80 91 78 02 	lds	r24, 0x0278
     59e:	80 87       	std	Z+8, r24	; 0x08
     5a0:	80 91 79 02 	lds	r24, 0x0279
     5a4:	81 87       	std	Z+9, r24	; 0x09
     5a6:	80 91 7a 02 	lds	r24, 0x027A
     5aa:	82 87       	std	Z+10, r24	; 0x0a
     5ac:	80 91 7b 02 	lds	r24, 0x027B
     5b0:	83 87       	std	Z+11, r24	; 0x0b
     5b2:	0e 94 50 4d 	call	0x9aa0	; 0x9aa0 <sprintf>
     5b6:	e8 0e       	add	r14, r24
     5b8:	f9 1e       	adc	r15, r25
     5ba:	f0 92 a5 11 	sts	0x11A5, r15
     5be:	e0 92 a4 11 	sts	0x11A4, r14
		printf("%s", fake_measurement_string);
     5c2:	ed b7       	in	r30, 0x3d	; 61
     5c4:	fe b7       	in	r31, 0x3e	; 62
     5c6:	38 96       	adiw	r30, 0x08	; 8
     5c8:	0f b6       	in	r0, 0x3f	; 63
     5ca:	f8 94       	cli
     5cc:	fe bf       	out	0x3e, r31	; 62
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	ed bf       	out	0x3d, r30	; 61
     5d2:	8d e4       	ldi	r24, 0x4D	; 77
     5d4:	92 e0       	ldi	r25, 0x02	; 2
     5d6:	92 83       	std	Z+2, r25	; 0x02
     5d8:	81 83       	std	Z+1, r24	; 0x01
     5da:	d4 83       	std	Z+4, r29	; 0x04
     5dc:	c3 83       	std	Z+3, r28	; 0x03
     5de:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		fibo[0]=fibo[1];
     5e2:	f8 01       	movw	r30, r16
     5e4:	38 96       	adiw	r30, 0x08	; 8
     5e6:	80 91 7c 02 	lds	r24, 0x027C
     5ea:	80 93 74 02 	sts	0x0274, r24
     5ee:	80 91 7d 02 	lds	r24, 0x027D
     5f2:	d8 01       	movw	r26, r16
     5f4:	11 96       	adiw	r26, 0x01	; 1
     5f6:	8c 93       	st	X, r24
     5f8:	11 97       	sbiw	r26, 0x01	; 1
     5fa:	80 91 7e 02 	lds	r24, 0x027E
     5fe:	12 96       	adiw	r26, 0x02	; 2
     600:	8c 93       	st	X, r24
     602:	12 97       	sbiw	r26, 0x02	; 2
     604:	80 91 7f 02 	lds	r24, 0x027F
     608:	13 96       	adiw	r26, 0x03	; 3
     60a:	8c 93       	st	X, r24
     60c:	13 97       	sbiw	r26, 0x03	; 3
     60e:	80 91 80 02 	lds	r24, 0x0280
     612:	14 96       	adiw	r26, 0x04	; 4
     614:	8c 93       	st	X, r24
     616:	14 97       	sbiw	r26, 0x04	; 4
     618:	80 91 81 02 	lds	r24, 0x0281
     61c:	15 96       	adiw	r26, 0x05	; 5
     61e:	8c 93       	st	X, r24
     620:	15 97       	sbiw	r26, 0x05	; 5
     622:	80 91 82 02 	lds	r24, 0x0282
     626:	16 96       	adiw	r26, 0x06	; 6
     628:	8c 93       	st	X, r24
     62a:	16 97       	sbiw	r26, 0x06	; 6
     62c:	80 91 83 02 	lds	r24, 0x0283
     630:	17 96       	adiw	r26, 0x07	; 7
     632:	8c 93       	st	X, r24
     634:	17 97       	sbiw	r26, 0x07	; 7
		fibo[1]=fibo[2];
     636:	80 91 84 02 	lds	r24, 0x0284
     63a:	18 96       	adiw	r26, 0x08	; 8
     63c:	8c 93       	st	X, r24
     63e:	80 91 85 02 	lds	r24, 0x0285
     642:	81 83       	std	Z+1, r24	; 0x01
     644:	80 91 86 02 	lds	r24, 0x0286
     648:	82 83       	std	Z+2, r24	; 0x02
     64a:	80 91 87 02 	lds	r24, 0x0287
     64e:	83 83       	std	Z+3, r24	; 0x03
     650:	80 91 88 02 	lds	r24, 0x0288
     654:	84 83       	std	Z+4, r24	; 0x04
     656:	80 91 89 02 	lds	r24, 0x0289
     65a:	85 83       	std	Z+5, r24	; 0x05
     65c:	80 91 8a 02 	lds	r24, 0x028A
     660:	86 83       	std	Z+6, r24	; 0x06
     662:	80 91 8b 02 	lds	r24, 0x028B
     666:	87 83       	std	Z+7, r24	; 0x07
		radiotftp_setNumBytesToSend(numBytes);
     668:	0f 90       	pop	r0
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	80 91 a4 11 	lds	r24, 0x11A4
     674:	90 91 a5 11 	lds	r25, 0x11A5
     678:	0e 94 22 13 	call	0x2644	; 0x2644 <radiotftp_setNumBytesToSend>
		process_post_synch(&radiotftp_process, PROCESS_EVENT_COM, (void*)fake_measurement_string);
     67c:	8a ea       	ldi	r24, 0xAA	; 170
     67e:	9d e0       	ldi	r25, 0x0D	; 13
     680:	69 e8       	ldi	r22, 0x89	; 137
     682:	ae 01       	movw	r20, r28
     684:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <process_post_synch>
		etimer_set(&measurement_timer, CLOCK_SECOND*10);
     688:	8c e9       	ldi	r24, 0x9C	; 156
     68a:	91 e1       	ldi	r25, 0x11	; 17
     68c:	60 e0       	ldi	r22, 0x00	; 0
     68e:	75 e0       	ldi	r23, 0x05	; 5
     690:	a7 ce       	rjmp	.-690    	; 0x3e0 <process_thread_measurement_process+0x3a>
	}
	PROCESS_END();
     692:	f6 01       	movw	r30, r12
     694:	11 82       	std	Z+1, r1	; 0x01
     696:	10 82       	st	Z, r1
     698:	83 e0       	ldi	r24, 0x03	; 3
}
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	0f 91       	pop	r16
     6a2:	ff 90       	pop	r15
     6a4:	ef 90       	pop	r14
     6a6:	df 90       	pop	r13
     6a8:	cf 90       	pop	r12
     6aa:	bf 90       	pop	r11
     6ac:	af 90       	pop	r10
     6ae:	9f 90       	pop	r9
     6b0:	8f 90       	pop	r8
     6b2:	7f 90       	pop	r7
     6b4:	08 95       	ret

000006b6 <ax25_compute_crc>:
	}
	return fcs;
}

static uint16_t ax25_compute_crc(uint8_t* buf, uint16_t len)
{
     6b6:	fc 01       	movw	r30, r24
     6b8:	2f ef       	ldi	r18, 0xFF	; 255
     6ba:	3f ef       	ldi	r19, 0xFF	; 255
     6bc:	12 c0       	rjmp	.+36     	; 0x6e2 <ax25_compute_crc+0x2c>

static uint16_t ax25_fcs(uint16_t fcs, uint8_t* cp, uint16_t len)
{
	while (len--)
	{
    	fcs = (fcs >> 8) ^ ax25_fcstab[(fcs ^ *cp++) & 0xff];
     6be:	83 2f       	mov	r24, r19
     6c0:	99 27       	eor	r25, r25
     6c2:	a1 91       	ld	r26, Z+
     6c4:	b0 e0       	ldi	r27, 0x00	; 0
     6c6:	a2 27       	eor	r26, r18
     6c8:	b3 27       	eor	r27, r19
     6ca:	b0 70       	andi	r27, 0x00	; 0
     6cc:	aa 0f       	add	r26, r26
     6ce:	bb 1f       	adc	r27, r27
     6d0:	a4 57       	subi	r26, 0x74	; 116
     6d2:	bd 4f       	sbci	r27, 0xFD	; 253
     6d4:	2d 91       	ld	r18, X+
     6d6:	3c 91       	ld	r19, X
     6d8:	11 97       	sbiw	r26, 0x01	; 1
     6da:	28 27       	eor	r18, r24
     6dc:	39 27       	eor	r19, r25
     6de:	61 50       	subi	r22, 0x01	; 1
     6e0:	70 40       	sbci	r23, 0x00	; 0
   0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

static uint16_t ax25_fcs(uint16_t fcs, uint8_t* cp, uint16_t len)
{
	while (len--)
     6e2:	61 15       	cp	r22, r1
     6e4:	71 05       	cpc	r23, r1
     6e6:	59 f7       	brne	.-42     	; 0x6be <ax25_compute_crc+0x8>

static uint16_t ax25_compute_crc(uint8_t* buf, uint16_t len)
{
	uint16_t fcs = INITFCS;
	fcs = ax25_fcs(fcs, buf, len);
	fcs ^= 0xffff;
     6e8:	20 95       	com	r18
     6ea:	30 95       	com	r19
	return fcs;
}
     6ec:	c9 01       	movw	r24, r18
     6ee:	08 95       	ret

000006f0 <ax25_initialize_network>:

void ax25_initialize_network(uint8_t* myCallsign)
{
     6f0:	28 2f       	mov	r18, r24
     6f2:	39 2f       	mov	r19, r25
     6f4:	d9 01       	movw	r26, r18
     6f6:	e3 e9       	ldi	r30, 0x93	; 147
     6f8:	f4 e0       	ldi	r31, 0x04	; 4
    uint32_t i;
    for(i=0; i<7; i++)
    	ax25_local_callsign[i] = myCallsign[i];
     6fa:	8d 91       	ld	r24, X+
     6fc:	81 93       	st	Z+, r24
}

void ax25_initialize_network(uint8_t* myCallsign)
{
    uint32_t i;
    for(i=0; i<7; i++)
     6fe:	84 e0       	ldi	r24, 0x04	; 4
     700:	ea 39       	cpi	r30, 0x9A	; 154
     702:	f8 07       	cpc	r31, r24
     704:	d1 f7       	brne	.-12     	; 0x6fa <ax25_initialize_network+0xa>
    	ax25_local_callsign[i] = myCallsign[i];
}
     706:	08 95       	ret

00000708 <ax25_get_local_callsign>:
uint8_t* ax25_get_local_callsign(uint8_t* callsign_out)
{
    uint8_t i;

    if(callsign_out!=NULL)
     708:	00 97       	sbiw	r24, 0x00	; 0
     70a:	49 f0       	breq	.+18     	; 0x71e <ax25_get_local_callsign+0x16>
     70c:	e3 e9       	ldi	r30, 0x93	; 147
     70e:	f4 e0       	ldi	r31, 0x04	; 4
     710:	dc 01       	movw	r26, r24
    {
        for(i=0; i<7; i++)
        	callsign_out[i] = ax25_local_callsign[i];
     712:	81 91       	ld	r24, Z+
     714:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(callsign_out!=NULL)
    {
        for(i=0; i<7; i++)
     716:	84 e0       	ldi	r24, 0x04	; 4
     718:	ea 39       	cpi	r30, 0x9A	; 154
     71a:	f8 07       	cpc	r31, r24
     71c:	d1 f7       	brne	.-12     	; 0x712 <ax25_get_local_callsign+0xa>
        	callsign_out[i] = ax25_local_callsign[i];
    }
    return ax25_local_callsign;
}
     71e:	83 e9       	ldi	r24, 0x93	; 147
     720:	94 e0       	ldi	r25, 0x04	; 4
     722:	08 95       	ret

00000724 <ax25_get_broadcast_callsign>:

uint8_t* ax25_get_broadcast_callsign(uint8_t* callsign_out)
{
    uint8_t i;

    if(callsign_out!=NULL)
     724:	00 97       	sbiw	r24, 0x00	; 0
     726:	49 f0       	breq	.+18     	; 0x73a <ax25_get_broadcast_callsign+0x16>
     728:	ec e8       	ldi	r30, 0x8C	; 140
     72a:	f4 e0       	ldi	r31, 0x04	; 4
     72c:	dc 01       	movw	r26, r24
    {
        for(i=0; i<7; i++)
        	callsign_out[i] = ax25_broadcast_address[i];
     72e:	81 91       	ld	r24, Z+
     730:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(callsign_out!=NULL)
    {
        for(i=0; i<7; i++)
     732:	84 e0       	ldi	r24, 0x04	; 4
     734:	e3 39       	cpi	r30, 0x93	; 147
     736:	f8 07       	cpc	r31, r24
     738:	d1 f7       	brne	.-12     	; 0x72e <ax25_get_broadcast_callsign+0xa>
        	callsign_out[i] = ax25_broadcast_address[i];
    }
    return ax25_broadcast_address;
}
     73a:	8c e8       	ldi	r24, 0x8C	; 140
     73c:	94 e0       	ldi	r25, 0x04	; 4
     73e:	08 95       	ret

00000740 <ax25_create_ui_packet>:

uint32_t ax25_create_ui_packet(uint8_t* src_in, uint8_t* dst_in, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
{
     740:	ef 92       	push	r14
     742:	ff 92       	push	r15
     744:	0f 93       	push	r16
     746:	1f 93       	push	r17
     748:	cf 93       	push	r28
     74a:	df 93       	push	r29
     74c:	79 01       	movw	r14, r18
	uint16_t crc=0;
	uint16_t len=0;
	uint16_t ax25_len=0;

    //check for input errors
    if(payload_length > AX25_MAX_PAYLOAD_LENGTH || packet_out==NULL)
     74e:	2b e1       	ldi	r18, 0x1B	; 27
     750:	e2 16       	cp	r14, r18
     752:	21 e0       	ldi	r18, 0x01	; 1
     754:	f2 06       	cpc	r15, r18
     756:	90 f5       	brcc	.+100    	; 0x7bc <ax25_create_ui_packet+0x7c>
     758:	01 15       	cp	r16, r1
     75a:	11 05       	cpc	r17, r1
     75c:	79 f1       	breq	.+94     	; 0x7bc <ax25_create_ui_packet+0x7c>
        return 0;

    //destination address
    memcpy(packet_out+AX25_DESTINATION_OFFSET, dst_in, AX25_DESTINATION_LENGTH);
     75e:	d8 01       	movw	r26, r16
     760:	26 2f       	mov	r18, r22
     762:	37 2f       	mov	r19, r23
     764:	f9 01       	movw	r30, r18
     766:	27 e0       	ldi	r18, 0x07	; 7
     768:	01 90       	ld	r0, Z+
     76a:	0d 92       	st	X+, r0
     76c:	21 50       	subi	r18, 0x01	; 1
     76e:	e1 f7       	brne	.-8      	; 0x768 <ax25_create_ui_packet+0x28>
    len+=AX25_DESTINATION_LENGTH;

    //source address
    memcpy(packet_out+AX25_SOURCE_OFFSET, src_in, AX25_SOURCE_LENGTH);
     770:	d8 01       	movw	r26, r16
     772:	17 96       	adiw	r26, 0x07	; 7
     774:	fc 01       	movw	r30, r24
     776:	87 e0       	ldi	r24, 0x07	; 7
     778:	01 90       	ld	r0, Z+
     77a:	0d 92       	st	X+, r0
     77c:	81 50       	subi	r24, 0x01	; 1
     77e:	e1 f7       	brne	.-8      	; 0x778 <ax25_create_ui_packet+0x38>
    len+=AX25_SOURCE_LENGTH;

    //control field
    packet_out[AX25_CONTROL_OFFSET]=AX25_CONTROL_UI_FINAL;
     780:	83 e0       	ldi	r24, 0x03	; 3
     782:	f8 01       	movw	r30, r16
     784:	86 87       	std	Z+14, r24	; 0x0e
    len+=AX25_CONTROL_LENGTH;

    //PID
    packet_out[AX25_PID_OFFSET]=AX25_PID_NO_PROTOCOL;
     786:	80 ef       	ldi	r24, 0xF0	; 240
     788:	87 87       	std	Z+15, r24	; 0x0f
    len+=AX25_PID_LENGTH;

    //payload
    memcpy(packet_out+AX25_PAYLOAD_OFFSET, payload_in, payload_length);
     78a:	98 01       	movw	r18, r16
     78c:	20 5f       	subi	r18, 0xF0	; 240
     78e:	3f 4f       	sbci	r19, 0xFF	; 255
     790:	c9 01       	movw	r24, r18
     792:	ba 01       	movw	r22, r20
     794:	a7 01       	movw	r20, r14
     796:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    len+=payload_length;
     79a:	e7 01       	movw	r28, r14
     79c:	60 96       	adiw	r28, 0x10	; 16

    //fcs (crc16)
    crc=ax25_compute_crc(packet_out, len);
     79e:	c8 01       	movw	r24, r16
     7a0:	be 01       	movw	r22, r28
     7a2:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <ax25_compute_crc>

    packet_out[len]=crc>>8 & 0xFF;
     7a6:	c0 0f       	add	r28, r16
     7a8:	d1 1f       	adc	r29, r17
     7aa:	98 83       	st	Y, r25
    packet_out[len+1]=crc & 0xFF;
     7ac:	89 83       	std	Y+1, r24	; 0x01
    len+=AX25_FCS_LENGTH;
     7ae:	82 e1       	ldi	r24, 0x12	; 18
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	e8 0e       	add	r14, r24
     7b4:	f9 1e       	adc	r15, r25

    return len;
     7b6:	00 e0       	ldi	r16, 0x00	; 0
     7b8:	10 e0       	ldi	r17, 0x00	; 0
     7ba:	03 c0       	rjmp	.+6      	; 0x7c2 <ax25_create_ui_packet+0x82>
	uint16_t len=0;
	uint16_t ax25_len=0;

    //check for input errors
    if(payload_length > AX25_MAX_PAYLOAD_LENGTH || packet_out==NULL)
        return 0;
     7bc:	ee 24       	eor	r14, r14
     7be:	ff 24       	eor	r15, r15
     7c0:	87 01       	movw	r16, r14
    packet_out[len]=crc>>8 & 0xFF;
    packet_out[len+1]=crc & 0xFF;
    len+=AX25_FCS_LENGTH;

    return len;
}
     7c2:	b7 01       	movw	r22, r14
     7c4:	c8 01       	movw	r24, r16
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	08 95       	ret

000007d4 <ax25_check_destination>:

uint8_t ax25_check_destination(uint8_t* my_dst, uint8_t* packet_dst_out, uint8_t* packet_in)
{
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	cf 93       	push	r28
     7da:	df 93       	push	r29
     7dc:	eb 01       	movw	r28, r22
     7de:	8a 01       	movw	r16, r20
    uint8_t result;
    //check for address match
    result=memcmp(my_dst, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     7e0:	ba 01       	movw	r22, r20
     7e2:	47 e0       	ldi	r20, 0x07	; 7
     7e4:	50 e0       	ldi	r21, 0x00	; 0
     7e6:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
    if(result)
     7ea:	88 23       	and	r24, r24
     7ec:	39 f0       	breq	.+14     	; 0x7fc <ax25_check_destination+0x28>
    {
        result=memcmp(ax25_broadcast_address, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     7ee:	8c e8       	ldi	r24, 0x8C	; 140
     7f0:	94 e0       	ldi	r25, 0x04	; 4
     7f2:	b8 01       	movw	r22, r16
     7f4:	47 e0       	ldi	r20, 0x07	; 7
     7f6:	50 e0       	ldi	r21, 0x00	; 0
     7f8:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
    }

    //copy the destination address in the packet
    if(packet_dst_out!=NULL)
     7fc:	20 97       	sbiw	r28, 0x00	; 0
     7fe:	41 f0       	breq	.+16     	; 0x810 <ax25_check_destination+0x3c>
    	memcpy(packet_dst_out, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     800:	20 2f       	mov	r18, r16
     802:	31 2f       	mov	r19, r17
     804:	f9 01       	movw	r30, r18
     806:	97 e0       	ldi	r25, 0x07	; 7
     808:	01 90       	ld	r0, Z+
     80a:	09 92       	st	Y+, r0
     80c:	91 50       	subi	r25, 0x01	; 1
     80e:	e1 f7       	brne	.-8      	; 0x808 <ax25_check_destination+0x34>
    return result;
}
     810:	df 91       	pop	r29
     812:	cf 91       	pop	r28
     814:	1f 91       	pop	r17
     816:	0f 91       	pop	r16
     818:	08 95       	ret

0000081a <ax25_open_ui_packet>:

uint16_t ax25_open_ui_packet(uint8_t* src_out, uint8_t* dst_out, uint8_t* payload_out, uint8_t* packet_in, uint16_t packet_length)
{
     81a:	af 92       	push	r10
     81c:	bf 92       	push	r11
     81e:	cf 92       	push	r12
     820:	df 92       	push	r13
     822:	ef 92       	push	r14
     824:	ff 92       	push	r15
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	6a 01       	movw	r12, r20
     830:	e9 01       	movw	r28, r18
     832:	98 01       	movw	r18, r16
    uint8_t control=0, pid=0;
    uint16_t ax25_len=0, len=0;
    uint16_t crc=0, packet_crc=0;
    //copy destination address
    if(dst_out!=NULL)
     834:	61 15       	cp	r22, r1
     836:	71 05       	cpc	r23, r1
     838:	39 f0       	breq	.+14     	; 0x848 <ax25_open_ui_packet+0x2e>
    	memcpy(dst_out, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     83a:	db 01       	movw	r26, r22
     83c:	fe 01       	movw	r30, r28
     83e:	47 e0       	ldi	r20, 0x07	; 7
     840:	01 90       	ld	r0, Z+
     842:	0d 92       	st	X+, r0
     844:	41 50       	subi	r20, 0x01	; 1
     846:	e1 f7       	brne	.-8      	; 0x840 <ax25_open_ui_packet+0x26>

    //copy source address
    if(src_out!=NULL)
     848:	00 97       	sbiw	r24, 0x00	; 0
     84a:	41 f0       	breq	.+16     	; 0x85c <ax25_open_ui_packet+0x42>
    	memcpy(src_out, packet_in+AX25_SOURCE_OFFSET, AX25_SOURCE_LENGTH);
     84c:	dc 01       	movw	r26, r24
     84e:	fe 01       	movw	r30, r28
     850:	37 96       	adiw	r30, 0x07	; 7
     852:	87 e0       	ldi	r24, 0x07	; 7
     854:	01 90       	ld	r0, Z+
     856:	0d 92       	st	X+, r0
     858:	81 50       	subi	r24, 0x01	; 1
     85a:	e1 f7       	brne	.-8      	; 0x854 <ax25_open_ui_packet+0x3a>
    //copy ax25 pid
    pid=packet_in[AX25_PID_OFFSET];

    //calculate payload length
    ax25_len=packet_length;
    len=ax25_len-AX25_DESTINATION_LENGTH-AX25_SOURCE_LENGTH-AX25_CONTROL_LENGTH-AX25_PID_LENGTH-AX25_FCS_LENGTH;
     85c:	89 01       	movw	r16, r18
     85e:	02 51       	subi	r16, 0x12	; 18
     860:	10 40       	sbci	r17, 0x00	; 0

    //copy the crc came with packet
    packet_crc=packet_in[AX25_FCS_OFFSET(len)] & 0xFF;
     862:	7e 01       	movw	r14, r28
     864:	e0 0e       	add	r14, r16
     866:	f1 1e       	adc	r15, r17
     868:	f7 01       	movw	r30, r14
     86a:	80 89       	ldd	r24, Z+16	; 0x10
    packet_crc=packet_crc<<8;
     86c:	b8 2e       	mov	r11, r24
     86e:	aa 24       	eor	r10, r10
    packet_crc|=packet_in[AX25_FCS_OFFSET(len)+1] & 0xFF;

    //calculate fcs (crc32)
    crc=ax25_compute_crc(packet_in, ax25_len-AX25_FCS_LENGTH);
     870:	b9 01       	movw	r22, r18
     872:	62 50       	subi	r22, 0x02	; 2
     874:	70 40       	sbci	r23, 0x00	; 0
     876:	ce 01       	movw	r24, r28
     878:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <ax25_compute_crc>
    len=ax25_len-AX25_DESTINATION_LENGTH-AX25_SOURCE_LENGTH-AX25_CONTROL_LENGTH-AX25_PID_LENGTH-AX25_FCS_LENGTH;

    //copy the crc came with packet
    packet_crc=packet_in[AX25_FCS_OFFSET(len)] & 0xFF;
    packet_crc=packet_crc<<8;
    packet_crc|=packet_in[AX25_FCS_OFFSET(len)+1] & 0xFF;
     87c:	f7 01       	movw	r30, r14
     87e:	21 89       	ldd	r18, Z+17	; 0x11
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	2a 29       	or	r18, r10
     884:	3b 29       	or	r19, r11

    //calculate fcs (crc32)
    crc=ax25_compute_crc(packet_in, ax25_len-AX25_FCS_LENGTH);

    //check for match
    if(packet_crc != crc)
     886:	28 17       	cp	r18, r24
     888:	39 07       	cpc	r19, r25
     88a:	71 f4       	brne	.+28     	; 0x8a8 <ax25_open_ui_packet+0x8e>
        return 0;

    if(payload_out!=NULL)
     88c:	c1 14       	cp	r12, r1
     88e:	d1 04       	cpc	r13, r1
     890:	69 f0       	breq	.+26     	; 0x8ac <ax25_open_ui_packet+0x92>
    {
        memcpy(payload_out, packet_in+AX25_PAYLOAD_OFFSET, len);
     892:	60 96       	adiw	r28, 0x10	; 16
     894:	c6 01       	movw	r24, r12
     896:	be 01       	movw	r22, r28
     898:	a8 01       	movw	r20, r16
     89a:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
        payload_out[len]=0;
     89e:	f6 01       	movw	r30, r12
     8a0:	e0 0f       	add	r30, r16
     8a2:	f1 1f       	adc	r31, r17
     8a4:	10 82       	st	Z, r1
     8a6:	02 c0       	rjmp	.+4      	; 0x8ac <ax25_open_ui_packet+0x92>
    //calculate fcs (crc32)
    crc=ax25_compute_crc(packet_in, ax25_len-AX25_FCS_LENGTH);

    //check for match
    if(packet_crc != crc)
        return 0;
     8a8:	00 e0       	ldi	r16, 0x00	; 0
     8aa:	10 e0       	ldi	r17, 0x00	; 0
        memcpy(payload_out, packet_in+AX25_PAYLOAD_OFFSET, len);
        payload_out[len]=0;
    }

    return len;
}
     8ac:	c8 01       	movw	r24, r16
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
     8b2:	1f 91       	pop	r17
     8b4:	0f 91       	pop	r16
     8b6:	ff 90       	pop	r15
     8b8:	ef 90       	pop	r14
     8ba:	df 90       	pop	r13
     8bc:	cf 90       	pop	r12
     8be:	bf 90       	pop	r11
     8c0:	af 90       	pop	r10
     8c2:	08 95       	ret

000008c4 <eth_compute_crc>:
        0xA005713C, 0xBDB26158, 0x9B6B51F4, 0x86DC4190,
        0xD6D930AC, 0xCB6E20C8, 0xEDB71064, 0xF0000000
    };

    static uint16_t eth_compute_crc(uint8_t* buf, uint16_t len)
    {
     8c4:	af 92       	push	r10
     8c6:	bf 92       	push	r11
     8c8:	df 92       	push	r13
     8ca:	ef 92       	push	r14
     8cc:	ff 92       	push	r15
     8ce:	0f 93       	push	r16
     8d0:	1f 93       	push	r17
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	5b 01       	movw	r10, r22
    	uint16_t n;
    	uint32_t crc=0;
        for (n=0; n<len; n++)
     8d8:	e8 2f       	mov	r30, r24
     8da:	f9 2f       	mov	r31, r25
    };

    static uint16_t eth_compute_crc(uint8_t* buf, uint16_t len)
    {
    	uint16_t n;
    	uint32_t crc=0;
     8dc:	20 e0       	ldi	r18, 0x00	; 0
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	a9 01       	movw	r20, r18
        for (n=0; n<len; n++)
     8e2:	60 e0       	ldi	r22, 0x00	; 0
     8e4:	70 e0       	ldi	r23, 0x00	; 0
     8e6:	4f c0       	rjmp	.+158    	; 0x986 <eth_compute_crc+0xc2>
        {
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 0)) & 0x0F];  /* lower nibble */
     8e8:	79 01       	movw	r14, r18
     8ea:	8a 01       	movw	r16, r20
     8ec:	a4 e0       	ldi	r26, 0x04	; 4
     8ee:	16 95       	lsr	r17
     8f0:	07 95       	ror	r16
     8f2:	f7 94       	ror	r15
     8f4:	e7 94       	ror	r14
     8f6:	aa 95       	dec	r26
     8f8:	d1 f7       	brne	.-12     	; 0x8ee <eth_compute_crc+0x2a>
     8fa:	d1 90       	ld	r13, Z+
     8fc:	8d 2d       	mov	r24, r13
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	a0 e0       	ldi	r26, 0x00	; 0
     902:	b0 e0       	ldi	r27, 0x00	; 0
     904:	82 27       	eor	r24, r18
     906:	93 27       	eor	r25, r19
     908:	a4 27       	eor	r26, r20
     90a:	b5 27       	eor	r27, r21
     90c:	8f 70       	andi	r24, 0x0F	; 15
     90e:	90 70       	andi	r25, 0x00	; 0
     910:	a0 70       	andi	r26, 0x00	; 0
     912:	b0 70       	andi	r27, 0x00	; 0
     914:	88 0f       	add	r24, r24
     916:	99 1f       	adc	r25, r25
     918:	88 0f       	add	r24, r24
     91a:	99 1f       	adc	r25, r25
     91c:	86 56       	subi	r24, 0x66	; 102
     91e:	9b 4f       	sbci	r25, 0xFB	; 251
     920:	ec 01       	movw	r28, r24
     922:	88 81       	ld	r24, Y
     924:	99 81       	ldd	r25, Y+1	; 0x01
     926:	aa 81       	ldd	r26, Y+2	; 0x02
     928:	bb 81       	ldd	r27, Y+3	; 0x03
     92a:	8e 25       	eor	r24, r14
     92c:	9f 25       	eor	r25, r15
     92e:	a0 27       	eor	r26, r16
     930:	b1 27       	eor	r27, r17
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 4)) & 0x0F];  /* upper nibble */
     932:	7c 01       	movw	r14, r24
     934:	8d 01       	movw	r16, r26
     936:	34 e0       	ldi	r19, 0x04	; 4
     938:	16 95       	lsr	r17
     93a:	07 95       	ror	r16
     93c:	f7 94       	ror	r15
     93e:	e7 94       	ror	r14
     940:	3a 95       	dec	r19
     942:	d1 f7       	brne	.-12     	; 0x938 <eth_compute_crc+0x74>
     944:	d2 94       	swap	r13
     946:	2f e0       	ldi	r18, 0x0F	; 15
     948:	d2 22       	and	r13, r18
     94a:	2d 2d       	mov	r18, r13
     94c:	30 e0       	ldi	r19, 0x00	; 0
     94e:	40 e0       	ldi	r20, 0x00	; 0
     950:	50 e0       	ldi	r21, 0x00	; 0
     952:	28 27       	eor	r18, r24
     954:	39 27       	eor	r19, r25
     956:	4a 27       	eor	r20, r26
     958:	5b 27       	eor	r21, r27
     95a:	2f 70       	andi	r18, 0x0F	; 15
     95c:	30 70       	andi	r19, 0x00	; 0
     95e:	40 70       	andi	r20, 0x00	; 0
     960:	50 70       	andi	r21, 0x00	; 0
     962:	22 0f       	add	r18, r18
     964:	33 1f       	adc	r19, r19
     966:	22 0f       	add	r18, r18
     968:	33 1f       	adc	r19, r19
     96a:	26 56       	subi	r18, 0x66	; 102
     96c:	3b 4f       	sbci	r19, 0xFB	; 251
     96e:	d9 01       	movw	r26, r18
     970:	2d 91       	ld	r18, X+
     972:	3d 91       	ld	r19, X+
     974:	4d 91       	ld	r20, X+
     976:	5c 91       	ld	r21, X
     978:	13 97       	sbiw	r26, 0x03	; 3
     97a:	2e 25       	eor	r18, r14
     97c:	3f 25       	eor	r19, r15
     97e:	40 27       	eor	r20, r16
     980:	51 27       	eor	r21, r17

    static uint16_t eth_compute_crc(uint8_t* buf, uint16_t len)
    {
    	uint16_t n;
    	uint32_t crc=0;
        for (n=0; n<len; n++)
     982:	6f 5f       	subi	r22, 0xFF	; 255
     984:	7f 4f       	sbci	r23, 0xFF	; 255
     986:	6a 15       	cp	r22, r10
     988:	7b 05       	cpc	r23, r11
     98a:	08 f4       	brcc	.+2      	; 0x98e <eth_compute_crc+0xca>
     98c:	ad cf       	rjmp	.-166    	; 0x8e8 <eth_compute_crc+0x24>
        {
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 0)) & 0x0F];  /* lower nibble */
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 4)) & 0x0F];  /* upper nibble */
        }
        return crc;
    }
     98e:	c9 01       	movw	r24, r18
     990:	df 91       	pop	r29
     992:	cf 91       	pop	r28
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	ff 90       	pop	r15
     99a:	ef 90       	pop	r14
     99c:	df 90       	pop	r13
     99e:	bf 90       	pop	r11
     9a0:	af 90       	pop	r10
     9a2:	08 95       	ret

000009a4 <eth_initialize_network>:


    void eth_initialize_network(uint8_t* myEth)
    {
     9a4:	28 2f       	mov	r18, r24
     9a6:	39 2f       	mov	r19, r25
     9a8:	d9 01       	movw	r26, r18
     9aa:	e0 ee       	ldi	r30, 0xE0	; 224
     9ac:	f4 e0       	ldi	r31, 0x04	; 4
        uint32_t i;
        for(i=0; i<6; i++)
            local_eth_address[i] = myEth[i];
     9ae:	8d 91       	ld	r24, X+
     9b0:	81 93       	st	Z+, r24


    void eth_initialize_network(uint8_t* myEth)
    {
        uint32_t i;
        for(i=0; i<6; i++)
     9b2:	84 e0       	ldi	r24, 0x04	; 4
     9b4:	e6 3e       	cpi	r30, 0xE6	; 230
     9b6:	f8 07       	cpc	r31, r24
     9b8:	d1 f7       	brne	.-12     	; 0x9ae <eth_initialize_network+0xa>
            local_eth_address[i] = myEth[i];
    }
     9ba:	08 95       	ret

000009bc <eth_get_local_address>:

    uint8_t* eth_get_local_address(uint8_t* eth_out)
    {
        uint8_t i;

        if(eth_out!=NULL)
     9bc:	00 97       	sbiw	r24, 0x00	; 0
     9be:	49 f0       	breq	.+18     	; 0x9d2 <eth_get_local_address+0x16>
     9c0:	e0 ee       	ldi	r30, 0xE0	; 224
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	dc 01       	movw	r26, r24
        {
            for(i=0; i<6; i++)
                eth_out[i] = local_eth_address[i];
     9c6:	81 91       	ld	r24, Z+
     9c8:	8d 93       	st	X+, r24
    {
        uint8_t i;

        if(eth_out!=NULL)
        {
            for(i=0; i<6; i++)
     9ca:	84 e0       	ldi	r24, 0x04	; 4
     9cc:	e6 3e       	cpi	r30, 0xE6	; 230
     9ce:	f8 07       	cpc	r31, r24
     9d0:	d1 f7       	brne	.-12     	; 0x9c6 <eth_get_local_address+0xa>
                eth_out[i] = local_eth_address[i];
        }
        return local_eth_address;
    }
     9d2:	80 ee       	ldi	r24, 0xE0	; 224
     9d4:	94 e0       	ldi	r25, 0x04	; 4
     9d6:	08 95       	ret

000009d8 <eth_get_broadcast_address>:

    uint8_t* eth_get_broadcast_address(uint8_t* eth_out)
    {
        uint8_t i;

        if(eth_out!=NULL)
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	49 f0       	breq	.+18     	; 0x9ee <eth_get_broadcast_address+0x16>
     9dc:	ea ed       	ldi	r30, 0xDA	; 218
     9de:	f4 e0       	ldi	r31, 0x04	; 4
     9e0:	dc 01       	movw	r26, r24
        {
            for(i=0; i<6; i++)
                eth_out[i] = eth_broadcast_address[i];
     9e2:	81 91       	ld	r24, Z+
     9e4:	8d 93       	st	X+, r24
    {
        uint8_t i;

        if(eth_out!=NULL)
        {
            for(i=0; i<6; i++)
     9e6:	84 e0       	ldi	r24, 0x04	; 4
     9e8:	e0 3e       	cpi	r30, 0xE0	; 224
     9ea:	f8 07       	cpc	r31, r24
     9ec:	d1 f7       	brne	.-12     	; 0x9e2 <eth_get_broadcast_address+0xa>
                eth_out[i] = eth_broadcast_address[i];
        }
        return eth_broadcast_address;
    }
     9ee:	8a ed       	ldi	r24, 0xDA	; 218
     9f0:	94 e0       	ldi	r25, 0x04	; 4
     9f2:	08 95       	ret

000009f4 <eth_create_packet>:
     *
     * note: since our application won't and can't use csma/cd this implementation ignores the padding which is used for csma/cd
     * therefore this packet may contain payloads with lengths lower then 40 bytes
     */
    uint32_t eth_create_packet(uint8_t* src_in, uint8_t* dst_in, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
    {
     9f4:	ef 92       	push	r14
     9f6:	ff 92       	push	r15
     9f8:	0f 93       	push	r16
     9fa:	1f 93       	push	r17
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	79 01       	movw	r14, r18
     a02:	e8 01       	movw	r28, r16
        uint32_t crc=0;
        uint16_t len=0;
        uint16_t eth_len=0;

        //check for input errors
        if(payload_length > ETH_MAX_PAYLOAD_LENGTH || packet_out==NULL)
     a04:	2b e1       	ldi	r18, 0x1B	; 27
     a06:	e2 16       	cp	r14, r18
     a08:	21 e0       	ldi	r18, 0x01	; 1
     a0a:	f2 06       	cpc	r15, r18
     a0c:	88 f5       	brcc	.+98     	; 0xa70 <eth_create_packet+0x7c>
     a0e:	20 97       	sbiw	r28, 0x00	; 0
     a10:	79 f1       	breq	.+94     	; 0xa70 <eth_create_packet+0x7c>
            return 0;

        //destination address
        memcpy(packet_out+ETH_DESTINATION_OFFSET, dst_in, ETH_DESTINATION_LENGTH);
     a12:	d8 01       	movw	r26, r16
     a14:	26 2f       	mov	r18, r22
     a16:	37 2f       	mov	r19, r23
     a18:	f9 01       	movw	r30, r18
     a1a:	26 e0       	ldi	r18, 0x06	; 6
     a1c:	01 90       	ld	r0, Z+
     a1e:	0d 92       	st	X+, r0
     a20:	21 50       	subi	r18, 0x01	; 1
     a22:	e1 f7       	brne	.-8      	; 0xa1c <eth_create_packet+0x28>
        len+=ETH_DESTINATION_LENGTH;

        //source address
        memcpy(packet_out+ETH_SOURCE_OFFSET, src_in, ETH_SOURCE_LENGTH);
     a24:	de 01       	movw	r26, r28
     a26:	16 96       	adiw	r26, 0x06	; 6
     a28:	fc 01       	movw	r30, r24
     a2a:	86 e0       	ldi	r24, 0x06	; 6
     a2c:	01 90       	ld	r0, Z+
     a2e:	0d 92       	st	X+, r0
     a30:	81 50       	subi	r24, 0x01	; 1
     a32:	e1 f7       	brne	.-8      	; 0xa2c <eth_create_packet+0x38>
        len+=ETH_SOURCE_LENGTH;

        //packet length
        eth_len=ETH_DESTINATION_LENGTH+ETH_SOURCE_LENGTH+ETH_LENGTH_LENGTH+payload_length+ETH_FCS_LENGTH;
     a34:	87 01       	movw	r16, r14
     a36:	0e 5e       	subi	r16, 0xEE	; 238
     a38:	1f 4f       	sbci	r17, 0xFF	; 255
        packet_out[len]=eth_len>>8 & 0xFF;
     a3a:	1c 87       	std	Y+12, r17	; 0x0c
        packet_out[len+1]=eth_len & 0xFF;
     a3c:	0d 87       	std	Y+13, r16	; 0x0d
        len+=ETH_LENGTH_LENGTH;

        //payload
        memcpy(packet_out+ETH_PAYLOAD_OFFSET, payload_in, payload_length);
     a3e:	9e 01       	movw	r18, r28
     a40:	22 5f       	subi	r18, 0xF2	; 242
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	c9 01       	movw	r24, r18
     a46:	ba 01       	movw	r22, r20
     a48:	a7 01       	movw	r20, r14
     a4a:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
        len+=payload_length;
     a4e:	8e e0       	ldi	r24, 0x0E	; 14
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	e8 0e       	add	r14, r24
     a54:	f9 1e       	adc	r15, r25

        //fcs (crc32)
        crc=eth_compute_crc(packet_out, len);
     a56:	ce 01       	movw	r24, r28
     a58:	b7 01       	movw	r22, r14
     a5a:	0e 94 62 04 	call	0x8c4	; 0x8c4 <eth_compute_crc>

        packet_out[len]=crc>>24 & 0xFF;
     a5e:	ce 0d       	add	r28, r14
     a60:	df 1d       	adc	r29, r15
     a62:	18 82       	st	Y, r1
        packet_out[len+1]=crc>>16 & 0xFF;
     a64:	19 82       	std	Y+1, r1	; 0x01
        packet_out[len+2]=crc>>8 & 0xFF;
     a66:	9a 83       	std	Y+2, r25	; 0x02
        packet_out[len+3]=crc & 0xFF;
     a68:	8b 83       	std	Y+3, r24	; 0x03
        len+=ETH_FCS_LENGTH;

        return len;
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	03 c0       	rjmp	.+6      	; 0xa76 <eth_create_packet+0x82>
        uint16_t len=0;
        uint16_t eth_len=0;

        //check for input errors
        if(payload_length > ETH_MAX_PAYLOAD_LENGTH || packet_out==NULL)
            return 0;
     a70:	00 e0       	ldi	r16, 0x00	; 0
     a72:	10 e0       	ldi	r17, 0x00	; 0
     a74:	98 01       	movw	r18, r16
        packet_out[len+2]=crc>>8 & 0xFF;
        packet_out[len+3]=crc & 0xFF;
        len+=ETH_FCS_LENGTH;

        return len;
    }
     a76:	b8 01       	movw	r22, r16
     a78:	c9 01       	movw	r24, r18
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	ff 90       	pop	r15
     a84:	ef 90       	pop	r14
     a86:	08 95       	ret

00000a88 <eth_check_destination>:
     * checks the destination of the packet_in with my_dst
     * if packet_dst is not null pointer writes the packet's destination to packet_dst
     * returns zero if the addresses match
     */
    uint8_t eth_check_destination(uint8_t* my_dst, uint8_t* packet_dst, uint8_t* packet_in)
    {
     a88:	0f 93       	push	r16
     a8a:	1f 93       	push	r17
     a8c:	cf 93       	push	r28
     a8e:	df 93       	push	r29
     a90:	eb 01       	movw	r28, r22
     a92:	8a 01       	movw	r16, r20
        uint8_t result;
        //check for address match
        result=memcmp(my_dst, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     a94:	ba 01       	movw	r22, r20
     a96:	46 e0       	ldi	r20, 0x06	; 6
     a98:	50 e0       	ldi	r21, 0x00	; 0
     a9a:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
        if(result)
     a9e:	88 23       	and	r24, r24
     aa0:	39 f0       	breq	.+14     	; 0xab0 <eth_check_destination+0x28>
        {
            result=memcmp(eth_broadcast_address, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     aa2:	8a ed       	ldi	r24, 0xDA	; 218
     aa4:	94 e0       	ldi	r25, 0x04	; 4
     aa6:	b8 01       	movw	r22, r16
     aa8:	46 e0       	ldi	r20, 0x06	; 6
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
        }

        //copy the destination address in the packet
        if(packet_dst!=NULL)
     ab0:	20 97       	sbiw	r28, 0x00	; 0
     ab2:	41 f0       	breq	.+16     	; 0xac4 <eth_check_destination+0x3c>
        	memcpy(packet_dst, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     ab4:	20 2f       	mov	r18, r16
     ab6:	31 2f       	mov	r19, r17
     ab8:	f9 01       	movw	r30, r18
     aba:	96 e0       	ldi	r25, 0x06	; 6
     abc:	01 90       	ld	r0, Z+
     abe:	09 92       	st	Y+, r0
     ac0:	91 50       	subi	r25, 0x01	; 1
     ac2:	e1 f7       	brne	.-8      	; 0xabc <eth_check_destination+0x34>
        return result;
    }
     ac4:	df 91       	pop	r29
     ac6:	cf 91       	pop	r28
     ac8:	1f 91       	pop	r17
     aca:	0f 91       	pop	r16
     acc:	08 95       	ret

00000ace <eth_open_packet>:
     * before writing anything it first checks the checksum, if the checksum doesn't match,
     * null is written to all pointers and function returns 0
     * on a successful opening function returns the length of the packet
     */
    uint16_t eth_open_packet(uint8_t* src_out, uint8_t* dst_out, uint8_t* payload_out, uint8_t* packet_in, uint16_t packet_length)
    {
     ace:	6f 92       	push	r6
     ad0:	7f 92       	push	r7
     ad2:	8f 92       	push	r8
     ad4:	9f 92       	push	r9
     ad6:	af 92       	push	r10
     ad8:	bf 92       	push	r11
     ada:	cf 92       	push	r12
     adc:	df 92       	push	r13
     ade:	ef 92       	push	r14
     ae0:	ff 92       	push	r15
     ae2:	0f 93       	push	r16
     ae4:	1f 93       	push	r17
     ae6:	cf 93       	push	r28
     ae8:	df 93       	push	r29
     aea:	3a 01       	movw	r6, r20
     aec:	e9 01       	movw	r28, r18
     aee:	68 01       	movw	r12, r16
        uint16_t len=0;
        uint16_t eth_len=0;
        uint32_t crc=0, packet_crc=0;
        //copy destination address
        if(dst_out!=NULL)
     af0:	61 15       	cp	r22, r1
     af2:	71 05       	cpc	r23, r1
     af4:	51 f0       	breq	.+20     	; 0xb0a <eth_open_packet+0x3c>
        	memcpy(dst_out, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     af6:	a9 01       	movw	r20, r18
     af8:	26 e0       	ldi	r18, 0x06	; 6
     afa:	da 01       	movw	r26, r20
     afc:	0d 90       	ld	r0, X+
     afe:	ad 01       	movw	r20, r26
     b00:	db 01       	movw	r26, r22
     b02:	0d 92       	st	X+, r0
     b04:	bd 01       	movw	r22, r26
     b06:	21 50       	subi	r18, 0x01	; 1
     b08:	c1 f7       	brne	.-16     	; 0xafa <eth_open_packet+0x2c>

        //copy source address
        if(src_out!=NULL)
     b0a:	00 97       	sbiw	r24, 0x00	; 0
     b0c:	61 f0       	breq	.+24     	; 0xb26 <eth_open_packet+0x58>
        	memcpy(src_out, packet_in+ETH_SOURCE_OFFSET, ETH_SOURCE_LENGTH);
     b0e:	ae 01       	movw	r20, r28
     b10:	4a 5f       	subi	r20, 0xFA	; 250
     b12:	5f 4f       	sbci	r21, 0xFF	; 255
     b14:	26 e0       	ldi	r18, 0x06	; 6
     b16:	da 01       	movw	r26, r20
     b18:	0d 90       	ld	r0, X+
     b1a:	ad 01       	movw	r20, r26
     b1c:	dc 01       	movw	r26, r24
     b1e:	0d 92       	st	X+, r0
     b20:	cd 01       	movw	r24, r26
     b22:	21 50       	subi	r18, 0x01	; 1
     b24:	c1 f7       	brne	.-16     	; 0xb16 <eth_open_packet+0x48>

        //copy ethernet packet length
        eth_len=packet_in[ETH_LENGTH_OFFSET] & 0xFF;
     b26:	8c 85       	ldd	r24, Y+12	; 0x0c
        eth_len=eth_len<<8;
     b28:	f8 2f       	mov	r31, r24
     b2a:	e0 e0       	ldi	r30, 0x00	; 0
        eth_len|=packet_in[ETH_LENGTH_OFFSET+1] & 0xFF;
     b2c:	8d 85       	ldd	r24, Y+13	; 0x0d
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	e8 2b       	or	r30, r24
     b32:	f9 2b       	or	r31, r25

        //printf("packet_length=%d\neth_len=%d\n",packet_length, eth_len);
        //calculate payload length
        if(packet_length!=eth_len)
     b34:	ce 16       	cp	r12, r30
     b36:	df 06       	cpc	r13, r31
     b38:	09 f0       	breq	.+2      	; 0xb3c <eth_open_packet+0x6e>
     b3a:	4c c0       	rjmp	.+152    	; 0xbd4 <eth_open_packet+0x106>
        	return 0;

        len=eth_len-ETH_DESTINATION_LENGTH-ETH_SOURCE_LENGTH-ETH_LENGTH_LENGTH-ETH_FCS_LENGTH;
     b3c:	86 01       	movw	r16, r12
     b3e:	02 51       	subi	r16, 0x12	; 18
     b40:	10 40       	sbci	r17, 0x00	; 0

        //copy the crc came with packet
        packet_crc=packet_in[ETH_PAYLOAD_OFFSET+len] & 0xFF;
     b42:	7e 01       	movw	r14, r28
     b44:	e0 0e       	add	r14, r16
     b46:	f1 1e       	adc	r15, r17
     b48:	f7 01       	movw	r30, r14
     b4a:	86 85       	ldd	r24, Z+14	; 0x0e
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	a0 e0       	ldi	r26, 0x00	; 0
     b50:	b0 e0       	ldi	r27, 0x00	; 0
        packet_crc=packet_crc<<8;
     b52:	ba 2f       	mov	r27, r26
     b54:	a9 2f       	mov	r26, r25
     b56:	98 2f       	mov	r25, r24
     b58:	88 27       	eor	r24, r24
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+1] & 0xFF;
     b5a:	27 85       	ldd	r18, Z+15	; 0x0f
     b5c:	30 e0       	ldi	r19, 0x00	; 0
     b5e:	40 e0       	ldi	r20, 0x00	; 0
     b60:	50 e0       	ldi	r21, 0x00	; 0
     b62:	82 2b       	or	r24, r18
     b64:	93 2b       	or	r25, r19
     b66:	a4 2b       	or	r26, r20
     b68:	b5 2b       	or	r27, r21
        packet_crc=packet_crc<<8;
     b6a:	ba 2f       	mov	r27, r26
     b6c:	a9 2f       	mov	r26, r25
     b6e:	98 2f       	mov	r25, r24
     b70:	88 27       	eor	r24, r24
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+2] & 0xFF;
     b72:	20 89       	ldd	r18, Z+16	; 0x10
     b74:	30 e0       	ldi	r19, 0x00	; 0
     b76:	40 e0       	ldi	r20, 0x00	; 0
     b78:	50 e0       	ldi	r21, 0x00	; 0
     b7a:	82 2b       	or	r24, r18
     b7c:	93 2b       	or	r25, r19
     b7e:	a4 2b       	or	r26, r20
     b80:	b5 2b       	or	r27, r21
        packet_crc=packet_crc<<8;
     b82:	88 24       	eor	r8, r8
     b84:	98 2e       	mov	r9, r24
     b86:	a9 2e       	mov	r10, r25
     b88:	ba 2e       	mov	r11, r26
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+3] & 0xFF;

        //calculate fcs (crc32)
        crc=eth_compute_crc(packet_in, eth_len-ETH_FCS_LENGTH);
     b8a:	b6 01       	movw	r22, r12
     b8c:	64 50       	subi	r22, 0x04	; 4
     b8e:	70 40       	sbci	r23, 0x00	; 0
     b90:	ce 01       	movw	r24, r28
     b92:	0e 94 62 04 	call	0x8c4	; 0x8c4 <eth_compute_crc>
        packet_crc=packet_crc<<8;
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+1] & 0xFF;
        packet_crc=packet_crc<<8;
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+2] & 0xFF;
        packet_crc=packet_crc<<8;
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+3] & 0xFF;
     b96:	d7 01       	movw	r26, r14
     b98:	51 96       	adiw	r26, 0x11	; 17
     b9a:	2c 91       	ld	r18, X
     b9c:	30 e0       	ldi	r19, 0x00	; 0
     b9e:	40 e0       	ldi	r20, 0x00	; 0
     ba0:	50 e0       	ldi	r21, 0x00	; 0
     ba2:	28 29       	or	r18, r8
     ba4:	39 29       	or	r19, r9
     ba6:	4a 29       	or	r20, r10
     ba8:	5b 29       	or	r21, r11

        //calculate fcs (crc32)
        crc=eth_compute_crc(packet_in, eth_len-ETH_FCS_LENGTH);
     baa:	a0 e0       	ldi	r26, 0x00	; 0
     bac:	b0 e0       	ldi	r27, 0x00	; 0

        //check for match
        if(packet_crc != crc)
     bae:	28 17       	cp	r18, r24
     bb0:	39 07       	cpc	r19, r25
     bb2:	4a 07       	cpc	r20, r26
     bb4:	5b 07       	cpc	r21, r27
     bb6:	71 f4       	brne	.+28     	; 0xbd4 <eth_open_packet+0x106>
            return 0;


        if(payload_out!=NULL)
     bb8:	61 14       	cp	r6, r1
     bba:	71 04       	cpc	r7, r1
     bbc:	69 f0       	breq	.+26     	; 0xbd8 <eth_open_packet+0x10a>
        {
            memcpy(payload_out, packet_in+ETH_PAYLOAD_OFFSET, len);
     bbe:	2e 96       	adiw	r28, 0x0e	; 14
     bc0:	c3 01       	movw	r24, r6
     bc2:	be 01       	movw	r22, r28
     bc4:	a8 01       	movw	r20, r16
     bc6:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
            payload_out[len]=0;
     bca:	f3 01       	movw	r30, r6
     bcc:	e0 0f       	add	r30, r16
     bce:	f1 1f       	adc	r31, r17
     bd0:	10 82       	st	Z, r1
     bd2:	02 c0       	rjmp	.+4      	; 0xbd8 <eth_open_packet+0x10a>
        //calculate fcs (crc32)
        crc=eth_compute_crc(packet_in, eth_len-ETH_FCS_LENGTH);

        //check for match
        if(packet_crc != crc)
            return 0;
     bd4:	00 e0       	ldi	r16, 0x00	; 0
     bd6:	10 e0       	ldi	r17, 0x00	; 0
            memcpy(payload_out, packet_in+ETH_PAYLOAD_OFFSET, len);
            payload_out[len]=0;
        }

        return len;
    }
     bd8:	c8 01       	movw	r24, r16
     bda:	df 91       	pop	r29
     bdc:	cf 91       	pop	r28
     bde:	1f 91       	pop	r17
     be0:	0f 91       	pop	r16
     be2:	ff 90       	pop	r15
     be4:	ef 90       	pop	r14
     be6:	df 90       	pop	r13
     be8:	cf 90       	pop	r12
     bea:	bf 90       	pop	r11
     bec:	af 90       	pop	r10
     bee:	9f 90       	pop	r9
     bf0:	8f 90       	pop	r8
     bf2:	7f 90       	pop	r7
     bf4:	6f 90       	pop	r6
     bf6:	08 95       	ret

00000bf8 <isManchester_encoded>:
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
0x0, 0x0, 0x0, 0x0, };

inline uint8_t isManchester_encoded(uint8_t byte)
{
	return me_valid_tab[byte];
     bf8:	e6 ee       	ldi	r30, 0xE6	; 230
     bfa:	f7 e0       	ldi	r31, 0x07	; 7
     bfc:	e8 0f       	add	r30, r24
     bfe:	f1 1d       	adc	r31, r1
}
     c00:	80 81       	ld	r24, Z
     c02:	08 95       	ret

00000c04 <manchester_encode>:

uint16_t manchester_encode(uint8_t* input, uint8_t* output, uint16_t size)
{
     c04:	ef 92       	push	r14
     c06:	ff 92       	push	r15
     c08:	cf 93       	push	r28
     c0a:	df 93       	push	r29
	uint16_t i, j = 0;
	for(i = 0; i<size; i++)
     c0c:	e6 2f       	mov	r30, r22
     c0e:	f7 2f       	mov	r31, r23
     c10:	e8 2e       	mov	r14, r24
     c12:	e7 01       	movw	r28, r14
     c14:	7e 01       	movw	r14, r28
     c16:	f9 2e       	mov	r15, r25
     c18:	e7 01       	movw	r28, r14
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	16 c0       	rjmp	.+44     	; 0xc4c <manchester_encode+0x48>
inline uint8_t isManchester_encoded(uint8_t byte)
{
	return me_valid_tab[byte];
}

uint16_t manchester_encode(uint8_t* input, uint8_t* output, uint16_t size)
     c20:	9e 01       	movw	r18, r28
{
	uint16_t i, j = 0;
	for(i = 0; i<size; i++)
	{
		output[j++] = (me_encode_tab[input[i]]>>8)&0xFF;
     c22:	a9 91       	ld	r26, Y+
     c24:	b0 e0       	ldi	r27, 0x00	; 0
     c26:	aa 0f       	add	r26, r26
     c28:	bb 1f       	adc	r27, r27
     c2a:	aa 51       	subi	r26, 0x1A	; 26
     c2c:	ba 4f       	sbci	r27, 0xFA	; 250
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	6c 91       	ld	r22, X
     c32:	60 83       	st	Z, r22
		output[j++] = me_encode_tab[input[i]]&0xFF;
     c34:	d9 01       	movw	r26, r18
     c36:	2c 91       	ld	r18, X
     c38:	a2 2f       	mov	r26, r18
     c3a:	b0 e0       	ldi	r27, 0x00	; 0
     c3c:	aa 0f       	add	r26, r26
     c3e:	bb 1f       	adc	r27, r27
     c40:	aa 51       	subi	r26, 0x1A	; 26
     c42:	ba 4f       	sbci	r27, 0xFA	; 250
     c44:	2c 91       	ld	r18, X
     c46:	21 83       	std	Z+1, r18	; 0x01
}

uint16_t manchester_encode(uint8_t* input, uint8_t* output, uint16_t size)
{
	uint16_t i, j = 0;
	for(i = 0; i<size; i++)
     c48:	01 96       	adiw	r24, 0x01	; 1
     c4a:	32 96       	adiw	r30, 0x02	; 2
     c4c:	84 17       	cp	r24, r20
     c4e:	95 07       	cpc	r25, r21
     c50:	38 f3       	brcs	.-50     	; 0xc20 <manchester_encode+0x1c>
     c52:	44 0f       	add	r20, r20
     c54:	55 1f       	adc	r21, r21
	{
		output[j++] = (me_encode_tab[input[i]]>>8)&0xFF;
		output[j++] = me_encode_tab[input[i]]&0xFF;
	}
	return j;
}
     c56:	ca 01       	movw	r24, r20
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	ff 90       	pop	r15
     c5e:	ef 90       	pop	r14
     c60:	08 95       	ret

00000c62 <manchester_decode>:
uint16_t manchester_decode(uint8_t* input, uint8_t* output, uint16_t size)
{
     c62:	cf 93       	push	r28
     c64:	df 93       	push	r29
	uint16_t i, k = 0;
     c66:	e8 2f       	mov	r30, r24
     c68:	f9 2f       	mov	r31, r25
     c6a:	86 2f       	mov	r24, r22
     c6c:	97 2f       	mov	r25, r23
     c6e:	ec 01       	movw	r28, r24
     c70:	20 e0       	ldi	r18, 0x00	; 0
     c72:	30 e0       	ldi	r19, 0x00	; 0
	for(i = 0; i<size; i+=2)
     c74:	11 c0       	rjmp	.+34     	; 0xc98 <manchester_decode+0x36>
	{
		output[k++] = (me_decode_tab[input[i]]<<4)|me_decode_tab[input[i+1]];
     c76:	a0 81       	ld	r26, Z
     c78:	b0 e0       	ldi	r27, 0x00	; 0
     c7a:	aa 51       	subi	r26, 0x1A	; 26
     c7c:	bb 4f       	sbci	r27, 0xFB	; 251
     c7e:	8c 91       	ld	r24, X
     c80:	82 95       	swap	r24
     c82:	80 7f       	andi	r24, 0xF0	; 240
     c84:	a1 81       	ldd	r26, Z+1	; 0x01
     c86:	b0 e0       	ldi	r27, 0x00	; 0
     c88:	aa 51       	subi	r26, 0x1A	; 26
     c8a:	bb 4f       	sbci	r27, 0xFB	; 251
     c8c:	9c 91       	ld	r25, X
     c8e:	89 2b       	or	r24, r25
     c90:	89 93       	st	Y+, r24
     c92:	2f 5f       	subi	r18, 0xFF	; 255
     c94:	3f 4f       	sbci	r19, 0xFF	; 255
     c96:	32 96       	adiw	r30, 0x02	; 2
	return j;
}
uint16_t manchester_decode(uint8_t* input, uint8_t* output, uint16_t size)
{
	uint16_t i, k = 0;
	for(i = 0; i<size; i+=2)
     c98:	c9 01       	movw	r24, r18
     c9a:	88 0f       	add	r24, r24
     c9c:	99 1f       	adc	r25, r25
     c9e:	84 17       	cp	r24, r20
     ca0:	95 07       	cpc	r25, r21
     ca2:	48 f3       	brcs	.-46     	; 0xc76 <manchester_decode+0x14>
	{
		output[k++] = (me_decode_tab[input[i]]<<4)|me_decode_tab[input[i+1]];
	}
	return k;
}
     ca4:	c9 01       	movw	r24, r18
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	08 95       	ret

00000cac <tftp_initialize>:
static uint16_t tftp_src_port=71;
static dataQueuerfptr_t mainDataQueuer;

uint8_t tftp_initialize(dataQueuerfptr_t dataQueuer)
{
    mainDataQueuer=dataQueuer;
     cac:	90 93 c9 12 	sts	0x12C9, r25
     cb0:	80 93 c8 12 	sts	0x12C8, r24
    return 0;
}

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
     cb4:	10 92 c2 12 	sts	0x12C2, r1
    mainDataQueuer=dataQueuer;
    tftp_setStatus(TFTP_STATUS_IDLE);
    //for testing
    //timers_create_timer("TFTP Timer", &tftp_timer, 3, 0);
    return 0;
}
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	08 95       	ret

00000cbc <tftp_setStatus>:

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
     cbc:	80 93 c2 12 	sts	0x12C2, r24
}
     cc0:	08 95       	ret

00000cc2 <tftp_transfer_src_port>:
uint16_t tftp_transfer_src_port(void)
{
    return tftp_src_port;
}
     cc2:	80 91 70 0b 	lds	r24, 0x0B70
     cc6:	90 91 71 0b 	lds	r25, 0x0B71
     cca:	08 95       	ret

00000ccc <tftp_transfer_dst_port>:
uint16_t tftp_transfer_dst_port(void)
{
    return tftp_dst_port;
}
     ccc:	80 91 6e 0b 	lds	r24, 0x0B6E
     cd0:	90 91 6f 0b 	lds	r25, 0x0B6F
     cd4:	08 95       	ret

00000cd6 <tftp_getRandomRetransmissionTime>:
uint8_t tftp_getRandomRetransmissionTime(void)
{
    uint8_t time = TFTP_ACK_TIMEOUT_MIN + (TFTP_ACK_TIMEOUT_MAX-TFTP_ACK_TIMEOUT_MIN+1)*(((float)rand())/((float)RAND_MAX));
     cd6:	0e 94 30 4c 	call	0x9860	; 0x9860 <rand>
     cda:	9c 01       	movw	r18, r24
     cdc:	b9 01       	movw	r22, r18
     cde:	88 27       	eor	r24, r24
     ce0:	77 fd       	sbrc	r23, 7
     ce2:	80 95       	com	r24
     ce4:	98 2f       	mov	r25, r24
     ce6:	0e 94 c6 48 	call	0x918c	; 0x918c <__floatsisf>
     cea:	20 e0       	ldi	r18, 0x00	; 0
     cec:	3e ef       	ldi	r19, 0xFE	; 254
     cee:	4f ef       	ldi	r20, 0xFF	; 255
     cf0:	56 e4       	ldi	r21, 0x46	; 70
     cf2:	0e 94 e8 47 	call	0x8fd0	; 0x8fd0 <__divsf3>
     cf6:	9b 01       	movw	r18, r22
     cf8:	ac 01       	movw	r20, r24
     cfa:	0e 94 90 46 	call	0x8d20	; 0x8d20 <__addsf3>
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	30 e0       	ldi	r19, 0x00	; 0
     d02:	40 e8       	ldi	r20, 0x80	; 128
     d04:	5f e3       	ldi	r21, 0x3F	; 63
     d06:	0e 94 90 46 	call	0x8d20	; 0x8d20 <__addsf3>
     d0a:	0e 94 1a 45 	call	0x8a34	; 0x8a34 <__fixunssfsi>
     d0e:	86 2f       	mov	r24, r22
    //PRINTF_D("time=%d\n", time);
    return time;
}
     d10:	08 95       	ret

00000d12 <tftp_sendSingleBlockData>:
uint8_t tftp_sendSingleBlockData(uint8_t* dst_ip, uint8_t* data_ptr, uint16_t data_len, uint8_t* remote_filename)
{
     d12:	af 92       	push	r10
     d14:	bf 92       	push	r11
     d16:	cf 92       	push	r12
     d18:	df 92       	push	r13
     d1a:	ef 92       	push	r14
     d1c:	ff 92       	push	r15
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	7c 01       	movw	r14, r24
     d28:	6b 01       	movw	r12, r22
     d2a:	8a 01       	movw	r16, r20
     d2c:	e9 01       	movw	r28, r18
	uint8_t filenameCheck=0;

	if(data_len>450)
     d2e:	21 e0       	ldi	r18, 0x01	; 1
     d30:	43 3c       	cpi	r20, 0xC3	; 195
     d32:	52 07       	cpc	r21, r18
     d34:	b0 f0       	brcs	.+44     	; 0xd62 <tftp_sendSingleBlockData+0x50>
	{
		printf("input data too large, %d\n", data_len);
     d36:	00 d0       	rcall	.+0      	; 0xd38 <tftp_sendSingleBlockData+0x26>
     d38:	00 d0       	rcall	.+0      	; 0xd3a <tftp_sendSingleBlockData+0x28>
     d3a:	86 ee       	ldi	r24, 0xE6	; 230
     d3c:	98 e0       	ldi	r25, 0x08	; 8
     d3e:	ad b7       	in	r26, 0x3d	; 61
     d40:	be b7       	in	r27, 0x3e	; 62
     d42:	12 96       	adiw	r26, 0x02	; 2
     d44:	9c 93       	st	X, r25
     d46:	8e 93       	st	-X, r24
     d48:	11 97       	sbiw	r26, 0x01	; 1
     d4a:	14 96       	adiw	r26, 0x04	; 4
     d4c:	5c 93       	st	X, r21
     d4e:	4e 93       	st	-X, r20
     d50:	13 97       	sbiw	r26, 0x03	; 3
     d52:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		return (-1);
     d56:	0f 90       	pop	r0
     d58:	0f 90       	pop	r0
     d5a:	0f 90       	pop	r0
     d5c:	0f 90       	pop	r0
     d5e:	8f ef       	ldi	r24, 0xFF	; 255
     d60:	45 c1       	rjmp	.+650    	; 0xfec <tftp_sendSingleBlockData+0x2da>
	}
	printf("destination = ");
     d62:	00 d0       	rcall	.+0      	; 0xd64 <tftp_sendSingleBlockData+0x52>
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	99 e0       	ldi	r25, 0x09	; 9
     d68:	ed b7       	in	r30, 0x3d	; 61
     d6a:	fe b7       	in	r31, 0x3e	; 62
     d6c:	92 83       	std	Z+2, r25	; 0x02
     d6e:	81 83       	std	Z+1, r24	; 0x01
     d70:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
	print_addr_dec(dst_ip);
     d74:	0f 90       	pop	r0
     d76:	0f 90       	pop	r0
     d78:	c7 01       	movw	r24, r14
     d7a:	0e 94 ff 10 	call	0x21fe	; 0x21fe <print_addr_dec>
//	printf("local-data-length = %d\n", data_len);
	filenameCheck |= (data_ptr==NULL);
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	c1 14       	cp	r12, r1
     d82:	d1 04       	cpc	r13, r1
     d84:	09 f0       	breq	.+2      	; 0xd88 <tftp_sendSingleBlockData+0x76>
     d86:	80 e0       	ldi	r24, 0x00	; 0
	filenameCheck = filenameCheck<<1;
     d88:	b8 2e       	mov	r11, r24
     d8a:	bb 0c       	add	r11, r11
//	printf("remote-filename = '%s'\n", remote_filename);
	filenameCheck |= (remote_filename==NULL || remote_filename[0]==0x00 );
     d8c:	20 97       	sbiw	r28, 0x00	; 0
     d8e:	41 f0       	breq	.+16     	; 0xda0 <tftp_sendSingleBlockData+0x8e>
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	90 e0       	ldi	r25, 0x00	; 0
     d94:	28 81       	ld	r18, Y
     d96:	22 23       	and	r18, r18
     d98:	29 f0       	breq	.+10     	; 0xda4 <tftp_sendSingleBlockData+0x92>
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	90 e0       	ldi	r25, 0x00	; 0
     d9e:	02 c0       	rjmp	.+4      	; 0xda4 <tftp_sendSingleBlockData+0x92>
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	b8 2a       	or	r11, r24
//	printf("filename-check = 0x%02x\n", filenameCheck);
	if(filenameCheck & 0x02)
     da6:	b1 fe       	sbrs	r11, 1
     da8:	06 c0       	rjmp	.+12     	; 0xdb6 <tftp_sendSingleBlockData+0xa4>
	{
		printf("empty local data ptr\n");
     daa:	8f e0       	ldi	r24, 0x0F	; 15
     dac:	99 e0       	ldi	r25, 0x09	; 9
     dae:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
		return (-2);
     db2:	8e ef       	ldi	r24, 0xFE	; 254
     db4:	1b c1       	rjmp	.+566    	; 0xfec <tftp_sendSingleBlockData+0x2da>
	}
	if(filenameCheck & 0x01)
     db6:	b0 fe       	sbrs	r11, 0
     db8:	06 c0       	rjmp	.+12     	; 0xdc6 <tftp_sendSingleBlockData+0xb4>
	{
		printf("empty remote filename, using default filename = "TFTP_DEFAULT_FILENAME"\n");
     dba:	84 e2       	ldi	r24, 0x24	; 36
     dbc:	99 e0       	ldi	r25, 0x09	; 9
     dbe:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
		remote_filename=TFTP_DEFAULT_FILENAME;
     dc2:	c0 e6       	ldi	r28, 0x60	; 96
     dc4:	d9 e0       	ldi	r29, 0x09	; 9
	}
	if(filenameCheck == 0x03)
     dc6:	fb 2d       	mov	r31, r11
     dc8:	f3 30       	cpi	r31, 0x03	; 3
     dca:	79 f4       	brne	.+30     	; 0xdea <tftp_sendSingleBlockData+0xd8>
	{
		printf("empty input filenames");
     dcc:	00 d0       	rcall	.+0      	; 0xdce <tftp_sendSingleBlockData+0xbc>
     dce:	8c e6       	ldi	r24, 0x6C	; 108
     dd0:	99 e0       	ldi	r25, 0x09	; 9
     dd2:	ad b7       	in	r26, 0x3d	; 61
     dd4:	be b7       	in	r27, 0x3e	; 62
     dd6:	12 96       	adiw	r26, 0x02	; 2
     dd8:	9c 93       	st	X, r25
     dda:	8e 93       	st	-X, r24
     ddc:	11 97       	sbiw	r26, 0x01	; 1
     dde:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		return (-3);
     de2:	0f 90       	pop	r0
     de4:	0f 90       	pop	r0
     de6:	8d ef       	ldi	r24, 0xFD	; 253
     de8:	01 c1       	rjmp	.+514    	; 0xfec <tftp_sendSingleBlockData+0x2da>
	}
    lastMessage.payloadLength=0;
     dea:	10 92 bd 12 	sts	0x12BD, r1
     dee:	10 92 bc 12 	sts	0x12BC, r1
    //put opcode in
    lastMessage.opcode=TFTP_OPCODE_WRQ_SINGLE;
     df2:	86 e0       	ldi	r24, 0x06	; 6
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	90 93 bb 11 	sts	0x11BB, r25
     dfa:	80 93 ba 11 	sts	0x11BA, r24
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
     dfe:	8a ea       	ldi	r24, 0xAA	; 170
     e00:	91 e1       	ldi	r25, 0x11	; 17
     e02:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
     e06:	a0 eb       	ldi	r26, 0xB0	; 176
     e08:	b1 e1       	ldi	r27, 0x11	; 17
     e0a:	8e 2d       	mov	r24, r14
     e0c:	9f 2d       	mov	r25, r15
     e0e:	fc 01       	movw	r30, r24
     e10:	86 e0       	ldi	r24, 0x06	; 6
     e12:	01 90       	ld	r0, Z+
     e14:	0d 92       	st	X+, r0
     e16:	81 50       	subi	r24, 0x01	; 1
     e18:	e1 f7       	brne	.-8      	; 0xe12 <tftp_sendSingleBlockData+0x100>
    //select destination port
    lastMessage.dst_port=69;
     e1a:	85 e4       	ldi	r24, 0x45	; 69
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	90 93 b9 11 	sts	0x11B9, r25
     e22:	80 93 b8 11 	sts	0x11B8, r24
    //select a random src port
    do
    {
        lastMessage.src_port= 65535*(((float)rand())/((float)RAND_MAX));
     e26:	0e 94 30 4c 	call	0x9860	; 0x9860 <rand>
     e2a:	fc 01       	movw	r30, r24
     e2c:	bf 01       	movw	r22, r30
     e2e:	88 27       	eor	r24, r24
     e30:	77 fd       	sbrc	r23, 7
     e32:	80 95       	com	r24
     e34:	98 2f       	mov	r25, r24
     e36:	0e 94 c6 48 	call	0x918c	; 0x918c <__floatsisf>
     e3a:	20 e0       	ldi	r18, 0x00	; 0
     e3c:	3e ef       	ldi	r19, 0xFE	; 254
     e3e:	4f ef       	ldi	r20, 0xFF	; 255
     e40:	56 e4       	ldi	r21, 0x46	; 70
     e42:	0e 94 e8 47 	call	0x8fd0	; 0x8fd0 <__divsf3>
     e46:	20 e0       	ldi	r18, 0x00	; 0
     e48:	3f ef       	ldi	r19, 0xFF	; 255
     e4a:	4f e7       	ldi	r20, 0x7F	; 127
     e4c:	57 e4       	ldi	r21, 0x47	; 71
     e4e:	0e 94 ee 46 	call	0x8ddc	; 0x8ddc <__mulsf3>
     e52:	0e 94 1a 45 	call	0x8a34	; 0x8a34 <__fixunssfsi>
     e56:	70 93 b7 11 	sts	0x11B7, r23
     e5a:	60 93 b6 11 	sts	0x11B6, r22
    }while(lastMessage.src_port==69 || lastMessage.src_port==0);
     e5e:	65 34       	cpi	r22, 0x45	; 69
     e60:	71 05       	cpc	r23, r1
     e62:	09 f3       	breq	.-62     	; 0xe26 <tftp_sendSingleBlockData+0x114>
     e64:	61 15       	cp	r22, r1
     e66:	71 05       	cpc	r23, r1
     e68:	f1 f2       	breq	.-68     	; 0xe26 <tftp_sendSingleBlockData+0x114>
    //assign the tft_src_port
    tftp_src_port=lastMessage.src_port;
     e6a:	70 93 71 0b 	sts	0x0B71, r23
     e6e:	60 93 70 0b 	sts	0x0B70, r22
    printf("tftp src port = %d\n", tftp_src_port);
     e72:	00 d0       	rcall	.+0      	; 0xe74 <tftp_sendSingleBlockData+0x162>
     e74:	00 d0       	rcall	.+0      	; 0xe76 <tftp_sendSingleBlockData+0x164>
     e76:	ed b7       	in	r30, 0x3d	; 61
     e78:	fe b7       	in	r31, 0x3e	; 62
     e7a:	31 96       	adiw	r30, 0x01	; 1
     e7c:	22 e8       	ldi	r18, 0x82	; 130
     e7e:	39 e0       	ldi	r19, 0x09	; 9
     e80:	ad b7       	in	r26, 0x3d	; 61
     e82:	be b7       	in	r27, 0x3e	; 62
     e84:	12 96       	adiw	r26, 0x02	; 2
     e86:	3c 93       	st	X, r19
     e88:	2e 93       	st	-X, r18
     e8a:	11 97       	sbiw	r26, 0x01	; 1
     e8c:	73 83       	std	Z+3, r23	; 0x03
     e8e:	62 83       	std	Z+2, r22	; 0x02
     e90:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
     e94:	e0 90 bc 12 	lds	r14, 0x12BC
     e98:	f0 90 bd 12 	lds	r15, 0x12BD
     e9c:	f7 01       	movw	r30, r14
     e9e:	e6 55       	subi	r30, 0x56	; 86
     ea0:	fe 4e       	sbci	r31, 0xEE	; 238
     ea2:	12 8a       	std	Z+18, r1	; 0x12
     ea4:	08 94       	sec
     ea6:	e1 1c       	adc	r14, r1
     ea8:	f1 1c       	adc	r15, r1
    lastMessage.payload[lastMessage.payloadLength++] = TFTP_OPCODE_WRQ_SINGLE;
     eaa:	f7 01       	movw	r30, r14
     eac:	e6 55       	subi	r30, 0x56	; 86
     eae:	fe 4e       	sbci	r31, 0xEE	; 238
     eb0:	86 e0       	ldi	r24, 0x06	; 6
     eb2:	82 8b       	std	Z+18, r24	; 0x12
     eb4:	08 94       	sec
     eb6:	e1 1c       	adc	r14, r1
     eb8:	f1 1c       	adc	r15, r1
     eba:	f0 92 bd 12 	sts	0x12BD, r15
     ebe:	e0 92 bc 12 	sts	0x12BC, r14
    memcpy(lastMessage.payload+lastMessage.payloadLength, remote_filename, strnlen(remote_filename, 16));
     ec2:	0f 90       	pop	r0
     ec4:	0f 90       	pop	r0
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	ce 01       	movw	r24, r28
     ecc:	60 e1       	ldi	r22, 0x10	; 16
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	0e 94 6b 4c 	call	0x98d6	; 0x98d6 <strnlen>
     ed4:	ac 01       	movw	r20, r24
     ed6:	97 01       	movw	r18, r14
     ed8:	24 54       	subi	r18, 0x44	; 68
     eda:	3e 4e       	sbci	r19, 0xEE	; 238
     edc:	c9 01       	movw	r24, r18
     ede:	be 01       	movw	r22, r28
     ee0:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    lastMessage.payloadLength+=strnlen(remote_filename, 16);
     ee4:	ce 01       	movw	r24, r28
     ee6:	60 e1       	ldi	r22, 0x10	; 16
     ee8:	70 e0       	ldi	r23, 0x00	; 0
     eea:	0e 94 6b 4c 	call	0x98d6	; 0x98d6 <strnlen>
     eee:	20 91 bc 12 	lds	r18, 0x12BC
     ef2:	30 91 bd 12 	lds	r19, 0x12BD
     ef6:	28 0f       	add	r18, r24
     ef8:	39 1f       	adc	r19, r25
     efa:	30 93 bd 12 	sts	0x12BD, r19
     efe:	20 93 bc 12 	sts	0x12BC, r18
    printf("remote_filename = '%s'\n", remote_filename);
     f02:	00 d0       	rcall	.+0      	; 0xf04 <tftp_sendSingleBlockData+0x1f2>
     f04:	00 d0       	rcall	.+0      	; 0xf06 <tftp_sendSingleBlockData+0x1f4>
     f06:	86 e9       	ldi	r24, 0x96	; 150
     f08:	99 e0       	ldi	r25, 0x09	; 9
     f0a:	ad b7       	in	r26, 0x3d	; 61
     f0c:	be b7       	in	r27, 0x3e	; 62
     f0e:	12 96       	adiw	r26, 0x02	; 2
     f10:	9c 93       	st	X, r25
     f12:	8e 93       	st	-X, r24
     f14:	11 97       	sbiw	r26, 0x01	; 1
     f16:	14 96       	adiw	r26, 0x04	; 4
     f18:	dc 93       	st	X, r29
     f1a:	ce 93       	st	-X, r28
     f1c:	13 97       	sbiw	r26, 0x03	; 3
     f1e:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    memcpy(lastMessage.payload+lastMessage.payloadLength, "\0netascii\0", 10);
     f22:	e0 91 bc 12 	lds	r30, 0x12BC
     f26:	f0 91 bd 12 	lds	r31, 0x12BD
     f2a:	e4 54       	subi	r30, 0x44	; 68
     f2c:	fe 4e       	sbci	r31, 0xEE	; 238
     f2e:	ae ea       	ldi	r26, 0xAE	; 174
     f30:	b9 e0       	ldi	r27, 0x09	; 9
     f32:	8a e0       	ldi	r24, 0x0A	; 10
     f34:	0d 90       	ld	r0, X+
     f36:	01 92       	st	Z+, r0
     f38:	81 50       	subi	r24, 0x01	; 1
     f3a:	e1 f7       	brne	.-8      	; 0xf34 <tftp_sendSingleBlockData+0x222>
    lastMessage.payloadLength+=10;
     f3c:	20 91 bc 12 	lds	r18, 0x12BC
     f40:	30 91 bd 12 	lds	r19, 0x12BD
     f44:	26 5f       	subi	r18, 0xF6	; 246
     f46:	3f 4f       	sbci	r19, 0xFF	; 255
     f48:	30 93 bd 12 	sts	0x12BD, r19
     f4c:	20 93 bc 12 	sts	0x12BC, r18
    lastMessage.append=0;
     f50:	10 92 c0 12 	sts	0x12C0, r1
    memcpy(&(lastMessage.payload[lastMessage.payloadLength]), data_ptr, data_len);
     f54:	24 54       	subi	r18, 0x44	; 68
     f56:	3e 4e       	sbci	r19, 0xEE	; 238
     f58:	0f 90       	pop	r0
     f5a:	0f 90       	pop	r0
     f5c:	0f 90       	pop	r0
     f5e:	0f 90       	pop	r0
     f60:	c9 01       	movw	r24, r18
     f62:	b6 01       	movw	r22, r12
     f64:	a8 01       	movw	r20, r16
     f66:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    lastMessage.payloadLength+=data_len;
     f6a:	80 91 bc 12 	lds	r24, 0x12BC
     f6e:	90 91 bd 12 	lds	r25, 0x12BD
     f72:	80 0f       	add	r24, r16
     f74:	91 1f       	adc	r25, r17
     f76:	90 93 bd 12 	sts	0x12BD, r25
     f7a:	80 93 bc 12 	sts	0x12BC, r24

    //put the block number in
    lastMessage.blockNumber = blockNumber=0;
     f7e:	10 92 c7 12 	sts	0x12C7, r1
     f82:	10 92 c6 12 	sts	0x12C6, r1
     f86:	10 92 bf 12 	sts	0x12BF, r1
     f8a:	10 92 be 12 	sts	0x12BE, r1

    //set a timer to exit after a certain amount of time
	timers_create_timer(TFTP_SINGLE_BLOCK_WAIT_TIME, 128);
     f8e:	81 e0       	ldi	r24, 0x01	; 1
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	60 e8       	ldi	r22, 0x80	; 128
     f94:	70 e0       	ldi	r23, 0x00	; 0
     f96:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>


    //reset acks
    ackNumber=-1;
     f9a:	8f ef       	ldi	r24, 0xFF	; 255
     f9c:	9f ef       	ldi	r25, 0xFF	; 255
     f9e:	90 93 c4 12 	sts	0x12C4, r25
     fa2:	80 93 c3 12 	sts	0x12C3, r24
    blockNumber=0;
     fa6:	10 92 c7 12 	sts	0x12C7, r1
     faa:	10 92 c6 12 	sts	0x12C6, r1
    isRequestOwner=1;
     fae:	81 e0       	ldi	r24, 0x01	; 1
     fb0:	80 93 c1 12 	sts	0x12C1, r24
    timeouts=0;
     fb4:	10 92 c5 12 	sts	0x12C5, r1
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
     fb8:	c0 91 c8 12 	lds	r28, 0x12C8
     fbc:	d0 91 c9 12 	lds	r29, 0x12C9
     fc0:	80 e0       	ldi	r24, 0x00	; 0
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
     fc8:	60 91 b6 11 	lds	r22, 0x11B6
     fcc:	70 91 b7 11 	lds	r23, 0x11B7
     fd0:	20 91 b8 11 	lds	r18, 0x11B8
     fd4:	30 91 b9 11 	lds	r19, 0x11B9
     fd8:	e0 90 bc 12 	lds	r14, 0x12BC
     fdc:	f0 90 bd 12 	lds	r15, 0x12BD
     fe0:	40 eb       	ldi	r20, 0xB0	; 176
     fe2:	51 e1       	ldi	r21, 0x11	; 17
     fe4:	0c eb       	ldi	r16, 0xBC	; 188
     fe6:	11 e1       	ldi	r17, 0x11	; 17
     fe8:	fe 01       	movw	r30, r28
     fea:	09 95       	icall
}
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	0f 91       	pop	r16
     ff4:	ff 90       	pop	r15
     ff6:	ef 90       	pop	r14
     ff8:	df 90       	pop	r13
     ffa:	cf 90       	pop	r12
     ffc:	bf 90       	pop	r11
     ffe:	af 90       	pop	r10
    1000:	08 95       	ret

00001002 <tftp_sendRequest>:
uint8_t tftp_sendRequest(uint8_t opcode, uint8_t* dst_ip, uint8_t* local_databuffer, uint16_t local_databuffer_len, uint8_t* remote_filename, uint8_t remote_filename_len, uint8_t append)
{
    1002:	6f 92       	push	r6
    1004:	7f 92       	push	r7
    1006:	8f 92       	push	r8
    1008:	9f 92       	push	r9
    100a:	af 92       	push	r10
    100c:	bf 92       	push	r11
    100e:	cf 92       	push	r12
    1010:	df 92       	push	r13
    1012:	ef 92       	push	r14
    1014:	ff 92       	push	r15
    1016:	0f 93       	push	r16
    1018:	1f 93       	push	r17
    101a:	cf 93       	push	r28
    101c:	df 93       	push	r29
    101e:	f8 2e       	mov	r15, r24
    1020:	96 2e       	mov	r9, r22
    1022:	d7 2e       	mov	r13, r23
    1024:	5a 01       	movw	r10, r20
    1026:	39 01       	movw	r6, r18
    1028:	e8 01       	movw	r28, r16
	uint8_t filenameCheck=0;
	PRINTF_D("destination = ");
    102a:	00 d0       	rcall	.+0      	; 0x102c <tftp_sendRequest+0x2a>
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	99 e0       	ldi	r25, 0x09	; 9
    1030:	ad b7       	in	r26, 0x3d	; 61
    1032:	be b7       	in	r27, 0x3e	; 62
    1034:	12 96       	adiw	r26, 0x02	; 2
    1036:	9c 93       	st	X, r25
    1038:	8e 93       	st	-X, r24
    103a:	11 97       	sbiw	r26, 0x01	; 1
    103c:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
	print_addr_dec(dst_ip);
    1040:	0f 90       	pop	r0
    1042:	0f 90       	pop	r0
    1044:	89 2d       	mov	r24, r9
    1046:	9d 2d       	mov	r25, r13
    1048:	0e 94 ff 10 	call	0x21fe	; 0x21fe <print_addr_dec>
	filenameCheck |= (local_databuffer==NULL);
    104c:	11 e0       	ldi	r17, 0x01	; 1
    104e:	a1 14       	cp	r10, r1
    1050:	b1 04       	cpc	r11, r1
    1052:	09 f0       	breq	.+2      	; 0x1056 <tftp_sendRequest+0x54>
    1054:	10 e0       	ldi	r17, 0x00	; 0
	filenameCheck = filenameCheck<<1;
    1056:	11 0f       	add	r17, r17
	//PRINTF_D("remote-filename = '%s' -> %d\n", remote_filename, remote_filename_len);
	filenameCheck |= (remote_filename==NULL || remote_filename_len==0 || remote_filename[0]==0x00 );
    1058:	20 97       	sbiw	r28, 0x00	; 0
    105a:	51 f0       	breq	.+20     	; 0x1070 <tftp_sendRequest+0x6e>
    105c:	ee 20       	and	r14, r14
    105e:	41 f0       	breq	.+16     	; 0x1070 <tftp_sendRequest+0x6e>
    1060:	81 e0       	ldi	r24, 0x01	; 1
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	28 81       	ld	r18, Y
    1066:	22 23       	and	r18, r18
    1068:	29 f0       	breq	.+10     	; 0x1074 <tftp_sendRequest+0x72>
    106a:	80 e0       	ldi	r24, 0x00	; 0
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	02 c0       	rjmp	.+4      	; 0x1074 <tftp_sendRequest+0x72>
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	18 2b       	or	r17, r24
	//PRINTF_D("filename-check = 0x%02x\n", filenameCheck);
	if(filenameCheck & 0x02)
    1076:	11 ff       	sbrs	r17, 1
    1078:	05 c0       	rjmp	.+10     	; 0x1084 <tftp_sendRequest+0x82>
	{
		PRINTF_D("null pointer, exiting\n");
    107a:	89 eb       	ldi	r24, 0xB9	; 185
    107c:	99 e0       	ldi	r25, 0x09	; 9
    107e:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
    1082:	43 c1       	rjmp	.+646    	; 0x130a <tftp_sendRequest+0x308>
		return -1;
	}
	if(filenameCheck & 0x01)
    1084:	10 ff       	sbrs	r17, 0
    1086:	08 c0       	rjmp	.+16     	; 0x1098 <tftp_sendRequest+0x96>
	{
		PRINTF_D("empty remote filename, using default 'sensors.dat'\n");
    1088:	8f ec       	ldi	r24, 0xCF	; 207
    108a:	99 e0       	ldi	r25, 0x09	; 9
    108c:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
		remote_filename="sensors.dat";
    1090:	c0 e6       	ldi	r28, 0x60	; 96
    1092:	d9 e0       	ldi	r29, 0x09	; 9
		remote_filename_len=strlen("sensors.dat");
    1094:	8b e0       	ldi	r24, 0x0B	; 11
    1096:	e8 2e       	mov	r14, r24
	}
	if(filenameCheck == 0x03)
    1098:	13 30       	cpi	r17, 0x03	; 3
    109a:	09 f4       	brne	.+2      	; 0x109e <tftp_sendRequest+0x9c>
    109c:	36 c1       	rjmp	.+620    	; 0x130a <tftp_sendRequest+0x308>
	{
		return -1;
	}
    if(opcode == TFTP_OPCODE_RRQ)
    109e:	bf 2d       	mov	r27, r15
    10a0:	b1 30       	cpi	r27, 0x01	; 1
    10a2:	29 f4       	brne	.+10     	; 0x10ae <tftp_sendRequest+0xac>
    {
    	printf("radiotftp_process does not receive files\n");
    10a4:	82 e0       	ldi	r24, 0x02	; 2
    10a6:	9a e0       	ldi	r25, 0x0A	; 10
    10a8:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
    10ac:	21 c0       	rjmp	.+66     	; 0x10f0 <tftp_sendRequest+0xee>
    }
    else if(opcode == TFTP_OPCODE_WRQ)
    10ae:	ef 2d       	mov	r30, r15
    10b0:	e2 30       	cpi	r30, 0x02	; 2
    10b2:	09 f0       	breq	.+2      	; 0x10b6 <tftp_sendRequest+0xb4>
    10b4:	2c c1       	rjmp	.+600    	; 0x130e <tftp_sendRequest+0x30c>
    return 0;
}

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	80 93 c2 12 	sts	0x12C2, r24
    	printf("radiotftp_process does not receive files\n");
    }
    else if(opcode == TFTP_OPCODE_WRQ)
    {
        tftp_setStatus(TFTP_STATUS_SENDING);
        data_buffer = local_databuffer;
    10bc:	b0 92 cd 12 	sts	0x12CD, r11
    10c0:	a0 92 cc 12 	sts	0x12CC, r10
        if(data_buffer == NULL)
    10c4:	a1 14       	cp	r10, r1
    10c6:	b1 04       	cpc	r11, r1
    10c8:	79 f4       	brne	.+30     	; 0x10e8 <tftp_sendRequest+0xe6>
        {
            PRINTF_D("error opening file for read");
    10ca:	00 d0       	rcall	.+0      	; 0x10cc <tftp_sendRequest+0xca>
    10cc:	8b e2       	ldi	r24, 0x2B	; 43
    10ce:	9a e0       	ldi	r25, 0x0A	; 10
    10d0:	ad b7       	in	r26, 0x3d	; 61
    10d2:	be b7       	in	r27, 0x3e	; 62
    10d4:	12 96       	adiw	r26, 0x02	; 2
    10d6:	9c 93       	st	X, r25
    10d8:	8e 93       	st	-X, r24
    10da:	11 97       	sbiw	r26, 0x01	; 1
    10dc:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
            return (-13);
    10e0:	0f 90       	pop	r0
    10e2:	0f 90       	pop	r0
    10e4:	83 ef       	ldi	r24, 0xF3	; 243
    10e6:	14 c1       	rjmp	.+552    	; 0x1310 <tftp_sendRequest+0x30e>
        }
        fileLen=local_databuffer_len;
    10e8:	70 92 cb 12 	sts	0x12CB, r7
    10ec:	60 92 ca 12 	sts	0x12CA, r6
    }
    else
    {
        return -10;
    }
    lastMessage.payloadLength=0;
    10f0:	10 92 bd 12 	sts	0x12BD, r1
    10f4:	10 92 bc 12 	sts	0x12BC, r1
    //put opcode in
    lastMessage.opcode=opcode;
    10f8:	f0 92 ba 11 	sts	0x11BA, r15
    10fc:	10 92 bb 11 	sts	0x11BB, r1
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
    1100:	8a ea       	ldi	r24, 0xAA	; 170
    1102:	91 e1       	ldi	r25, 0x11	; 17
    1104:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
    1108:	a0 eb       	ldi	r26, 0xB0	; 176
    110a:	b1 e1       	ldi	r27, 0x11	; 17
    110c:	89 2d       	mov	r24, r9
    110e:	9d 2d       	mov	r25, r13
    1110:	fc 01       	movw	r30, r24
    1112:	86 e0       	ldi	r24, 0x06	; 6
    1114:	01 90       	ld	r0, Z+
    1116:	0d 92       	st	X+, r0
    1118:	81 50       	subi	r24, 0x01	; 1
    111a:	e1 f7       	brne	.-8      	; 0x1114 <tftp_sendRequest+0x112>
    //select destination port
    lastMessage.dst_port=69;
    111c:	85 e4       	ldi	r24, 0x45	; 69
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	90 93 b9 11 	sts	0x11B9, r25
    1124:	80 93 b8 11 	sts	0x11B8, r24
    //select a random src port
    do
    {
        lastMessage.src_port= 65535*(((float)rand())/((float)RAND_MAX));
    1128:	0e 94 30 4c 	call	0x9860	; 0x9860 <rand>
    112c:	fc 01       	movw	r30, r24
    112e:	bf 01       	movw	r22, r30
    1130:	88 27       	eor	r24, r24
    1132:	77 fd       	sbrc	r23, 7
    1134:	80 95       	com	r24
    1136:	98 2f       	mov	r25, r24
    1138:	0e 94 c6 48 	call	0x918c	; 0x918c <__floatsisf>
    113c:	20 e0       	ldi	r18, 0x00	; 0
    113e:	3e ef       	ldi	r19, 0xFE	; 254
    1140:	4f ef       	ldi	r20, 0xFF	; 255
    1142:	56 e4       	ldi	r21, 0x46	; 70
    1144:	0e 94 e8 47 	call	0x8fd0	; 0x8fd0 <__divsf3>
    1148:	20 e0       	ldi	r18, 0x00	; 0
    114a:	3f ef       	ldi	r19, 0xFF	; 255
    114c:	4f e7       	ldi	r20, 0x7F	; 127
    114e:	57 e4       	ldi	r21, 0x47	; 71
    1150:	0e 94 ee 46 	call	0x8ddc	; 0x8ddc <__mulsf3>
    1154:	0e 94 1a 45 	call	0x8a34	; 0x8a34 <__fixunssfsi>
    1158:	70 93 b7 11 	sts	0x11B7, r23
    115c:	60 93 b6 11 	sts	0x11B6, r22
    }while(lastMessage.src_port==69 || lastMessage.src_port==0);
    1160:	65 34       	cpi	r22, 0x45	; 69
    1162:	71 05       	cpc	r23, r1
    1164:	09 f3       	breq	.-62     	; 0x1128 <tftp_sendRequest+0x126>
    1166:	61 15       	cp	r22, r1
    1168:	71 05       	cpc	r23, r1
    116a:	f1 f2       	breq	.-68     	; 0x1128 <tftp_sendRequest+0x126>
    //assign the tft_src_port
    tftp_src_port=lastMessage.src_port;
    116c:	70 93 71 0b 	sts	0x0B71, r23
    1170:	60 93 70 0b 	sts	0x0B70, r22
    PRINTF_D("tftp src port = %d\n", tftp_src_port);
    1174:	00 d0       	rcall	.+0      	; 0x1176 <tftp_sendRequest+0x174>
    1176:	00 d0       	rcall	.+0      	; 0x1178 <tftp_sendRequest+0x176>
    1178:	ed b7       	in	r30, 0x3d	; 61
    117a:	fe b7       	in	r31, 0x3e	; 62
    117c:	31 96       	adiw	r30, 0x01	; 1
    117e:	22 e8       	ldi	r18, 0x82	; 130
    1180:	39 e0       	ldi	r19, 0x09	; 9
    1182:	ad b7       	in	r26, 0x3d	; 61
    1184:	be b7       	in	r27, 0x3e	; 62
    1186:	12 96       	adiw	r26, 0x02	; 2
    1188:	3c 93       	st	X, r19
    118a:	2e 93       	st	-X, r18
    118c:	11 97       	sbiw	r26, 0x01	; 1
    118e:	73 83       	std	Z+3, r23	; 0x03
    1190:	62 83       	std	Z+2, r22	; 0x02
    1192:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    1196:	20 91 bc 12 	lds	r18, 0x12BC
    119a:	30 91 bd 12 	lds	r19, 0x12BD
    119e:	f9 01       	movw	r30, r18
    11a0:	e6 55       	subi	r30, 0x56	; 86
    11a2:	fe 4e       	sbci	r31, 0xEE	; 238
    11a4:	12 8a       	std	Z+18, r1	; 0x12
    11a6:	2f 5f       	subi	r18, 0xFF	; 255
    11a8:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = opcode;
    11aa:	f9 01       	movw	r30, r18
    11ac:	e6 55       	subi	r30, 0x56	; 86
    11ae:	fe 4e       	sbci	r31, 0xEE	; 238
    11b0:	f2 8a       	std	Z+18, r15	; 0x12
    11b2:	2f 5f       	subi	r18, 0xFF	; 255
    11b4:	3f 4f       	sbci	r19, 0xFF	; 255
    11b6:	30 93 bd 12 	sts	0x12BD, r19
    11ba:	20 93 bc 12 	sts	0x12BC, r18
    memcpy(lastMessage.payload+lastMessage.payloadLength, remote_filename, remote_filename_len);
    11be:	ae 2c       	mov	r10, r14
    11c0:	bb 24       	eor	r11, r11
    11c2:	24 54       	subi	r18, 0x44	; 68
    11c4:	3e 4e       	sbci	r19, 0xEE	; 238
    11c6:	0f 90       	pop	r0
    11c8:	0f 90       	pop	r0
    11ca:	0f 90       	pop	r0
    11cc:	0f 90       	pop	r0
    11ce:	c9 01       	movw	r24, r18
    11d0:	be 01       	movw	r22, r28
    11d2:	4e 2d       	mov	r20, r14
    11d4:	50 e0       	ldi	r21, 0x00	; 0
    11d6:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    lastMessage.payloadLength+=remote_filename_len;
    11da:	80 91 bc 12 	lds	r24, 0x12BC
    11de:	90 91 bd 12 	lds	r25, 0x12BD
    11e2:	8a 0d       	add	r24, r10
    11e4:	9b 1d       	adc	r25, r11
    11e6:	90 93 bd 12 	sts	0x12BD, r25
    11ea:	80 93 bc 12 	sts	0x12BC, r24
    PRINTF_D("remote_filename = '%s'\n", remote_filename);
    11ee:	00 d0       	rcall	.+0      	; 0x11f0 <tftp_sendRequest+0x1ee>
    11f0:	00 d0       	rcall	.+0      	; 0x11f2 <tftp_sendRequest+0x1f0>
    11f2:	86 e9       	ldi	r24, 0x96	; 150
    11f4:	99 e0       	ldi	r25, 0x09	; 9
    11f6:	ad b7       	in	r26, 0x3d	; 61
    11f8:	be b7       	in	r27, 0x3e	; 62
    11fa:	12 96       	adiw	r26, 0x02	; 2
    11fc:	9c 93       	st	X, r25
    11fe:	8e 93       	st	-X, r24
    1200:	11 97       	sbiw	r26, 0x01	; 1
    1202:	14 96       	adiw	r26, 0x04	; 4
    1204:	dc 93       	st	X, r29
    1206:	ce 93       	st	-X, r28
    1208:	13 97       	sbiw	r26, 0x03	; 3
    120a:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    memcpy(lastMessage.payload+lastMessage.payloadLength, "\0netascii\0", 10);
    120e:	e0 91 bc 12 	lds	r30, 0x12BC
    1212:	f0 91 bd 12 	lds	r31, 0x12BD
    1216:	e4 54       	subi	r30, 0x44	; 68
    1218:	fe 4e       	sbci	r31, 0xEE	; 238
    121a:	ae ea       	ldi	r26, 0xAE	; 174
    121c:	b9 e0       	ldi	r27, 0x09	; 9
    121e:	8a e0       	ldi	r24, 0x0A	; 10
    1220:	0d 90       	ld	r0, X+
    1222:	01 92       	st	Z+, r0
    1224:	81 50       	subi	r24, 0x01	; 1
    1226:	e1 f7       	brne	.-8      	; 0x1220 <tftp_sendRequest+0x21e>
    lastMessage.payloadLength+=10;
    1228:	20 91 bc 12 	lds	r18, 0x12BC
    122c:	30 91 bd 12 	lds	r19, 0x12BD
    1230:	c9 01       	movw	r24, r18
    1232:	0a 96       	adiw	r24, 0x0a	; 10
    1234:	90 93 bd 12 	sts	0x12BD, r25
    1238:	80 93 bc 12 	sts	0x12BC, r24
    if(append)
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	cc 20       	and	r12, r12
    1246:	b9 f0       	breq	.+46     	; 0x1276 <tftp_sendRequest+0x274>
    {
    	memcpy(lastMessage.payload+lastMessage.payloadLength, "append\0", 7);
    1248:	dc 01       	movw	r26, r24
    124a:	a4 54       	subi	r26, 0x44	; 68
    124c:	be 4e       	sbci	r27, 0xEE	; 238
    124e:	e7 e4       	ldi	r30, 0x47	; 71
    1250:	fa e0       	ldi	r31, 0x0A	; 10
    1252:	87 e0       	ldi	r24, 0x07	; 7
    1254:	01 90       	ld	r0, Z+
    1256:	0d 92       	st	X+, r0
    1258:	81 50       	subi	r24, 0x01	; 1
    125a:	e1 f7       	brne	.-8      	; 0x1254 <tftp_sendRequest+0x252>
    	lastMessage.payloadLength+=7;
    125c:	80 91 bc 12 	lds	r24, 0x12BC
    1260:	90 91 bd 12 	lds	r25, 0x12BD
    1264:	07 96       	adiw	r24, 0x07	; 7
    1266:	90 93 bd 12 	sts	0x12BD, r25
    126a:	80 93 bc 12 	sts	0x12BC, r24
    	lastMessage.append=1;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	80 93 c0 12 	sts	0x12C0, r24
    1274:	0c c0       	rjmp	.+24     	; 0x128e <tftp_sendRequest+0x28c>
    }
    else
    {
    	lastMessage.payload[lastMessage.payloadLength]='\0';
    1276:	86 55       	subi	r24, 0x56	; 86
    1278:	9e 4e       	sbci	r25, 0xEE	; 238
    127a:	fc 01       	movw	r30, r24
    127c:	12 8a       	std	Z+18, r1	; 0x12
    	lastMessage.payloadLength++;
    127e:	25 5f       	subi	r18, 0xF5	; 245
    1280:	3f 4f       	sbci	r19, 0xFF	; 255
    1282:	30 93 bd 12 	sts	0x12BD, r19
    1286:	20 93 bc 12 	sts	0x12BC, r18
    	lastMessage.append=0;
    128a:	10 92 c0 12 	sts	0x12C0, r1
    }
    //put the block number in
    lastMessage.blockNumber = blockNumber=0;
    128e:	10 92 c7 12 	sts	0x12C7, r1
    1292:	10 92 c6 12 	sts	0x12C6, r1
    1296:	10 92 bf 12 	sts	0x12BF, r1
    129a:	10 92 be 12 	sts	0x12BE, r1
    	//set up retransmit timer
    if(opcode==TFTP_OPCODE_WRQ || opcode==TFTP_OPCODE_RRQ)
    129e:	8f 2d       	mov	r24, r15
    12a0:	81 50       	subi	r24, 0x01	; 1
    12a2:	82 30       	cpi	r24, 0x02	; 2
    12a4:	40 f4       	brcc	.+16     	; 0x12b6 <tftp_sendRequest+0x2b4>
    {
    	timers_create_timer(tftp_getRandomRetransmissionTime()+1, 128);
    12a6:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <tftp_getRandomRetransmissionTime>
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	60 e8       	ldi	r22, 0x80	; 128
    12b0:	70 e0       	ldi	r23, 0x00	; 0
    12b2:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>
    }
    //reset acks
    ackNumber=-1;
    12b6:	8f ef       	ldi	r24, 0xFF	; 255
    12b8:	9f ef       	ldi	r25, 0xFF	; 255
    12ba:	90 93 c4 12 	sts	0x12C4, r25
    12be:	80 93 c3 12 	sts	0x12C3, r24
    blockNumber=0;
    12c2:	10 92 c7 12 	sts	0x12C7, r1
    12c6:	10 92 c6 12 	sts	0x12C6, r1
    isRequestOwner=1;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	80 93 c1 12 	sts	0x12C1, r24
    timeouts=0;
    12d0:	10 92 c5 12 	sts	0x12C5, r1
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    12d4:	c0 91 c8 12 	lds	r28, 0x12C8
    12d8:	d0 91 c9 12 	lds	r29, 0x12C9
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    12e4:	60 91 b6 11 	lds	r22, 0x11B6
    12e8:	70 91 b7 11 	lds	r23, 0x11B7
    12ec:	20 91 b8 11 	lds	r18, 0x11B8
    12f0:	30 91 b9 11 	lds	r19, 0x11B9
    12f4:	e0 90 bc 12 	lds	r14, 0x12BC
    12f8:	f0 90 bd 12 	lds	r15, 0x12BD
    12fc:	40 eb       	ldi	r20, 0xB0	; 176
    12fe:	51 e1       	ldi	r21, 0x11	; 17
    1300:	0c eb       	ldi	r16, 0xBC	; 188
    1302:	11 e1       	ldi	r17, 0x11	; 17
    1304:	fe 01       	movw	r30, r28
    1306:	09 95       	icall
    1308:	03 c0       	rjmp	.+6      	; 0x1310 <tftp_sendRequest+0x30e>
		remote_filename="sensors.dat";
		remote_filename_len=strlen("sensors.dat");
	}
	if(filenameCheck == 0x03)
	{
		return -1;
    130a:	8f ef       	ldi	r24, 0xFF	; 255
    130c:	01 c0       	rjmp	.+2      	; 0x1310 <tftp_sendRequest+0x30e>
        }
        fileLen=local_databuffer_len;
    }
    else
    {
        return -10;
    130e:	86 ef       	ldi	r24, 0xF6	; 246
    ackNumber=-1;
    blockNumber=0;
    isRequestOwner=1;
    timeouts=0;
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
}
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
    1316:	0f 91       	pop	r16
    1318:	ff 90       	pop	r15
    131a:	ef 90       	pop	r14
    131c:	df 90       	pop	r13
    131e:	cf 90       	pop	r12
    1320:	bf 90       	pop	r11
    1322:	af 90       	pop	r10
    1324:	9f 90       	pop	r9
    1326:	8f 90       	pop	r8
    1328:	7f 90       	pop	r7
    132a:	6f 90       	pop	r6
    132c:	08 95       	ret

0000132e <tftp_sendData>:
uint8_t tftp_sendData(uint8_t* dst_ip, uint8_t blockNum)
{
    132e:	cf 92       	push	r12
    1330:	df 92       	push	r13
    1332:	ef 92       	push	r14
    1334:	ff 92       	push	r15
    1336:	0f 93       	push	r16
    1338:	1f 93       	push	r17
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	8c 01       	movw	r16, r24
    1340:	e6 2e       	mov	r14, r22
    uint16_t curPos, writeLen;
//    PRINTF_D("tftp_sendData\n");
    lastMessage.payloadLength=0;
    1342:	10 92 bd 12 	sts	0x12BD, r1
    1346:	10 92 bc 12 	sts	0x12BC, r1
    //put opcode in
    lastMessage.opcode=TFTP_OPCODE_DATA;
    134a:	23 e0       	ldi	r18, 0x03	; 3
    134c:	30 e0       	ldi	r19, 0x00	; 0
    134e:	30 93 bb 11 	sts	0x11BB, r19
    1352:	20 93 ba 11 	sts	0x11BA, r18
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
    1356:	8a ea       	ldi	r24, 0xAA	; 170
    1358:	91 e1       	ldi	r25, 0x11	; 17
    135a:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
    135e:	a0 eb       	ldi	r26, 0xB0	; 176
    1360:	b1 e1       	ldi	r27, 0x11	; 17
    1362:	80 2f       	mov	r24, r16
    1364:	91 2f       	mov	r25, r17
    1366:	fc 01       	movw	r30, r24
    1368:	86 e0       	ldi	r24, 0x06	; 6
    136a:	01 90       	ld	r0, Z+
    136c:	0d 92       	st	X+, r0
    136e:	81 50       	subi	r24, 0x01	; 1
    1370:	e1 f7       	brne	.-8      	; 0x136a <tftp_sendData+0x3c>
    //select destination port
    lastMessage.dst_port=tftp_dst_port;
    1372:	80 91 6e 0b 	lds	r24, 0x0B6E
    1376:	90 91 6f 0b 	lds	r25, 0x0B6F
    137a:	90 93 b9 11 	sts	0x11B9, r25
    137e:	80 93 b8 11 	sts	0x11B8, r24
    //select a random src port
    lastMessage.src_port=tftp_src_port;
    1382:	80 91 70 0b 	lds	r24, 0x0B70
    1386:	90 91 71 0b 	lds	r25, 0x0B71
    138a:	90 93 b7 11 	sts	0x11B7, r25
    138e:	80 93 b6 11 	sts	0x11B6, r24
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    1392:	40 91 bc 12 	lds	r20, 0x12BC
    1396:	50 91 bd 12 	lds	r21, 0x12BD
    139a:	fa 01       	movw	r30, r20
    139c:	e6 55       	subi	r30, 0x56	; 86
    139e:	fe 4e       	sbci	r31, 0xEE	; 238
    13a0:	12 8a       	std	Z+18, r1	; 0x12
    13a2:	4f 5f       	subi	r20, 0xFF	; 255
    13a4:	5f 4f       	sbci	r21, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = lastMessage.opcode;
    13a6:	fa 01       	movw	r30, r20
    13a8:	e6 55       	subi	r30, 0x56	; 86
    13aa:	fe 4e       	sbci	r31, 0xEE	; 238
    13ac:	80 91 ba 11 	lds	r24, 0x11BA
    13b0:	82 8b       	std	Z+18, r24	; 0x12
    13b2:	4f 5f       	subi	r20, 0xFF	; 255
    13b4:	5f 4f       	sbci	r21, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    13b6:	fa 01       	movw	r30, r20
    13b8:	e6 55       	subi	r30, 0x56	; 86
    13ba:	fe 4e       	sbci	r31, 0xEE	; 238
    13bc:	12 8a       	std	Z+18, r1	; 0x12
    13be:	4f 5f       	subi	r20, 0xFF	; 255
    13c0:	5f 4f       	sbci	r21, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = blockNum;
    13c2:	fa 01       	movw	r30, r20
    13c4:	e6 55       	subi	r30, 0x56	; 86
    13c6:	fe 4e       	sbci	r31, 0xEE	; 238
    13c8:	e2 8a       	std	Z+18, r14	; 0x12
    13ca:	4f 5f       	subi	r20, 0xFF	; 255
    13cc:	5f 4f       	sbci	r21, 0xFF	; 255
    13ce:	50 93 bd 12 	sts	0x12BD, r21
    13d2:	40 93 bc 12 	sts	0x12BC, r20
    //copy the data
#if 0
    curPos=buffer_pos; //this one was found to be faulty in case of retransmission
#else
    curPos=TFTP_MAX_BLOCK_SIZE*(blockNum-1);
    13d6:	8e 2d       	mov	r24, r14
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	01 97       	sbiw	r24, 0x01	; 1
    13dc:	98 2f       	mov	r25, r24
    13de:	88 27       	eor	r24, r24
    13e0:	99 0f       	add	r25, r25
#endif
//    PRINTF_D("tftp_sendData: before memcpy\n");
    if(fileLen-curPos < TFTP_MAX_BLOCK_SIZE)
    13e2:	c0 91 ca 12 	lds	r28, 0x12CA
    13e6:	d0 91 cb 12 	lds	r29, 0x12CB
    13ea:	c8 1b       	sub	r28, r24
    13ec:	d9 0b       	sbc	r29, r25
    13ee:	22 e0       	ldi	r18, 0x02	; 2
    13f0:	c0 30       	cpi	r28, 0x00	; 0
    13f2:	d2 07       	cpc	r29, r18
    13f4:	10 f0       	brcs	.+4      	; 0x13fa <tftp_sendData+0xcc>
    	writeLen=fileLen-curPos;
    else
    	writeLen=TFTP_MAX_BLOCK_SIZE;
    13f6:	c0 e0       	ldi	r28, 0x00	; 0
    13f8:	d2 e0       	ldi	r29, 0x02	; 2
    memcpy(lastMessage.payload+lastMessage.payloadLength, data_buffer+curPos, writeLen);
    13fa:	44 54       	subi	r20, 0x44	; 68
    13fc:	5e 4e       	sbci	r21, 0xEE	; 238
    13fe:	20 91 cc 12 	lds	r18, 0x12CC
    1402:	30 91 cd 12 	lds	r19, 0x12CD
    1406:	28 0f       	add	r18, r24
    1408:	39 1f       	adc	r19, r25
    140a:	ca 01       	movw	r24, r20
    140c:	b9 01       	movw	r22, r18
    140e:	ae 01       	movw	r20, r28
    1410:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    lastMessage.payloadLength+=writeLen;
    1414:	80 91 bc 12 	lds	r24, 0x12BC
    1418:	90 91 bd 12 	lds	r25, 0x12BD
    141c:	8c 0f       	add	r24, r28
    141e:	9d 1f       	adc	r25, r29
    1420:	90 93 bd 12 	sts	0x12BD, r25
    1424:	80 93 bc 12 	sts	0x12BC, r24
    curPos+=writeLen;

//    PRINTF_D("tftp_sendData: after memcpy\n");
    //put the block number in
    lastMessage.blockNumber = blockNum;
    1428:	e0 92 be 12 	sts	0x12BE, r14
    142c:	10 92 bf 12 	sts	0x12BF, r1
    //set up retransmit timer
    timers_create_timer(tftp_getRandomRetransmissionTime(), 128);
    1430:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <tftp_getRandomRetransmissionTime>
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	60 e8       	ldi	r22, 0x80	; 128
    1438:	70 e0       	ldi	r23, 0x00	; 0
    143a:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>
    PRINTF_D("sent data size = %u\n", lastMessage.payloadLength);
    143e:	00 d0       	rcall	.+0      	; 0x1440 <tftp_sendData+0x112>
    1440:	00 d0       	rcall	.+0      	; 0x1442 <tftp_sendData+0x114>
    1442:	8f e4       	ldi	r24, 0x4F	; 79
    1444:	9a e0       	ldi	r25, 0x0A	; 10
    1446:	ed b7       	in	r30, 0x3d	; 61
    1448:	fe b7       	in	r31, 0x3e	; 62
    144a:	92 83       	std	Z+2, r25	; 0x02
    144c:	81 83       	std	Z+1, r24	; 0x01
    144e:	80 91 bc 12 	lds	r24, 0x12BC
    1452:	90 91 bd 12 	lds	r25, 0x12BD
    1456:	94 83       	std	Z+4, r25	; 0x04
    1458:	83 83       	std	Z+3, r24	; 0x03
    145a:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    145e:	c0 91 c8 12 	lds	r28, 0x12C8
    1462:	d0 91 c9 12 	lds	r29, 0x12C9
    1466:	0f 90       	pop	r0
    1468:	0f 90       	pop	r0
    146a:	0f 90       	pop	r0
    146c:	0f 90       	pop	r0
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    1476:	60 91 b6 11 	lds	r22, 0x11B6
    147a:	70 91 b7 11 	lds	r23, 0x11B7
    147e:	20 91 b8 11 	lds	r18, 0x11B8
    1482:	30 91 b9 11 	lds	r19, 0x11B9
    1486:	e0 90 bc 12 	lds	r14, 0x12BC
    148a:	f0 90 bd 12 	lds	r15, 0x12BD
    148e:	40 eb       	ldi	r20, 0xB0	; 176
    1490:	51 e1       	ldi	r21, 0x11	; 17
    1492:	0c eb       	ldi	r16, 0xBC	; 188
    1494:	11 e1       	ldi	r17, 0x11	; 17
    1496:	fe 01       	movw	r30, r28
    1498:	09 95       	icall
}
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	1f 91       	pop	r17
    14a0:	0f 91       	pop	r16
    14a2:	ff 90       	pop	r15
    14a4:	ef 90       	pop	r14
    14a6:	df 90       	pop	r13
    14a8:	cf 90       	pop	r12
    14aa:	08 95       	ret

000014ac <tftp_sendError>:
uint8_t tftp_sendError(uint8_t type, uint8_t* dst_ip, uint16_t dst_prt, uint8_t* additionalInfo, uint8_t infoLen)
{
    14ac:	cf 92       	push	r12
    14ae:	df 92       	push	r13
    14b0:	ef 92       	push	r14
    14b2:	ff 92       	push	r15
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	df 93       	push	r29
    14ba:	cf 93       	push	r28
    14bc:	00 d0       	rcall	.+0      	; 0x14be <tftp_sendError+0x12>
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	18 2f       	mov	r17, r24
    14c4:	6a 01       	movw	r12, r20
    14c6:	79 01       	movw	r14, r18
    lastMessage.payloadLength=0;
    14c8:	10 92 bd 12 	sts	0x12BD, r1
    14cc:	10 92 bc 12 	sts	0x12BC, r1
    //put opcode in
    lastMessage.opcode=TFTP_OPCODE_ERROR;
    14d0:	85 e0       	ldi	r24, 0x05	; 5
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	90 93 bb 11 	sts	0x11BB, r25
    14d8:	80 93 ba 11 	sts	0x11BA, r24
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
    14dc:	8a ea       	ldi	r24, 0xAA	; 170
    14de:	91 e1       	ldi	r25, 0x11	; 17
    14e0:	69 83       	std	Y+1, r22	; 0x01
    14e2:	7a 83       	std	Y+2, r23	; 0x02
    14e4:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
    14e8:	a0 eb       	ldi	r26, 0xB0	; 176
    14ea:	b1 e1       	ldi	r27, 0x11	; 17
    14ec:	69 81       	ldd	r22, Y+1	; 0x01
    14ee:	7a 81       	ldd	r23, Y+2	; 0x02
    14f0:	86 2f       	mov	r24, r22
    14f2:	97 2f       	mov	r25, r23
    14f4:	fc 01       	movw	r30, r24
    14f6:	86 e0       	ldi	r24, 0x06	; 6
    14f8:	01 90       	ld	r0, Z+
    14fa:	0d 92       	st	X+, r0
    14fc:	81 50       	subi	r24, 0x01	; 1
    14fe:	e1 f7       	brne	.-8      	; 0x14f8 <tftp_sendError+0x4c>
    //select destination port
    lastMessage.dst_port=dst_prt;
    1500:	d0 92 b9 11 	sts	0x11B9, r13
    1504:	c0 92 b8 11 	sts	0x11B8, r12
    //select a random src port
    lastMessage.src_port=tftp_src_port;
    1508:	80 91 70 0b 	lds	r24, 0x0B70
    150c:	90 91 71 0b 	lds	r25, 0x0B71
    1510:	90 93 b7 11 	sts	0x11B7, r25
    1514:	80 93 b6 11 	sts	0x11B6, r24
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    1518:	20 91 bc 12 	lds	r18, 0x12BC
    151c:	30 91 bd 12 	lds	r19, 0x12BD
    1520:	f9 01       	movw	r30, r18
    1522:	e6 55       	subi	r30, 0x56	; 86
    1524:	fe 4e       	sbci	r31, 0xEE	; 238
    1526:	12 8a       	std	Z+18, r1	; 0x12
    1528:	2f 5f       	subi	r18, 0xFF	; 255
    152a:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = lastMessage.opcode;
    152c:	f9 01       	movw	r30, r18
    152e:	e6 55       	subi	r30, 0x56	; 86
    1530:	fe 4e       	sbci	r31, 0xEE	; 238
    1532:	80 91 ba 11 	lds	r24, 0x11BA
    1536:	82 8b       	std	Z+18, r24	; 0x12
    1538:	2f 5f       	subi	r18, 0xFF	; 255
    153a:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    153c:	f9 01       	movw	r30, r18
    153e:	e6 55       	subi	r30, 0x56	; 86
    1540:	fe 4e       	sbci	r31, 0xEE	; 238
    1542:	12 8a       	std	Z+18, r1	; 0x12
    1544:	2f 5f       	subi	r18, 0xFF	; 255
    1546:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = type;
    1548:	f9 01       	movw	r30, r18
    154a:	e6 55       	subi	r30, 0x56	; 86
    154c:	fe 4e       	sbci	r31, 0xEE	; 238
    154e:	12 8b       	std	Z+18, r17	; 0x12
    1550:	2f 5f       	subi	r18, 0xFF	; 255
    1552:	3f 4f       	sbci	r19, 0xFF	; 255
    1554:	30 93 bd 12 	sts	0x12BD, r19
    1558:	20 93 bc 12 	sts	0x12BC, r18
    //copy the info
    if(additionalInfo!=NULL)
    155c:	e1 14       	cp	r14, r1
    155e:	f1 04       	cpc	r15, r1
    1560:	a1 f0       	breq	.+40     	; 0x158a <tftp_sendError+0xde>
    {
    	memcpy(lastMessage.payload+lastMessage.payloadLength, additionalInfo, infoLen);
    1562:	c0 2e       	mov	r12, r16
    1564:	dd 24       	eor	r13, r13
    1566:	24 54       	subi	r18, 0x44	; 68
    1568:	3e 4e       	sbci	r19, 0xEE	; 238
    156a:	c9 01       	movw	r24, r18
    156c:	b7 01       	movw	r22, r14
    156e:	40 2f       	mov	r20, r16
    1570:	50 e0       	ldi	r21, 0x00	; 0
    1572:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
        lastMessage.payloadLength+=infoLen;
    1576:	80 91 bc 12 	lds	r24, 0x12BC
    157a:	90 91 bd 12 	lds	r25, 0x12BD
    157e:	8c 0d       	add	r24, r12
    1580:	9d 1d       	adc	r25, r13
    1582:	90 93 bd 12 	sts	0x12BD, r25
    1586:	80 93 bc 12 	sts	0x12BC, r24
    }
    //set up retransmit timer
    //PRINTF_D("sent error size = %d\n", lastMessage.payloadLength);
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    158a:	c0 90 c8 12 	lds	r12, 0x12C8
    158e:	d0 90 c9 12 	lds	r13, 0x12C9
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	90 e0       	ldi	r25, 0x00	; 0
    1596:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    159a:	60 91 b6 11 	lds	r22, 0x11B6
    159e:	70 91 b7 11 	lds	r23, 0x11B7
    15a2:	20 91 b8 11 	lds	r18, 0x11B8
    15a6:	30 91 b9 11 	lds	r19, 0x11B9
    15aa:	e0 90 bc 12 	lds	r14, 0x12BC
    15ae:	f0 90 bd 12 	lds	r15, 0x12BD
    15b2:	40 eb       	ldi	r20, 0xB0	; 176
    15b4:	51 e1       	ldi	r21, 0x11	; 17
    15b6:	0c eb       	ldi	r16, 0xBC	; 188
    15b8:	11 e1       	ldi	r17, 0x11	; 17
    15ba:	f6 01       	movw	r30, r12
    15bc:	09 95       	icall
}
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	cf 91       	pop	r28
    15c4:	df 91       	pop	r29
    15c6:	1f 91       	pop	r17
    15c8:	0f 91       	pop	r16
    15ca:	ff 90       	pop	r15
    15cc:	ef 90       	pop	r14
    15ce:	df 90       	pop	r13
    15d0:	cf 90       	pop	r12
    15d2:	08 95       	ret

000015d4 <tftp_sendAck>:
uint8_t tftp_sendAck(uint8_t* dst_ip, uint8_t blockNum)
{
    15d4:	cf 92       	push	r12
    15d6:	df 92       	push	r13
    15d8:	ef 92       	push	r14
    15da:	ff 92       	push	r15
    15dc:	0f 93       	push	r16
    15de:	1f 93       	push	r17
    15e0:	df 93       	push	r29
    15e2:	cf 93       	push	r28
    15e4:	00 d0       	rcall	.+0      	; 0x15e6 <tftp_sendAck+0x12>
    15e6:	00 d0       	rcall	.+0      	; 0x15e8 <tftp_sendAck+0x14>
    15e8:	cd b7       	in	r28, 0x3d	; 61
    15ea:	de b7       	in	r29, 0x3e	; 62
    15ec:	8c 01       	movw	r16, r24
    uint16_t i=0;
    uint8_t buffer[4];
    //create the payload
    buffer[i++]=0x00;
    15ee:	19 82       	std	Y+1, r1	; 0x01
    buffer[i++]=TFTP_OPCODE_ACK;
    15f0:	84 e0       	ldi	r24, 0x04	; 4
    15f2:	8a 83       	std	Y+2, r24	; 0x02
    buffer[i++]= (blockNum>>8)&0xFF;
    15f4:	1b 82       	std	Y+3, r1	; 0x03
    buffer[i++]= (blockNum&0xFF);
    15f6:	6c 83       	std	Y+4, r22	; 0x04

    PRINTF_D("sent ack size = %d\n", i);
    15f8:	00 d0       	rcall	.+0      	; 0x15fa <tftp_sendAck+0x26>
    15fa:	00 d0       	rcall	.+0      	; 0x15fc <tftp_sendAck+0x28>
    15fc:	84 e6       	ldi	r24, 0x64	; 100
    15fe:	9a e0       	ldi	r25, 0x0A	; 10
    1600:	ed b7       	in	r30, 0x3d	; 61
    1602:	fe b7       	in	r31, 0x3e	; 62
    1604:	92 83       	std	Z+2, r25	; 0x02
    1606:	81 83       	std	Z+1, r24	; 0x01
    1608:	84 e0       	ldi	r24, 0x04	; 4
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	94 83       	std	Z+4, r25	; 0x04
    160e:	83 83       	std	Z+3, r24	; 0x03
    1610:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    return mainDataQueuer(udp_get_localhost_ip(NULL), tftp_src_port, dst_ip, tftp_dst_port, buffer, i);
    1614:	c0 90 c8 12 	lds	r12, 0x12C8
    1618:	d0 90 c9 12 	lds	r13, 0x12C9
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	0f 90       	pop	r0
    1622:	0f 90       	pop	r0
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    162c:	60 91 70 0b 	lds	r22, 0x0B70
    1630:	70 91 71 0b 	lds	r23, 0x0B71
    1634:	20 91 6e 0b 	lds	r18, 0x0B6E
    1638:	30 91 6f 0b 	lds	r19, 0x0B6F
    163c:	a8 01       	movw	r20, r16
    163e:	8e 01       	movw	r16, r28
    1640:	0f 5f       	subi	r16, 0xFF	; 255
    1642:	1f 4f       	sbci	r17, 0xFF	; 255
    1644:	e4 e0       	ldi	r30, 0x04	; 4
    1646:	ee 2e       	mov	r14, r30
    1648:	f1 2c       	mov	r15, r1
    164a:	f6 01       	movw	r30, r12
    164c:	09 95       	icall
}
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	0f 90       	pop	r0
    1654:	0f 90       	pop	r0
    1656:	cf 91       	pop	r28
    1658:	df 91       	pop	r29
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	ff 90       	pop	r15
    1660:	ef 90       	pop	r14
    1662:	df 90       	pop	r13
    1664:	cf 90       	pop	r12
    1666:	08 95       	ret

00001668 <tftp_transfer>:

PACKET_HANDLER_FUNCTION(tftp_transfer)
{
    1668:	af 92       	push	r10
    166a:	bf 92       	push	r11
    166c:	cf 92       	push	r12
    166e:	df 92       	push	r13
    1670:	ef 92       	push	r14
    1672:	ff 92       	push	r15
    1674:	0f 93       	push	r16
    1676:	1f 93       	push	r17
    1678:	cf 93       	push	r28
    167a:	df 93       	push	r29
    167c:	5c 01       	movw	r10, r24
    167e:	6b 01       	movw	r12, r22
    uint8_t result=0;
    uint16_t opcode, block, error, i=0;

    //PRINTF_D("%s\n", payload);
    //read in the opcode
    opcode = payload[i++] & 0xFF;
    1680:	f8 01       	movw	r30, r16
    1682:	90 81       	ld	r25, Z
    opcode <<= 8;
    opcode |= payload[i++] & 0xFF;
    1684:	81 81       	ldd	r24, Z+1	; 0x01

    //check the opcode
    if(status==TFTP_STATUS_SENDING)
    1686:	40 91 c2 12 	lds	r20, 0x12C2
    168a:	41 30       	cpi	r20, 0x01	; 1
    168c:	09 f0       	breq	.+2      	; 0x1690 <tftp_transfer+0x28>
    168e:	a3 c0       	rjmp	.+326    	; 0x17d6 <tftp_transfer+0x16e>
    uint16_t opcode, block, error, i=0;

    //PRINTF_D("%s\n", payload);
    //read in the opcode
    opcode = payload[i++] & 0xFF;
    opcode <<= 8;
    1690:	39 2f       	mov	r19, r25
    1692:	20 e0       	ldi	r18, 0x00	; 0
    opcode |= payload[i++] & 0xFF;
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	82 2b       	or	r24, r18
    1698:	93 2b       	or	r25, r19

    //check the opcode
    if(status==TFTP_STATUS_SENDING)
    {
        if(opcode==TFTP_OPCODE_ACK)
    169a:	84 30       	cpi	r24, 0x04	; 4
    169c:	91 05       	cpc	r25, r1
    169e:	09 f0       	breq	.+2      	; 0x16a2 <tftp_transfer+0x3a>
    16a0:	49 c0       	rjmp	.+146    	; 0x1734 <tftp_transfer+0xcc>
        {
            if(timers_cancel_timer())
    16a2:	0e 94 ac 0c 	call	0x1958	; 0x1958 <timers_cancel_timer>
    16a6:	88 23       	and	r24, r24
    16a8:	21 f0       	breq	.+8      	; 0x16b2 <tftp_transfer+0x4a>
                PRINTF_D("couldnt cancel timer\n");
    16aa:	88 e7       	ldi	r24, 0x78	; 120
    16ac:	9a e0       	ldi	r25, 0x0A	; 10
    16ae:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
            block = payload[i++] & 0xFF;
    16b2:	f8 01       	movw	r30, r16
            block <<= 8;
    16b4:	e0 e0       	ldi	r30, 0x00	; 0
    16b6:	ef 01       	movw	r28, r30
            block |= payload[i++] & 0xFF;
    16b8:	f8 01       	movw	r30, r16
    16ba:	83 81       	ldd	r24, Z+3	; 0x03
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	c8 2b       	or	r28, r24
    16c0:	d9 2b       	or	r29, r25
            ackNumber = block;
    16c2:	d0 93 c4 12 	sts	0x12C4, r29
    16c6:	c0 93 c3 12 	sts	0x12C3, r28
            PRINTF_D("tftp wrq ack #%d received\n", block);
    16ca:	00 d0       	rcall	.+0      	; 0x16cc <tftp_transfer+0x64>
    16cc:	00 d0       	rcall	.+0      	; 0x16ce <tftp_transfer+0x66>
    16ce:	8d e8       	ldi	r24, 0x8D	; 141
    16d0:	9a e0       	ldi	r25, 0x0A	; 10
    16d2:	ed b7       	in	r30, 0x3d	; 61
    16d4:	fe b7       	in	r31, 0x3e	; 62
    16d6:	92 83       	std	Z+2, r25	; 0x02
    16d8:	81 83       	std	Z+1, r24	; 0x01
    16da:	d4 83       	std	Z+4, r29	; 0x04
    16dc:	c3 83       	std	Z+3, r28	; 0x03
    16de:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
            //prepare and send next packet

            tftp_dst_port=src_port;
    16e2:	d0 92 6f 0b 	sts	0x0B6F, r13
    16e6:	c0 92 6e 0b 	sts	0x0B6E, r12
            timeouts=0;
    16ea:	10 92 c5 12 	sts	0x12C5, r1
            result=tftp_sendData(src, ackNumber+1);
    16ee:	0f 90       	pop	r0
    16f0:	0f 90       	pop	r0
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	60 91 c3 12 	lds	r22, 0x12C3
    16fa:	6f 5f       	subi	r22, 0xFF	; 255
    16fc:	c5 01       	movw	r24, r10
    16fe:	0e 94 97 09 	call	0x132e	; 0x132e <tftp_sendData>
            if(result)
    1702:	88 23       	and	r24, r24
    1704:	09 f4       	brne	.+2      	; 0x1708 <tftp_transfer+0xa0>
    1706:	68 c0       	rjmp	.+208    	; 0x17d8 <tftp_transfer+0x170>
            {
                PRINTF_D("!!! couldn't send data #%d\n", ackNumber+1);
    1708:	00 d0       	rcall	.+0      	; 0x170a <tftp_transfer+0xa2>
    170a:	00 d0       	rcall	.+0      	; 0x170c <tftp_transfer+0xa4>
    170c:	88 ea       	ldi	r24, 0xA8	; 168
    170e:	9a e0       	ldi	r25, 0x0A	; 10
    1710:	ed b7       	in	r30, 0x3d	; 61
    1712:	fe b7       	in	r31, 0x3e	; 62
    1714:	92 83       	std	Z+2, r25	; 0x02
    1716:	81 83       	std	Z+1, r24	; 0x01
    1718:	80 91 c3 12 	lds	r24, 0x12C3
    171c:	90 91 c4 12 	lds	r25, 0x12C4
    1720:	01 96       	adiw	r24, 0x01	; 1
    1722:	94 83       	std	Z+4, r25	; 0x04
    1724:	83 83       	std	Z+3, r24	; 0x03
    1726:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	51 c0       	rjmp	.+162    	; 0x17d6 <tftp_transfer+0x16e>
            }
            return 0;
        }
        else if(opcode==TFTP_OPCODE_ERROR)
    1734:	85 30       	cpi	r24, 0x05	; 5
    1736:	91 05       	cpc	r25, r1
    1738:	09 f0       	breq	.+2      	; 0x173c <tftp_transfer+0xd4>
    173a:	4d c0       	rjmp	.+154    	; 0x17d6 <tftp_transfer+0x16e>
        {
            //read in the error code
            error = payload[i++] & 0xFF;
    173c:	f8 01       	movw	r30, r16
    173e:	82 81       	ldd	r24, Z+2	; 0x02
            error <<= 8;
    1740:	f8 2e       	mov	r15, r24
    1742:	ee 24       	eor	r14, r14
            error |= payload[i++] & 0xFF;
    1744:	83 81       	ldd	r24, Z+3	; 0x03
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	e8 2a       	or	r14, r24
    174a:	f9 2a       	or	r15, r25
        	timers_cancel_timer();
    174c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <timers_cancel_timer>

            if(error==TFTP_ERROR_SEE_MESSAGE)
    1750:	e1 14       	cp	r14, r1
    1752:	f1 04       	cpc	r15, r1
    1754:	41 f5       	brne	.+80     	; 0x17a6 <tftp_transfer+0x13e>
            {
                PRINTF_D("tftp error received -> %s\n", payload+i);
    1756:	00 d0       	rcall	.+0      	; 0x1758 <tftp_transfer+0xf0>
    1758:	00 d0       	rcall	.+0      	; 0x175a <tftp_transfer+0xf2>
    175a:	84 ec       	ldi	r24, 0xC4	; 196
    175c:	9a e0       	ldi	r25, 0x0A	; 10
    175e:	ed b7       	in	r30, 0x3d	; 61
    1760:	fe b7       	in	r31, 0x3e	; 62
    1762:	92 83       	std	Z+2, r25	; 0x02
    1764:	81 83       	std	Z+1, r24	; 0x01
    1766:	0c 5f       	subi	r16, 0xFC	; 252
    1768:	1f 4f       	sbci	r17, 0xFF	; 255
    176a:	14 83       	std	Z+4, r17	; 0x04
    176c:	03 83       	std	Z+3, r16	; 0x03
    176e:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
                if(!strncmp("TRANSMISSION COMPLETE", payload+i, strlen("TRANSMISSION COMPLETE")))
    1772:	0f 90       	pop	r0
    1774:	0f 90       	pop	r0
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	8f ed       	ldi	r24, 0xDF	; 223
    177c:	9a e0       	ldi	r25, 0x0A	; 10
    177e:	b8 01       	movw	r22, r16
    1780:	45 e1       	ldi	r20, 0x15	; 21
    1782:	50 e0       	ldi	r21, 0x00	; 0
    1784:	0e 94 5d 4c 	call	0x98ba	; 0x98ba <strncmp>
    1788:	00 97       	sbiw	r24, 0x00	; 0
    178a:	e9 f4       	brne	.+58     	; 0x17c6 <tftp_transfer+0x15e>
                {
                    if(isRequestOwner)
    178c:	80 91 c1 12 	lds	r24, 0x12C1
    1790:	88 23       	and	r24, r24
    1792:	09 f5       	brne	.+66     	; 0x17d6 <tftp_transfer+0x16e>
                    {
                    	return 0;
                    }
                    ackNumber=lastMessage.blockNumber;
    1794:	80 91 be 12 	lds	r24, 0x12BE
    1798:	90 91 bf 12 	lds	r25, 0x12BF
    179c:	90 93 c4 12 	sts	0x12C4, r25
    17a0:	80 93 c3 12 	sts	0x12C3, r24
    17a4:	10 c0       	rjmp	.+32     	; 0x17c6 <tftp_transfer+0x15e>
                }
            }
            else
            {
                PRINTF_D("tftp error received %d\n", error);
    17a6:	00 d0       	rcall	.+0      	; 0x17a8 <tftp_transfer+0x140>
    17a8:	00 d0       	rcall	.+0      	; 0x17aa <tftp_transfer+0x142>
    17aa:	85 ef       	ldi	r24, 0xF5	; 245
    17ac:	9a e0       	ldi	r25, 0x0A	; 10
    17ae:	ed b7       	in	r30, 0x3d	; 61
    17b0:	fe b7       	in	r31, 0x3e	; 62
    17b2:	92 83       	std	Z+2, r25	; 0x02
    17b4:	81 83       	std	Z+1, r24	; 0x01
    17b6:	f4 82       	std	Z+4, r15	; 0x04
    17b8:	e3 82       	std	Z+3, r14	; 0x03
    17ba:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	0f 90       	pop	r0
    17c4:	0f 90       	pop	r0
            }
            //return to pending status
            status=TFTP_STATUS_IDLE;
    17c6:	10 92 c2 12 	sts	0x12C2, r1
            if(isRequestOwner)
    17ca:	80 91 c1 12 	lds	r24, 0x12C1
    17ce:	88 23       	and	r24, r24
    17d0:	11 f0       	breq	.+4      	; 0x17d6 <tftp_transfer+0x16e>
            	return -16;
    17d2:	80 ef       	ldi	r24, 0xF0	; 240
    17d4:	01 c0       	rjmp	.+2      	; 0x17d8 <tftp_transfer+0x170>
    {
        //silent discard
        return 0;
    }

    return result;
    17d6:	80 e0       	ldi	r24, 0x00	; 0
}
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	ff 90       	pop	r15
    17e2:	ef 90       	pop	r14
    17e4:	df 90       	pop	r13
    17e6:	cf 90       	pop	r12
    17e8:	bf 90       	pop	r11
    17ea:	af 90       	pop	r10
    17ec:	08 95       	ret

000017ee <tftp_timer_handler>:
TIMER_HANDLER_FUNCTION(tftp_timer_handler)
{
    17ee:	ef 92       	push	r14
    17f0:	ff 92       	push	r15
    17f2:	0f 93       	push	r16
    17f4:	1f 93       	push	r17
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
	//TODO something is really weird here with the control statements
	if(lastMessage.opcode==TFTP_OPCODE_WRQ_SINGLE)
    17fa:	80 91 ba 11 	lds	r24, 0x11BA
    17fe:	90 91 bb 11 	lds	r25, 0x11BB
    1802:	86 30       	cpi	r24, 0x06	; 6
    1804:	91 05       	cpc	r25, r1
    1806:	29 f4       	brne	.+10     	; 0x1812 <tftp_timer_handler+0x24>
	{
		printf("connection closed\n");
    1808:	8d e0       	ldi	r24, 0x0D	; 13
    180a:	9b e0       	ldi	r25, 0x0B	; 11
    180c:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
    1810:	77 c0       	rjmp	.+238    	; 0x1900 <tftp_timer_handler+0x112>
		if(isRequestOwner)
			return 0;
	}
	else
	{
		if(status==TFTP_STATUS_SENDING)
    1812:	80 91 c2 12 	lds	r24, 0x12C2
    1816:	81 30       	cpi	r24, 0x01	; 1
    1818:	09 f0       	breq	.+2      	; 0x181c <tftp_timer_handler+0x2e>
    181a:	72 c0       	rjmp	.+228    	; 0x1900 <tftp_timer_handler+0x112>
		{
			PRINTF_D("tftp_timer_handler\n");
    181c:	8f e1       	ldi	r24, 0x1F	; 31
    181e:	9b e0       	ldi	r25, 0x0B	; 11
    1820:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
			//if the last taken block number is less than the last transmitted ack number
			//or if we sent a write request and couldn't get an ack yet
			if( (lastMessage.blockNumber>ackNumber) || (lastMessage.opcode==TFTP_OPCODE_WRQ))
    1824:	80 91 c3 12 	lds	r24, 0x12C3
    1828:	90 91 c4 12 	lds	r25, 0x12C4
    182c:	20 91 be 12 	lds	r18, 0x12BE
    1830:	30 91 bf 12 	lds	r19, 0x12BF
    1834:	82 17       	cp	r24, r18
    1836:	93 07       	cpc	r25, r19
    1838:	40 f0       	brcs	.+16     	; 0x184a <tftp_timer_handler+0x5c>
    183a:	20 91 ba 11 	lds	r18, 0x11BA
    183e:	30 91 bb 11 	lds	r19, 0x11BB
    1842:	22 30       	cpi	r18, 0x02	; 2
    1844:	31 05       	cpc	r19, r1
    1846:	09 f0       	breq	.+2      	; 0x184a <tftp_timer_handler+0x5c>
    1848:	5b c0       	rjmp	.+182    	; 0x1900 <tftp_timer_handler+0x112>
			{
				timeouts++;
    184a:	40 91 c5 12 	lds	r20, 0x12C5
    184e:	4f 5f       	subi	r20, 0xFF	; 255
    1850:	40 93 c5 12 	sts	0x12C5, r20
				PRINTF_D("tftp ack timer timeout %d, timeouts=%d\n", ackNumber, timeouts);
    1854:	00 d0       	rcall	.+0      	; 0x1856 <tftp_timer_handler+0x68>
    1856:	00 d0       	rcall	.+0      	; 0x1858 <tftp_timer_handler+0x6a>
    1858:	00 d0       	rcall	.+0      	; 0x185a <tftp_timer_handler+0x6c>
    185a:	ed b7       	in	r30, 0x3d	; 61
    185c:	fe b7       	in	r31, 0x3e	; 62
    185e:	31 96       	adiw	r30, 0x01	; 1
    1860:	22 e3       	ldi	r18, 0x32	; 50
    1862:	3b e0       	ldi	r19, 0x0B	; 11
    1864:	ad b7       	in	r26, 0x3d	; 61
    1866:	be b7       	in	r27, 0x3e	; 62
    1868:	12 96       	adiw	r26, 0x02	; 2
    186a:	3c 93       	st	X, r19
    186c:	2e 93       	st	-X, r18
    186e:	11 97       	sbiw	r26, 0x01	; 1
    1870:	93 83       	std	Z+3, r25	; 0x03
    1872:	82 83       	std	Z+2, r24	; 0x02
    1874:	44 83       	std	Z+4, r20	; 0x04
    1876:	15 82       	std	Z+5, r1	; 0x05
    1878:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>

				if(timeouts>=TFTP_MAX_TIMEOUTS)
    187c:	8d b7       	in	r24, 0x3d	; 61
    187e:	9e b7       	in	r25, 0x3e	; 62
    1880:	06 96       	adiw	r24, 0x06	; 6
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	9e bf       	out	0x3e, r25	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	8d bf       	out	0x3d, r24	; 61
    188c:	80 91 c5 12 	lds	r24, 0x12C5
    1890:	8a 30       	cpi	r24, 0x0A	; 10
    1892:	a0 f0       	brcs	.+40     	; 0x18bc <tftp_timer_handler+0xce>
    return 0;
}

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
    1894:	10 92 c2 12 	sts	0x12C2, r1
				PRINTF_D("tftp ack timer timeout %d, timeouts=%d\n", ackNumber, timeouts);

				if(timeouts>=TFTP_MAX_TIMEOUTS)
				{
					tftp_setStatus(TFTP_STATUS_IDLE);
					blockNumber=0;
    1898:	10 92 c7 12 	sts	0x12C7, r1
    189c:	10 92 c6 12 	sts	0x12C6, r1
					ackNumber=0;
    18a0:	10 92 c4 12 	sts	0x12C4, r1
    18a4:	10 92 c3 12 	sts	0x12C3, r1
					PRINTF_D("connection canceled\n");
    18a8:	8a e5       	ldi	r24, 0x5A	; 90
    18aa:	9b e0       	ldi	r25, 0x0B	; 11
    18ac:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
					if(isRequestOwner)
    18b0:	80 91 c1 12 	lds	r24, 0x12C1
    18b4:	88 23       	and	r24, r24
    18b6:	21 f1       	breq	.+72     	; 0x1900 <tftp_timer_handler+0x112>
						return (-18);
    18b8:	8e ee       	ldi	r24, 0xEE	; 238
    18ba:	23 c0       	rjmp	.+70     	; 0x1902 <tftp_timer_handler+0x114>
					return 0;
				}

				//set up retransmit timer
				timers_create_timer(tftp_getRandomRetransmissionTime(), 128);
    18bc:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <tftp_getRandomRetransmissionTime>
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	60 e8       	ldi	r22, 0x80	; 128
    18c4:	70 e0       	ldi	r23, 0x00	; 0
    18c6:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>
				//retransmit
				return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    18ca:	c0 91 c8 12 	lds	r28, 0x12C8
    18ce:	d0 91 c9 12 	lds	r29, 0x12C9
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    18da:	60 91 b6 11 	lds	r22, 0x11B6
    18de:	70 91 b7 11 	lds	r23, 0x11B7
    18e2:	20 91 b8 11 	lds	r18, 0x11B8
    18e6:	30 91 b9 11 	lds	r19, 0x11B9
    18ea:	e0 90 bc 12 	lds	r14, 0x12BC
    18ee:	f0 90 bd 12 	lds	r15, 0x12BD
    18f2:	40 eb       	ldi	r20, 0xB0	; 176
    18f4:	51 e1       	ldi	r21, 0x11	; 17
    18f6:	0c eb       	ldi	r16, 0xBC	; 188
    18f8:	11 e1       	ldi	r17, 0x11	; 17
    18fa:	fe 01       	movw	r30, r28
    18fc:	09 95       	icall
    18fe:	01 c0       	rjmp	.+2      	; 0x1902 <tftp_timer_handler+0x114>
					blockNumber=0;
					ackNumber=0;
					PRINTF_D("connection canceled\n");
					if(isRequestOwner)
						return (-18);
					return 0;
    1900:	80 e0       	ldi	r24, 0x00	; 0
				return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
			}
		}
	}
	return 0;
}
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	1f 91       	pop	r17
    1908:	0f 91       	pop	r16
    190a:	ff 90       	pop	r15
    190c:	ef 90       	pop	r14
    190e:	08 95       	ret

00001910 <timers_initialize>:
static struct ctimer alarm_timer;
void (*mainTimerHandler)(void*);

uint8_t timers_initialize( void(*handlerfptr)(void* ))
{
    mainTimerHandler=handlerfptr;
    1910:	90 93 2c 25 	sts	0x252C, r25
    1914:	80 93 2b 25 	sts	0x252B, r24
    return 0;
}
    1918:	80 e0       	ldi	r24, 0x00	; 0
    191a:	08 95       	ret

0000191c <timers_create_timer>:

uint8_t timers_create_timer( int expireS, int expireMS)
{
    191c:	9c 01       	movw	r18, r24
    191e:	cb 01       	movw	r24, r22
	ctimer_set(&alarm_timer, (expireS*CLOCK_SECOND)+(expireMS*CLOCK_SECOND/1000), mainTimerHandler, 0);
    1920:	96 95       	lsr	r25
    1922:	98 2f       	mov	r25, r24
    1924:	88 27       	eor	r24, r24
    1926:	97 95       	ror	r25
    1928:	87 95       	ror	r24
    192a:	68 ee       	ldi	r22, 0xE8	; 232
    192c:	73 e0       	ldi	r23, 0x03	; 3
    192e:	0e 94 76 4b 	call	0x96ec	; 0x96ec <__divmodhi4>
    1932:	36 95       	lsr	r19
    1934:	32 2f       	mov	r19, r18
    1936:	22 27       	eor	r18, r18
    1938:	37 95       	ror	r19
    193a:	27 95       	ror	r18
    193c:	62 0f       	add	r22, r18
    193e:	73 1f       	adc	r23, r19
    1940:	40 91 2b 25 	lds	r20, 0x252B
    1944:	50 91 2c 25 	lds	r21, 0x252C
    1948:	8e ec       	ldi	r24, 0xCE	; 206
    194a:	92 e1       	ldi	r25, 0x12	; 18
    194c:	20 e0       	ldi	r18, 0x00	; 0
    194e:	30 e0       	ldi	r19, 0x00	; 0
    1950:	0e 94 dd 18 	call	0x31ba	; 0x31ba <ctimer_set>
	return 0;
}
    1954:	80 e0       	ldi	r24, 0x00	; 0
    1956:	08 95       	ret

00001958 <timers_cancel_timer>:
uint8_t timers_cancel_timer(void)
{
	ctimer_stop(&alarm_timer);
    1958:	8e ec       	ldi	r24, 0xCE	; 206
    195a:	92 e1       	ldi	r25, 0x12	; 18
    195c:	0e 94 64 19 	call	0x32c8	; 0x32c8 <ctimer_stop>
    return 0;
}
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	08 95       	ret

00001964 <udp_calculate_checksum>:
static dataQueuerfptr_t mainDataQueuer;
static uint8_t local_ip_address[4]={127, 0, 0, 1};
static const uint8_t udp_broadcast_address[4]={ 255, 255, 255, 255};

static uint16_t udp_calculate_checksum(uint8_t* src_addr, uint8_t* dest_addr, uint8_t* payload, uint16_t udp_len)
{
    1964:	2f 92       	push	r2
    1966:	3f 92       	push	r3
    1968:	5f 92       	push	r5
    196a:	6f 92       	push	r6
    196c:	7f 92       	push	r7
    196e:	8f 92       	push	r8
    1970:	9f 92       	push	r9
    1972:	af 92       	push	r10
    1974:	bf 92       	push	r11
    1976:	cf 92       	push	r12
    1978:	df 92       	push	r13
    197a:	ef 92       	push	r14
    197c:	ff 92       	push	r15
    197e:	0f 93       	push	r16
    1980:	1f 93       	push	r17
    1982:	cf 93       	push	r28
    1984:	df 93       	push	r29
    1986:	fc 01       	movw	r30, r24
    1988:	db 01       	movw	r26, r22
    198a:	89 01       	movw	r16, r18
    //initialize sum to zero
    sum=0;

    // make 16 bit words out of every two adjacent 8 bit words and
    // calculate the sum of all 16 vit words
    for (i=0; i<udp_len-8; i=i+2)
    198c:	e4 2e       	mov	r14, r20
    198e:	e7 01       	movw	r28, r14
    1990:	7e 01       	movw	r14, r28
    1992:	f5 2e       	mov	r15, r21
    1994:	e7 01       	movw	r28, r14
    uint8_t prot_udp=17;
    uint16_t word16;
    uint32_t sum;

    //initialize sum to zero
    sum=0;
    1996:	88 24       	eor	r8, r8
    1998:	99 24       	eor	r9, r9
    199a:	54 01       	movw	r10, r8

    // make 16 bit words out of every two adjacent 8 bit words and
    // calculate the sum of all 16 vit words
    for (i=0; i<udp_len-8; i=i+2)
    199c:	20 e0       	ldi	r18, 0x00	; 0
    199e:	30 e0       	ldi	r19, 0x00	; 0
    19a0:	a9 01       	movw	r20, r18
    19a2:	c8 01       	movw	r24, r16
    19a4:	08 97       	sbiw	r24, 0x08	; 8
    19a6:	6c 01       	movw	r12, r24
    19a8:	ee 24       	eor	r14, r14
    19aa:	ff 24       	eor	r15, r15
    19ac:	21 c0       	rjmp	.+66     	; 0x19f0 <udp_calculate_checksum+0x8c>
    {
        if(i+1<udp_len-8)
    19ae:	ca 01       	movw	r24, r20
    19b0:	b9 01       	movw	r22, r18
    19b2:	6f 5f       	subi	r22, 0xFF	; 255
    19b4:	7f 4f       	sbci	r23, 0xFF	; 255
    19b6:	8f 4f       	sbci	r24, 0xFF	; 255
    19b8:	9f 4f       	sbci	r25, 0xFF	; 255
    19ba:	58 80       	ld	r5, Y
    19bc:	6c 15       	cp	r22, r12
    19be:	7d 05       	cpc	r23, r13
    19c0:	8e 05       	cpc	r24, r14
    19c2:	9f 05       	cpc	r25, r15
    19c4:	38 f4       	brcc	.+14     	; 0x19d4 <udp_calculate_checksum+0x70>
            word16 =((payload[i]<<8)&0xFF00)+(payload[i+1]&0x00FF);
    19c6:	35 2c       	mov	r3, r5
    19c8:	22 24       	eor	r2, r2
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	31 01       	movw	r6, r2
    19ce:	68 0e       	add	r6, r24
    19d0:	71 1c       	adc	r7, r1
    19d2:	02 c0       	rjmp	.+4      	; 0x19d8 <udp_calculate_checksum+0x74>
        else
            word16 =((payload[i]<<8)&0xFF00);
    19d4:	75 2c       	mov	r7, r5
    19d6:	66 24       	eor	r6, r6
        sum = sum + (uint32_t)word16;
    19d8:	b3 01       	movw	r22, r6
    19da:	80 e0       	ldi	r24, 0x00	; 0
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	86 0e       	add	r8, r22
    19e0:	97 1e       	adc	r9, r23
    19e2:	a8 1e       	adc	r10, r24
    19e4:	b9 1e       	adc	r11, r25
    //initialize sum to zero
    sum=0;

    // make 16 bit words out of every two adjacent 8 bit words and
    // calculate the sum of all 16 vit words
    for (i=0; i<udp_len-8; i=i+2)
    19e6:	2e 5f       	subi	r18, 0xFE	; 254
    19e8:	3f 4f       	sbci	r19, 0xFF	; 255
    19ea:	4f 4f       	sbci	r20, 0xFF	; 255
    19ec:	5f 4f       	sbci	r21, 0xFF	; 255
    19ee:	22 96       	adiw	r28, 0x02	; 2
    19f0:	2c 15       	cp	r18, r12
    19f2:	3d 05       	cpc	r19, r13
    19f4:	4e 05       	cpc	r20, r14
    19f6:	5f 05       	cpc	r21, r15
    19f8:	d0 f2       	brcs	.-76     	; 0x19ae <udp_calculate_checksum+0x4a>
    {
        word16 =((dest_addr[i]<<8)&0xFF00)+(dest_addr[i+1]&0xFF);
        sum=sum+word16;
    }
    // the protocol number and the length of the UDP packet
    sum = sum + prot_udp + udp_len;
    19fa:	20 e0       	ldi	r18, 0x00	; 0
    19fc:	30 e0       	ldi	r19, 0x00	; 0

    // add the UDP pseudo header which contains the IP source and destination addresses
    for (i=0; i<IPV4_SOURCE_LENGTH; i+=2)
    {
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
        sum=sum+word16;
    19fe:	0f 5e       	subi	r16, 0xEF	; 239
    1a00:	1f 4f       	sbci	r17, 0xFF	; 255
    1a02:	2f 4f       	sbci	r18, 0xFF	; 255
    1a04:	3f 4f       	sbci	r19, 0xFF	; 255
    }

    // add the UDP pseudo header which contains the IP source and destination addresses
    for (i=0; i<IPV4_SOURCE_LENGTH; i+=2)
    {
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
    1a06:	81 81       	ldd	r24, Z+1	; 0x01
    1a08:	50 81       	ld	r21, Z
    1a0a:	40 e0       	ldi	r20, 0x00	; 0
    1a0c:	48 0f       	add	r20, r24
    1a0e:	51 1d       	adc	r21, r1
        sum=sum+word16;
    1a10:	60 e0       	ldi	r22, 0x00	; 0
    1a12:	70 e0       	ldi	r23, 0x00	; 0
    1a14:	04 0f       	add	r16, r20
    1a16:	15 1f       	adc	r17, r21
    1a18:	26 1f       	adc	r18, r22
    1a1a:	37 1f       	adc	r19, r23
    }

    // add the UDP pseudo header which contains the IP source and destination addresses
    for (i=0; i<IPV4_SOURCE_LENGTH; i+=2)
    {
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
    1a1c:	52 81       	ldd	r21, Z+2	; 0x02
    1a1e:	40 e0       	ldi	r20, 0x00	; 0
    1a20:	83 81       	ldd	r24, Z+3	; 0x03
    1a22:	48 0f       	add	r20, r24
    1a24:	51 1d       	adc	r21, r1
        sum=sum+word16;
    1a26:	60 e0       	ldi	r22, 0x00	; 0
    1a28:	70 e0       	ldi	r23, 0x00	; 0
    }
    for (i=0; i<IPV4_DESTINATION_LENGTH; i+=2)
    {
        word16 =((dest_addr[i]<<8)&0xFF00)+(dest_addr[i+1]&0xFF);
        sum=sum+word16;
    1a2a:	04 0f       	add	r16, r20
    1a2c:	15 1f       	adc	r17, r21
    1a2e:	26 1f       	adc	r18, r22
    1a30:	37 1f       	adc	r19, r23
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
        sum=sum+word16;
    }
    for (i=0; i<IPV4_DESTINATION_LENGTH; i+=2)
    {
        word16 =((dest_addr[i]<<8)&0xFF00)+(dest_addr[i+1]&0xFF);
    1a32:	11 96       	adiw	r26, 0x01	; 1
    1a34:	8c 91       	ld	r24, X
    1a36:	11 97       	sbiw	r26, 0x01	; 1
    1a38:	5c 91       	ld	r21, X
    1a3a:	40 e0       	ldi	r20, 0x00	; 0
    1a3c:	48 0f       	add	r20, r24
    1a3e:	51 1d       	adc	r21, r1
        sum=sum+word16;
    1a40:	60 e0       	ldi	r22, 0x00	; 0
    1a42:	70 e0       	ldi	r23, 0x00	; 0
    1a44:	04 0f       	add	r16, r20
    1a46:	15 1f       	adc	r17, r21
    1a48:	26 1f       	adc	r18, r22
    1a4a:	37 1f       	adc	r19, r23
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
        sum=sum+word16;
    }
    for (i=0; i<IPV4_DESTINATION_LENGTH; i+=2)
    {
        word16 =((dest_addr[i]<<8)&0xFF00)+(dest_addr[i+1]&0xFF);
    1a4c:	12 96       	adiw	r26, 0x02	; 2
    1a4e:	9c 91       	ld	r25, X
    1a50:	12 97       	sbiw	r26, 0x02	; 2
    1a52:	80 e0       	ldi	r24, 0x00	; 0
    1a54:	13 96       	adiw	r26, 0x03	; 3
    1a56:	4c 91       	ld	r20, X
    1a58:	84 0f       	add	r24, r20
    1a5a:	91 1d       	adc	r25, r1
        sum=sum+word16;
    1a5c:	a0 e0       	ldi	r26, 0x00	; 0
    1a5e:	b0 e0       	ldi	r27, 0x00	; 0
    }
    // the protocol number and the length of the UDP packet
    sum = sum + prot_udp + udp_len;
    1a60:	08 0f       	add	r16, r24
    1a62:	19 1f       	adc	r17, r25
    1a64:	2a 1f       	adc	r18, r26
    1a66:	3b 1f       	adc	r19, r27
    1a68:	08 0d       	add	r16, r8
    1a6a:	19 1d       	adc	r17, r9
    1a6c:	2a 1d       	adc	r18, r10
    1a6e:	3b 1d       	adc	r19, r11

    // keep only the last 16 bits of the 32 bit calculated sum and add the carries
    while (sum>>16)
    1a70:	06 c0       	rjmp	.+12     	; 0x1a7e <udp_calculate_checksum+0x11a>
    {
        sum = (sum & 0xFFFF)+(sum >> 16);
    1a72:	20 70       	andi	r18, 0x00	; 0
    1a74:	30 70       	andi	r19, 0x00	; 0
    1a76:	08 0f       	add	r16, r24
    1a78:	19 1f       	adc	r17, r25
    1a7a:	2a 1f       	adc	r18, r26
    1a7c:	3b 1f       	adc	r19, r27
    }
    // the protocol number and the length of the UDP packet
    sum = sum + prot_udp + udp_len;

    // keep only the last 16 bits of the 32 bit calculated sum and add the carries
    while (sum>>16)
    1a7e:	c9 01       	movw	r24, r18
    1a80:	aa 27       	eor	r26, r26
    1a82:	bb 27       	eor	r27, r27
    1a84:	00 97       	sbiw	r24, 0x00	; 0
    1a86:	a1 05       	cpc	r26, r1
    1a88:	b1 05       	cpc	r27, r1
    1a8a:	99 f7       	brne	.-26     	; 0x1a72 <udp_calculate_checksum+0x10e>
    {
        sum = (sum & 0xFFFF)+(sum >> 16);
    }

    // Take the one's complement of sum
    sum = ~sum;
    1a8c:	00 95       	com	r16
    1a8e:	10 95       	com	r17
    1a90:	20 95       	com	r18
    1a92:	30 95       	com	r19

    return ((uint16_t) (sum&0xFFFF));
}
    1a94:	c8 01       	movw	r24, r16
    1a96:	df 91       	pop	r29
    1a98:	cf 91       	pop	r28
    1a9a:	1f 91       	pop	r17
    1a9c:	0f 91       	pop	r16
    1a9e:	ff 90       	pop	r15
    1aa0:	ef 90       	pop	r14
    1aa2:	df 90       	pop	r13
    1aa4:	cf 90       	pop	r12
    1aa6:	bf 90       	pop	r11
    1aa8:	af 90       	pop	r10
    1aaa:	9f 90       	pop	r9
    1aac:	8f 90       	pop	r8
    1aae:	7f 90       	pop	r7
    1ab0:	6f 90       	pop	r6
    1ab2:	5f 90       	pop	r5
    1ab4:	3f 90       	pop	r3
    1ab6:	2f 90       	pop	r2
    1ab8:	08 95       	ret

00001aba <udp_get_data_queuer_fptr>:
}

dataQueuerfptr_t udp_get_data_queuer_fptr(void)
{
    return mainDataQueuer;
}
    1aba:	80 91 de 12 	lds	r24, 0x12DE
    1abe:	90 91 df 12 	lds	r25, 0x12DF
    1ac2:	08 95       	ret

00001ac4 <udp_initialize_ip_network>:

void udp_initialize_ip_network(uint8_t* myIpAddress, dataQueuerfptr_t dataQueuer)
{
    1ac4:	28 2f       	mov	r18, r24
    1ac6:	39 2f       	mov	r19, r25
    1ac8:	d9 01       	movw	r26, r18
    1aca:	e5 ed       	ldi	r30, 0xD5	; 213
    1acc:	fb e0       	ldi	r31, 0x0B	; 11
    uint8_t i;
    for(i=0; i<IPV4_SOURCE_LENGTH; i++)
        local_ip_address[i] = myIpAddress[i];
    1ace:	8d 91       	ld	r24, X+
    1ad0:	81 93       	st	Z+, r24
}

void udp_initialize_ip_network(uint8_t* myIpAddress, dataQueuerfptr_t dataQueuer)
{
    uint8_t i;
    for(i=0; i<IPV4_SOURCE_LENGTH; i++)
    1ad2:	8b e0       	ldi	r24, 0x0B	; 11
    1ad4:	e9 3d       	cpi	r30, 0xD9	; 217
    1ad6:	f8 07       	cpc	r31, r24
    1ad8:	d1 f7       	brne	.-12     	; 0x1ace <udp_initialize_ip_network+0xa>
        local_ip_address[i] = myIpAddress[i];

    mainDataQueuer=dataQueuer;
    1ada:	70 93 df 12 	sts	0x12DF, r23
    1ade:	60 93 de 12 	sts	0x12DE, r22
}
    1ae2:	08 95       	ret

00001ae4 <udp_get_localhost_ip>:

uint8_t* udp_get_localhost_ip(uint8_t* ip_out)
{
    uint8_t i;

    if(ip_out!=NULL)
    1ae4:	00 97       	sbiw	r24, 0x00	; 0
    1ae6:	49 f0       	breq	.+18     	; 0x1afa <udp_get_localhost_ip+0x16>
    1ae8:	e5 ed       	ldi	r30, 0xD5	; 213
    1aea:	fb e0       	ldi	r31, 0x0B	; 11
    1aec:	dc 01       	movw	r26, r24
    {
        for(i=0; i<IPV4_SOURCE_LENGTH; i++)
            ip_out[i] = local_ip_address[i];
    1aee:	81 91       	ld	r24, Z+
    1af0:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(ip_out!=NULL)
    {
        for(i=0; i<IPV4_SOURCE_LENGTH; i++)
    1af2:	8b e0       	ldi	r24, 0x0B	; 11
    1af4:	e9 3d       	cpi	r30, 0xD9	; 217
    1af6:	f8 07       	cpc	r31, r24
    1af8:	d1 f7       	brne	.-12     	; 0x1aee <udp_get_localhost_ip+0xa>
            ip_out[i] = local_ip_address[i];
    }
    return local_ip_address;
}
    1afa:	85 ed       	ldi	r24, 0xD5	; 213
    1afc:	9b e0       	ldi	r25, 0x0B	; 11
    1afe:	08 95       	ret

00001b00 <udp_get_broadcast_ip>:
uint8_t* udp_get_broadcast_ip(uint8_t* ip_out)
{
    1b00:	fc 01       	movw	r30, r24
    uint8_t i;

    if(ip_out!=NULL)
    1b02:	00 97       	sbiw	r24, 0x00	; 0
    1b04:	29 f0       	breq	.+10     	; 0x1b10 <udp_get_broadcast_ip+0x10>
    {
        for(i=0; i<IPV4_SOURCE_LENGTH; i++)
            ip_out[i] = udp_broadcast_address[i];
    1b06:	8f ef       	ldi	r24, 0xFF	; 255
    1b08:	80 83       	st	Z, r24
    1b0a:	81 83       	std	Z+1, r24	; 0x01
    1b0c:	82 83       	std	Z+2, r24	; 0x02
    1b0e:	83 83       	std	Z+3, r24	; 0x03
    }

    return udp_broadcast_address;
}
    1b10:	8f eb       	ldi	r24, 0xBF	; 191
    1b12:	9b e0       	ldi	r25, 0x0B	; 11
    1b14:	08 95       	ret

00001b16 <udp_create_packet>:

uint16_t udp_create_packet(uint8_t* src_in, uint16_t src_port, uint8_t* dst_in, uint16_t dst_port, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
{
    1b16:	2f 92       	push	r2
    1b18:	3f 92       	push	r3
    1b1a:	4f 92       	push	r4
    1b1c:	5f 92       	push	r5
    1b1e:	6f 92       	push	r6
    1b20:	7f 92       	push	r7
    1b22:	8f 92       	push	r8
    1b24:	9f 92       	push	r9
    1b26:	af 92       	push	r10
    1b28:	bf 92       	push	r11
    1b2a:	cf 92       	push	r12
    1b2c:	df 92       	push	r13
    1b2e:	ef 92       	push	r14
    1b30:	ff 92       	push	r15
    1b32:	0f 93       	push	r16
    1b34:	1f 93       	push	r17
    1b36:	df 93       	push	r29
    1b38:	cf 93       	push	r28
    1b3a:	00 d0       	rcall	.+0      	; 0x1b3c <udp_create_packet+0x26>
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    1b40:	98 2e       	mov	r9, r24
    1b42:	89 2e       	mov	r8, r25
    1b44:	69 83       	std	Y+1, r22	; 0x01
    1b46:	7a 83       	std	Y+2, r23	; 0x02
    1b48:	74 2e       	mov	r7, r20
    1b4a:	65 2e       	mov	r6, r21
    1b4c:	19 01       	movw	r2, r18
    1b4e:	58 01       	movw	r10, r16
    1b50:	87 01       	movw	r16, r14
    uint32_t header_checksum=0;
    uint16_t* checksumPtr;
    uint8_t i;

    //check for input errors
    if(payload_length > UDP_MAX_PAYLOAD_LENGTH || packet_out==NULL)
    1b52:	21 e0       	ldi	r18, 0x01	; 1
    1b54:	01 30       	cpi	r16, 0x01	; 1
    1b56:	12 07       	cpc	r17, r18
    1b58:	08 f0       	brcs	.+2      	; 0x1b5c <udp_create_packet+0x46>
    1b5a:	a8 c0       	rjmp	.+336    	; 0x1cac <udp_create_packet+0x196>
    1b5c:	c1 14       	cp	r12, r1
    1b5e:	d1 04       	cpc	r13, r1
    1b60:	09 f4       	brne	.+2      	; 0x1b64 <udp_create_packet+0x4e>
    1b62:	a4 c0       	rjmp	.+328    	; 0x1cac <udp_create_packet+0x196>
        return 0;

    //IPv4 Headers
    CHECKPOINT(1);
    1b64:	00 d0       	rcall	.+0      	; 0x1b66 <udp_create_packet+0x50>
    1b66:	00 d0       	rcall	.+0      	; 0x1b68 <udp_create_packet+0x52>
    1b68:	00 d0       	rcall	.+0      	; 0x1b6a <udp_create_packet+0x54>
    1b6a:	ed b7       	in	r30, 0x3d	; 61
    1b6c:	fe b7       	in	r31, 0x3e	; 62
    1b6e:	31 96       	adiw	r30, 0x01	; 1
    1b70:	82 e7       	ldi	r24, 0x72	; 114
    1b72:	9b e0       	ldi	r25, 0x0B	; 11
    1b74:	ad b7       	in	r26, 0x3d	; 61
    1b76:	be b7       	in	r27, 0x3e	; 62
    1b78:	12 96       	adiw	r26, 0x02	; 2
    1b7a:	9c 93       	st	X, r25
    1b7c:	8e 93       	st	-X, r24
    1b7e:	11 97       	sbiw	r26, 0x01	; 1
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	90 e0       	ldi	r25, 0x00	; 0
    1b84:	93 83       	std	Z+3, r25	; 0x03
    1b86:	82 83       	std	Z+2, r24	; 0x02
    1b88:	83 ec       	ldi	r24, 0xC3	; 195
    1b8a:	9b e0       	ldi	r25, 0x0B	; 11
    1b8c:	95 83       	std	Z+5, r25	; 0x05
    1b8e:	84 83       	std	Z+4, r24	; 0x04
    1b90:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    //version and header length
    //version 4
    //length 5x32
    packet_out[IPV4_VERSIONnIHL_OFFSET]= ((0x04)<<4) | (0x05);
    1b94:	85 e4       	ldi	r24, 0x45	; 69
    1b96:	f6 01       	movw	r30, r12
    1b98:	80 83       	st	Z, r24
    len+=IPV4_VERSIONnIHL_LENGTH;

    //differentiated services code point and explicit congestion notification
    packet_out[IPV4_DSCPnECN_OFFSET] = (0x03<<4) | (0x00);
    1b9a:	80 e3       	ldi	r24, 0x30	; 48
    1b9c:	81 83       	std	Z+1, r24	; 0x01
    len+=IPV4_DSCPnECN_LENGTH;

    //total length
    //add udp header length + ip header length
    total_length = payload_length+8+20;
    1b9e:	c7 01       	movw	r24, r14
    1ba0:	4c 96       	adiw	r24, 0x1c	; 28
    packet_out[IPV4_TOTAL_LENGTH_OFFSET]=((total_length>>8) & 0xFF);
    1ba2:	92 83       	std	Z+2, r25	; 0x02
    packet_out[IPV4_TOTAL_LENGTH_OFFSET+1]=(total_length & 0xFF);
    1ba4:	83 83       	std	Z+3, r24	; 0x03
    len+=IPV4_TOTAL_LENGTH_LENGTH;

    //fragment identification
    packet_out[IPV4_IDENTIFICATION_OFFSET]=0;
    1ba6:	14 82       	std	Z+4, r1	; 0x04
    packet_out[IPV4_IDENTIFICATION_OFFSET+1]=0;
    1ba8:	15 82       	std	Z+5, r1	; 0x05
    len+=IPV4_IDENTIFICATION_LENGTH;

    //flags and fragment offset
    //bit 1 for flags means dont fragment
    packet_out[IPV4_FLAGSnFRAGMENT_OFFSET_OFFSET]= (0x01<<5) | (0x00);
    1baa:	80 e2       	ldi	r24, 0x20	; 32
    1bac:	86 83       	std	Z+6, r24	; 0x06
    packet_out[IPV4_FLAGSnFRAGMENT_OFFSET_OFFSET+1]= 0x00;
    1bae:	17 82       	std	Z+7, r1	; 0x07
    len+=IPV4_FLAGSnFRAGMENT_OFFSET_LENGTH;

    //time to live
    packet_out[IPV4_TIME_TO_LIVE_OFFSET] = IPV4_TTL_LIMIT;
    1bb0:	82 e0       	ldi	r24, 0x02	; 2
    1bb2:	80 87       	std	Z+8, r24	; 0x08
    len+=IPV4_TIME_TO_LIVE_LENGTH;

    //protocol
    packet_out[IPV4_PROTOCOL_OFFSET] = UDP_IPV4_PROTOCOL_NUMBER;
    1bb4:	81 e1       	ldi	r24, 0x11	; 17
    1bb6:	81 87       	std	Z+9, r24	; 0x09
    1bb8:	2d b7       	in	r18, 0x3d	; 61
    1bba:	3e b7       	in	r19, 0x3e	; 62
    1bbc:	2a 5f       	subi	r18, 0xFA	; 250
    1bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc0:	0f b6       	in	r0, 0x3f	; 63
    1bc2:	f8 94       	cli
    1bc4:	3e bf       	out	0x3e, r19	; 62
    1bc6:	0f be       	out	0x3f, r0	; 63
    1bc8:	2d bf       	out	0x3d, r18	; 61
    1bca:	80 e0       	ldi	r24, 0x00	; 0
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	dc 01       	movw	r26, r24
    uint32_t sum;
    uint16_t i;

    // make 16 bit words out of every two adjacent 8 bit words in the packet
    // and add them up
    for (i=0;i<length;i=i+2){
    1bd0:	60 e0       	ldi	r22, 0x00	; 0
    1bd2:	70 e0       	ldi	r23, 0x00	; 0
        word16 =((header[i]<<8)&0xFF00)+(header[i+1]&0xFF);
    1bd4:	50 80       	ld	r5, Z
    1bd6:	44 24       	eor	r4, r4
    1bd8:	21 81       	ldd	r18, Z+1	; 0x01
    1bda:	a2 01       	movw	r20, r4
    1bdc:	42 0f       	add	r20, r18
    1bde:	51 1d       	adc	r21, r1
    1be0:	9a 01       	movw	r18, r20
        sum = sum + (uint32_t) word16;
    1be2:	40 e0       	ldi	r20, 0x00	; 0
    1be4:	50 e0       	ldi	r21, 0x00	; 0
    1be6:	82 0f       	add	r24, r18
    1be8:	93 1f       	adc	r25, r19
    1bea:	a4 1f       	adc	r26, r20
    1bec:	b5 1f       	adc	r27, r21
    uint32_t sum;
    uint16_t i;

    // make 16 bit words out of every two adjacent 8 bit words in the packet
    // and add them up
    for (i=0;i<length;i=i+2){
    1bee:	6e 5f       	subi	r22, 0xFE	; 254
    1bf0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf2:	32 96       	adiw	r30, 0x02	; 2
    1bf4:	6a 30       	cpi	r22, 0x0A	; 10
    1bf6:	71 05       	cpc	r23, r1
    1bf8:	69 f7       	brne	.-38     	; 0x1bd4 <udp_create_packet+0xbe>
    1bfa:	06 c0       	rjmp	.+12     	; 0x1c08 <udp_create_packet+0xf2>
        sum = sum + (uint32_t) word16;
    }

    // take only 16 bits out of the 32 bit sum and add up the carries
    while (sum>>16)
      sum = (sum & 0xFFFF)+(sum >> 16);
    1bfc:	a0 70       	andi	r26, 0x00	; 0
    1bfe:	b0 70       	andi	r27, 0x00	; 0
    1c00:	82 0f       	add	r24, r18
    1c02:	93 1f       	adc	r25, r19
    1c04:	a4 1f       	adc	r26, r20
    1c06:	b5 1f       	adc	r27, r21
        word16 =((header[i]<<8)&0xFF00)+(header[i+1]&0xFF);
        sum = sum + (uint32_t) word16;
    }

    // take only 16 bits out of the 32 bit sum and add up the carries
    while (sum>>16)
    1c08:	9d 01       	movw	r18, r26
    1c0a:	44 27       	eor	r20, r20
    1c0c:	55 27       	eor	r21, r21
    1c0e:	21 15       	cp	r18, r1
    1c10:	31 05       	cpc	r19, r1
    1c12:	41 05       	cpc	r20, r1
    1c14:	51 05       	cpc	r21, r1
    1c16:	91 f7       	brne	.-28     	; 0x1bfc <udp_create_packet+0xe6>
      sum = (sum & 0xFFFF)+(sum >> 16);

    // one's complement the result
    sum = ~sum;
    1c18:	80 95       	com	r24
    1c1a:	90 95       	com	r25
    1c1c:	a0 95       	com	r26
    1c1e:	b0 95       	com	r27
    packet_out[IPV4_PROTOCOL_OFFSET] = UDP_IPV4_PROTOCOL_NUMBER;
    len+=IPV4_PROTOCOL_LENGTH;

    //header checksum
    header_checksum = ip_header_calculate_checksum(packet_out, len);
    packet_out[IPV4_HEADER_CHECKSUM_OFFSET] = (header_checksum >> 8) & 0xFF;
    1c20:	f6 01       	movw	r30, r12
    1c22:	92 87       	std	Z+10, r25	; 0x0a
    packet_out[IPV4_HEADER_CHECKSUM_OFFSET+1] = header_checksum & 0xFF;
    1c24:	83 87       	std	Z+11, r24	; 0x0b
    1c26:	c4 01       	movw	r24, r8
    1c28:	a9 2f       	mov	r26, r25
    1c2a:	b8 2d       	mov	r27, r8
    }

    return udp_broadcast_address;
}

uint16_t udp_create_packet(uint8_t* src_in, uint16_t src_port, uint8_t* dst_in, uint16_t dst_port, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
    1c2c:	3c 96       	adiw	r30, 0x0c	; 12
    packet_out[IPV4_HEADER_CHECKSUM_OFFSET] = (header_checksum >> 8) & 0xFF;
    packet_out[IPV4_HEADER_CHECKSUM_OFFSET+1] = header_checksum & 0xFF;
    len+=IPV4_HEADER_CHECKSUM_LENGTH;

    //source address
    for(i=0; i<IPV4_SOURCE_LENGTH; i++)
    1c2e:	80 e0       	ldi	r24, 0x00	; 0
        packet_out[IPV4_SOURCE_OFFSET+i]=src_in[i];
    1c30:	9d 91       	ld	r25, X+
    1c32:	91 93       	st	Z+, r25
    packet_out[IPV4_HEADER_CHECKSUM_OFFSET] = (header_checksum >> 8) & 0xFF;
    packet_out[IPV4_HEADER_CHECKSUM_OFFSET+1] = header_checksum & 0xFF;
    len+=IPV4_HEADER_CHECKSUM_LENGTH;

    //source address
    for(i=0; i<IPV4_SOURCE_LENGTH; i++)
    1c34:	8f 5f       	subi	r24, 0xFF	; 255
    1c36:	84 30       	cpi	r24, 0x04	; 4
    1c38:	d9 f7       	brne	.-10     	; 0x1c30 <udp_create_packet+0x11a>
    1c3a:	c3 01       	movw	r24, r6
    1c3c:	a9 2f       	mov	r26, r25
    1c3e:	b6 2d       	mov	r27, r6
    }

    return udp_broadcast_address;
}

uint16_t udp_create_packet(uint8_t* src_in, uint16_t src_port, uint8_t* dst_in, uint16_t dst_port, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
    1c40:	f6 01       	movw	r30, r12
    1c42:	70 96       	adiw	r30, 0x10	; 16
    1c44:	84 e0       	ldi	r24, 0x04	; 4
        packet_out[IPV4_SOURCE_OFFSET+i]=src_in[i];
    len+=IPV4_SOURCE_LENGTH;

    //paste the destination address
    for(i=0; i<IPV4_DESTINATION_LENGTH; i++)
        packet_out[IPV4_DESTINATION_OFFSET+i]=dst_in[i];
    1c46:	9d 91       	ld	r25, X+
    1c48:	91 93       	st	Z+, r25
    1c4a:	81 50       	subi	r24, 0x01	; 1
    for(i=0; i<IPV4_SOURCE_LENGTH; i++)
        packet_out[IPV4_SOURCE_OFFSET+i]=src_in[i];
    len+=IPV4_SOURCE_LENGTH;

    //paste the destination address
    for(i=0; i<IPV4_DESTINATION_LENGTH; i++)
    1c4c:	e1 f7       	brne	.-8      	; 0x1c46 <udp_create_packet+0x130>
    len+=IPV4_DESTINATION_LENGTH;

    //UDP Headers

    //source port
    packet_out[UDP_SOURCE_PORT_OFFSET]=((src_port>>8) & 0xFF);
    1c4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1c50:	d6 01       	movw	r26, r12
    1c52:	54 96       	adiw	r26, 0x14	; 20
    1c54:	ec 93       	st	X, r30
    1c56:	54 97       	sbiw	r26, 0x14	; 20
    packet_out[UDP_SOURCE_PORT_OFFSET+1]=(src_port & 0xFF);
    1c58:	f9 81       	ldd	r31, Y+1	; 0x01
    1c5a:	55 96       	adiw	r26, 0x15	; 21
    1c5c:	fc 93       	st	X, r31
    1c5e:	55 97       	sbiw	r26, 0x15	; 21
    len+=UDP_SOURCE_PORT_LENGTH;

    //destination port
    packet_out[UDP_DESTINATION_PORT_OFFSET]=((dst_port>>8) & 0xFF);
    1c60:	56 96       	adiw	r26, 0x16	; 22
    1c62:	3c 92       	st	X, r3
    1c64:	56 97       	sbiw	r26, 0x16	; 22
    packet_out[UDP_DESTINATION_PORT_OFFSET+1]=(dst_port & 0xFF);
    1c66:	57 96       	adiw	r26, 0x17	; 23
    1c68:	2c 92       	st	X, r2
    1c6a:	57 97       	sbiw	r26, 0x17	; 23
    len+=UDP_DESTINATION_PORT_LENGTH;

    //udp length = data+udp headers
    //we've already added 8 to payload_length above, we don't do it again
    payload_length+=8;
    1c6c:	98 01       	movw	r18, r16
    1c6e:	28 5f       	subi	r18, 0xF8	; 248
    1c70:	3f 4f       	sbci	r19, 0xFF	; 255
    packet_out[UDP_LENGTH_OFFSET]=((payload_length>>8) & 0xFF);
    1c72:	58 96       	adiw	r26, 0x18	; 24
    1c74:	3c 93       	st	X, r19
    1c76:	58 97       	sbiw	r26, 0x18	; 24
    packet_out[UDP_LENGTH_OFFSET+1]=(payload_length & 0xFF);
    1c78:	59 96       	adiw	r26, 0x19	; 25
    1c7a:	2c 93       	st	X, r18
    len+=UDP_LENGTH_LENGTH;

    //udp checksum
    //we've already added 8 to payload_length above, we don't do it again
    udp_checksum=udp_calculate_checksum(src_in, dst_in, payload_in, payload_length);
    1c7c:	89 2d       	mov	r24, r9
    1c7e:	98 2d       	mov	r25, r8
    1c80:	67 2d       	mov	r22, r7
    1c82:	76 2d       	mov	r23, r6
    1c84:	a5 01       	movw	r20, r10
    1c86:	0e 94 b2 0c 	call	0x1964	; 0x1964 <udp_calculate_checksum>
    packet_out[UDP_CHECKSUM_OFFSET]=((udp_checksum>>8) & 0xFF);
    1c8a:	d6 01       	movw	r26, r12
    1c8c:	5a 96       	adiw	r26, 0x1a	; 26
    1c8e:	9c 93       	st	X, r25
    1c90:	5a 97       	sbiw	r26, 0x1a	; 26
    packet_out[UDP_CHECKSUM_OFFSET+1]=(udp_checksum & 0xFF);
    1c92:	5b 96       	adiw	r26, 0x1b	; 27
    1c94:	8c 93       	st	X, r24
    len+=UDP_CHECKSUM_LENGTH;

    memcpy(packet_out+UDP_PAYLOAD_OFFSET, payload_in, payload_length-8);
    1c96:	a6 01       	movw	r20, r12
    1c98:	44 5e       	subi	r20, 0xE4	; 228
    1c9a:	5f 4f       	sbci	r21, 0xFF	; 255
    1c9c:	ca 01       	movw	r24, r20
    1c9e:	b5 01       	movw	r22, r10
    1ca0:	a8 01       	movw	r20, r16
    1ca2:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    len+=payload_length-8;
    1ca6:	04 5e       	subi	r16, 0xE4	; 228
    1ca8:	1f 4f       	sbci	r17, 0xFF	; 255
    

    return len;
    1caa:	02 c0       	rjmp	.+4      	; 0x1cb0 <udp_create_packet+0x19a>
    uint16_t* checksumPtr;
    uint8_t i;

    //check for input errors
    if(payload_length > UDP_MAX_PAYLOAD_LENGTH || packet_out==NULL)
        return 0;
    1cac:	00 e0       	ldi	r16, 0x00	; 0
    1cae:	10 e0       	ldi	r17, 0x00	; 0
    memcpy(packet_out+UDP_PAYLOAD_OFFSET, payload_in, payload_length-8);
    len+=payload_length-8;
    

    return len;
}
    1cb0:	c8 01       	movw	r24, r16
    1cb2:	0f 90       	pop	r0
    1cb4:	0f 90       	pop	r0
    1cb6:	cf 91       	pop	r28
    1cb8:	df 91       	pop	r29
    1cba:	1f 91       	pop	r17
    1cbc:	0f 91       	pop	r16
    1cbe:	ff 90       	pop	r15
    1cc0:	ef 90       	pop	r14
    1cc2:	df 90       	pop	r13
    1cc4:	cf 90       	pop	r12
    1cc6:	bf 90       	pop	r11
    1cc8:	af 90       	pop	r10
    1cca:	9f 90       	pop	r9
    1ccc:	8f 90       	pop	r8
    1cce:	7f 90       	pop	r7
    1cd0:	6f 90       	pop	r6
    1cd2:	5f 90       	pop	r5
    1cd4:	4f 90       	pop	r4
    1cd6:	3f 90       	pop	r3
    1cd8:	2f 90       	pop	r2
    1cda:	08 95       	ret

00001cdc <udp_check_destination>:

uint8_t udp_check_destination(uint8_t* my_dst, uint8_t* packet_dst, uint8_t* packet_in)
{
    1cdc:	ef 92       	push	r14
    1cde:	ff 92       	push	r15
    1ce0:	0f 93       	push	r16
    1ce2:	1f 93       	push	r17
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	7b 01       	movw	r14, r22
    1cea:	8a 01       	movw	r16, r20
    uint8_t result;
    
    //check for address match
    result=memcmp(my_dst, packet_in+IPV4_DESTINATION_OFFSET, IPV4_DESTINATION_LENGTH);
    1cec:	ea 01       	movw	r28, r20
    1cee:	60 96       	adiw	r28, 0x10	; 16
    1cf0:	be 01       	movw	r22, r28
    1cf2:	44 e0       	ldi	r20, 0x04	; 4
    1cf4:	50 e0       	ldi	r21, 0x00	; 0
    1cf6:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
    if(result)
    1cfa:	88 23       	and	r24, r24
    1cfc:	39 f0       	breq	.+14     	; 0x1d0c <udp_check_destination+0x30>
    {
        result=memcmp(udp_broadcast_address, packet_in+IPV4_DESTINATION_OFFSET, IPV4_DESTINATION_LENGTH);
    1cfe:	8f eb       	ldi	r24, 0xBF	; 191
    1d00:	9b e0       	ldi	r25, 0x0B	; 11
    1d02:	be 01       	movw	r22, r28
    1d04:	44 e0       	ldi	r20, 0x04	; 4
    1d06:	50 e0       	ldi	r21, 0x00	; 0
    1d08:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
    }

    //copy the destination address in the packet
    if(packet_dst!=NULL)
    1d0c:	e1 14       	cp	r14, r1
    1d0e:	f1 04       	cpc	r15, r1
    1d10:	51 f0       	breq	.+20     	; 0x1d26 <udp_check_destination+0x4a>
        memcpy(packet_dst, packet_in+IPV4_DESTINATION_OFFSET, IPV4_DESTINATION_LENGTH);
    1d12:	f8 01       	movw	r30, r16
    1d14:	20 89       	ldd	r18, Z+16	; 0x10
    1d16:	31 89       	ldd	r19, Z+17	; 0x11
    1d18:	42 89       	ldd	r20, Z+18	; 0x12
    1d1a:	53 89       	ldd	r21, Z+19	; 0x13
    1d1c:	f7 01       	movw	r30, r14
    1d1e:	20 83       	st	Z, r18
    1d20:	31 83       	std	Z+1, r19	; 0x01
    1d22:	42 83       	std	Z+2, r20	; 0x02
    1d24:	53 83       	std	Z+3, r21	; 0x03
    
    return result;
}
    1d26:	df 91       	pop	r29
    1d28:	cf 91       	pop	r28
    1d2a:	1f 91       	pop	r17
    1d2c:	0f 91       	pop	r16
    1d2e:	ff 90       	pop	r15
    1d30:	ef 90       	pop	r14
    1d32:	08 95       	ret

00001d34 <udp_open_packet_extended>:
                                    uint16_t* fragmentoffset_out,
                                    uint8_t* ttl_out,
                                    uint8_t* protocol_out,
                                    uint16_t* headerchecksum_out
                                    )
{
    1d34:	2f 92       	push	r2
    1d36:	3f 92       	push	r3
    1d38:	4f 92       	push	r4
    1d3a:	5f 92       	push	r5
    1d3c:	6f 92       	push	r6
    1d3e:	7f 92       	push	r7
    1d40:	8f 92       	push	r8
    1d42:	9f 92       	push	r9
    1d44:	af 92       	push	r10
    1d46:	bf 92       	push	r11
    1d48:	cf 92       	push	r12
    1d4a:	df 92       	push	r13
    1d4c:	ef 92       	push	r14
    1d4e:	ff 92       	push	r15
    1d50:	0f 93       	push	r16
    1d52:	1f 93       	push	r17
    1d54:	df 93       	push	r29
    1d56:	cf 93       	push	r28
    1d58:	cd b7       	in	r28, 0x3d	; 61
    1d5a:	de b7       	in	r29, 0x3e	; 62
    1d5c:	2c 97       	sbiw	r28, 0x0c	; 12
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	9a 87       	std	Y+10, r25	; 0x0a
    1d6a:	89 87       	std	Y+9, r24	; 0x09
    1d6c:	1b 01       	movw	r2, r22
    1d6e:	5c 87       	std	Y+12, r21	; 0x0c
    1d70:	4b 87       	std	Y+11, r20	; 0x0b
    1d72:	29 01       	movw	r4, r18
    1d74:	1e 83       	std	Y+6, r17	; 0x06
    1d76:	0d 83       	std	Y+5, r16	; 0x05
    1d78:	87 01       	movw	r16, r14
    1d7a:	f5 01       	movw	r30, r10
    1d7c:	49 a1       	ldd	r20, Y+33	; 0x21
    1d7e:	5a a1       	ldd	r21, Y+34	; 0x22
    1d80:	2d a1       	ldd	r18, Y+37	; 0x25
    1d82:	3e a1       	ldd	r19, Y+38	; 0x26
    1d84:	ef a0       	ldd	r14, Y+39	; 0x27
    1d86:	f8 a4       	ldd	r15, Y+40	; 0x28
    1d88:	89 a5       	ldd	r24, Y+41	; 0x29
    1d8a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d8c:	ab a4       	ldd	r10, Y+43	; 0x2b
    1d8e:	bc a4       	ldd	r11, Y+44	; 0x2c
    uint16_t udp_len_from_udp=0;
    uint16_t udp_checksum=0;
    uint16_t calculated_checksum=0;

    //copy version and priority
    if(version_out!=NULL)
    1d90:	c1 14       	cp	r12, r1
    1d92:	d1 04       	cpc	r13, r1
    1d94:	29 f0       	breq	.+10     	; 0x1da0 <udp_open_packet_extended+0x6c>
        *version_out = packet_in[IPV4_VERSIONnIHL_OFFSET] & 0xF0;
    1d96:	d8 01       	movw	r26, r16
    1d98:	6c 91       	ld	r22, X
    1d9a:	60 7f       	andi	r22, 0xF0	; 240
    1d9c:	d6 01       	movw	r26, r12
    1d9e:	6c 93       	st	X, r22

    if(headerlength_out!=NULL)
    1da0:	30 97       	sbiw	r30, 0x00	; 0
    1da2:	21 f0       	breq	.+8      	; 0x1dac <udp_open_packet_extended+0x78>
        *headerlength_out = packet_in[IPV4_VERSIONnIHL_OFFSET] & 0x0F;
    1da4:	d8 01       	movw	r26, r16
    1da6:	6c 91       	ld	r22, X
    1da8:	6f 70       	andi	r22, 0x0F	; 15
    1daa:	60 83       	st	Z, r22

    if(dscp_out!=NULL)
    1dac:	81 14       	cp	r8, r1
    1dae:	91 04       	cpc	r9, r1
    1db0:	31 f0       	breq	.+12     	; 0x1dbe <udp_open_packet_extended+0x8a>
        *dscp_out = ( packet_in[IPV4_DSCPnECN_OFFSET] >> 2 ) & 0x3F;
    1db2:	f8 01       	movw	r30, r16
    1db4:	61 81       	ldd	r22, Z+1	; 0x01
    1db6:	66 95       	lsr	r22
    1db8:	66 95       	lsr	r22
    1dba:	d4 01       	movw	r26, r8
    1dbc:	6c 93       	st	X, r22

    if(ecn_out!=NULL)
    1dbe:	41 15       	cp	r20, r1
    1dc0:	51 05       	cpc	r21, r1
    1dc2:	29 f0       	breq	.+10     	; 0x1dce <udp_open_packet_extended+0x9a>
        *ecn_out = packet_in[IPV4_DSCPnECN_OFFSET] & 0x03;
    1dc4:	f8 01       	movw	r30, r16
    1dc6:	61 81       	ldd	r22, Z+1	; 0x01
    1dc8:	63 70       	andi	r22, 0x03	; 3
    1dca:	da 01       	movw	r26, r20
    1dcc:	6c 93       	st	X, r22

    udp_len_from_ip = (packet_in[IPV4_TOTAL_LENGTH_OFFSET] & 0x00FF);
    1dce:	f8 01       	movw	r30, r16
    1dd0:	42 81       	ldd	r20, Z+2	; 0x02
    udp_len_from_ip <<= 8;
    1dd2:	74 2e       	mov	r7, r20
    1dd4:	66 24       	eor	r6, r6
    udp_len_from_ip |= (packet_in[IPV4_TOTAL_LENGTH_OFFSET+1] & 0x00FF);
    1dd6:	43 81       	ldd	r20, Z+3	; 0x03
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	64 2a       	or	r6, r20
    1ddc:	75 2a       	or	r7, r21
    udp_len_from_ip -= (20); //ip header length=20
    1dde:	4c ee       	ldi	r20, 0xEC	; 236
    1de0:	5f ef       	ldi	r21, 0xFF	; 255
    1de2:	64 0e       	add	r6, r20
    1de4:	75 1e       	adc	r7, r21

    if(fragmentidentification_out!=NULL)
    1de6:	21 15       	cp	r18, r1
    1de8:	31 05       	cpc	r19, r1
    1dea:	69 f0       	breq	.+26     	; 0x1e06 <udp_open_packet_extended+0xd2>
    {
        *fragmentidentification_out = packet_in[IPV4_IDENTIFICATION_OFFSET];
        *fragmentidentification_out <<= 8;
    1dec:	54 81       	ldd	r21, Z+4	; 0x04
    1dee:	40 e0       	ldi	r20, 0x00	; 0
    1df0:	d9 01       	movw	r26, r18
    1df2:	11 96       	adiw	r26, 0x01	; 1
    1df4:	5c 93       	st	X, r21
    1df6:	4e 93       	st	-X, r20
        *fragmentidentification_out |= packet_in[IPV4_IDENTIFICATION_OFFSET+1];
    1df8:	65 81       	ldd	r22, Z+5	; 0x05
    1dfa:	70 e0       	ldi	r23, 0x00	; 0
    1dfc:	64 2b       	or	r22, r20
    1dfe:	75 2b       	or	r23, r21
    1e00:	11 96       	adiw	r26, 0x01	; 1
    1e02:	7c 93       	st	X, r23
    1e04:	6e 93       	st	-X, r22
    }

    if(flags_out!=NULL)
    1e06:	e1 14       	cp	r14, r1
    1e08:	f1 04       	cpc	r15, r1
    1e0a:	59 f0       	breq	.+22     	; 0x1e22 <udp_open_packet_extended+0xee>
        *flags_out= ( packet_in[IPV4_FLAGSnFRAGMENT_OFFSET_OFFSET] >> 5 ) * 0x07;
    1e0c:	f8 01       	movw	r30, r16
    1e0e:	26 81       	ldd	r18, Z+6	; 0x06
    1e10:	22 95       	swap	r18
    1e12:	26 95       	lsr	r18
    1e14:	27 70       	andi	r18, 0x07	; 7
    1e16:	37 e0       	ldi	r19, 0x07	; 7
    1e18:	23 9f       	mul	r18, r19
    1e1a:	20 2d       	mov	r18, r0
    1e1c:	11 24       	eor	r1, r1
    1e1e:	d7 01       	movw	r26, r14
    1e20:	2c 93       	st	X, r18

    if(fragmentoffset_out!=NULL)
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	91 f0       	breq	.+36     	; 0x1e4a <udp_open_packet_extended+0x116>
    {
        *fragmentoffset_out = packet_in[IPV4_FLAGSnFRAGMENT_OFFSET_OFFSET] & 0x1F;
    1e26:	f8 01       	movw	r30, r16
    1e28:	46 81       	ldd	r20, Z+6	; 0x06
    1e2a:	50 e0       	ldi	r21, 0x00	; 0
    1e2c:	4f 71       	andi	r20, 0x1F	; 31
    1e2e:	50 70       	andi	r21, 0x00	; 0
        *fragmentoffset_out <<= 8;
    1e30:	54 2f       	mov	r21, r20
    1e32:	44 27       	eor	r20, r20
    1e34:	dc 01       	movw	r26, r24
    1e36:	11 96       	adiw	r26, 0x01	; 1
    1e38:	5c 93       	st	X, r21
    1e3a:	4e 93       	st	-X, r20
        *fragmentoffset_out |= packet_in[IPV4_FLAGSnFRAGMENT_OFFSET_OFFSET+1];
    1e3c:	27 81       	ldd	r18, Z+7	; 0x07
    1e3e:	30 e0       	ldi	r19, 0x00	; 0
    1e40:	24 2b       	or	r18, r20
    1e42:	35 2b       	or	r19, r21
    1e44:	11 96       	adiw	r26, 0x01	; 1
    1e46:	3c 93       	st	X, r19
    1e48:	2e 93       	st	-X, r18
    }

    if(ttl_out!=NULL)
    1e4a:	a1 14       	cp	r10, r1
    1e4c:	b1 04       	cpc	r11, r1
    1e4e:	21 f0       	breq	.+8      	; 0x1e58 <udp_open_packet_extended+0x124>
        *ttl_out = packet_in[IPV4_TIME_TO_LIVE_OFFSET];
    1e50:	f8 01       	movw	r30, r16
    1e52:	80 85       	ldd	r24, Z+8	; 0x08
    1e54:	d5 01       	movw	r26, r10
    1e56:	8c 93       	st	X, r24

    if(protocol_out!=NULL)
    1e58:	ed a5       	ldd	r30, Y+45	; 0x2d
    1e5a:	fe a5       	ldd	r31, Y+46	; 0x2e
    1e5c:	30 97       	sbiw	r30, 0x00	; 0
    1e5e:	29 f0       	breq	.+10     	; 0x1e6a <udp_open_packet_extended+0x136>
        *protocol_out = packet_in[IPV4_PROTOCOL_OFFSET];
    1e60:	d8 01       	movw	r26, r16
    1e62:	19 96       	adiw	r26, 0x09	; 9
    1e64:	8c 91       	ld	r24, X
    1e66:	19 97       	sbiw	r26, 0x09	; 9
    1e68:	80 83       	st	Z, r24

    if(headerchecksum_out!=NULL)
    1e6a:	ef a5       	ldd	r30, Y+47	; 0x2f
    1e6c:	f8 a9       	ldd	r31, Y+48	; 0x30
    1e6e:	30 97       	sbiw	r30, 0x00	; 0
    1e70:	79 f0       	breq	.+30     	; 0x1e90 <udp_open_packet_extended+0x15c>
    {
        *headerchecksum_out = packet_in[IPV4_HEADER_CHECKSUM_OFFSET];
        *headerchecksum_out <<= 8;
    1e72:	d8 01       	movw	r26, r16
    1e74:	1a 96       	adiw	r26, 0x0a	; 10
    1e76:	9c 91       	ld	r25, X
    1e78:	1a 97       	sbiw	r26, 0x0a	; 10
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	91 83       	std	Z+1, r25	; 0x01
    1e7e:	80 83       	st	Z, r24
        *headerchecksum_out |= packet_in[IPV4_HEADER_CHECKSUM_OFFSET+1];
    1e80:	1b 96       	adiw	r26, 0x0b	; 11
    1e82:	2c 91       	ld	r18, X
    1e84:	1b 97       	sbiw	r26, 0x0b	; 11
    1e86:	30 e0       	ldi	r19, 0x00	; 0
    1e88:	28 2b       	or	r18, r24
    1e8a:	39 2b       	or	r19, r25
    1e8c:	31 83       	std	Z+1, r19	; 0x01
    1e8e:	20 83       	st	Z, r18
    }

    //copy source address
    if(src_out!=NULL)
    1e90:	e9 85       	ldd	r30, Y+9	; 0x09
    1e92:	fa 85       	ldd	r31, Y+10	; 0x0a
    1e94:	30 97       	sbiw	r30, 0x00	; 0
    1e96:	59 f0       	breq	.+22     	; 0x1eae <udp_open_packet_extended+0x17a>
        memcpy(src_out, packet_in+IPV4_SOURCE_OFFSET, IPV4_SOURCE_LENGTH);
    1e98:	f8 01       	movw	r30, r16
    1e9a:	84 85       	ldd	r24, Z+12	; 0x0c
    1e9c:	95 85       	ldd	r25, Z+13	; 0x0d
    1e9e:	a6 85       	ldd	r26, Z+14	; 0x0e
    1ea0:	b7 85       	ldd	r27, Z+15	; 0x0f
    1ea2:	e9 85       	ldd	r30, Y+9	; 0x09
    1ea4:	fa 85       	ldd	r31, Y+10	; 0x0a
    1ea6:	80 83       	st	Z, r24
    1ea8:	91 83       	std	Z+1, r25	; 0x01
    1eaa:	a2 83       	std	Z+2, r26	; 0x02
    1eac:	b3 83       	std	Z+3, r27	; 0x03

    //copy destination address
    if(dst_out!=NULL)
    1eae:	2b 85       	ldd	r18, Y+11	; 0x0b
    1eb0:	3c 85       	ldd	r19, Y+12	; 0x0c
    1eb2:	21 15       	cp	r18, r1
    1eb4:	31 05       	cpc	r19, r1
    1eb6:	51 f0       	breq	.+20     	; 0x1ecc <udp_open_packet_extended+0x198>
        memcpy(dst_out, packet_in+IPV4_DESTINATION_OFFSET, IPV4_DESTINATION_LENGTH);
    1eb8:	f8 01       	movw	r30, r16
    1eba:	80 89       	ldd	r24, Z+16	; 0x10
    1ebc:	91 89       	ldd	r25, Z+17	; 0x11
    1ebe:	a2 89       	ldd	r26, Z+18	; 0x12
    1ec0:	b3 89       	ldd	r27, Z+19	; 0x13
    1ec2:	f9 01       	movw	r30, r18
    1ec4:	80 83       	st	Z, r24
    1ec6:	91 83       	std	Z+1, r25	; 0x01
    1ec8:	a2 83       	std	Z+2, r26	; 0x02
    1eca:	b3 83       	std	Z+3, r27	; 0x03

    //copy source port
    if(src_port_out!=NULL)
    1ecc:	21 14       	cp	r2, r1
    1ece:	31 04       	cpc	r3, r1
    1ed0:	99 f0       	breq	.+38     	; 0x1ef8 <udp_open_packet_extended+0x1c4>
    {
        *src_port_out=packet_in[UDP_SOURCE_PORT_OFFSET] & 0xFF;
    1ed2:	d8 01       	movw	r26, r16
    1ed4:	54 96       	adiw	r26, 0x14	; 20
    1ed6:	8c 91       	ld	r24, X
    1ed8:	54 97       	sbiw	r26, 0x14	; 20
        *src_port_out <<= 8;
    1eda:	8a 83       	std	Y+2, r24	; 0x02
    1edc:	19 82       	std	Y+1, r1	; 0x01
    1ede:	29 81       	ldd	r18, Y+1	; 0x01
    1ee0:	3a 81       	ldd	r19, Y+2	; 0x02
    1ee2:	f1 01       	movw	r30, r2
    1ee4:	31 83       	std	Z+1, r19	; 0x01
    1ee6:	20 83       	st	Z, r18
        *src_port_out|=packet_in[UDP_SOURCE_PORT_OFFSET+1] & 0xFF;
    1ee8:	55 96       	adiw	r26, 0x15	; 21
    1eea:	8c 91       	ld	r24, X
    1eec:	55 97       	sbiw	r26, 0x15	; 21
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	82 2b       	or	r24, r18
    1ef2:	93 2b       	or	r25, r19
    1ef4:	91 83       	std	Z+1, r25	; 0x01
    1ef6:	80 83       	st	Z, r24
    }

    //copy destination port
    if(dst_port_out!=NULL)
    1ef8:	41 14       	cp	r4, r1
    1efa:	51 04       	cpc	r5, r1
    1efc:	91 f0       	breq	.+36     	; 0x1f22 <udp_open_packet_extended+0x1ee>
    {
        *dst_port_out=packet_in[UDP_DESTINATION_PORT_OFFSET] & 0xFF;
    1efe:	d8 01       	movw	r26, r16
    1f00:	56 96       	adiw	r26, 0x16	; 22
    1f02:	8c 91       	ld	r24, X
    1f04:	56 97       	sbiw	r26, 0x16	; 22
        *dst_port_out <<= 8;
    1f06:	8c 83       	std	Y+4, r24	; 0x04
    1f08:	1b 82       	std	Y+3, r1	; 0x03
    1f0a:	2b 81       	ldd	r18, Y+3	; 0x03
    1f0c:	3c 81       	ldd	r19, Y+4	; 0x04
    1f0e:	f2 01       	movw	r30, r4
    1f10:	31 83       	std	Z+1, r19	; 0x01
    1f12:	20 83       	st	Z, r18
        *dst_port_out|=packet_in[UDP_DESTINATION_PORT_OFFSET+1] & 0xFF;
    1f14:	57 96       	adiw	r26, 0x17	; 23
    1f16:	8c 91       	ld	r24, X
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	82 2b       	or	r24, r18
    1f1c:	93 2b       	or	r25, r19
    1f1e:	91 83       	std	Z+1, r25	; 0x01
    1f20:	80 83       	st	Z, r24
    }

    //copy and check udp length
    udp_len_from_udp = packet_in[UDP_LENGTH_OFFSET];
    udp_len_from_udp<<=8;
    1f22:	d8 01       	movw	r26, r16
    1f24:	58 96       	adiw	r26, 0x18	; 24
    1f26:	3c 91       	ld	r19, X
    1f28:	58 97       	sbiw	r26, 0x18	; 24
    1f2a:	20 e0       	ldi	r18, 0x00	; 0
    udp_len_from_udp |= packet_in[UDP_LENGTH_OFFSET+1] & 0xFF;
    1f2c:	59 96       	adiw	r26, 0x19	; 25
    1f2e:	8c 91       	ld	r24, X
    1f30:	59 97       	sbiw	r26, 0x19	; 25
    1f32:	90 e0       	ldi	r25, 0x00	; 0
    1f34:	82 2b       	or	r24, r18
    1f36:	93 2b       	or	r25, r19


    if(udp_len_from_ip != udp_len_from_udp)
    1f38:	68 16       	cp	r6, r24
    1f3a:	79 06       	cpc	r7, r25
    1f3c:	29 f0       	breq	.+10     	; 0x1f48 <udp_open_packet_extended+0x214>
    {
        printf("Length mismatch while opening udp/ip packet\n");
    1f3e:	83 e9       	ldi	r24, 0x93	; 147
    1f40:	9b e0       	ldi	r25, 0x0B	; 11
    1f42:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
    1f46:	2a c0       	rjmp	.+84     	; 0x1f9c <udp_open_packet_extended+0x268>
    {
        len = udp_len_from_udp;
    }

    //copy checksum and check
    udp_checksum = (packet_in[UDP_CHECKSUM_OFFSET] & 0xFF);
    1f48:	f8 01       	movw	r30, r16
    1f4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    udp_checksum = udp_checksum<<8;
    1f4c:	88 87       	std	Y+8, r24	; 0x08
    1f4e:	1f 82       	std	Y+7, r1	; 0x07
    udp_checksum |= (packet_in[UDP_CHECKSUM_OFFSET+1] & 0xFF);

    calculated_checksum=udp_calculate_checksum(packet_in+IPV4_SOURCE_OFFSET, packet_in+IPV4_DESTINATION_OFFSET, packet_in+UDP_PAYLOAD_OFFSET, len);
    1f50:	3c e1       	ldi	r19, 0x1C	; 28
    1f52:	e3 2e       	mov	r14, r19
    1f54:	f1 2c       	mov	r15, r1
    1f56:	e0 0e       	add	r14, r16
    1f58:	f1 1e       	adc	r15, r17
    1f5a:	b8 01       	movw	r22, r16
    1f5c:	60 5f       	subi	r22, 0xF0	; 240
    1f5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f60:	c8 01       	movw	r24, r16
    1f62:	0c 96       	adiw	r24, 0x0c	; 12
    1f64:	a7 01       	movw	r20, r14
    1f66:	93 01       	movw	r18, r6
    1f68:	0e 94 b2 0c 	call	0x1964	; 0x1964 <udp_calculate_checksum>
    }

    //copy checksum and check
    udp_checksum = (packet_in[UDP_CHECKSUM_OFFSET] & 0xFF);
    udp_checksum = udp_checksum<<8;
    udp_checksum |= (packet_in[UDP_CHECKSUM_OFFSET+1] & 0xFF);
    1f6c:	d8 01       	movw	r26, r16
    1f6e:	5b 96       	adiw	r26, 0x1b	; 27
    1f70:	2c 91       	ld	r18, X
    1f72:	5b 97       	sbiw	r26, 0x1b	; 27
    1f74:	30 e0       	ldi	r19, 0x00	; 0
    1f76:	ef 81       	ldd	r30, Y+7	; 0x07
    1f78:	f8 85       	ldd	r31, Y+8	; 0x08
    1f7a:	2e 2b       	or	r18, r30
    1f7c:	3f 2b       	or	r19, r31

    calculated_checksum=udp_calculate_checksum(packet_in+IPV4_SOURCE_OFFSET, packet_in+IPV4_DESTINATION_OFFSET, packet_in+UDP_PAYLOAD_OFFSET, len);
    
    if(udp_checksum != calculated_checksum)
    1f7e:	28 17       	cp	r18, r24
    1f80:	39 07       	cpc	r19, r25
    1f82:	61 f4       	brne	.+24     	; 0x1f9c <udp_open_packet_extended+0x268>
        return 0;
    //finally copy the payload itself
    if(payload_out != NULL)
    1f84:	2d 81       	ldd	r18, Y+5	; 0x05
    1f86:	3e 81       	ldd	r19, Y+6	; 0x06
    1f88:	21 15       	cp	r18, r1
    1f8a:	31 05       	cpc	r19, r1
    1f8c:	51 f0       	breq	.+20     	; 0x1fa2 <udp_open_packet_extended+0x26e>
        memcpy(payload_out, packet_in+UDP_PAYLOAD_OFFSET, len);
    1f8e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f90:	9e 81       	ldd	r25, Y+6	; 0x06
    1f92:	b7 01       	movw	r22, r14
    1f94:	a3 01       	movw	r20, r6
    1f96:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    1f9a:	03 c0       	rjmp	.+6      	; 0x1fa2 <udp_open_packet_extended+0x26e>
    udp_checksum |= (packet_in[UDP_CHECKSUM_OFFSET+1] & 0xFF);

    calculated_checksum=udp_calculate_checksum(packet_in+IPV4_SOURCE_OFFSET, packet_in+IPV4_DESTINATION_OFFSET, packet_in+UDP_PAYLOAD_OFFSET, len);
    
    if(udp_checksum != calculated_checksum)
        return 0;
    1f9c:	20 e0       	ldi	r18, 0x00	; 0
    1f9e:	30 e0       	ldi	r19, 0x00	; 0
    1fa0:	01 c0       	rjmp	.+2      	; 0x1fa4 <udp_open_packet_extended+0x270>
    //finally copy the payload itself
    if(payload_out != NULL)
    1fa2:	93 01       	movw	r18, r6
        memcpy(payload_out, packet_in+UDP_PAYLOAD_OFFSET, len);


    return len;
}
    1fa4:	c9 01       	movw	r24, r18
    1fa6:	2c 96       	adiw	r28, 0x0c	; 12
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	cd bf       	out	0x3d, r28	; 61
    1fb2:	cf 91       	pop	r28
    1fb4:	df 91       	pop	r29
    1fb6:	1f 91       	pop	r17
    1fb8:	0f 91       	pop	r16
    1fba:	ff 90       	pop	r15
    1fbc:	ef 90       	pop	r14
    1fbe:	df 90       	pop	r13
    1fc0:	cf 90       	pop	r12
    1fc2:	bf 90       	pop	r11
    1fc4:	af 90       	pop	r10
    1fc6:	9f 90       	pop	r9
    1fc8:	8f 90       	pop	r8
    1fca:	7f 90       	pop	r7
    1fcc:	6f 90       	pop	r6
    1fce:	5f 90       	pop	r5
    1fd0:	4f 90       	pop	r4
    1fd2:	3f 90       	pop	r3
    1fd4:	2f 90       	pop	r2
    1fd6:	08 95       	ret

00001fd8 <udp_open_packet>:
uint16_t udp_open_packet(uint8_t* src_out, uint16_t* src_port_out,
                                    uint8_t* dst_out, uint16_t* dst_port_out,
                                    uint8_t* payload_out,
                                    uint8_t* packet_in
                            )
{
    1fd8:	8f 92       	push	r8
    1fda:	9f 92       	push	r9
    1fdc:	af 92       	push	r10
    1fde:	bf 92       	push	r11
    1fe0:	cf 92       	push	r12
    1fe2:	df 92       	push	r13
    1fe4:	ef 92       	push	r14
    1fe6:	ff 92       	push	r15
    1fe8:	0f 93       	push	r16
    1fea:	1f 93       	push	r17
    return udp_open_packet_extended(src_out, src_port_out,
    1fec:	ad b7       	in	r26, 0x3d	; 61
    1fee:	be b7       	in	r27, 0x3e	; 62
    1ff0:	50 97       	sbiw	r26, 0x10	; 16
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	be bf       	out	0x3e, r27	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	ad bf       	out	0x3d, r26	; 61
    1ffc:	ed b7       	in	r30, 0x3d	; 61
    1ffe:	fe b7       	in	r31, 0x3e	; 62
    2000:	31 96       	adiw	r30, 0x01	; 1
    2002:	12 96       	adiw	r26, 0x02	; 2
    2004:	1c 92       	st	X, r1
    2006:	1e 92       	st	-X, r1
    2008:	11 97       	sbiw	r26, 0x01	; 1
    200a:	13 82       	std	Z+3, r1	; 0x03
    200c:	12 82       	std	Z+2, r1	; 0x02
    200e:	15 82       	std	Z+5, r1	; 0x05
    2010:	14 82       	std	Z+4, r1	; 0x04
    2012:	17 82       	std	Z+7, r1	; 0x07
    2014:	16 82       	std	Z+6, r1	; 0x06
    2016:	11 86       	std	Z+9, r1	; 0x09
    2018:	10 86       	std	Z+8, r1	; 0x08
    201a:	13 86       	std	Z+11, r1	; 0x0b
    201c:	12 86       	std	Z+10, r1	; 0x0a
    201e:	15 86       	std	Z+13, r1	; 0x0d
    2020:	14 86       	std	Z+12, r1	; 0x0c
    2022:	17 86       	std	Z+15, r1	; 0x0f
    2024:	16 86       	std	Z+14, r1	; 0x0e
    2026:	cc 24       	eor	r12, r12
    2028:	dd 24       	eor	r13, r13
    202a:	aa 24       	eor	r10, r10
    202c:	bb 24       	eor	r11, r11
    202e:	88 24       	eor	r8, r8
    2030:	99 24       	eor	r9, r9
    2032:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <udp_open_packet_extended>
    2036:	ed b7       	in	r30, 0x3d	; 61
    2038:	fe b7       	in	r31, 0x3e	; 62
    203a:	70 96       	adiw	r30, 0x10	; 16
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	f8 94       	cli
    2040:	fe bf       	out	0x3e, r31	; 62
    2042:	0f be       	out	0x3f, r0	; 63
    2044:	ed bf       	out	0x3d, r30	; 61
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );
}
    2046:	1f 91       	pop	r17
    2048:	0f 91       	pop	r16
    204a:	ff 90       	pop	r15
    204c:	ef 90       	pop	r14
    204e:	df 90       	pop	r13
    2050:	cf 90       	pop	r12
    2052:	bf 90       	pop	r11
    2054:	af 90       	pop	r10
    2056:	9f 90       	pop	r9
    2058:	8f 90       	pop	r8
    205a:	08 95       	ret

0000205c <text_to_ip>:
#include "radiotftp.h"

uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
{
	uint8_t i;
	uint8_t point=0;
    205c:	fc 01       	movw	r30, r24
#include <stdlib.h>

#include "util.h"
#include "radiotftp.h"

uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
    205e:	9c 01       	movw	r18, r24
    2060:	26 0f       	add	r18, r22
    2062:	31 1d       	adc	r19, r1
{
	uint8_t i;
	uint8_t point=0;
	uint8_t sum=0;
    2064:	40 e0       	ldi	r20, 0x00	; 0
#include "radiotftp.h"

uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
{
	uint8_t i;
	uint8_t point=0;
    2066:	60 e0       	ldi	r22, 0x00	; 0
	uint8_t sum=0;
	for(i=0; i<in_length; i++)
    2068:	16 c0       	rjmp	.+44     	; 0x2096 <text_to_ip+0x3a>
	{
		if(in_and_out[i]=='.' || in_and_out[i]==':' || in_and_out[i]==0x00)
    206a:	51 91       	ld	r21, Z+
    206c:	5e 32       	cpi	r21, 0x2E	; 46
    206e:	21 f0       	breq	.+8      	; 0x2078 <text_to_ip+0x1c>
    2070:	5a 33       	cpi	r21, 0x3A	; 58
    2072:	11 f0       	breq	.+4      	; 0x2078 <text_to_ip+0x1c>
    2074:	55 23       	and	r21, r21
    2076:	39 f4       	brne	.+14     	; 0x2086 <text_to_ip+0x2a>
		{
			in_and_out[point++]=sum;
    2078:	dc 01       	movw	r26, r24
    207a:	a6 0f       	add	r26, r22
    207c:	b1 1d       	adc	r27, r1
    207e:	4c 93       	st	X, r20
    2080:	6f 5f       	subi	r22, 0xFF	; 255
			sum=0;
    2082:	40 e0       	ldi	r20, 0x00	; 0
    2084:	08 c0       	rjmp	.+16     	; 0x2096 <text_to_ip+0x3a>
//			printf("\n");
		}
		else
		{
			sum = (sum*10) + (in_and_out[i]-'0');
    2086:	44 0f       	add	r20, r20
    2088:	74 2f       	mov	r23, r20
    208a:	77 0f       	add	r23, r23
    208c:	77 0f       	add	r23, r23
    208e:	74 0f       	add	r23, r20
    2090:	45 2f       	mov	r20, r21
    2092:	40 53       	subi	r20, 0x30	; 48
    2094:	47 0f       	add	r20, r23
uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
{
	uint8_t i;
	uint8_t point=0;
	uint8_t sum=0;
	for(i=0; i<in_length; i++)
    2096:	e2 17       	cp	r30, r18
    2098:	f3 07       	cpc	r31, r19
    209a:	39 f7       	brne	.-50     	; 0x206a <text_to_ip+0xe>
			sum = (sum*10) + (in_and_out[i]-'0');
//			printf("sum=%d ", sum);
		}
	}
	return 0;
}
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	08 95       	ret

000020a0 <readnline>:
uint8_t readnline(FILE* fptr, uint8_t* out, uint8_t length)
{
    20a0:	ef 92       	push	r14
    20a2:	ff 92       	push	r15
    20a4:	0f 93       	push	r16
    20a6:	1f 93       	push	r17
    20a8:	cf 93       	push	r28
    20aa:	df 93       	push	r29
    20ac:	7c 01       	movw	r14, r24
    20ae:	eb 01       	movw	r28, r22
    20b0:	04 2f       	mov	r16, r20
	uint8_t previ=0, i=0;
    20b2:	10 e0       	ldi	r17, 0x00	; 0
    20b4:	01 c0       	rjmp	.+2      	; 0x20b8 <readnline+0x18>
	do
	{
		previ=i;
		i+=fread(out+i, 1, 1, fptr);
	} while(out[i-1]!='\n' && i<length && previ!=i);
    20b6:	18 2f       	mov	r17, r24
{
	uint8_t previ=0, i=0;
	do
	{
		previ=i;
		i+=fread(out+i, 1, 1, fptr);
    20b8:	ce 01       	movw	r24, r28
    20ba:	81 0f       	add	r24, r17
    20bc:	91 1d       	adc	r25, r1
    20be:	61 e0       	ldi	r22, 0x01	; 1
    20c0:	70 e0       	ldi	r23, 0x00	; 0
    20c2:	41 e0       	ldi	r20, 0x01	; 1
    20c4:	50 e0       	ldi	r21, 0x00	; 0
    20c6:	97 01       	movw	r18, r14
    20c8:	0e 94 a2 4c 	call	0x9944	; 0x9944 <fread>
    20cc:	81 0f       	add	r24, r17
	} while(out[i-1]!='\n' && i<length && previ!=i);
    20ce:	e8 2f       	mov	r30, r24
    20d0:	f0 e0       	ldi	r31, 0x00	; 0
    20d2:	31 97       	sbiw	r30, 0x01	; 1
    20d4:	ec 0f       	add	r30, r28
    20d6:	fd 1f       	adc	r31, r29
    20d8:	90 81       	ld	r25, Z
    20da:	9a 30       	cpi	r25, 0x0A	; 10
    20dc:	21 f0       	breq	.+8      	; 0x20e6 <readnline+0x46>
    20de:	80 17       	cp	r24, r16
    20e0:	10 f4       	brcc	.+4      	; 0x20e6 <readnline+0x46>
    20e2:	18 17       	cp	r17, r24
    20e4:	41 f7       	brne	.-48     	; 0x20b6 <readnline+0x16>
	out[i-1]=0;
    20e6:	10 82       	st	Z, r1
	return 0;
}
    20e8:	80 e0       	ldi	r24, 0x00	; 0
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	1f 91       	pop	r17
    20f0:	0f 91       	pop	r16
    20f2:	ff 90       	pop	r15
    20f4:	ef 90       	pop	r14
    20f6:	08 95       	ret

000020f8 <print_callsign>:
void print_callsign(uint8_t* callsign)
{
    20f8:	ef 92       	push	r14
    20fa:	ff 92       	push	r15
    20fc:	0f 93       	push	r16
    20fe:	1f 93       	push	r17
    2100:	df 93       	push	r29
    2102:	cf 93       	push	r28
    2104:	0f 92       	push	r0
    2106:	cd b7       	in	r28, 0x3d	; 61
    2108:	de b7       	in	r29, 0x3e	; 62
    210a:	8c 01       	movw	r16, r24
	uint8_t i;
	for(i=0; i<6; i++)
    210c:	7c 01       	movw	r14, r24
    210e:	20 e0       	ldi	r18, 0x00	; 0
	{
		if(callsign[i]>=32 && callsign[i]<=125 )
    2110:	d7 01       	movw	r26, r14
    2112:	8d 91       	ld	r24, X+
    2114:	7d 01       	movw	r14, r26
    2116:	98 2f       	mov	r25, r24
    2118:	90 52       	subi	r25, 0x20	; 32
    211a:	9e 35       	cpi	r25, 0x5E	; 94
    211c:	48 f4       	brcc	.+18     	; 0x2130 <print_callsign+0x38>
			putchar(callsign[i]);
    211e:	60 91 dd 2d 	lds	r22, 0x2DDD
    2122:	70 91 de 2d 	lds	r23, 0x2DDE
    2126:	90 e0       	ldi	r25, 0x00	; 0
    2128:	29 83       	std	Y+1, r18	; 0x01
    212a:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    212e:	29 81       	ldd	r18, Y+1	; 0x01
	return 0;
}
void print_callsign(uint8_t* callsign)
{
	uint8_t i;
	for(i=0; i<6; i++)
    2130:	2f 5f       	subi	r18, 0xFF	; 255
    2132:	26 30       	cpi	r18, 0x06	; 6
    2134:	69 f7       	brne	.-38     	; 0x2110 <print_callsign+0x18>
	{
		if(callsign[i]>=32 && callsign[i]<=125 )
			putchar(callsign[i]);
	}
	printf("%d", callsign[6]);
    2136:	00 d0       	rcall	.+0      	; 0x2138 <print_callsign+0x40>
    2138:	00 d0       	rcall	.+0      	; 0x213a <print_callsign+0x42>
    213a:	ed b7       	in	r30, 0x3d	; 61
    213c:	fe b7       	in	r31, 0x3e	; 62
    213e:	31 96       	adiw	r30, 0x01	; 1
    2140:	89 ed       	ldi	r24, 0xD9	; 217
    2142:	9b e0       	ldi	r25, 0x0B	; 11
    2144:	ad b7       	in	r26, 0x3d	; 61
    2146:	be b7       	in	r27, 0x3e	; 62
    2148:	12 96       	adiw	r26, 0x02	; 2
    214a:	9c 93       	st	X, r25
    214c:	8e 93       	st	-X, r24
    214e:	11 97       	sbiw	r26, 0x01	; 1
    2150:	d8 01       	movw	r26, r16
    2152:	16 96       	adiw	r26, 0x06	; 6
    2154:	8c 91       	ld	r24, X
    2156:	82 83       	std	Z+2, r24	; 0x02
    2158:	13 82       	std	Z+3, r1	; 0x03
    215a:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
	putchar('\n');
    215e:	0f 90       	pop	r0
    2160:	0f 90       	pop	r0
    2162:	0f 90       	pop	r0
    2164:	0f 90       	pop	r0
    2166:	60 91 dd 2d 	lds	r22, 0x2DDD
    216a:	70 91 de 2d 	lds	r23, 0x2DDE
    216e:	8a e0       	ldi	r24, 0x0A	; 10
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
}
    2176:	0f 90       	pop	r0
    2178:	cf 91       	pop	r28
    217a:	df 91       	pop	r29
    217c:	1f 91       	pop	r17
    217e:	0f 91       	pop	r16
    2180:	ff 90       	pop	r15
    2182:	ef 90       	pop	r14
    2184:	08 95       	ret

00002186 <print_addr_hex>:
void print_addr_hex(uint8_t* addr)
{
    2186:	cf 93       	push	r28
    2188:	df 93       	push	r29
    218a:	dc 01       	movw	r26, r24
	printf("%x:%x:%x:%x:%x:%x\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
    218c:	8d b7       	in	r24, 0x3d	; 61
    218e:	9e b7       	in	r25, 0x3e	; 62
    2190:	0e 97       	sbiw	r24, 0x0e	; 14
    2192:	0f b6       	in	r0, 0x3f	; 63
    2194:	f8 94       	cli
    2196:	9e bf       	out	0x3e, r25	; 62
    2198:	0f be       	out	0x3f, r0	; 63
    219a:	8d bf       	out	0x3d, r24	; 61
    219c:	ed b7       	in	r30, 0x3d	; 61
    219e:	fe b7       	in	r31, 0x3e	; 62
    21a0:	31 96       	adiw	r30, 0x01	; 1
    21a2:	8c ed       	ldi	r24, 0xDC	; 220
    21a4:	9b e0       	ldi	r25, 0x0B	; 11
    21a6:	cd b7       	in	r28, 0x3d	; 61
    21a8:	de b7       	in	r29, 0x3e	; 62
    21aa:	9a 83       	std	Y+2, r25	; 0x02
    21ac:	89 83       	std	Y+1, r24	; 0x01
    21ae:	8c 91       	ld	r24, X
    21b0:	82 83       	std	Z+2, r24	; 0x02
    21b2:	13 82       	std	Z+3, r1	; 0x03
    21b4:	11 96       	adiw	r26, 0x01	; 1
    21b6:	8c 91       	ld	r24, X
    21b8:	11 97       	sbiw	r26, 0x01	; 1
    21ba:	84 83       	std	Z+4, r24	; 0x04
    21bc:	15 82       	std	Z+5, r1	; 0x05
    21be:	12 96       	adiw	r26, 0x02	; 2
    21c0:	8c 91       	ld	r24, X
    21c2:	12 97       	sbiw	r26, 0x02	; 2
    21c4:	86 83       	std	Z+6, r24	; 0x06
    21c6:	17 82       	std	Z+7, r1	; 0x07
    21c8:	13 96       	adiw	r26, 0x03	; 3
    21ca:	8c 91       	ld	r24, X
    21cc:	13 97       	sbiw	r26, 0x03	; 3
    21ce:	80 87       	std	Z+8, r24	; 0x08
    21d0:	11 86       	std	Z+9, r1	; 0x09
    21d2:	14 96       	adiw	r26, 0x04	; 4
    21d4:	8c 91       	ld	r24, X
    21d6:	14 97       	sbiw	r26, 0x04	; 4
    21d8:	82 87       	std	Z+10, r24	; 0x0a
    21da:	13 86       	std	Z+11, r1	; 0x0b
    21dc:	15 96       	adiw	r26, 0x05	; 5
    21de:	8c 91       	ld	r24, X
    21e0:	84 87       	std	Z+12, r24	; 0x0c
    21e2:	15 86       	std	Z+13, r1	; 0x0d
    21e4:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    21e8:	8d b7       	in	r24, 0x3d	; 61
    21ea:	9e b7       	in	r25, 0x3e	; 62
    21ec:	0e 96       	adiw	r24, 0x0e	; 14
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	9e bf       	out	0x3e, r25	; 62
    21f4:	0f be       	out	0x3f, r0	; 63
    21f6:	8d bf       	out	0x3d, r24	; 61
}
    21f8:	df 91       	pop	r29
    21fa:	cf 91       	pop	r28
    21fc:	08 95       	ret

000021fe <print_addr_dec>:
void print_addr_dec(uint8_t* addr)
{
    21fe:	cf 93       	push	r28
    2200:	df 93       	push	r29
    2202:	dc 01       	movw	r26, r24
	printf("%d.%d.%d.%d.%d.%d\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
    2204:	8d b7       	in	r24, 0x3d	; 61
    2206:	9e b7       	in	r25, 0x3e	; 62
    2208:	0e 97       	sbiw	r24, 0x0e	; 14
    220a:	0f b6       	in	r0, 0x3f	; 63
    220c:	f8 94       	cli
    220e:	9e bf       	out	0x3e, r25	; 62
    2210:	0f be       	out	0x3f, r0	; 63
    2212:	8d bf       	out	0x3d, r24	; 61
    2214:	ed b7       	in	r30, 0x3d	; 61
    2216:	fe b7       	in	r31, 0x3e	; 62
    2218:	31 96       	adiw	r30, 0x01	; 1
    221a:	8f ee       	ldi	r24, 0xEF	; 239
    221c:	9b e0       	ldi	r25, 0x0B	; 11
    221e:	cd b7       	in	r28, 0x3d	; 61
    2220:	de b7       	in	r29, 0x3e	; 62
    2222:	9a 83       	std	Y+2, r25	; 0x02
    2224:	89 83       	std	Y+1, r24	; 0x01
    2226:	8c 91       	ld	r24, X
    2228:	82 83       	std	Z+2, r24	; 0x02
    222a:	13 82       	std	Z+3, r1	; 0x03
    222c:	11 96       	adiw	r26, 0x01	; 1
    222e:	8c 91       	ld	r24, X
    2230:	11 97       	sbiw	r26, 0x01	; 1
    2232:	84 83       	std	Z+4, r24	; 0x04
    2234:	15 82       	std	Z+5, r1	; 0x05
    2236:	12 96       	adiw	r26, 0x02	; 2
    2238:	8c 91       	ld	r24, X
    223a:	12 97       	sbiw	r26, 0x02	; 2
    223c:	86 83       	std	Z+6, r24	; 0x06
    223e:	17 82       	std	Z+7, r1	; 0x07
    2240:	13 96       	adiw	r26, 0x03	; 3
    2242:	8c 91       	ld	r24, X
    2244:	13 97       	sbiw	r26, 0x03	; 3
    2246:	80 87       	std	Z+8, r24	; 0x08
    2248:	11 86       	std	Z+9, r1	; 0x09
    224a:	14 96       	adiw	r26, 0x04	; 4
    224c:	8c 91       	ld	r24, X
    224e:	14 97       	sbiw	r26, 0x04	; 4
    2250:	82 87       	std	Z+10, r24	; 0x0a
    2252:	13 86       	std	Z+11, r1	; 0x0b
    2254:	15 96       	adiw	r26, 0x05	; 5
    2256:	8c 91       	ld	r24, X
    2258:	84 87       	std	Z+12, r24	; 0x0c
    225a:	15 86       	std	Z+13, r1	; 0x0d
    225c:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    2260:	8d b7       	in	r24, 0x3d	; 61
    2262:	9e b7       	in	r25, 0x3e	; 62
    2264:	0e 96       	adiw	r24, 0x0e	; 14
    2266:	0f b6       	in	r0, 0x3f	; 63
    2268:	f8 94       	cli
    226a:	9e bf       	out	0x3e, r25	; 62
    226c:	0f be       	out	0x3f, r0	; 63
    226e:	8d bf       	out	0x3d, r24	; 61
}
    2270:	df 91       	pop	r29
    2272:	cf 91       	pop	r28
    2274:	08 95       	ret

00002276 <printAsciiHex>:

#include <stdio.h>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
{
    2276:	2f 92       	push	r2
    2278:	3f 92       	push	r3
    227a:	4f 92       	push	r4
    227c:	5f 92       	push	r5
    227e:	6f 92       	push	r6
    2280:	7f 92       	push	r7
    2282:	8f 92       	push	r8
    2284:	9f 92       	push	r9
    2286:	af 92       	push	r10
    2288:	bf 92       	push	r11
    228a:	cf 92       	push	r12
    228c:	df 92       	push	r13
    228e:	ef 92       	push	r14
    2290:	ff 92       	push	r15
    2292:	0f 93       	push	r16
    2294:	1f 93       	push	r17
    2296:	cf 93       	push	r28
    2298:	df 93       	push	r29
    229a:	38 2f       	mov	r19, r24
    229c:	29 2f       	mov	r18, r25
    229e:	6b 01       	movw	r12, r22
			putchar('\n');
		}
		else if(i==nread)
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
    22a0:	cb 01       	movw	r24, r22
    22a2:	60 e1       	ldi	r22, 0x10	; 16
    22a4:	70 e0       	ldi	r23, 0x00	; 0
    22a6:	0e 94 76 4b 	call	0x96ec	; 0x96ec <__divmodhi4>
    22aa:	5c 01       	movw	r10, r24
    22ac:	aa 0c       	add	r10, r10
    22ae:	bb 1c       	adc	r11, r11
    22b0:	a8 0e       	add	r10, r24
    22b2:	b9 1e       	adc	r11, r25
    22b4:	b0 94       	com	r11
    22b6:	a1 94       	neg	r10
    22b8:	b1 08       	sbc	r11, r1
    22ba:	b3 94       	inc	r11
    22bc:	8f e2       	ldi	r24, 0x2F	; 47
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	a8 0e       	add	r10, r24
    22c2:	b9 1e       	adc	r11, r25
				putchar(' ');
			putchar('\t');
			for(j=(nread/COLUMN_SIZE)*COLUMN_SIZE; j<nread; j++)
    22c4:	3b 01       	movw	r6, r22
    22c6:	44 e0       	ldi	r20, 0x04	; 4
    22c8:	66 0c       	add	r6, r6
    22ca:	77 1c       	adc	r7, r7
    22cc:	4a 95       	dec	r20
    22ce:	e1 f7       	brne	.-8      	; 0x22c8 <printAsciiHex+0x52>
    22d0:	e3 2e       	mov	r14, r19
    22d2:	f2 2e       	mov	r15, r18
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
{
	int i,j;
	for(i = 1; i <= nread; i++)
    22d4:	c1 e0       	ldi	r28, 0x01	; 1
    22d6:	d0 e0       	ldi	r29, 0x00	; 0
	{
		printf("%02x", buffer[i - 1] & (0xFF));
    22d8:	92 e0       	ldi	r25, 0x02	; 2
    22da:	49 2e       	mov	r4, r25
    22dc:	9c e0       	ldi	r25, 0x0C	; 12
    22de:	59 2e       	mov	r5, r25

#include <stdio.h>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
    22e0:	17 01       	movw	r2, r14
    22e2:	26 0c       	add	r2, r6
    22e4:	37 1c       	adc	r3, r7
{
	int i,j;
	for(i = 1; i <= nread; i++)
    22e6:	82 c0       	rjmp	.+260    	; 0x23ec <printAsciiHex+0x176>
	{
		printf("%02x", buffer[i - 1] & (0xFF));
    22e8:	f7 01       	movw	r30, r14
    22ea:	81 91       	ld	r24, Z+
    22ec:	7f 01       	movw	r14, r30
    22ee:	00 d0       	rcall	.+0      	; 0x22f0 <printAsciiHex+0x7a>
    22f0:	00 d0       	rcall	.+0      	; 0x22f2 <printAsciiHex+0x7c>
    22f2:	ed b7       	in	r30, 0x3d	; 61
    22f4:	fe b7       	in	r31, 0x3e	; 62
    22f6:	52 82       	std	Z+2, r5	; 0x02
    22f8:	41 82       	std	Z+1, r4	; 0x01
    22fa:	83 83       	std	Z+3, r24	; 0x03
    22fc:	14 82       	std	Z+4, r1	; 0x04
    22fe:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		if(i%2==0 && i!=0)
    2302:	0f 90       	pop	r0
    2304:	0f 90       	pop	r0
    2306:	0f 90       	pop	r0
    2308:	0f 90       	pop	r0
    230a:	c0 fd       	sbrc	r28, 0
    230c:	04 c0       	rjmp	.+8      	; 0x2316 <printAsciiHex+0xa0>
			printf(" ");
    230e:	80 e2       	ldi	r24, 0x20	; 32
    2310:	90 e0       	ldi	r25, 0x00	; 0
    2312:	0e 94 12 4d 	call	0x9a24	; 0x9a24 <putchar>
		if(i%COLUMN_SIZE == 0)
    2316:	ce 01       	movw	r24, r28
    2318:	8f 70       	andi	r24, 0x0F	; 15
    231a:	90 70       	andi	r25, 0x00	; 0
    231c:	00 97       	sbiw	r24, 0x00	; 0
    231e:	41 f5       	brne	.+80     	; 0x2370 <printAsciiHex+0xfa>
		{
			putchar('\t');
    2320:	60 91 dd 2d 	lds	r22, 0x2DDD
    2324:	70 91 de 2d 	lds	r23, 0x2DDE
    2328:	89 e0       	ldi	r24, 0x09	; 9
    232a:	90 e0       	ldi	r25, 0x00	; 0
    232c:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    2330:	80 ef       	ldi	r24, 0xF0	; 240
    2332:	88 2e       	mov	r8, r24
    2334:	8f ef       	ldi	r24, 0xFF	; 255
    2336:	98 2e       	mov	r9, r24
    2338:	8e 0c       	add	r8, r14
    233a:	9f 1c       	adc	r9, r15
			for(j=i-COLUMN_SIZE; j<i; j++)
    233c:	01 e1       	ldi	r16, 0x11	; 17
    233e:	10 e0       	ldi	r17, 0x00	; 0
    2340:	13 c0       	rjmp	.+38     	; 0x2368 <printAsciiHex+0xf2>
			{
				if(buffer[j] >= 32 && buffer[j] <= 126)
    2342:	f4 01       	movw	r30, r8
    2344:	81 91       	ld	r24, Z+
    2346:	4f 01       	movw	r8, r30
    2348:	98 2f       	mov	r25, r24
    234a:	90 52       	subi	r25, 0x20	; 32
    234c:	60 91 dd 2d 	lds	r22, 0x2DDD
    2350:	70 91 de 2d 	lds	r23, 0x2DDE
    2354:	9f 35       	cpi	r25, 0x5F	; 95
    2356:	20 f4       	brcc	.+8      	; 0x2360 <printAsciiHex+0xea>
					putchar(buffer[j]);
    2358:	99 27       	eor	r25, r25
    235a:	87 fd       	sbrc	r24, 7
    235c:	90 95       	com	r25
    235e:	02 c0       	rjmp	.+4      	; 0x2364 <printAsciiHex+0xee>
				else
					putchar('.');
    2360:	8e e2       	ldi	r24, 0x2E	; 46
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    2368:	01 50       	subi	r16, 0x01	; 1
    236a:	10 40       	sbci	r17, 0x00	; 0
		if(i%2==0 && i!=0)
			printf(" ");
		if(i%COLUMN_SIZE == 0)
		{
			putchar('\t');
			for(j=i-COLUMN_SIZE; j<i; j++)
    236c:	51 f7       	brne	.-44     	; 0x2342 <printAsciiHex+0xcc>
    236e:	35 c0       	rjmp	.+106    	; 0x23da <printAsciiHex+0x164>
				else
					putchar('.');
			}
			putchar('\n');
		}
		else if(i==nread)
    2370:	cc 15       	cp	r28, r12
    2372:	dd 05       	cpc	r29, r13
    2374:	d1 f5       	brne	.+116    	; 0x23ea <printAsciiHex+0x174>
    2376:	00 e0       	ldi	r16, 0x00	; 0
    2378:	10 e0       	ldi	r17, 0x00	; 0
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
				putchar(' ');
    237a:	60 91 dd 2d 	lds	r22, 0x2DDD
    237e:	70 91 de 2d 	lds	r23, 0x2DDE
    2382:	80 e2       	ldi	r24, 0x20	; 32
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
			putchar('\n');
		}
		else if(i==nread)
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
    238a:	0f 5f       	subi	r16, 0xFF	; 255
    238c:	1f 4f       	sbci	r17, 0xFF	; 255
    238e:	a0 16       	cp	r10, r16
    2390:	b1 06       	cpc	r11, r17
    2392:	9c f7       	brge	.-26     	; 0x237a <printAsciiHex+0x104>
				putchar(' ');
			putchar('\t');
    2394:	60 91 dd 2d 	lds	r22, 0x2DDD
    2398:	70 91 de 2d 	lds	r23, 0x2DDE
    239c:	89 e0       	ldi	r24, 0x09	; 9
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>

#include <stdio.h>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
    23a4:	41 01       	movw	r8, r2
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
				putchar(' ');
			putchar('\t');
			for(j=(nread/COLUMN_SIZE)*COLUMN_SIZE; j<nread; j++)
    23a6:	83 01       	movw	r16, r6
    23a8:	15 c0       	rjmp	.+42     	; 0x23d4 <printAsciiHex+0x15e>
			{
				if(buffer[j] >= 32 && buffer[j] <= 126)
    23aa:	f4 01       	movw	r30, r8
    23ac:	81 91       	ld	r24, Z+
    23ae:	4f 01       	movw	r8, r30
    23b0:	98 2f       	mov	r25, r24
    23b2:	90 52       	subi	r25, 0x20	; 32
    23b4:	60 91 dd 2d 	lds	r22, 0x2DDD
    23b8:	70 91 de 2d 	lds	r23, 0x2DDE
    23bc:	9f 35       	cpi	r25, 0x5F	; 95
    23be:	20 f4       	brcc	.+8      	; 0x23c8 <printAsciiHex+0x152>
					putchar(buffer[j]);
    23c0:	99 27       	eor	r25, r25
    23c2:	87 fd       	sbrc	r24, 7
    23c4:	90 95       	com	r25
    23c6:	02 c0       	rjmp	.+4      	; 0x23cc <printAsciiHex+0x156>
				else
					putchar('.');
    23c8:	8e e2       	ldi	r24, 0x2E	; 46
    23ca:	90 e0       	ldi	r25, 0x00	; 0
    23cc:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
				putchar(' ');
			putchar('\t');
			for(j=(nread/COLUMN_SIZE)*COLUMN_SIZE; j<nread; j++)
    23d0:	0f 5f       	subi	r16, 0xFF	; 255
    23d2:	1f 4f       	sbci	r17, 0xFF	; 255
    23d4:	0c 15       	cp	r16, r12
    23d6:	1d 05       	cpc	r17, r13
    23d8:	44 f3       	brlt	.-48     	; 0x23aa <printAsciiHex+0x134>
				if(buffer[j] >= 32 && buffer[j] <= 126)
					putchar(buffer[j]);
				else
					putchar('.');
			}
			putchar('\n');
    23da:	60 91 dd 2d 	lds	r22, 0x2DDD
    23de:	70 91 de 2d 	lds	r23, 0x2DDE
    23e2:	8a e0       	ldi	r24, 0x0A	; 10
    23e4:	90 e0       	ldi	r25, 0x00	; 0
    23e6:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
{
	int i,j;
	for(i = 1; i <= nread; i++)
    23ea:	21 96       	adiw	r28, 0x01	; 1
    23ec:	cc 16       	cp	r12, r28
    23ee:	dd 06       	cpc	r13, r29
    23f0:	0c f0       	brlt	.+2      	; 0x23f4 <printAsciiHex+0x17e>
    23f2:	7a cf       	rjmp	.-268    	; 0x22e8 <printAsciiHex+0x72>
					putchar('.');
			}
			putchar('\n');
		}
	}
	putchar('\n');
    23f4:	60 91 dd 2d 	lds	r22, 0x2DDD
    23f8:	70 91 de 2d 	lds	r23, 0x2DDE
    23fc:	8a e0       	ldi	r24, 0x0A	; 10
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
}
    2404:	df 91       	pop	r29
    2406:	cf 91       	pop	r28
    2408:	1f 91       	pop	r17
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	ef 90       	pop	r14
    2410:	df 90       	pop	r13
    2412:	cf 90       	pop	r12
    2414:	bf 90       	pop	r11
    2416:	af 90       	pop	r10
    2418:	9f 90       	pop	r9
    241a:	8f 90       	pop	r8
    241c:	7f 90       	pop	r7
    241e:	6f 90       	pop	r6
    2420:	5f 90       	pop	r5
    2422:	4f 90       	pop	r4
    2424:	3f 90       	pop	r3
    2426:	2f 90       	pop	r2
    2428:	08 95       	ret

0000242a <uart0_rx>:
	timer_flag = 1;
	process_post(&radiotftp_process, PROCESS_EVENT_TIMER, NULL);
}

int uart0_rx(unsigned char receivedByte)
{
    242a:	68 2f       	mov	r22, r24
	//stdin
	rs232_send(RS232_PORT_0, receivedByte);
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>
	return 0;
}
    2432:	80 e0       	ldi	r24, 0x00	; 0
    2434:	90 e0       	ldi	r25, 0x00	; 0
    2436:	08 95       	ret

00002438 <queueSerialData>:
{
	return numBytesToSend;
}

uint8_t queueSerialData(uint8_t* src, uint16_t src_port, uint8_t* dst, uint16_t dst_port, uint8_t* dataptr, uint16_t datalen)
{
    2438:	cf 92       	push	r12
    243a:	df 92       	push	r13
    243c:	ef 92       	push	r14
    243e:	ff 92       	push	r15
    2440:	0f 93       	push	r16
    2442:	1f 93       	push	r17
    2444:	cf 93       	push	r28
    2446:	df 93       	push	r29
    2448:	f8 01       	movw	r30, r16
    244a:	67 01       	movw	r12, r14
	uint16_t idx = 0, len = 0;

	wdt_reset();
    244c:	a8 95       	wdr
	if(queue_flag)
    244e:	a0 91 e3 12 	lds	r26, 0x12E3
    2452:	aa 23       	and	r26, r26
    2454:	09 f0       	breq	.+2      	; 0x2458 <queueSerialData+0x20>
    2456:	78 c0       	rjmp	.+240    	; 0x2548 <queueSerialData+0x110>
	{
		return -1;
	}

	memcpy(transmit_buffer, preamble, PREAMBLE_LENGTH);
    2458:	c6 ef       	ldi	r28, 0xF6	; 246
    245a:	d9 e1       	ldi	r29, 0x19	; 25
    245c:	a3 e8       	ldi	r26, 0x83	; 131
    245e:	bd e0       	ldi	r27, 0x0D	; 13
    2460:	0a e0       	ldi	r16, 0x0A	; 10
    2462:	0d 90       	ld	r0, X+
    2464:	09 92       	st	Y+, r0
    2466:	01 50       	subi	r16, 0x01	; 1
    2468:	e1 f7       	brne	.-8      	; 0x2462 <queueSerialData+0x2a>
	idx += PREAMBLE_LENGTH;

	memcpy(transmit_buffer+idx, syncword, SYNC_LENGTH);
    246a:	e0 90 8d 0d 	lds	r14, 0x0D8D
    246e:	f0 90 8e 0d 	lds	r15, 0x0D8E
    2472:	00 91 8f 0d 	lds	r16, 0x0D8F
    2476:	10 91 90 0d 	lds	r17, 0x0D90
    247a:	e0 92 00 1a 	sts	0x1A00, r14
    247e:	f0 92 01 1a 	sts	0x1A01, r15
    2482:	00 93 02 1a 	sts	0x1A02, r16
    2486:	10 93 03 1a 	sts	0x1A03, r17
	idx += SYNC_LENGTH;

	//PRINTF_D("udp payload: %s\n", dataptr);
	len = udp_create_packet(src, src_port, dst, dst_port, dataptr, datalen, udp_buffer);
    248a:	8f 01       	movw	r16, r30
    248c:	76 01       	movw	r14, r12
    248e:	e2 ee       	ldi	r30, 0xE2	; 226
    2490:	ce 2e       	mov	r12, r30
    2492:	e8 e1       	ldi	r30, 0x18	; 24
    2494:	de 2e       	mov	r13, r30
    2496:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_create_packet>
    249a:	ec 01       	movw	r28, r24
	if(len==0)
    249c:	00 97       	sbiw	r24, 0x00	; 0
    249e:	31 f4       	brne	.+12     	; 0x24ac <queueSerialData+0x74>
	{
		PRINTF_D("couldn't prepare udp packet\n");
    24a0:	87 e0       	ldi	r24, 0x07	; 7
    24a2:	9c e0       	ldi	r25, 0x0C	; 12
    24a4:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
		return -2;
    24a8:	8e ef       	ldi	r24, 0xFE	; 254
    24aa:	51 c0       	rjmp	.+162    	; 0x254e <queueSerialData+0x116>
		return -3;
	}
	len = manchester_encode(ethernet_buffer, manchester_buffer, len);
#elif AX25_ENABLED==1
	//PRINTF_D("ax25 payload: %s\n", udp_buffer);
	len = ax25_create_ui_packet(ax25_get_local_callsign(NULL), ax25_get_broadcast_callsign(NULL), udp_buffer, len, ax25_buffer);
    24ac:	80 e0       	ldi	r24, 0x00	; 0
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	0e 94 84 03 	call	0x708	; 0x708 <ax25_get_local_callsign>
    24b4:	8c 01       	movw	r16, r24
    24b6:	80 e0       	ldi	r24, 0x00	; 0
    24b8:	90 e0       	ldi	r25, 0x00	; 0
    24ba:	0e 94 92 03 	call	0x724	; 0x724 <ax25_get_broadcast_callsign>
    24be:	bc 01       	movw	r22, r24
    24c0:	c8 01       	movw	r24, r16
    24c2:	42 ee       	ldi	r20, 0xE2	; 226
    24c4:	58 e1       	ldi	r21, 0x18	; 24
    24c6:	9e 01       	movw	r18, r28
    24c8:	0a ea       	ldi	r16, 0xAA	; 170
    24ca:	17 e1       	ldi	r17, 0x17	; 23
    24cc:	0e 94 a0 03 	call	0x740	; 0x740 <ax25_create_ui_packet>
    24d0:	9b 01       	movw	r18, r22
    24d2:	ac 01       	movw	r20, r24
	if(len==0)
    24d4:	61 15       	cp	r22, r1
    24d6:	71 05       	cpc	r23, r1
    24d8:	31 f4       	brne	.+12     	; 0x24e6 <queueSerialData+0xae>
	{
		PRINTF_D("couldn't prepare ax25 packet\n");
    24da:	83 e2       	ldi	r24, 0x23	; 35
    24dc:	9c e0       	ldi	r25, 0x0C	; 12
    24de:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
		return -3;
    24e2:	8d ef       	ldi	r24, 0xFD	; 253
    24e4:	34 c0       	rjmp	.+104    	; 0x254e <queueSerialData+0x116>
	}
	len = manchester_encode(ax25_buffer, manchester_buffer, len);
    24e6:	02 e5       	ldi	r16, 0x52	; 82
    24e8:	15 e1       	ldi	r17, 0x15	; 21
    24ea:	8a ea       	ldi	r24, 0xAA	; 170
    24ec:	97 e1       	ldi	r25, 0x17	; 23
    24ee:	b8 01       	movw	r22, r16
    24f0:	a9 01       	movw	r20, r18
    24f2:	0e 94 02 06 	call	0xc04	; 0xc04 <manchester_encode>
    24f6:	ec 01       	movw	r28, r24
#else
	len = manchester_encode(udp_buffer, manchester_buffer, len);
#endif

	memcpy(&transmit_buffer[idx], manchester_buffer, len);
    24f8:	24 e0       	ldi	r18, 0x04	; 4
    24fa:	3a e1       	ldi	r19, 0x1A	; 26
    24fc:	c9 01       	movw	r24, r18
    24fe:	b8 01       	movw	r22, r16
    2500:	ae 01       	movw	r20, r28
    2502:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
	idx += len;

	transmit_buffer[idx++] = END_OF_FILE;
    2506:	fe 01       	movw	r30, r28
    2508:	ec 5f       	subi	r30, 0xFC	; 252
    250a:	f5 4e       	sbci	r31, 0xE5	; 229
    250c:	8c e1       	ldi	r24, 0x1C	; 28
    250e:	80 83       	st	Z, r24
	transmit_buffer[idx++] = 0;
    2510:	fe 01       	movw	r30, r28
    2512:	eb 5f       	subi	r30, 0xFB	; 251
    2514:	f5 4e       	sbci	r31, 0xE5	; 229
    2516:	10 82       	st	Z, r1

	queue_flag = 1;
    2518:	81 e0       	ldi	r24, 0x01	; 1
    251a:	80 93 e3 12 	sts	0x12E3, r24

	memcpy(&transmit_buffer[idx], manchester_buffer, len);
	idx += len;

	transmit_buffer[idx++] = END_OF_FILE;
	transmit_buffer[idx++] = 0;
    251e:	60 96       	adiw	r28, 0x10	; 16

	queue_flag = 1;
	transmit_length = idx;
    2520:	d0 93 5f 1c 	sts	0x1C5F, r29
    2524:	c0 93 5e 1c 	sts	0x1C5E, r28

	//print_time("data queued");
	wdt_reset();
    2528:	a8 95       	wdr

	if(process_post(&radiotftp_process, PROCESS_EVENT_COM, (void*) io)==PROCESS_ERR_FULL)
    252a:	8a ea       	ldi	r24, 0xAA	; 170
    252c:	9d e0       	ldi	r25, 0x0D	; 13
    252e:	69 e8       	ldi	r22, 0x89	; 137
    2530:	4a ee       	ldi	r20, 0xEA	; 234
    2532:	52 e1       	ldi	r21, 0x12	; 18
    2534:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <process_post>
    2538:	81 30       	cpi	r24, 0x01	; 1
    253a:	91 05       	cpc	r25, r1
    253c:	39 f4       	brne	.+14     	; 0x254c <queueSerialData+0x114>
	{
		printf("incoming transmission discarded\n");
    253e:	80 e4       	ldi	r24, 0x40	; 64
    2540:	9c e0       	ldi	r25, 0x0C	; 12
    2542:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
    2546:	02 c0       	rjmp	.+4      	; 0x254c <queueSerialData+0x114>
	uint16_t idx = 0, len = 0;

	wdt_reset();
	if(queue_flag)
	{
		return -1;
    2548:	8f ef       	ldi	r24, 0xFF	; 255
    254a:	01 c0       	rjmp	.+2      	; 0x254e <queueSerialData+0x116>
	if(process_post(&radiotftp_process, PROCESS_EVENT_COM, (void*) io)==PROCESS_ERR_FULL)
	{
		printf("incoming transmission discarded\n");
	}
	
	return 0;
    254c:	80 e0       	ldi	r24, 0x00	; 0
}
    254e:	df 91       	pop	r29
    2550:	cf 91       	pop	r28
    2552:	1f 91       	pop	r17
    2554:	0f 91       	pop	r16
    2556:	ff 90       	pop	r15
    2558:	ef 90       	pop	r14
    255a:	df 90       	pop	r13
    255c:	cf 90       	pop	r12
    255e:	08 95       	ret

00002560 <radiotftpAlarm_callback>:
PROCESS(radiotftp_process, "Radiotftp Process");

void radiotftpAlarm_callback(void* data)
{
	//PRINTF_D("main timer handler\n");
	timer_flag = 1;
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	80 93 e2 12 	sts	0x12E2, r24
	process_post(&radiotftp_process, PROCESS_EVENT_TIMER, NULL);
    2566:	8a ea       	ldi	r24, 0xAA	; 170
    2568:	9d e0       	ldi	r25, 0x0D	; 13
    256a:	68 e8       	ldi	r22, 0x88	; 136
    256c:	40 e0       	ldi	r20, 0x00	; 0
    256e:	50 e0       	ldi	r21, 0x00	; 0
    2570:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <process_post>
}
    2574:	08 95       	ret

00002576 <uart1_rx>:
	//stdin
	rs232_send(RS232_PORT_0, receivedByte);
	return 0;
}
int uart1_rx(unsigned char receivedByte)
{
    2576:	1f 93       	push	r17
    2578:	18 2f       	mov	r17, r24
	//radiometrix
//	putchar(receivedByte);
	if(sync_passed)
    257a:	80 91 e6 12 	lds	r24, 0x12E6
    257e:	88 23       	and	r24, r24
    2580:	f1 f1       	breq	.+124    	; 0x25fe <uart1_rx+0x88>
	{
		if(receivedByte==END_OF_FILE || !isManchester_encoded(receivedByte) )
    2582:	1c 31       	cpi	r17, 0x1C	; 28
    2584:	29 f0       	breq	.+10     	; 0x2590 <uart1_rx+0x1a>
    2586:	81 2f       	mov	r24, r17
    2588:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <isManchester_encoded>
    258c:	88 23       	and	r24, r24
    258e:	21 f5       	brne	.+72     	; 0x25d8 <uart1_rx+0x62>
		{
			putchar('\n');
    2590:	60 91 dd 2d 	lds	r22, 0x2DDD
    2594:	70 91 de 2d 	lds	r23, 0x2DDE
    2598:	8a e0       	ldi	r24, 0x0A	; 10
    259a:	90 e0       	ldi	r25, 0x00	; 0
    259c:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
			sync_passed = 0;
    25a0:	10 92 e6 12 	sts	0x12E6, r1
			saved_io_index = io_index;
    25a4:	80 91 60 1c 	lds	r24, 0x1C60
    25a8:	90 91 61 1c 	lds	r25, 0x1C61
    25ac:	90 93 e9 12 	sts	0x12E9, r25
    25b0:	80 93 e8 12 	sts	0x12E8, r24
			io_flag=1;
    25b4:	81 e0       	ldi	r24, 0x01	; 1
    25b6:	80 93 e0 12 	sts	0x12E0, r24
			if(process_post(&radiotftp_process, PROCESS_EVENT_COM, (void*) io)==PROCESS_ERR_FULL)
    25ba:	8a ea       	ldi	r24, 0xAA	; 170
    25bc:	9d e0       	ldi	r25, 0x0D	; 13
    25be:	69 e8       	ldi	r22, 0x89	; 137
    25c0:	4a ee       	ldi	r20, 0xEA	; 234
    25c2:	52 e1       	ldi	r21, 0x12	; 18
    25c4:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <process_post>
    25c8:	81 30       	cpi	r24, 0x01	; 1
    25ca:	91 05       	cpc	r25, r1
    25cc:	79 f5       	brne	.+94     	; 0x262c <uart1_rx+0xb6>
			{
				printf("incoming transmission discarded\n");
    25ce:	80 e4       	ldi	r24, 0x40	; 64
    25d0:	9c e0       	ldi	r25, 0x0C	; 12
    25d2:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
    25d6:	2a c0       	rjmp	.+84     	; 0x262c <uart1_rx+0xb6>
			}
		}
		else
		{
			io[io_index] = receivedByte;
    25d8:	20 91 60 1c 	lds	r18, 0x1C60
    25dc:	30 91 61 1c 	lds	r19, 0x1C61
    25e0:	f9 01       	movw	r30, r18
    25e2:	e6 51       	subi	r30, 0x16	; 22
    25e4:	fd 4e       	sbci	r31, 0xED	; 237
    25e6:	10 83       	st	Z, r17
			io_index = ((io_index+1)%sizeof(io));
    25e8:	c9 01       	movw	r24, r18
    25ea:	01 96       	adiw	r24, 0x01	; 1
    25ec:	68 e6       	ldi	r22, 0x68	; 104
    25ee:	72 e0       	ldi	r23, 0x02	; 2
    25f0:	0e 94 62 4b 	call	0x96c4	; 0x96c4 <__udivmodhi4>
    25f4:	90 93 61 1c 	sts	0x1C61, r25
    25f8:	80 93 60 1c 	sts	0x1C60, r24
    25fc:	17 c0       	rjmp	.+46     	; 0x262c <uart1_rx+0xb6>
		}
	}
	else
	{
		if(receivedByte==syncword[sync_counter])
    25fe:	80 91 e7 12 	lds	r24, 0x12E7
    2602:	e8 2f       	mov	r30, r24
    2604:	f0 e0       	ldi	r31, 0x00	; 0
    2606:	e3 57       	subi	r30, 0x73	; 115
    2608:	f2 4f       	sbci	r31, 0xF2	; 242
    260a:	90 81       	ld	r25, Z
    260c:	19 17       	cp	r17, r25
    260e:	61 f4       	brne	.+24     	; 0x2628 <uart1_rx+0xb2>
		{
			//one more step closer to
			sync_counter++;
    2610:	8f 5f       	subi	r24, 0xFF	; 255
    2612:	80 93 e7 12 	sts	0x12E7, r24
			//PRINTF_D("sync counting=%d\n", sync_counter);
			if(sync_counter==SYNC_LENGTH)
    2616:	84 30       	cpi	r24, 0x04	; 4
    2618:	49 f4       	brne	.+18     	; 0x262c <uart1_rx+0xb6>
			{
				io_index=0;
    261a:	10 92 61 1c 	sts	0x1C61, r1
    261e:	10 92 60 1c 	sts	0x1C60, r1
				sync_passed = 1;
    2622:	81 e0       	ldi	r24, 0x01	; 1
    2624:	80 93 e6 12 	sts	0x12E6, r24
			}
		}
		else
		{
			//reset the sync counter
			sync_counter = 0;
    2628:	10 92 e7 12 	sts	0x12E7, r1
		}
	}
	return 0;
}
    262c:	80 e0       	ldi	r24, 0x00	; 0
    262e:	90 e0       	ldi	r25, 0x00	; 0
    2630:	1f 91       	pop	r17
    2632:	08 95       	ret

00002634 <setRTS>:

uint8_t setRTS(uint8_t level)
{
	if(level)
    2634:	88 23       	and	r24, r24
    2636:	11 f0       	breq	.+4      	; 0x263c <setRTS+0x8>
		SET_BIT(PORTF, 0);
    2638:	88 9a       	sbi	0x11, 0	; 17
    263a:	01 c0       	rjmp	.+2      	; 0x263e <setRTS+0xa>
	else
		CLR_BIT(PORTF, 0);
    263c:	88 98       	cbi	0x11, 0	; 17
	return READ_BIT(PORTF, 0);
    263e:	81 b3       	in	r24, 0x11	; 17
}
    2640:	81 70       	andi	r24, 0x01	; 1
    2642:	08 95       	ret

00002644 <radiotftp_setNumBytesToSend>:

void radiotftp_setNumBytesToSend(uint16_t numBytes)
{
//	PRINTF_D("setting num of bytes to send %d\n", numBytes);
	ATOMIC_SET(numBytesToSend, numBytes);
    2644:	f8 94       	cli
    2646:	90 93 e5 12 	sts	0x12E5, r25
    264a:	80 93 e4 12 	sts	0x12E4, r24
    264e:	78 94       	sei
}
    2650:	08 95       	ret

00002652 <radiotftp_getNumBytesToSend>:

uint16_t radiotftp_getNumBytesToSend()
{
	return numBytesToSend;
    2652:	20 91 e4 12 	lds	r18, 0x12E4
    2656:	30 91 e5 12 	lds	r19, 0x12E5
}
    265a:	c9 01       	movw	r24, r18
    265c:	08 95       	ret

0000265e <transmitSerialData>:
	
	return 0;
}

uint16_t transmitSerialData(void)
{
    265e:	0f 93       	push	r16
    2660:	1f 93       	push	r17
    2662:	cf 93       	push	r28
    2664:	df 93       	push	r29
	uint16_t i = 0;

	wdt_reset();
    2666:	a8 95       	wdr
	setRTS(0);
    2668:	80 e0       	ldi	r24, 0x00	; 0
    266a:	0e 94 1a 13 	call	0x2634	; 0x2634 <setRTS>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    266e:	8f e3       	ldi	r24, 0x3F	; 63
    2670:	9c e9       	ldi	r25, 0x9C	; 156
    2672:	01 97       	sbiw	r24, 0x01	; 1
    2674:	f1 f7       	brne	.-4      	; 0x2672 <transmitSerialData+0x14>
    2676:	00 c0       	rjmp	.+0      	; 0x2678 <transmitSerialData+0x1a>
    2678:	00 00       	nop
	_delay_ms(2e1);

	ATOMIC_BEGIN();
    267a:	f8 94       	cli
    267c:	06 ef       	ldi	r16, 0xF6	; 246
    267e:	19 e1       	ldi	r17, 0x19	; 25
	for(i = 0; i<transmit_length; i++)
    2680:	c0 e0       	ldi	r28, 0x00	; 0
    2682:	d0 e0       	ldi	r29, 0x00	; 0
    2684:	07 c0       	rjmp	.+14     	; 0x2694 <transmitSerialData+0x36>
	{
		//NOTE: rs232_send has caused problems before
		//while (!READ_BIT(UCSR1A, UDRE1));
		//UDR1 = transmit_buffer[i];
		rs232_send(RS232_PORT_1, transmit_buffer[i]);
    2686:	f8 01       	movw	r30, r16
    2688:	61 91       	ld	r22, Z+
    268a:	8f 01       	movw	r16, r30
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>
	wdt_reset();
	setRTS(0);
	_delay_ms(2e1);

	ATOMIC_BEGIN();
	for(i = 0; i<transmit_length; i++)
    2692:	21 96       	adiw	r28, 0x01	; 1
    2694:	80 91 5e 1c 	lds	r24, 0x1C5E
    2698:	90 91 5f 1c 	lds	r25, 0x1C5F
    269c:	c8 17       	cp	r28, r24
    269e:	d9 07       	cpc	r29, r25
    26a0:	90 f3       	brcs	.-28     	; 0x2686 <transmitSerialData+0x28>
		//while (!READ_BIT(UCSR1A, UDRE1));
		//UDR1 = transmit_buffer[i];
		rs232_send(RS232_PORT_1, transmit_buffer[i]);
		//rs232_send(RS232_PORT_0, transmit_buffer[i]);
	}
	while (!READ_BIT(UCSR1A, UDRE1));
    26a2:	80 91 c8 00 	lds	r24, 0x00C8
    26a6:	85 ff       	sbrs	r24, 5
    26a8:	fc cf       	rjmp	.-8      	; 0x26a2 <transmitSerialData+0x44>
	ATOMIC_END();
    26aa:	78 94       	sei
    26ac:	8f e3       	ldi	r24, 0x3F	; 63
    26ae:	9c e9       	ldi	r25, 0x9C	; 156
    26b0:	01 97       	sbiw	r24, 0x01	; 1
    26b2:	f1 f7       	brne	.-4      	; 0x26b0 <transmitSerialData+0x52>
    26b4:	00 c0       	rjmp	.+0      	; 0x26b6 <transmitSerialData+0x58>
    26b6:	00 00       	nop

	_delay_ms(2e1);
	setRTS(1);
    26b8:	81 e0       	ldi	r24, 0x01	; 1
    26ba:	0e 94 1a 13 	call	0x2634	; 0x2634 <setRTS>
	wdt_reset();
    26be:	a8 95       	wdr


	//print_time("data sent");

	return 0;
}
    26c0:	80 e0       	ldi	r24, 0x00	; 0
    26c2:	90 e0       	ldi	r25, 0x00	; 0
    26c4:	df 91       	pop	r29
    26c6:	cf 91       	pop	r28
    26c8:	1f 91       	pop	r17
    26ca:	0f 91       	pop	r16
    26cc:	08 95       	ret

000026ce <udp_packet_demultiplexer>:

uint8_t udp_packet_demultiplexer(uint8_t* src, uint16_t src_port, uint8_t* dst, uint16_t dst_port, uint8_t* payload, uint16_t len)
{
    26ce:	8f 92       	push	r8
    26d0:	9f 92       	push	r9
    26d2:	af 92       	push	r10
    26d4:	bf 92       	push	r11
    26d6:	cf 92       	push	r12
    26d8:	df 92       	push	r13
    26da:	ef 92       	push	r14
    26dc:	ff 92       	push	r15
    26de:	0f 93       	push	r16
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	ec 01       	movw	r28, r24
    26e8:	4b 01       	movw	r8, r22
    26ea:	5a 01       	movw	r10, r20
    26ec:	69 01       	movw	r12, r18
//    PRINTF_D("== udp packet handler ==\n");
//    PRINTF_D("== SRC: %d.%d.%d.%d:%d ==\n", src[0], src[1], src[2], src[3], src_port);
//    PRINTF_D("== DST: %d.%d.%d.%d:%d ==\n", dst[0], dst[1], dst[2], dst[3], dst_port);

	uint8_t different = 0;
	wdt_reset();
    26ee:	a8 95       	wdr

	//check for address match
	different = memcmp(udp_get_localhost_ip(NULL), dst, IPV4_DESTINATION_LENGTH);
    26f0:	80 e0       	ldi	r24, 0x00	; 0
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    26f8:	b5 01       	movw	r22, r10
    26fa:	44 e0       	ldi	r20, 0x04	; 4
    26fc:	50 e0       	ldi	r21, 0x00	; 0
    26fe:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
	if(different)
    2702:	88 23       	and	r24, r24
    2704:	61 f0       	breq	.+24     	; 0x271e <udp_packet_demultiplexer+0x50>
	{
		different = memcmp(udp_get_broadcast_ip(NULL), dst, IPV4_DESTINATION_LENGTH);
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	90 e0       	ldi	r25, 0x00	; 0
    270a:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <udp_get_broadcast_ip>
    270e:	b5 01       	movw	r22, r10
    2710:	44 e0       	ldi	r20, 0x04	; 4
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	0e 94 40 4c 	call	0x9880	; 0x9880 <memcmp>
	}

	if(!different)
    2718:	88 23       	and	r24, r24
    271a:	09 f0       	breq	.+2      	; 0x271e <udp_packet_demultiplexer+0x50>
    271c:	52 c0       	rjmp	.+164    	; 0x27c2 <udp_packet_demultiplexer+0xf4>
		 {
		 //PRINTF_D("tftp negotiate port\n");
		 tftp_negotiate(src, src_port, dst, dst_port, payload, len - 8);
		 }
		 else */
		if(dst_port==tftp_transfer_src_port())
    271e:	0e 94 61 06 	call	0xcc2	; 0xcc2 <tftp_transfer_src_port>
    2722:	c8 16       	cp	r12, r24
    2724:	d9 06       	cpc	r13, r25
    2726:	59 f4       	brne	.+22     	; 0x273e <udp_packet_demultiplexer+0x70>
		{
			//PRINTF_D("tftp negotiate port\n");
			tftp_transfer(src, src_port, dst, dst_port, payload, len-8);
    2728:	88 ef       	ldi	r24, 0xF8	; 248
    272a:	9f ef       	ldi	r25, 0xFF	; 255
    272c:	e8 0e       	add	r14, r24
    272e:	f9 1e       	adc	r15, r25
    2730:	ce 01       	movw	r24, r28
    2732:	b4 01       	movw	r22, r8
    2734:	a5 01       	movw	r20, r10
    2736:	96 01       	movw	r18, r12
    2738:	0e 94 34 0b 	call	0x1668	; 0x1668 <tftp_transfer>
    273c:	50 c0       	rjmp	.+160    	; 0x27de <udp_packet_demultiplexer+0x110>
		}
		else if(dst_port==HELLO_WORLD_PORT)
    273e:	99 e3       	ldi	r25, 0x39	; 57
    2740:	c9 16       	cp	r12, r25
    2742:	90 e3       	ldi	r25, 0x30	; 48
    2744:	d9 06       	cpc	r13, r25
    2746:	41 f5       	brne	.+80     	; 0x2798 <udp_packet_demultiplexer+0xca>
		{
			PRINTF_D("New neighbour:\nIP = %d.%d.%d.%d\n", src[0], src[1], src[2], src[3]);
    2748:	ad b7       	in	r26, 0x3d	; 61
    274a:	be b7       	in	r27, 0x3e	; 62
    274c:	1a 97       	sbiw	r26, 0x0a	; 10
    274e:	0f b6       	in	r0, 0x3f	; 63
    2750:	f8 94       	cli
    2752:	be bf       	out	0x3e, r27	; 62
    2754:	0f be       	out	0x3f, r0	; 63
    2756:	ad bf       	out	0x3d, r26	; 61
    2758:	ed b7       	in	r30, 0x3d	; 61
    275a:	fe b7       	in	r31, 0x3e	; 62
    275c:	31 96       	adiw	r30, 0x01	; 1
    275e:	80 e6       	ldi	r24, 0x60	; 96
    2760:	9c e0       	ldi	r25, 0x0C	; 12
    2762:	12 96       	adiw	r26, 0x02	; 2
    2764:	9c 93       	st	X, r25
    2766:	8e 93       	st	-X, r24
    2768:	11 97       	sbiw	r26, 0x01	; 1
    276a:	88 81       	ld	r24, Y
    276c:	82 83       	std	Z+2, r24	; 0x02
    276e:	13 82       	std	Z+3, r1	; 0x03
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	84 83       	std	Z+4, r24	; 0x04
    2774:	15 82       	std	Z+5, r1	; 0x05
    2776:	8a 81       	ldd	r24, Y+2	; 0x02
    2778:	86 83       	std	Z+6, r24	; 0x06
    277a:	17 82       	std	Z+7, r1	; 0x07
    277c:	8b 81       	ldd	r24, Y+3	; 0x03
    277e:	80 87       	std	Z+8, r24	; 0x08
    2780:	11 86       	std	Z+9, r1	; 0x09
    2782:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    2786:	ed b7       	in	r30, 0x3d	; 61
    2788:	fe b7       	in	r31, 0x3e	; 62
    278a:	3a 96       	adiw	r30, 0x0a	; 10
    278c:	0f b6       	in	r0, 0x3f	; 63
    278e:	f8 94       	cli
    2790:	fe bf       	out	0x3e, r31	; 62
    2792:	0f be       	out	0x3f, r0	; 63
    2794:	ed bf       	out	0x3d, r30	; 61
    2796:	23 c0       	rjmp	.+70     	; 0x27de <udp_packet_demultiplexer+0x110>
		}
		else
		{
			PRINTF_D("packet received for unassigned port: %d\n", dst_port);
    2798:	00 d0       	rcall	.+0      	; 0x279a <udp_packet_demultiplexer+0xcc>
    279a:	00 d0       	rcall	.+0      	; 0x279c <udp_packet_demultiplexer+0xce>
    279c:	81 e8       	ldi	r24, 0x81	; 129
    279e:	9c e0       	ldi	r25, 0x0C	; 12
    27a0:	ad b7       	in	r26, 0x3d	; 61
    27a2:	be b7       	in	r27, 0x3e	; 62
    27a4:	12 96       	adiw	r26, 0x02	; 2
    27a6:	9c 93       	st	X, r25
    27a8:	8e 93       	st	-X, r24
    27aa:	11 97       	sbiw	r26, 0x01	; 1
    27ac:	14 96       	adiw	r26, 0x04	; 4
    27ae:	dc 92       	st	X, r13
    27b0:	ce 92       	st	-X, r12
    27b2:	13 97       	sbiw	r26, 0x03	; 3
    27b4:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
    27b8:	0f 90       	pop	r0
    27ba:	0f 90       	pop	r0
    27bc:	0f 90       	pop	r0
    27be:	0f 90       	pop	r0
    27c0:	0e c0       	rjmp	.+28     	; 0x27de <udp_packet_demultiplexer+0x110>
	}
	else
	{
		//nothing to do here yet
		//may be for routing purposes...
		PRINTF_D("packet for someone else: ");
    27c2:	00 d0       	rcall	.+0      	; 0x27c4 <udp_packet_demultiplexer+0xf6>
    27c4:	8a ea       	ldi	r24, 0xAA	; 170
    27c6:	9c e0       	ldi	r25, 0x0C	; 12
    27c8:	ed b7       	in	r30, 0x3d	; 61
    27ca:	fe b7       	in	r31, 0x3e	; 62
    27cc:	92 83       	std	Z+2, r25	; 0x02
    27ce:	81 83       	std	Z+1, r24	; 0x01
    27d0:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		print_addr_dec(dst);
    27d4:	0f 90       	pop	r0
    27d6:	0f 90       	pop	r0
    27d8:	c5 01       	movw	r24, r10
    27da:	0e 94 ff 10 	call	0x21fe	; 0x21fe <print_addr_dec>

	}
	return 0;
}
    27de:	80 e0       	ldi	r24, 0x00	; 0
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	1f 91       	pop	r17
    27e6:	0f 91       	pop	r16
    27e8:	ff 90       	pop	r15
    27ea:	ef 90       	pop	r14
    27ec:	df 90       	pop	r13
    27ee:	cf 90       	pop	r12
    27f0:	bf 90       	pop	r11
    27f2:	af 90       	pop	r10
    27f4:	9f 90       	pop	r9
    27f6:	8f 90       	pop	r8
    27f8:	08 95       	ret

000027fa <process_thread_radiotftp_process>:
PROCESS_THREAD(radiotftp_process, ev, data)
{
    27fa:	cf 92       	push	r12
    27fc:	ef 92       	push	r14
    27fe:	ff 92       	push	r15
    2800:	0f 93       	push	r16
    2802:	1f 93       	push	r17
    2804:	cf 93       	push	r28
    2806:	df 93       	push	r29
    2808:	ec 01       	movw	r28, r24
    280a:	8a 01       	movw	r16, r20
	uint16_t i, temp_io_index;
	int16_t result = 0;
	static struct etimer wait_timer;
	PROCESS_BEGIN()
    280c:	88 81       	ld	r24, Y
    280e:	99 81       	ldd	r25, Y+1	; 0x01
    2810:	00 97       	sbiw	r24, 0x00	; 0
    2812:	31 f0       	breq	.+12     	; 0x2820 <process_thread_radiotftp_process+0x26>
    2814:	21 e0       	ldi	r18, 0x01	; 1
    2816:	84 37       	cpi	r24, 0x74	; 116
    2818:	92 07       	cpc	r25, r18
    281a:	09 f0       	breq	.+2      	; 0x281e <process_thread_radiotftp_process+0x24>
    281c:	1f c1       	rjmp	.+574    	; 0x2a5c <process_thread_radiotftp_process+0x262>
    281e:	85 c0       	rjmp	.+266    	; 0x292a <process_thread_radiotftp_process+0x130>
		;
		PRINTF_D("%s begin\n", PROCESS_CURRENT()->name);
    2820:	00 d0       	rcall	.+0      	; 0x2822 <process_thread_radiotftp_process+0x28>
    2822:	00 d0       	rcall	.+0      	; 0x2824 <process_thread_radiotftp_process+0x2a>
    2824:	84 ec       	ldi	r24, 0xC4	; 196
    2826:	9c e0       	ldi	r25, 0x0C	; 12
    2828:	ed b7       	in	r30, 0x3d	; 61
    282a:	fe b7       	in	r31, 0x3e	; 62
    282c:	92 83       	std	Z+2, r25	; 0x02
    282e:	81 83       	std	Z+1, r24	; 0x01
    2830:	e0 91 64 1c 	lds	r30, 0x1C64
    2834:	f0 91 65 1c 	lds	r31, 0x1C65
    2838:	82 81       	ldd	r24, Z+2	; 0x02
    283a:	93 81       	ldd	r25, Z+3	; 0x03
    283c:	ed b7       	in	r30, 0x3d	; 61
    283e:	fe b7       	in	r31, 0x3e	; 62
    2840:	94 83       	std	Z+4, r25	; 0x04
    2842:	83 83       	std	Z+3, r24	; 0x03
    2844:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>

		SET_BIT(DDRF, 0);
    2848:	80 9a       	sbi	0x10, 0	; 16
		SET_BIT(MCUCR, PUD);
    284a:	85 b7       	in	r24, 0x35	; 53
    284c:	80 61       	ori	r24, 0x10	; 16
    284e:	85 bf       	out	0x35, r24	; 53
		SET_BIT(DPDS0, PFDRV1);
    2850:	80 91 36 01 	lds	r24, 0x0136
    2854:	80 68       	ori	r24, 0x80	; 128
    2856:	80 93 36 01 	sts	0x0136, r24
		SET_BIT(DPDS0, PFDRV0);
    285a:	80 91 36 01 	lds	r24, 0x0136
    285e:	80 64       	ori	r24, 0x40	; 64
    2860:	80 93 36 01 	sts	0x0136, r24

		CLR_BIT(DDRE, 0);
    2864:	68 98       	cbi	0x0d, 0	; 13
		SET_BIT(DDRE, 1);
    2866:	69 9a       	sbi	0x0d, 1	; 13
		SET_BIT(DDRE, 2);
    2868:	6a 9a       	sbi	0x0d, 2	; 13
		SET_BIT(DDRE, 3);
    286a:	6b 9a       	sbi	0x0d, 3	; 13
		SET_BIT(DDRE, 4);
    286c:	6c 9a       	sbi	0x0d, 4	; 13
		CLR_BIT(DDRE, 5);
    286e:	6d 98       	cbi	0x0d, 5	; 13

		SET_BIT(PORTE, 2);
    2870:	72 9a       	sbi	0x0e, 2	; 14
		SET_BIT(PORTE, 3);
    2872:	73 9a       	sbi	0x0e, 3	; 14
		SET_BIT(PORTE, 4);
    2874:	74 9a       	sbi	0x0e, 4	; 14

		rs232_init(RS232_PORT_0, USART_BAUD_38400, USART_PARITY_NONE|USART_STOP_BITS_1|USART_DATA_BITS_8|USART_RECEIVER_ENABLE|USART_INTERRUPT_RX_COMPLETE);
    2876:	0f 90       	pop	r0
    2878:	0f 90       	pop	r0
    287a:	0f 90       	pop	r0
    287c:	0f 90       	pop	r0
    287e:	80 e0       	ldi	r24, 0x00	; 0
    2880:	6c e0       	ldi	r22, 0x0C	; 12
    2882:	46 e9       	ldi	r20, 0x96	; 150
    2884:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <rs232_init>
		rs232_set_input(RS232_PORT_0, uart0_rx);
    2888:	80 e0       	ldi	r24, 0x00	; 0
    288a:	65 e1       	ldi	r22, 0x15	; 21
    288c:	72 e1       	ldi	r23, 0x12	; 18
    288e:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <rs232_set_input>

		rs232_init(RS232_PORT_1, USART_BAUD_4800, USART_PARITY_NONE|USART_STOP_BITS_1|USART_DATA_BITS_8|USART_RECEIVER_ENABLE|USART_INTERRUPT_RX_COMPLETE);
    2892:	81 e0       	ldi	r24, 0x01	; 1
    2894:	67 e6       	ldi	r22, 0x67	; 103
    2896:	46 e9       	ldi	r20, 0x96	; 150
    2898:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <rs232_init>
		rs232_set_input(RS232_PORT_1, uart1_rx);
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	6b eb       	ldi	r22, 0xBB	; 187
    28a0:	72 e1       	ldi	r23, 0x12	; 18
    28a2:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <rs232_set_input>
		 ATOMIC_SET(io_index, 0);
		 ATOMIC_SET(io_flag, 0);
		 }
		 }*/

		timers_initialize(radiotftpAlarm_callback);
    28a6:	80 eb       	ldi	r24, 0xB0	; 176
    28a8:	92 e1       	ldi	r25, 0x12	; 18
    28aa:	0e 94 88 0c 	call	0x1910	; 0x1910 <timers_initialize>
#if AX25_ENABLED==1
		ax25_initialize_network(my_ax25_callsign);
    28ae:	81 e9       	ldi	r24, 0x91	; 145
    28b0:	9d e0       	ldi	r25, 0x0D	; 13
    28b2:	0e 94 78 03 	call	0x6f0	; 0x6f0 <ax25_initialize_network>
		PRINTF_D("AX25 CALLSIGN = ");
    28b6:	00 d0       	rcall	.+0      	; 0x28b8 <process_thread_radiotftp_process+0xbe>
    28b8:	8e ec       	ldi	r24, 0xCE	; 206
    28ba:	9c e0       	ldi	r25, 0x0C	; 12
    28bc:	ed b7       	in	r30, 0x3d	; 61
    28be:	fe b7       	in	r31, 0x3e	; 62
    28c0:	92 83       	std	Z+2, r25	; 0x02
    28c2:	81 83       	std	Z+1, r24	; 0x01
    28c4:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		print_callsign(ax25_get_local_callsign(NULL));
    28c8:	0f 90       	pop	r0
    28ca:	0f 90       	pop	r0
    28cc:	80 e0       	ldi	r24, 0x00	; 0
    28ce:	90 e0       	ldi	r25, 0x00	; 0
    28d0:	0e 94 84 03 	call	0x708	; 0x708 <ax25_get_local_callsign>
    28d4:	0e 94 7c 10 	call	0x20f8	; 0x20f8 <print_callsign>
#elif ETHERNET_ENABLED==1
		eth_initialize_network(my_eth_address);
		PRINTF_D("Ethernet Address = ");
		print_addr_hex(eth_get_local_address(NULL));
#endif
		udp_initialize_ip_network(my_ip_address, &queueSerialData);
    28d8:	8f e7       	ldi	r24, 0x7F	; 127
    28da:	9d e0       	ldi	r25, 0x0D	; 13
    28dc:	6c e1       	ldi	r22, 0x1C	; 28
    28de:	72 e1       	ldi	r23, 0x12	; 18
    28e0:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <udp_initialize_ip_network>
		PRINTF_D("IPv4 Address = ");
    28e4:	00 d0       	rcall	.+0      	; 0x28e6 <process_thread_radiotftp_process+0xec>
    28e6:	8f ed       	ldi	r24, 0xDF	; 223
    28e8:	9c e0       	ldi	r25, 0x0C	; 12
    28ea:	ed b7       	in	r30, 0x3d	; 61
    28ec:	fe b7       	in	r31, 0x3e	; 62
    28ee:	92 83       	std	Z+2, r25	; 0x02
    28f0:	81 83       	std	Z+1, r24	; 0x01
    28f2:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
		print_addr_dec(udp_get_localhost_ip(NULL));
    28f6:	0f 90       	pop	r0
    28f8:	0f 90       	pop	r0
    28fa:	80 e0       	ldi	r24, 0x00	; 0
    28fc:	90 e0       	ldi	r25, 0x00	; 0
    28fe:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <udp_get_localhost_ip>
    2902:	0e 94 ff 10 	call	0x21fe	; 0x21fe <print_addr_dec>
		tftp_initialize(udp_get_data_queuer_fptr());
    2906:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <udp_get_data_queuer_fptr>
    290a:	0e 94 56 06 	call	0xcac	; 0xcac <tftp_initialize>

		//entering the main while loop
		PRINTF_D("started listening...\n");
    290e:	8f ee       	ldi	r24, 0xEF	; 239
    2910:	9c e0       	ldi	r25, 0x0C	; 12
    2912:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
		{
			/* usage
			 * radiotftp_setNumBytesToSend(500);
			 * process_post_synch(&radiotftp_process, PROCESS_EVENT_CONTINUE, io);
			 */
			PRINTF_D("waiting for an event/flag\n");
    2916:	84 e0       	ldi	r24, 0x04	; 4
    2918:	9d e0       	ldi	r25, 0x0D	; 13
    291a:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
			PROCESS_WAIT_EVENT();
    291e:	84 e7       	ldi	r24, 0x74	; 116
    2920:	91 e0       	ldi	r25, 0x01	; 1
    2922:	99 83       	std	Y+1, r25	; 0x01
    2924:	88 83       	st	Y, r24
    2926:	81 e0       	ldi	r24, 0x01	; 1
    2928:	9c c0       	rjmp	.+312    	; 0x2a62 <process_thread_radiotftp_process+0x268>
			//PROCESS_WAIT_EVENT_UNTIL(timer_flag || queue_flag || io_flag || numBytesToSend);
			if(numBytesToSend)
    292a:	80 91 e4 12 	lds	r24, 0x12E4
    292e:	90 91 e5 12 	lds	r25, 0x12E5
    2932:	00 97       	sbiw	r24, 0x00	; 0
    2934:	59 f1       	breq	.+86     	; 0x298c <process_thread_radiotftp_process+0x192>
			{
				PRINTF_D("starting to send request, numBytes=%d\n", numBytesToSend);
    2936:	80 91 e4 12 	lds	r24, 0x12E4
    293a:	90 91 e5 12 	lds	r25, 0x12E5
    293e:	00 d0       	rcall	.+0      	; 0x2940 <process_thread_radiotftp_process+0x146>
    2940:	00 d0       	rcall	.+0      	; 0x2942 <process_thread_radiotftp_process+0x148>
    2942:	2e e1       	ldi	r18, 0x1E	; 30
    2944:	3d e0       	ldi	r19, 0x0D	; 13
    2946:	ed b7       	in	r30, 0x3d	; 61
    2948:	fe b7       	in	r31, 0x3e	; 62
    294a:	32 83       	std	Z+2, r19	; 0x02
    294c:	21 83       	std	Z+1, r18	; 0x01
    294e:	94 83       	std	Z+4, r25	; 0x04
    2950:	83 83       	std	Z+3, r24	; 0x03
    2952:	0e 94 e0 4c 	call	0x99c0	; 0x99c0 <printf>
#if RADIOTFTP_ENABLE_ACKNOWLEDGMENTS
				tftp_sendRequest(TFTP_OPCODE_WRQ, udp_get_broadcast_ip(NULL), (uint8_t*) data, numBytesToSend, REMOTE_FILENAME, strlen(REMOTE_FILENAME), APPEND);
    2956:	0f 90       	pop	r0
    2958:	0f 90       	pop	r0
    295a:	0f 90       	pop	r0
    295c:	0f 90       	pop	r0
    295e:	80 e0       	ldi	r24, 0x00	; 0
    2960:	90 e0       	ldi	r25, 0x00	; 0
    2962:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <udp_get_broadcast_ip>
    2966:	bc 01       	movw	r22, r24
    2968:	20 91 e4 12 	lds	r18, 0x12E4
    296c:	30 91 e5 12 	lds	r19, 0x12E5
    2970:	82 e0       	ldi	r24, 0x02	; 2
    2972:	a8 01       	movw	r20, r16
    2974:	05 e4       	ldi	r16, 0x45	; 69
    2976:	1d e0       	ldi	r17, 0x0D	; 13
    2978:	ab e0       	ldi	r26, 0x0B	; 11
    297a:	ea 2e       	mov	r14, r26
    297c:	cc 24       	eor	r12, r12
    297e:	c3 94       	inc	r12
    2980:	0e 94 01 08 	call	0x1002	; 0x1002 <tftp_sendRequest>
#else
				tftp_sendSingleBlockData(udp_get_broadcast_ip(NULL), (uint8_t*)data, numBytesToSend, REMOTE_FILENAME);
#endif
				numBytesToSend = 0;
    2984:	10 92 e5 12 	sts	0x12E5, r1
    2988:	10 92 e4 12 	sts	0x12E4, r1
			}
			if(timer_flag)
    298c:	80 91 e2 12 	lds	r24, 0x12E2
    2990:	88 23       	and	r24, r24
    2992:	41 f0       	breq	.+16     	; 0x29a4 <process_thread_radiotftp_process+0x1aa>
			{
				PRINTF_D("timer_flag=1\n");
    2994:	81 e5       	ldi	r24, 0x51	; 81
    2996:	9d e0       	ldi	r25, 0x0D	; 13
    2998:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
				tftp_timer_handler();
    299c:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <tftp_timer_handler>
				timer_flag = 0;
    29a0:	10 92 e2 12 	sts	0x12E2, r1
			}
			if(queue_flag)
    29a4:	80 91 e3 12 	lds	r24, 0x12E3
    29a8:	88 23       	and	r24, r24
    29aa:	61 f0       	breq	.+24     	; 0x29c4 <process_thread_radiotftp_process+0x1ca>
			{
				if(!sync_passed&&sync_counter<1)
    29ac:	80 91 e6 12 	lds	r24, 0x12E6
    29b0:	88 23       	and	r24, r24
    29b2:	41 f4       	brne	.+16     	; 0x29c4 <process_thread_radiotftp_process+0x1ca>
    29b4:	80 91 e7 12 	lds	r24, 0x12E7
    29b8:	88 23       	and	r24, r24
    29ba:	21 f4       	brne	.+8      	; 0x29c4 <process_thread_radiotftp_process+0x1ca>
					 do
					 {
					 PROCESS_YIELD();
					 } while(ev != PROCESS_EVENT_TIMER);
					 */
					transmitSerialData();
    29bc:	0e 94 2f 13 	call	0x265e	; 0x265e <transmitSerialData>
					queue_flag = 0;
    29c0:	10 92 e3 12 	sts	0x12E3, r1
				}
			}
			if(io_flag)
    29c4:	80 91 e0 12 	lds	r24, 0x12E0
    29c8:	88 23       	and	r24, r24
    29ca:	09 f4       	brne	.+2      	; 0x29ce <process_thread_radiotftp_process+0x1d4>
    29cc:	42 c0       	rjmp	.+132    	; 0x2a52 <process_thread_radiotftp_process+0x258>
			{
				//PRINTF_D("# of bytes read = %d\n", saved_io_index);
				ATOMIC_SET(temp_io_index, saved_io_index);
    29ce:	f8 94       	cli
    29d0:	40 91 e8 12 	lds	r20, 0x12E8
    29d4:	50 91 e9 12 	lds	r21, 0x12E9
    29d8:	78 94       	sei
				result = manchester_decode(io, manchester_buffer, temp_io_index);
    29da:	8a ee       	ldi	r24, 0xEA	; 234
    29dc:	92 e1       	ldi	r25, 0x12	; 18
    29de:	62 e5       	ldi	r22, 0x52	; 82
    29e0:	75 e1       	ldi	r23, 0x15	; 21
    29e2:	0e 94 31 06 	call	0xc62	; 0xc62 <manchester_decode>
    29e6:	8c 01       	movw	r16, r24
#if ETHERNET_ENABLED==1
				result = eth_open_packet(NULL, NULL, ethernet_buffer, manchester_buffer, result);
#elif AX25_ENABLED==1
				result = ax25_open_ui_packet(NULL, NULL, ax25_buffer, manchester_buffer, result);
    29e8:	80 e0       	ldi	r24, 0x00	; 0
    29ea:	90 e0       	ldi	r25, 0x00	; 0
    29ec:	60 e0       	ldi	r22, 0x00	; 0
    29ee:	70 e0       	ldi	r23, 0x00	; 0
    29f0:	4a ea       	ldi	r20, 0xAA	; 170
    29f2:	57 e1       	ldi	r21, 0x17	; 23
    29f4:	22 e5       	ldi	r18, 0x52	; 82
    29f6:	35 e1       	ldi	r19, 0x15	; 21
    29f8:	0e 94 0d 04 	call	0x81a	; 0x81a <ax25_open_ui_packet>
#else
				result = 1;
#endif
				if(result)
    29fc:	00 97       	sbiw	r24, 0x00	; 0
    29fe:	29 f1       	breq	.+74     	; 0x2a4a <process_thread_radiotftp_process+0x250>
				{
					//PRINTF_D("%s\n",buf);
#if ETHERNET_ENABLED==1
					result = udp_open_packet(udp_src, &udp_src_prt, udp_dst, &udp_dst_prt, udp_buffer, ethernet_buffer);
#elif AX25_ENABLED==1
					result = udp_open_packet(udp_src, &udp_src_prt, udp_dst, &udp_dst_prt, udp_buffer, ax25_buffer);
    2a00:	86 ed       	ldi	r24, 0xD6	; 214
    2a02:	98 e1       	ldi	r25, 0x18	; 24
    2a04:	6a ed       	ldi	r22, 0xDA	; 218
    2a06:	78 e1       	ldi	r23, 0x18	; 24
    2a08:	4c ed       	ldi	r20, 0xDC	; 220
    2a0a:	58 e1       	ldi	r21, 0x18	; 24
    2a0c:	20 ee       	ldi	r18, 0xE0	; 224
    2a0e:	38 e1       	ldi	r19, 0x18	; 24
    2a10:	02 ee       	ldi	r16, 0xE2	; 226
    2a12:	18 e1       	ldi	r17, 0x18	; 24
    2a14:	fa ea       	ldi	r31, 0xAA	; 170
    2a16:	ef 2e       	mov	r14, r31
    2a18:	f7 e1       	ldi	r31, 0x17	; 23
    2a1a:	ff 2e       	mov	r15, r31
    2a1c:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <udp_open_packet>
    2a20:	7c 01       	movw	r14, r24
#else
					result = udp_open_packet(udp_src, &udp_src_prt, udp_dst, &udp_dst_prt, udp_buffer, manchester_buffer);
#endif
					if(result)
    2a22:	00 97       	sbiw	r24, 0x00	; 0
    2a24:	79 f0       	breq	.+30     	; 0x2a44 <process_thread_radiotftp_process+0x24a>
					{
						//PRINTF_D("%s\n",buf);
						udp_packet_demultiplexer(udp_src, udp_src_prt, udp_dst, udp_dst_prt, udp_buffer, result);
    2a26:	60 91 da 18 	lds	r22, 0x18DA
    2a2a:	70 91 db 18 	lds	r23, 0x18DB
    2a2e:	20 91 e0 18 	lds	r18, 0x18E0
    2a32:	30 91 e1 18 	lds	r19, 0x18E1
    2a36:	86 ed       	ldi	r24, 0xD6	; 214
    2a38:	98 e1       	ldi	r25, 0x18	; 24
    2a3a:	4c ed       	ldi	r20, 0xDC	; 220
    2a3c:	58 e1       	ldi	r21, 0x18	; 24
    2a3e:	0e 94 67 13 	call	0x26ce	; 0x26ce <udp_packet_demultiplexer>
    2a42:	07 c0       	rjmp	.+14     	; 0x2a52 <process_thread_radiotftp_process+0x258>
					}
					else
					{
						PRINTF_D("!udp discarded!\n");
    2a44:	8e e5       	ldi	r24, 0x5E	; 94
    2a46:	9d e0       	ldi	r25, 0x0D	; 13
    2a48:	02 c0       	rjmp	.+4      	; 0x2a4e <process_thread_radiotftp_process+0x254>
				else
				{
#if ETHERNET_ENABLED==1
					PRINTF_D("!eth discarded!\n");
#elif AX25_ENABLED==1
					PRINTF_D("!ax25_discarded!\n");
    2a4a:	8e e6       	ldi	r24, 0x6E	; 110
    2a4c:	9d e0       	ldi	r25, 0x0D	; 13
    2a4e:	0e 94 19 4d 	call	0x9a32	; 0x9a32 <puts>
#endif
				}
			}
			ATOMIC_SET(io_flag, 0);
    2a52:	f8 94       	cli
    2a54:	10 92 e0 12 	sts	0x12E0, r1
    2a58:	78 94       	sei
		}
    2a5a:	5d cf       	rjmp	.-326    	; 0x2916 <process_thread_radiotftp_process+0x11c>

	PROCESS_END();
    2a5c:	19 82       	std	Y+1, r1	; 0x01
    2a5e:	18 82       	st	Y, r1
    2a60:	83 e0       	ldi	r24, 0x03	; 3
}
    2a62:	df 91       	pop	r29
    2a64:	cf 91       	pop	r28
    2a66:	1f 91       	pop	r17
    2a68:	0f 91       	pop	r16
    2a6a:	ff 90       	pop	r15
    2a6c:	ef 90       	pop	r14
    2a6e:	cf 90       	pop	r12
    2a70:	08 95       	ret

00002a72 <call_process>:
  process_current = old_current;
}
/*---------------------------------------------------------------------------*/
static void
call_process(struct process *p, process_event_t ev, process_data_t data)
{
    2a72:	1f 93       	push	r17
    2a74:	cf 93       	push	r28
    2a76:	df 93       	push	r29
    2a78:	ec 01       	movw	r28, r24
    2a7a:	16 2f       	mov	r17, r22
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
    2a7c:	88 85       	ldd	r24, Y+8	; 0x08
    2a7e:	80 ff       	sbrs	r24, 0
    2a80:	1d c0       	rjmp	.+58     	; 0x2abc <call_process+0x4a>
     p->thread != NULL) {
    2a82:	ec 81       	ldd	r30, Y+4	; 0x04
    2a84:	fd 81       	ldd	r31, Y+5	; 0x05
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
    2a86:	30 97       	sbiw	r30, 0x00	; 0
    2a88:	c9 f0       	breq	.+50     	; 0x2abc <call_process+0x4a>
     p->thread != NULL) {
    PRINTF("process: calling process '%s' with event %d\n", PROCESS_NAME_STRING(p), ev);
    process_current = p;
    2a8a:	d0 93 65 1c 	sts	0x1C65, r29
    2a8e:	c0 93 64 1c 	sts	0x1C64, r28
    p->state = PROCESS_STATE_CALLED;
    2a92:	82 e0       	ldi	r24, 0x02	; 2
    2a94:	88 87       	std	Y+8, r24	; 0x08
    ret = p->thread(&p->pt, ev, data);
    2a96:	ce 01       	movw	r24, r28
    2a98:	06 96       	adiw	r24, 0x06	; 6
    2a9a:	09 95       	icall
    2a9c:	99 27       	eor	r25, r25
    2a9e:	87 fd       	sbrc	r24, 7
    2aa0:	90 95       	com	r25
    if(ret == PT_EXITED ||
    2aa2:	02 97       	sbiw	r24, 0x02	; 2
    2aa4:	82 30       	cpi	r24, 0x02	; 2
    2aa6:	91 05       	cpc	r25, r1
    2aa8:	10 f0       	brcs	.+4      	; 0x2aae <call_process+0x3c>
       ret == PT_ENDED ||
    2aaa:	13 38       	cpi	r17, 0x83	; 131
    2aac:	29 f4       	brne	.+10     	; 0x2ab8 <call_process+0x46>
       ev == PROCESS_EVENT_EXIT) {
      exit_process(p, p);
    2aae:	ce 01       	movw	r24, r28
    2ab0:	be 01       	movw	r22, r28
    2ab2:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <exit_process>
    2ab6:	02 c0       	rjmp	.+4      	; 0x2abc <call_process+0x4a>
    } else {
      p->state = PROCESS_STATE_RUNNING;
    2ab8:	81 e0       	ldi	r24, 0x01	; 1
    2aba:	88 87       	std	Y+8, r24	; 0x08
    }
  }
}
    2abc:	df 91       	pop	r29
    2abe:	cf 91       	pop	r28
    2ac0:	1f 91       	pop	r17
    2ac2:	08 95       	ret

00002ac4 <exit_process>:
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
}
/*---------------------------------------------------------------------------*/
static void
exit_process(struct process *p, struct process *fromprocess)
{
    2ac4:	cf 92       	push	r12
    2ac6:	df 92       	push	r13
    2ac8:	ef 92       	push	r14
    2aca:	ff 92       	push	r15
    2acc:	0f 93       	push	r16
    2ace:	1f 93       	push	r17
    2ad0:	cf 93       	push	r28
    2ad2:	df 93       	push	r29
    2ad4:	ec 01       	movw	r28, r24
    2ad6:	7b 01       	movw	r14, r22
  register struct process *q;
  struct process *old_current = process_current;
    2ad8:	c0 90 64 1c 	lds	r12, 0x1C64
    2adc:	d0 90 65 1c 	lds	r13, 0x1C65

  PRINTF("process: exit_process '%s'\n", PROCESS_NAME_STRING(p));

  /* Make sure the process is in the process list before we try to
     exit it. */
  for(q = process_list; q != p && q != NULL; q = q->next);
    2ae0:	00 91 62 1c 	lds	r16, 0x1C62
    2ae4:	10 91 63 1c 	lds	r17, 0x1C63
    2ae8:	f8 01       	movw	r30, r16
    2aea:	03 c0       	rjmp	.+6      	; 0x2af2 <exit_process+0x2e>
    2aec:	01 90       	ld	r0, Z+
    2aee:	f0 81       	ld	r31, Z
    2af0:	e0 2d       	mov	r30, r0
    2af2:	ec 17       	cp	r30, r28
    2af4:	fd 07       	cpc	r31, r29
    2af6:	19 f0       	breq	.+6      	; 0x2afe <exit_process+0x3a>
    2af8:	30 97       	sbiw	r30, 0x00	; 0
    2afa:	c1 f7       	brne	.-16     	; 0x2aec <exit_process+0x28>
    2afc:	46 c0       	rjmp	.+140    	; 0x2b8a <exit_process+0xc6>
  if(q == NULL) {
    2afe:	20 97       	sbiw	r28, 0x00	; 0
    2b00:	09 f4       	brne	.+2      	; 0x2b04 <exit_process+0x40>
    2b02:	43 c0       	rjmp	.+134    	; 0x2b8a <exit_process+0xc6>
    return;
  }

  if(process_is_running(p)) {
    2b04:	88 85       	ldd	r24, Y+8	; 0x08
    2b06:	88 23       	and	r24, r24
    2b08:	09 f1       	breq	.+66     	; 0x2b4c <exit_process+0x88>
    /* Process was running */
    p->state = PROCESS_STATE_NONE;
    2b0a:	18 86       	std	Y+8, r1	; 0x08
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
    2b0c:	0b c0       	rjmp	.+22     	; 0x2b24 <exit_process+0x60>
      if(p != q) {
    2b0e:	c0 17       	cp	r28, r16
    2b10:	d1 07       	cpc	r29, r17
    2b12:	29 f0       	breq	.+10     	; 0x2b1e <exit_process+0x5a>
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
    2b14:	c8 01       	movw	r24, r16
    2b16:	67 e8       	ldi	r22, 0x87	; 135
    2b18:	ae 01       	movw	r20, r28
    2b1a:	0e 94 39 15 	call	0x2a72	; 0x2a72 <call_process>
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
    2b1e:	f8 01       	movw	r30, r16
    2b20:	00 81       	ld	r16, Z
    2b22:	11 81       	ldd	r17, Z+1	; 0x01
    2b24:	01 15       	cp	r16, r1
    2b26:	11 05       	cpc	r17, r1
    2b28:	91 f7       	brne	.-28     	; 0x2b0e <exit_process+0x4a>
      if(p != q) {
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
      }
    }

    if(p->thread != NULL && p != fromprocess) {
    2b2a:	ec 81       	ldd	r30, Y+4	; 0x04
    2b2c:	fd 81       	ldd	r31, Y+5	; 0x05
    2b2e:	30 97       	sbiw	r30, 0x00	; 0
    2b30:	69 f0       	breq	.+26     	; 0x2b4c <exit_process+0x88>
    2b32:	ce 15       	cp	r28, r14
    2b34:	df 05       	cpc	r29, r15
    2b36:	51 f0       	breq	.+20     	; 0x2b4c <exit_process+0x88>
      /* Post the exit event to the process that is about to exit. */
      process_current = p;
    2b38:	d0 93 65 1c 	sts	0x1C65, r29
    2b3c:	c0 93 64 1c 	sts	0x1C64, r28
      p->thread(&p->pt, PROCESS_EVENT_EXIT, NULL);
    2b40:	ce 01       	movw	r24, r28
    2b42:	06 96       	adiw	r24, 0x06	; 6
    2b44:	63 e8       	ldi	r22, 0x83	; 131
    2b46:	40 e0       	ldi	r20, 0x00	; 0
    2b48:	50 e0       	ldi	r21, 0x00	; 0
    2b4a:	09 95       	icall
    }
  }

  if(p == process_list) {
    2b4c:	e0 91 62 1c 	lds	r30, 0x1C62
    2b50:	f0 91 63 1c 	lds	r31, 0x1C63
    2b54:	ce 17       	cp	r28, r30
    2b56:	df 07       	cpc	r29, r31
    2b58:	91 f4       	brne	.+36     	; 0x2b7e <exit_process+0xba>
    process_list = process_list->next;
    2b5a:	88 81       	ld	r24, Y
    2b5c:	99 81       	ldd	r25, Y+1	; 0x01
    2b5e:	90 93 63 1c 	sts	0x1C63, r25
    2b62:	80 93 62 1c 	sts	0x1C62, r24
    2b66:	0d c0       	rjmp	.+26     	; 0x2b82 <exit_process+0xbe>
  } else {
    for(q = process_list; q != NULL; q = q->next) {
      if(q->next == p) {
    2b68:	80 81       	ld	r24, Z
    2b6a:	91 81       	ldd	r25, Z+1	; 0x01
    2b6c:	8c 17       	cp	r24, r28
    2b6e:	9d 07       	cpc	r25, r29
    2b70:	29 f4       	brne	.+10     	; 0x2b7c <exit_process+0xb8>
	q->next = p->next;
    2b72:	88 81       	ld	r24, Y
    2b74:	99 81       	ldd	r25, Y+1	; 0x01
    2b76:	91 83       	std	Z+1, r25	; 0x01
    2b78:	80 83       	st	Z, r24
	break;
    2b7a:	03 c0       	rjmp	.+6      	; 0x2b82 <exit_process+0xbe>

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
      if(q->next == p) {
    2b7c:	fc 01       	movw	r30, r24
  }

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
    2b7e:	30 97       	sbiw	r30, 0x00	; 0
    2b80:	99 f7       	brne	.-26     	; 0x2b68 <exit_process+0xa4>
	break;
      }
    }
  }

  process_current = old_current;
    2b82:	d0 92 65 1c 	sts	0x1C65, r13
    2b86:	c0 92 64 1c 	sts	0x1C64, r12
}
    2b8a:	df 91       	pop	r29
    2b8c:	cf 91       	pop	r28
    2b8e:	1f 91       	pop	r17
    2b90:	0f 91       	pop	r16
    2b92:	ff 90       	pop	r15
    2b94:	ef 90       	pop	r14
    2b96:	df 90       	pop	r13
    2b98:	cf 90       	pop	r12
    2b9a:	08 95       	ret

00002b9c <do_poll>:
 * Call each process' poll handler.
 */
/*---------------------------------------------------------------------------*/
static void
do_poll(void)
{
    2b9c:	1f 93       	push	r17
    2b9e:	cf 93       	push	r28
    2ba0:	df 93       	push	r29
  struct process *p;

  poll_requested = 0;
    2ba2:	10 92 66 1c 	sts	0x1C66, r1
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    2ba6:	c0 91 62 1c 	lds	r28, 0x1C62
    2baa:	d0 91 63 1c 	lds	r29, 0x1C63
    if(p->needspoll) {
      p->state = PROCESS_STATE_RUNNING;
    2bae:	11 e0       	ldi	r17, 0x01	; 1
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    2bb0:	0e c0       	rjmp	.+28     	; 0x2bce <do_poll+0x32>
    if(p->needspoll) {
    2bb2:	89 85       	ldd	r24, Y+9	; 0x09
    2bb4:	88 23       	and	r24, r24
    2bb6:	41 f0       	breq	.+16     	; 0x2bc8 <do_poll+0x2c>
      p->state = PROCESS_STATE_RUNNING;
    2bb8:	18 87       	std	Y+8, r17	; 0x08
      p->needspoll = 0;
    2bba:	19 86       	std	Y+9, r1	; 0x09
      call_process(p, PROCESS_EVENT_POLL, NULL);
    2bbc:	ce 01       	movw	r24, r28
    2bbe:	62 e8       	ldi	r22, 0x82	; 130
    2bc0:	40 e0       	ldi	r20, 0x00	; 0
    2bc2:	50 e0       	ldi	r21, 0x00	; 0
    2bc4:	0e 94 39 15 	call	0x2a72	; 0x2a72 <call_process>
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    2bc8:	09 90       	ld	r0, Y+
    2bca:	d8 81       	ld	r29, Y
    2bcc:	c0 2d       	mov	r28, r0
    2bce:	20 97       	sbiw	r28, 0x00	; 0
    2bd0:	81 f7       	brne	.-32     	; 0x2bb2 <do_poll+0x16>
      p->state = PROCESS_STATE_RUNNING;
      p->needspoll = 0;
      call_process(p, PROCESS_EVENT_POLL, NULL);
    }
  }
}
    2bd2:	df 91       	pop	r29
    2bd4:	cf 91       	pop	r28
    2bd6:	1f 91       	pop	r17
    2bd8:	08 95       	ret

00002bda <process_alloc_event>:

/*---------------------------------------------------------------------------*/
process_event_t
process_alloc_event(void)
{
  return lastevent++;
    2bda:	80 91 11 1d 	lds	r24, 0x1D11
    2bde:	98 2f       	mov	r25, r24
    2be0:	9f 5f       	subi	r25, 0xFF	; 255
    2be2:	90 93 11 1d 	sts	0x1D11, r25
}
    2be6:	08 95       	ret

00002be8 <process_exit>:
}
/*---------------------------------------------------------------------------*/
void
process_exit(struct process *p)
{
  exit_process(p, PROCESS_CURRENT());
    2be8:	60 91 64 1c 	lds	r22, 0x1C64
    2bec:	70 91 65 1c 	lds	r23, 0x1C65
    2bf0:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <exit_process>
}
    2bf4:	08 95       	ret

00002bf6 <process_init>:
/*---------------------------------------------------------------------------*/
void
process_init(void)
{
  lastevent = PROCESS_EVENT_MAX;
    2bf6:	8a e8       	ldi	r24, 0x8A	; 138
    2bf8:	80 93 11 1d 	sts	0x1D11, r24

  nevents = fevent = 0;
    2bfc:	10 92 68 1c 	sts	0x1C68, r1
    2c00:	10 92 67 1c 	sts	0x1C67, r1
#if PROCESS_CONF_STATS
  process_maxevents = 0;
#endif /* PROCESS_CONF_STATS */

  process_current = process_list = NULL;
    2c04:	10 92 63 1c 	sts	0x1C63, r1
    2c08:	10 92 62 1c 	sts	0x1C62, r1
    2c0c:	10 92 65 1c 	sts	0x1C65, r1
    2c10:	10 92 64 1c 	sts	0x1C64, r1
}
    2c14:	08 95       	ret

00002c16 <process_run>:
/*---------------------------------------------------------------------------*/
int
process_run(void)
{
  /* Process poll events. */
  if(poll_requested) {
    2c16:	80 91 66 1c 	lds	r24, 0x1C66
    2c1a:	88 23       	and	r24, r24
    2c1c:	11 f0       	breq	.+4      	; 0x2c22 <process_run+0xc>
    do_poll();
    2c1e:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <do_poll>
   * delivered to any of them. If so, we call the event handler
   * function for the process. We only process one event at a time and
   * call the poll handlers inbetween.
   */

  if(nevents > 0) {
    2c22:	70 91 67 1c 	lds	r23, 0x1C67
    2c26:	77 23       	and	r23, r23
    2c28:	09 f4       	brne	.+2      	; 0x2c2c <process_run+0x16>
    2c2a:	55 c0       	rjmp	.+170    	; 0x2cd6 <process_run+0xc0>
    
    /* There are events that we should deliver. */
    ev = events[fevent].ev;
    2c2c:	20 91 68 1c 	lds	r18, 0x1C68
    2c30:	30 e0       	ldi	r19, 0x00	; 0
    2c32:	f9 01       	movw	r30, r18
    2c34:	ee 0f       	add	r30, r30
    2c36:	ff 1f       	adc	r31, r31
    2c38:	ee 0f       	add	r30, r30
    2c3a:	ff 1f       	adc	r31, r31
    2c3c:	e2 0f       	add	r30, r18
    2c3e:	f3 1f       	adc	r31, r19
    2c40:	e7 59       	subi	r30, 0x97	; 151
    2c42:	f3 4e       	sbci	r31, 0xE3	; 227
    2c44:	60 81       	ld	r22, Z
    2c46:	60 93 10 1d 	sts	0x1D10, r22
    
    data = events[fevent].data;
    2c4a:	41 81       	ldd	r20, Z+1	; 0x01
    2c4c:	52 81       	ldd	r21, Z+2	; 0x02
    2c4e:	50 93 0f 1d 	sts	0x1D0F, r21
    2c52:	40 93 0e 1d 	sts	0x1D0E, r20
    receiver = events[fevent].p;
    2c56:	83 81       	ldd	r24, Z+3	; 0x03
    2c58:	94 81       	ldd	r25, Z+4	; 0x04
    2c5a:	90 93 0d 1d 	sts	0x1D0D, r25
    2c5e:	80 93 0c 1d 	sts	0x1D0C, r24

    /* Since we have seen the new event, we move pointer upwards
       and decrese the number of events. */
    fevent = (fevent + 1) % PROCESS_CONF_NUMEVENTS;
    2c62:	2f 5f       	subi	r18, 0xFF	; 255
    2c64:	3f 4f       	sbci	r19, 0xFF	; 255
    2c66:	2f 71       	andi	r18, 0x1F	; 31
    2c68:	30 70       	andi	r19, 0x00	; 0
    2c6a:	20 93 68 1c 	sts	0x1C68, r18
    --nevents;
    2c6e:	71 50       	subi	r23, 0x01	; 1
    2c70:	70 93 67 1c 	sts	0x1C67, r23

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
    2c74:	00 97       	sbiw	r24, 0x00	; 0
    2c76:	41 f5       	brne	.+80     	; 0x2cc8 <process_run+0xb2>
      for(p = process_list; p != NULL; p = p->next) {
    2c78:	80 91 62 1c 	lds	r24, 0x1C62
    2c7c:	90 91 63 1c 	lds	r25, 0x1C63
    2c80:	18 c0       	rjmp	.+48     	; 0x2cb2 <process_run+0x9c>

	/* If we have been requested to poll a process, we do this in
	   between processing the broadcast event. */
	if(poll_requested) {
    2c82:	80 91 66 1c 	lds	r24, 0x1C66
    2c86:	88 23       	and	r24, r24
    2c88:	11 f0       	breq	.+4      	; 0x2c8e <process_run+0x78>
	  do_poll();
    2c8a:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <do_poll>
	}
	call_process(p, ev, data);
    2c8e:	40 91 0e 1d 	lds	r20, 0x1D0E
    2c92:	50 91 0f 1d 	lds	r21, 0x1D0F
    2c96:	80 91 0a 1d 	lds	r24, 0x1D0A
    2c9a:	90 91 0b 1d 	lds	r25, 0x1D0B
    2c9e:	60 91 10 1d 	lds	r22, 0x1D10
    2ca2:	0e 94 39 15 	call	0x2a72	; 0x2a72 <call_process>
    --nevents;

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
      for(p = process_list; p != NULL; p = p->next) {
    2ca6:	e0 91 0a 1d 	lds	r30, 0x1D0A
    2caa:	f0 91 0b 1d 	lds	r31, 0x1D0B
    2cae:	80 81       	ld	r24, Z
    2cb0:	91 81       	ldd	r25, Z+1	; 0x01
    2cb2:	90 93 0b 1d 	sts	0x1D0B, r25
    2cb6:	80 93 0a 1d 	sts	0x1D0A, r24
    2cba:	80 91 0a 1d 	lds	r24, 0x1D0A
    2cbe:	90 91 0b 1d 	lds	r25, 0x1D0B
    2cc2:	00 97       	sbiw	r24, 0x00	; 0
    2cc4:	f1 f6       	brne	.-68     	; 0x2c82 <process_run+0x6c>
    2cc6:	07 c0       	rjmp	.+14     	; 0x2cd6 <process_run+0xc0>
    } else {
      /* This is not a broadcast event, so we deliver it to the
	 specified process. */
      /* If the event was an INIT event, we should also update the
	 state of the process. */
      if(ev == PROCESS_EVENT_INIT) {
    2cc8:	61 38       	cpi	r22, 0x81	; 129
    2cca:	19 f4       	brne	.+6      	; 0x2cd2 <process_run+0xbc>
	receiver->state = PROCESS_STATE_RUNNING;
    2ccc:	21 e0       	ldi	r18, 0x01	; 1
    2cce:	fc 01       	movw	r30, r24
    2cd0:	20 87       	std	Z+8, r18	; 0x08
      }

      /* Make sure that the process actually is running. */
      call_process(receiver, ev, data);
    2cd2:	0e 94 39 15 	call	0x2a72	; 0x2a72 <call_process>
  }

  /* Process one event from the queue */
  do_event();

  return nevents + poll_requested;
    2cd6:	80 91 66 1c 	lds	r24, 0x1C66
    2cda:	20 91 67 1c 	lds	r18, 0x1C67
    2cde:	30 e0       	ldi	r19, 0x00	; 0
    2ce0:	28 0f       	add	r18, r24
    2ce2:	31 1d       	adc	r19, r1
}
    2ce4:	c9 01       	movw	r24, r18
    2ce6:	08 95       	ret

00002ce8 <process_nevents>:
/*---------------------------------------------------------------------------*/
int
process_nevents(void)
{
  return nevents + poll_requested;
    2ce8:	80 91 66 1c 	lds	r24, 0x1C66
    2cec:	20 91 67 1c 	lds	r18, 0x1C67
    2cf0:	30 e0       	ldi	r19, 0x00	; 0
    2cf2:	28 0f       	add	r18, r24
    2cf4:	31 1d       	adc	r19, r1
}
    2cf6:	c9 01       	movw	r24, r18
    2cf8:	08 95       	ret

00002cfa <process_post>:
    PRINTF("process_post: Process '%s' posts event %d to process '%s', nevents %d\n",
	   PROCESS_NAME_STRING(PROCESS_CURRENT()), ev,
	   p == PROCESS_BROADCAST? "<broadcast>": PROCESS_NAME_STRING(p), nevents);
  }
  
  if(nevents == PROCESS_CONF_NUMEVENTS) {
    2cfa:	70 91 67 1c 	lds	r23, 0x1C67
    2cfe:	70 32       	cpi	r23, 0x20	; 32
    2d00:	d9 f0       	breq	.+54     	; 0x2d38 <process_post+0x3e>
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
  }
  
  snum = (process_num_events_t)(fevent + nevents) % PROCESS_CONF_NUMEVENTS;
    2d02:	20 91 68 1c 	lds	r18, 0x1C68
    2d06:	27 0f       	add	r18, r23
    2d08:	2f 71       	andi	r18, 0x1F	; 31
    2d0a:	20 93 09 1d 	sts	0x1D09, r18
  events[snum].ev = ev;
    2d0e:	30 e0       	ldi	r19, 0x00	; 0
    2d10:	f9 01       	movw	r30, r18
    2d12:	ee 0f       	add	r30, r30
    2d14:	ff 1f       	adc	r31, r31
    2d16:	ee 0f       	add	r30, r30
    2d18:	ff 1f       	adc	r31, r31
    2d1a:	e2 0f       	add	r30, r18
    2d1c:	f3 1f       	adc	r31, r19
    2d1e:	e7 59       	subi	r30, 0x97	; 151
    2d20:	f3 4e       	sbci	r31, 0xE3	; 227
    2d22:	60 83       	st	Z, r22
  events[snum].data = data;
    2d24:	52 83       	std	Z+2, r21	; 0x02
    2d26:	41 83       	std	Z+1, r20	; 0x01
  events[snum].p = p;
    2d28:	94 83       	std	Z+4, r25	; 0x04
    2d2a:	83 83       	std	Z+3, r24	; 0x03
  ++nevents;
    2d2c:	7f 5f       	subi	r23, 0xFF	; 255
    2d2e:	70 93 67 1c 	sts	0x1C67, r23
  if(nevents > process_maxevents) {
    process_maxevents = nevents;
  }
#endif /* PROCESS_CONF_STATS */
  
  return PROCESS_ERR_OK;
    2d32:	20 e0       	ldi	r18, 0x00	; 0
    2d34:	30 e0       	ldi	r19, 0x00	; 0
    2d36:	02 c0       	rjmp	.+4      	; 0x2d3c <process_post+0x42>
      printf("soft panic: event queue is full when broadcast event %d was posted from %s\n", ev, PROCESS_NAME_STRING(process_current));
    } else {
      printf("soft panic: event queue is full when event %d was posted to %s frpm %s\n", ev, PROCESS_NAME_STRING(p), PROCESS_NAME_STRING(process_current));
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
    2d38:	21 e0       	ldi	r18, 0x01	; 1
    2d3a:	30 e0       	ldi	r19, 0x00	; 0
    process_maxevents = nevents;
  }
#endif /* PROCESS_CONF_STATS */
  
  return PROCESS_ERR_OK;
}
    2d3c:	c9 01       	movw	r24, r18
    2d3e:	08 95       	ret

00002d40 <process_post_synch>:
/*---------------------------------------------------------------------------*/
void
process_post_synch(struct process *p, process_event_t ev, process_data_t data)
{
    2d40:	cf 93       	push	r28
    2d42:	df 93       	push	r29
  struct process *caller = process_current;
    2d44:	c0 91 64 1c 	lds	r28, 0x1C64
    2d48:	d0 91 65 1c 	lds	r29, 0x1C65

  call_process(p, ev, data);
    2d4c:	0e 94 39 15 	call	0x2a72	; 0x2a72 <call_process>
  process_current = caller;
    2d50:	d0 93 65 1c 	sts	0x1C65, r29
    2d54:	c0 93 64 1c 	sts	0x1C64, r28
}
    2d58:	df 91       	pop	r29
    2d5a:	cf 91       	pop	r28
    2d5c:	08 95       	ret

00002d5e <process_start>:
  return lastevent++;
}
/*---------------------------------------------------------------------------*/
void
process_start(struct process *p, const char *arg)
{
    2d5e:	fc 01       	movw	r30, r24
    2d60:	ab 01       	movw	r20, r22
  struct process *q;

  /* First make sure that we don't try to start a process that is
     already running. */
  for(q = process_list; q != p && q != NULL; q = q->next);
    2d62:	90 91 62 1c 	lds	r25, 0x1C62
    2d66:	80 91 63 1c 	lds	r24, 0x1C63
    2d6a:	9c 01       	movw	r18, r24
    2d6c:	a3 2f       	mov	r26, r19
    2d6e:	b2 2f       	mov	r27, r18
    2d70:	03 c0       	rjmp	.+6      	; 0x2d78 <process_start+0x1a>
    2d72:	0d 90       	ld	r0, X+
    2d74:	bc 91       	ld	r27, X
    2d76:	a0 2d       	mov	r26, r0
    2d78:	ae 17       	cp	r26, r30
    2d7a:	bf 07       	cpc	r27, r31
    2d7c:	91 f0       	breq	.+36     	; 0x2da2 <process_start+0x44>
    2d7e:	10 97       	sbiw	r26, 0x00	; 0
    2d80:	c1 f7       	brne	.-16     	; 0x2d72 <process_start+0x14>

  /* If we found the process on the process list, we bail out. */
  if(q == p) {
    2d82:	30 97       	sbiw	r30, 0x00	; 0
    2d84:	71 f0       	breq	.+28     	; 0x2da2 <process_start+0x44>
    return;
  }
  /* Put on the procs list.*/
  p->next = process_list;
    2d86:	90 83       	st	Z, r25
    2d88:	81 83       	std	Z+1, r24	; 0x01
  process_list = p;
    2d8a:	f0 93 63 1c 	sts	0x1C63, r31
    2d8e:	e0 93 62 1c 	sts	0x1C62, r30
  p->state = PROCESS_STATE_RUNNING;
    2d92:	81 e0       	ldi	r24, 0x01	; 1
    2d94:	80 87       	std	Z+8, r24	; 0x08
  PT_INIT(&p->pt);
    2d96:	17 82       	std	Z+7, r1	; 0x07
    2d98:	16 82       	std	Z+6, r1	; 0x06

  PRINTF("process: starting '%s'\n", PROCESS_NAME_STRING(p));

  /* Post a synchronous initialization event to the process. */
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
    2d9a:	cf 01       	movw	r24, r30
    2d9c:	61 e8       	ldi	r22, 0x81	; 129
    2d9e:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <process_post_synch>
    2da2:	08 95       	ret

00002da4 <process_poll>:
  process_current = caller;
}
/*---------------------------------------------------------------------------*/
void
process_poll(struct process *p)
{
    2da4:	fc 01       	movw	r30, r24
  if(p != NULL) {
    2da6:	00 97       	sbiw	r24, 0x00	; 0
    2da8:	41 f0       	breq	.+16     	; 0x2dba <process_poll+0x16>
    if(p->state == PROCESS_STATE_RUNNING ||
    2daa:	80 85       	ldd	r24, Z+8	; 0x08
    2dac:	81 50       	subi	r24, 0x01	; 1
    2dae:	82 30       	cpi	r24, 0x02	; 2
    2db0:	20 f4       	brcc	.+8      	; 0x2dba <process_poll+0x16>
       p->state == PROCESS_STATE_CALLED) {
      p->needspoll = 1;
    2db2:	81 e0       	ldi	r24, 0x01	; 1
    2db4:	81 87       	std	Z+9, r24	; 0x09
      poll_requested = 1;
    2db6:	80 93 66 1c 	sts	0x1C66, r24
    2dba:	08 95       	ret

00002dbc <process_is_running>:
}
/*---------------------------------------------------------------------------*/
int
process_is_running(struct process *p)
{
  return p->state != PROCESS_STATE_NONE;
    2dbc:	21 e0       	ldi	r18, 0x01	; 1
    2dbe:	30 e0       	ldi	r19, 0x00	; 0
    2dc0:	fc 01       	movw	r30, r24
    2dc2:	80 85       	ldd	r24, Z+8	; 0x08
    2dc4:	88 23       	and	r24, r24
    2dc6:	11 f4       	brne	.+4      	; 0x2dcc <process_is_running+0x10>
    2dc8:	20 e0       	ldi	r18, 0x00	; 0
    2dca:	30 e0       	ldi	r19, 0x00	; 0
}
    2dcc:	c9 01       	movw	r24, r18
    2dce:	08 95       	ret

00002dd0 <update_time>:
{
  clock_time_t tdist;
  clock_time_t now;
  struct etimer *t;

  if (timerlist == NULL) {
    2dd0:	80 91 12 1d 	lds	r24, 0x1D12
    2dd4:	90 91 13 1d 	lds	r25, 0x1D13
    2dd8:	00 97       	sbiw	r24, 0x00	; 0
    2dda:	29 f4       	brne	.+10     	; 0x2de6 <update_time+0x16>
    next_expiration = 0;
    2ddc:	10 92 15 1d 	sts	0x1D15, r1
    2de0:	10 92 14 1d 	sts	0x1D14, r1
    2de4:	08 95       	ret
  } else {
    now = clock_time();
    2de6:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    t = timerlist;
    2dea:	e0 91 12 1d 	lds	r30, 0x1D12
    2dee:	f0 91 13 1d 	lds	r31, 0x1D13
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
    2df2:	22 81       	ldd	r18, Z+2	; 0x02
    2df4:	33 81       	ldd	r19, Z+3	; 0x03
    2df6:	40 81       	ld	r20, Z
    2df8:	51 81       	ldd	r21, Z+1	; 0x01
    2dfa:	24 0f       	add	r18, r20
    2dfc:	35 1f       	adc	r19, r21
    2dfe:	28 1b       	sub	r18, r24
    2e00:	39 0b       	sbc	r19, r25
    2e02:	0c c0       	rjmp	.+24     	; 0x2e1c <update_time+0x4c>
    for(t = t->next; t != NULL; t = t->next) {
      if(t->timer.start + t->timer.interval - now < tdist) {
    2e04:	42 81       	ldd	r20, Z+2	; 0x02
    2e06:	53 81       	ldd	r21, Z+3	; 0x03
    2e08:	60 81       	ld	r22, Z
    2e0a:	71 81       	ldd	r23, Z+1	; 0x01
    2e0c:	46 0f       	add	r20, r22
    2e0e:	57 1f       	adc	r21, r23
    2e10:	48 1b       	sub	r20, r24
    2e12:	59 0b       	sbc	r21, r25
  } else {
    now = clock_time();
    t = timerlist;
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
    for(t = t->next; t != NULL; t = t->next) {
    2e14:	42 17       	cp	r20, r18
    2e16:	53 07       	cpc	r21, r19
    2e18:	08 f4       	brcc	.+2      	; 0x2e1c <update_time+0x4c>
    2e1a:	9a 01       	movw	r18, r20
    2e1c:	04 80       	ldd	r0, Z+4	; 0x04
    2e1e:	f5 81       	ldd	r31, Z+5	; 0x05
    2e20:	e0 2d       	mov	r30, r0
    2e22:	30 97       	sbiw	r30, 0x00	; 0
    2e24:	79 f7       	brne	.-34     	; 0x2e04 <update_time+0x34>
      if(t->timer.start + t->timer.interval - now < tdist) {
	tdist = t->timer.start + t->timer.interval - now;
      }
    }
    next_expiration = now + tdist;
    2e26:	28 0f       	add	r18, r24
    2e28:	39 1f       	adc	r19, r25
    2e2a:	30 93 15 1d 	sts	0x1D15, r19
    2e2e:	20 93 14 1d 	sts	0x1D14, r18
    2e32:	08 95       	ret

00002e34 <etimer_request_poll>:
}
/*---------------------------------------------------------------------------*/
void
etimer_request_poll(void)
{
  process_poll(&etimer_process);
    2e34:	80 ec       	ldi	r24, 0xC0	; 192
    2e36:	9d e0       	ldi	r25, 0x0D	; 13
    2e38:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <process_poll>
}
    2e3c:	08 95       	ret

00002e3e <process_thread_etimer_process>:
    next_expiration = now + tdist;
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(etimer_process, ev, data)
{
    2e3e:	cf 92       	push	r12
    2e40:	df 92       	push	r13
    2e42:	ef 92       	push	r14
    2e44:	ff 92       	push	r15
    2e46:	0f 93       	push	r16
    2e48:	1f 93       	push	r17
    2e4a:	cf 93       	push	r28
    2e4c:	df 93       	push	r29
    2e4e:	7c 01       	movw	r14, r24
  struct etimer *t, *u;
	
  PROCESS_BEGIN();
    2e50:	fc 01       	movw	r30, r24
    2e52:	80 81       	ld	r24, Z
    2e54:	91 81       	ldd	r25, Z+1	; 0x01
    2e56:	00 97       	sbiw	r24, 0x00	; 0
    2e58:	29 f0       	breq	.+10     	; 0x2e64 <process_thread_etimer_process+0x26>
    2e5a:	89 35       	cpi	r24, 0x59	; 89
    2e5c:	91 05       	cpc	r25, r1
    2e5e:	09 f0       	breq	.+2      	; 0x2e62 <process_thread_etimer_process+0x24>
    2e60:	6e c0       	rjmp	.+220    	; 0x2f3e <process_thread_etimer_process+0x100>
    2e62:	0b c0       	rjmp	.+22     	; 0x2e7a <process_thread_etimer_process+0x3c>

  timerlist = NULL;
    2e64:	10 92 13 1d 	sts	0x1D13, r1
    2e68:	10 92 12 1d 	sts	0x1D12, r1
  
  while(1) {
    PROCESS_YIELD();
    2e6c:	89 e5       	ldi	r24, 0x59	; 89
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	f7 01       	movw	r30, r14
    2e72:	91 83       	std	Z+1, r25	; 0x01
    2e74:	80 83       	st	Z, r24
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	66 c0       	rjmp	.+204    	; 0x2f46 <process_thread_etimer_process+0x108>

    if(ev == PROCESS_EVENT_EXITED) {
    2e7a:	67 38       	cpi	r22, 0x87	; 135
    2e7c:	49 f5       	brne	.+82     	; 0x2ed0 <process_thread_etimer_process+0x92>
      struct process *p = data;
    2e7e:	ca 01       	movw	r24, r20
    2e80:	e0 91 12 1d 	lds	r30, 0x1D12
    2e84:	f0 91 13 1d 	lds	r31, 0x1D13

      while(timerlist != NULL && timerlist->p == p) {
    2e88:	03 c0       	rjmp	.+6      	; 0x2e90 <process_thread_etimer_process+0x52>
	timerlist = timerlist->next;
    2e8a:	04 80       	ldd	r0, Z+4	; 0x04
    2e8c:	f5 81       	ldd	r31, Z+5	; 0x05
    2e8e:	e0 2d       	mov	r30, r0
    PROCESS_YIELD();

    if(ev == PROCESS_EVENT_EXITED) {
      struct process *p = data;

      while(timerlist != NULL && timerlist->p == p) {
    2e90:	30 97       	sbiw	r30, 0x00	; 0
    2e92:	41 f3       	breq	.-48     	; 0x2e64 <process_thread_etimer_process+0x26>
    2e94:	26 81       	ldd	r18, Z+6	; 0x06
    2e96:	37 81       	ldd	r19, Z+7	; 0x07
    2e98:	28 17       	cp	r18, r24
    2e9a:	39 07       	cpc	r19, r25
    2e9c:	b1 f3       	breq	.-20     	; 0x2e8a <process_thread_etimer_process+0x4c>
    2e9e:	e0 93 12 1d 	sts	0x1D12, r30
    2ea2:	f0 93 13 1d 	sts	0x1D13, r31
    2ea6:	0f c0       	rjmp	.+30     	; 0x2ec6 <process_thread_etimer_process+0x88>
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
	  if(t->next->p == p) {
    2ea8:	16 96       	adiw	r26, 0x06	; 6
    2eaa:	2d 91       	ld	r18, X+
    2eac:	3c 91       	ld	r19, X
    2eae:	17 97       	sbiw	r26, 0x07	; 7
    2eb0:	28 17       	cp	r18, r24
    2eb2:	39 07       	cpc	r19, r25
    2eb4:	39 f4       	brne	.+14     	; 0x2ec4 <process_thread_etimer_process+0x86>
	    t->next = t->next->next;
    2eb6:	14 96       	adiw	r26, 0x04	; 4
    2eb8:	2d 91       	ld	r18, X+
    2eba:	3c 91       	ld	r19, X
    2ebc:	15 97       	sbiw	r26, 0x05	; 5
    2ebe:	35 83       	std	Z+5, r19	; 0x05
    2ec0:	24 83       	std	Z+4, r18	; 0x04
    2ec2:	df 01       	movw	r26, r30
    2ec4:	fd 01       	movw	r30, r26
	timerlist = timerlist->next;
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
    2ec6:	a4 81       	ldd	r26, Z+4	; 0x04
    2ec8:	b5 81       	ldd	r27, Z+5	; 0x05
    2eca:	10 97       	sbiw	r26, 0x00	; 0
    2ecc:	69 f7       	brne	.-38     	; 0x2ea8 <process_thread_etimer_process+0x6a>
    2ece:	ce cf       	rjmp	.-100    	; 0x2e6c <process_thread_etimer_process+0x2e>
	  } else
	    t = t->next;
	}
      }
      continue;
    } else if(ev != PROCESS_EVENT_POLL) {
    2ed0:	62 38       	cpi	r22, 0x82	; 130
    2ed2:	61 f6       	brne	.-104    	; 0x2e6c <process_thread_etimer_process+0x2e>

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
    2ed4:	c0 91 12 1d 	lds	r28, 0x1D12
    2ed8:	d0 91 13 1d 	lds	r29, 0x1D13
      continue;
    }

  again:
    
    u = NULL;
    2edc:	00 e0       	ldi	r16, 0x00	; 0
    2ede:	10 e0       	ldi	r17, 0x00	; 0
    
    for(t = timerlist; t != NULL; t = t->next) {
    2ee0:	2b c0       	rjmp	.+86     	; 0x2f38 <process_thread_etimer_process+0xfa>
      if(timer_expired(&t->timer)) {
    2ee2:	ce 01       	movw	r24, r28
    2ee4:	0e 94 de 2d 	call	0x5bbc	; 0x5bbc <timer_expired>
    2ee8:	00 97       	sbiw	r24, 0x00	; 0
    2eea:	f1 f0       	breq	.+60     	; 0x2f28 <process_thread_etimer_process+0xea>
	if(process_post(t->p, PROCESS_EVENT_TIMER, t) == PROCESS_ERR_OK) {
    2eec:	8e 81       	ldd	r24, Y+6	; 0x06
    2eee:	9f 81       	ldd	r25, Y+7	; 0x07
    2ef0:	68 e8       	ldi	r22, 0x88	; 136
    2ef2:	ae 01       	movw	r20, r28
    2ef4:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <process_post>
    2ef8:	00 97       	sbiw	r24, 0x00	; 0
    2efa:	a1 f4       	brne	.+40     	; 0x2f24 <process_thread_etimer_process+0xe6>
	  
	  /* Reset the process ID of the event timer, to signal that the
	     etimer has expired. This is later checked in the
	     etimer_expired() function. */
	  t->p = PROCESS_NONE;
    2efc:	1f 82       	std	Y+7, r1	; 0x07
    2efe:	1e 82       	std	Y+6, r1	; 0x06
    2f00:	8c 81       	ldd	r24, Y+4	; 0x04
    2f02:	9d 81       	ldd	r25, Y+5	; 0x05
	  if(u != NULL) {
    2f04:	01 15       	cp	r16, r1
    2f06:	11 05       	cpc	r17, r1
    2f08:	21 f0       	breq	.+8      	; 0x2f12 <process_thread_etimer_process+0xd4>
	    u->next = t->next;
    2f0a:	f8 01       	movw	r30, r16
    2f0c:	95 83       	std	Z+5, r25	; 0x05
    2f0e:	84 83       	std	Z+4, r24	; 0x04
    2f10:	04 c0       	rjmp	.+8      	; 0x2f1a <process_thread_etimer_process+0xdc>
	  } else {
	    timerlist = t->next;
    2f12:	90 93 13 1d 	sts	0x1D13, r25
    2f16:	80 93 12 1d 	sts	0x1D12, r24
	  }
	  t->next = NULL;
    2f1a:	1d 82       	std	Y+5, r1	; 0x05
    2f1c:	1c 82       	std	Y+4, r1	; 0x04
	  update_time();
    2f1e:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <update_time>
	  goto again;
    2f22:	d8 cf       	rjmp	.-80     	; 0x2ed4 <process_thread_etimer_process+0x96>
	} else {
	  etimer_request_poll();
    2f24:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <etimer_request_poll>

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
    2f28:	8e 01       	movw	r16, r28
    2f2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f2e:	c9 2e       	mov	r12, r25
    2f30:	e6 01       	movw	r28, r12
    2f32:	6e 01       	movw	r12, r28
    2f34:	d8 2e       	mov	r13, r24
    2f36:	e6 01       	movw	r28, r12
    2f38:	20 97       	sbiw	r28, 0x00	; 0
    2f3a:	99 f6       	brne	.-90     	; 0x2ee2 <process_thread_etimer_process+0xa4>
    2f3c:	97 cf       	rjmp	.-210    	; 0x2e6c <process_thread_etimer_process+0x2e>
      u = t;
    }
    
  }
  
  PROCESS_END();
    2f3e:	f7 01       	movw	r30, r14
    2f40:	11 82       	std	Z+1, r1	; 0x01
    2f42:	10 82       	st	Z, r1
    2f44:	83 e0       	ldi	r24, 0x03	; 3
}
    2f46:	df 91       	pop	r29
    2f48:	cf 91       	pop	r28
    2f4a:	1f 91       	pop	r17
    2f4c:	0f 91       	pop	r16
    2f4e:	ff 90       	pop	r15
    2f50:	ef 90       	pop	r14
    2f52:	df 90       	pop	r13
    2f54:	cf 90       	pop	r12
    2f56:	08 95       	ret

00002f58 <add_timer>:
  process_poll(&etimer_process);
}
/*---------------------------------------------------------------------------*/
static void
add_timer(struct etimer *timer)
{
    2f58:	cf 93       	push	r28
    2f5a:	df 93       	push	r29
    2f5c:	ec 01       	movw	r28, r24
  struct etimer *t;

  etimer_request_poll();
    2f5e:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <etimer_request_poll>

  if(timer->p != PROCESS_NONE) {
    2f62:	8e 81       	ldd	r24, Y+6	; 0x06
    2f64:	9f 81       	ldd	r25, Y+7	; 0x07
    2f66:	00 97       	sbiw	r24, 0x00	; 0
    2f68:	69 f0       	breq	.+26     	; 0x2f84 <add_timer+0x2c>
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
    2f6a:	e0 91 12 1d 	lds	r30, 0x1D12
    2f6e:	f0 91 13 1d 	lds	r31, 0x1D13
    2f72:	06 c0       	rjmp	.+12     	; 0x2f80 <add_timer+0x28>
      if(t == timer) {
    2f74:	ec 17       	cp	r30, r28
    2f76:	fd 07       	cpc	r31, r29
    2f78:	a9 f0       	breq	.+42     	; 0x2fa4 <add_timer+0x4c>
  etimer_request_poll();

  if(timer->p != PROCESS_NONE) {
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
    2f7a:	04 80       	ldd	r0, Z+4	; 0x04
    2f7c:	f5 81       	ldd	r31, Z+5	; 0x05
    2f7e:	e0 2d       	mov	r30, r0
    2f80:	30 97       	sbiw	r30, 0x00	; 0
    2f82:	c1 f7       	brne	.-16     	; 0x2f74 <add_timer+0x1c>
	return;
      }
    }
  }

  timer->p = PROCESS_CURRENT();
    2f84:	80 91 64 1c 	lds	r24, 0x1C64
    2f88:	90 91 65 1c 	lds	r25, 0x1C65
    2f8c:	9f 83       	std	Y+7, r25	; 0x07
    2f8e:	8e 83       	std	Y+6, r24	; 0x06
  timer->next = timerlist;
    2f90:	80 91 12 1d 	lds	r24, 0x1D12
    2f94:	90 91 13 1d 	lds	r25, 0x1D13
    2f98:	9d 83       	std	Y+5, r25	; 0x05
    2f9a:	8c 83       	std	Y+4, r24	; 0x04
  timerlist = timer;
    2f9c:	d0 93 13 1d 	sts	0x1D13, r29
    2fa0:	c0 93 12 1d 	sts	0x1D12, r28

  update_time();
    2fa4:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <update_time>
}
    2fa8:	df 91       	pop	r29
    2faa:	cf 91       	pop	r28
    2fac:	08 95       	ret

00002fae <etimer_set>:
/*---------------------------------------------------------------------------*/
void
etimer_set(struct etimer *et, clock_time_t interval)
{
    2fae:	cf 93       	push	r28
    2fb0:	df 93       	push	r29
    2fb2:	ec 01       	movw	r28, r24
  timer_set(&et->timer, interval);
    2fb4:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <timer_set>
  add_timer(et);
    2fb8:	ce 01       	movw	r24, r28
    2fba:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <add_timer>
}
    2fbe:	df 91       	pop	r29
    2fc0:	cf 91       	pop	r28
    2fc2:	08 95       	ret

00002fc4 <etimer_reset>:
/*---------------------------------------------------------------------------*/
void
etimer_reset(struct etimer *et)
{
    2fc4:	cf 93       	push	r28
    2fc6:	df 93       	push	r29
    2fc8:	ec 01       	movw	r28, r24
  timer_reset(&et->timer);
    2fca:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <timer_reset>
  add_timer(et);
    2fce:	ce 01       	movw	r24, r28
    2fd0:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <add_timer>
}
    2fd4:	df 91       	pop	r29
    2fd6:	cf 91       	pop	r28
    2fd8:	08 95       	ret

00002fda <etimer_restart>:
/*---------------------------------------------------------------------------*/
void
etimer_restart(struct etimer *et)
{
    2fda:	cf 93       	push	r28
    2fdc:	df 93       	push	r29
    2fde:	ec 01       	movw	r28, r24
  timer_restart(&et->timer);
    2fe0:	0e 94 d4 2d 	call	0x5ba8	; 0x5ba8 <timer_restart>
  add_timer(et);
    2fe4:	ce 01       	movw	r24, r28
    2fe6:	0e 94 ac 17 	call	0x2f58	; 0x2f58 <add_timer>
}
    2fea:	df 91       	pop	r29
    2fec:	cf 91       	pop	r28
    2fee:	08 95       	ret

00002ff0 <etimer_adjust>:
/*---------------------------------------------------------------------------*/
void
etimer_adjust(struct etimer *et, int timediff)
{
    2ff0:	fc 01       	movw	r30, r24
  et->timer.start += timediff;
    2ff2:	80 81       	ld	r24, Z
    2ff4:	91 81       	ldd	r25, Z+1	; 0x01
    2ff6:	86 0f       	add	r24, r22
    2ff8:	97 1f       	adc	r25, r23
    2ffa:	91 83       	std	Z+1, r25	; 0x01
    2ffc:	80 83       	st	Z, r24
  update_time();
    2ffe:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <update_time>
}
    3002:	08 95       	ret

00003004 <etimer_expired>:
/*---------------------------------------------------------------------------*/
int
etimer_expired(struct etimer *et)
{
  return et->p == PROCESS_NONE;
    3004:	21 e0       	ldi	r18, 0x01	; 1
    3006:	30 e0       	ldi	r19, 0x00	; 0
    3008:	fc 01       	movw	r30, r24
    300a:	86 81       	ldd	r24, Z+6	; 0x06
    300c:	97 81       	ldd	r25, Z+7	; 0x07
    300e:	00 97       	sbiw	r24, 0x00	; 0
    3010:	11 f0       	breq	.+4      	; 0x3016 <etimer_expired+0x12>
    3012:	20 e0       	ldi	r18, 0x00	; 0
    3014:	30 e0       	ldi	r19, 0x00	; 0
}
    3016:	c9 01       	movw	r24, r18
    3018:	08 95       	ret

0000301a <etimer_expiration_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_expiration_time(struct etimer *et)
{
    301a:	fc 01       	movw	r30, r24
  return et->timer.start + et->timer.interval;
    301c:	22 81       	ldd	r18, Z+2	; 0x02
    301e:	33 81       	ldd	r19, Z+3	; 0x03
    3020:	80 81       	ld	r24, Z
    3022:	91 81       	ldd	r25, Z+1	; 0x01
    3024:	28 0f       	add	r18, r24
    3026:	39 1f       	adc	r19, r25
}
    3028:	c9 01       	movw	r24, r18
    302a:	08 95       	ret

0000302c <etimer_start_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_start_time(struct etimer *et)
{
    302c:	fc 01       	movw	r30, r24
  return et->timer.start;
}
    302e:	80 81       	ld	r24, Z
    3030:	91 81       	ldd	r25, Z+1	; 0x01
    3032:	08 95       	ret

00003034 <etimer_pending>:
/*---------------------------------------------------------------------------*/
int
etimer_pending(void)
{
  return timerlist != NULL;
    3034:	21 e0       	ldi	r18, 0x01	; 1
    3036:	30 e0       	ldi	r19, 0x00	; 0
    3038:	80 91 12 1d 	lds	r24, 0x1D12
    303c:	90 91 13 1d 	lds	r25, 0x1D13
    3040:	00 97       	sbiw	r24, 0x00	; 0
    3042:	11 f4       	brne	.+4      	; 0x3048 <etimer_pending+0x14>
    3044:	20 e0       	ldi	r18, 0x00	; 0
    3046:	30 e0       	ldi	r19, 0x00	; 0
}
    3048:	c9 01       	movw	r24, r18
    304a:	08 95       	ret

0000304c <etimer_next_expiration_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_next_expiration_time(void)
{
  return etimer_pending() ? next_expiration : 0;
    304c:	80 91 12 1d 	lds	r24, 0x1D12
    3050:	90 91 13 1d 	lds	r25, 0x1D13
    3054:	00 97       	sbiw	r24, 0x00	; 0
    3056:	29 f0       	breq	.+10     	; 0x3062 <etimer_next_expiration_time+0x16>
    3058:	20 91 14 1d 	lds	r18, 0x1D14
    305c:	30 91 15 1d 	lds	r19, 0x1D15
    3060:	02 c0       	rjmp	.+4      	; 0x3066 <etimer_next_expiration_time+0x1a>
    3062:	20 e0       	ldi	r18, 0x00	; 0
    3064:	30 e0       	ldi	r19, 0x00	; 0
}
    3066:	c9 01       	movw	r24, r18
    3068:	08 95       	ret

0000306a <etimer_stop>:
/*---------------------------------------------------------------------------*/
void
etimer_stop(struct etimer *et)
{
    306a:	cf 93       	push	r28
    306c:	df 93       	push	r29
    306e:	ec 01       	movw	r28, r24
  struct etimer *t;

  /* First check if et is the first event timer on the list. */
  if(et == timerlist) {
    3070:	e0 91 12 1d 	lds	r30, 0x1D12
    3074:	f0 91 13 1d 	lds	r31, 0x1D13
    3078:	8e 17       	cp	r24, r30
    307a:	9f 07       	cpc	r25, r31
    307c:	41 f4       	brne	.+16     	; 0x308e <etimer_stop+0x24>
    timerlist = timerlist->next;
    307e:	8c 81       	ldd	r24, Y+4	; 0x04
    3080:	9d 81       	ldd	r25, Y+5	; 0x05
    3082:	90 93 13 1d 	sts	0x1D13, r25
    3086:	80 93 12 1d 	sts	0x1D12, r24
    308a:	14 c0       	rjmp	.+40     	; 0x30b4 <etimer_stop+0x4a>
    update_time();
  } else {
    /* Else walk through the list and try to find the item before the
       et timer. */
    for(t = timerlist; t != NULL && t->next != et; t = t->next);
    308c:	fc 01       	movw	r30, r24
    308e:	30 97       	sbiw	r30, 0x00	; 0
    3090:	31 f0       	breq	.+12     	; 0x309e <etimer_stop+0x34>
    3092:	84 81       	ldd	r24, Z+4	; 0x04
    3094:	95 81       	ldd	r25, Z+5	; 0x05
    3096:	8c 17       	cp	r24, r28
    3098:	9d 07       	cpc	r25, r29
    309a:	c1 f7       	brne	.-16     	; 0x308c <etimer_stop+0x22>
    309c:	07 c0       	rjmp	.+14     	; 0x30ac <etimer_stop+0x42>
      update_time();
    }
  }

  /* Remove the next pointer from the item to be removed. */
  et->next = NULL;
    309e:	1d 82       	std	Y+5, r1	; 0x05
    30a0:	1c 82       	std	Y+4, r1	; 0x04
  /* Set the timer as expired */
  et->p = PROCESS_NONE;
    30a2:	1f 82       	std	Y+7, r1	; 0x07
    30a4:	1e 82       	std	Y+6, r1	; 0x06
}
    30a6:	df 91       	pop	r29
    30a8:	cf 91       	pop	r28
    30aa:	08 95       	ret

    if(t != NULL) {
      /* We've found the item before the event timer that we are about
	 to remove. We point the items next pointer to the event after
	 the removed item. */
      t->next = et->next;
    30ac:	8c 81       	ldd	r24, Y+4	; 0x04
    30ae:	9d 81       	ldd	r25, Y+5	; 0x05
    30b0:	95 83       	std	Z+5, r25	; 0x05
    30b2:	84 83       	std	Z+4, r24	; 0x04

      update_time();
    30b4:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <update_time>
    30b8:	f2 cf       	rjmp	.-28     	; 0x309e <etimer_stop+0x34>

000030ba <process_thread_ctimer_process>:
#endif

/*---------------------------------------------------------------------------*/
PROCESS(ctimer_process, "Ctimer process");
PROCESS_THREAD(ctimer_process, ev, data)
{
    30ba:	cf 92       	push	r12
    30bc:	df 92       	push	r13
    30be:	ef 92       	push	r14
    30c0:	ff 92       	push	r15
    30c2:	0f 93       	push	r16
    30c4:	1f 93       	push	r17
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	8c 01       	movw	r16, r24
    30cc:	7a 01       	movw	r14, r20
  struct ctimer *c;
  PROCESS_BEGIN();
    30ce:	fc 01       	movw	r30, r24
    30d0:	80 81       	ld	r24, Z
    30d2:	91 81       	ldd	r25, Z+1	; 0x01
    30d4:	00 97       	sbiw	r24, 0x00	; 0
    30d6:	29 f0       	breq	.+10     	; 0x30e2 <process_thread_ctimer_process+0x28>
    30d8:	8a 34       	cpi	r24, 0x4A	; 74
    30da:	91 05       	cpc	r25, r1
    30dc:	09 f0       	breq	.+2      	; 0x30e0 <process_thread_ctimer_process+0x26>
    30de:	51 c0       	rjmp	.+162    	; 0x3182 <process_thread_ctimer_process+0xc8>
    30e0:	1e c0       	rjmp	.+60     	; 0x311e <process_thread_ctimer_process+0x64>

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    30e2:	87 e1       	ldi	r24, 0x17	; 23
    30e4:	9d e1       	ldi	r25, 0x1D	; 29
    30e6:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    30ea:	c8 2e       	mov	r12, r24
    30ec:	e6 01       	movw	r28, r12
    30ee:	7e 01       	movw	r14, r28
    30f0:	f9 2e       	mov	r15, r25
    30f2:	e7 01       	movw	r28, r14
    30f4:	09 c0       	rjmp	.+18     	; 0x3108 <process_thread_ctimer_process+0x4e>
    etimer_set(&c->etimer, c->etimer.timer.interval);
    30f6:	6c 81       	ldd	r22, Y+4	; 0x04
    30f8:	7d 81       	ldd	r23, Y+5	; 0x05
    30fa:	ce 01       	movw	r24, r28
    30fc:	02 96       	adiw	r24, 0x02	; 2
    30fe:	0e 94 d7 17 	call	0x2fae	; 0x2fae <etimer_set>
PROCESS_THREAD(ctimer_process, ev, data)
{
  struct ctimer *c;
  PROCESS_BEGIN();

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    3102:	09 90       	ld	r0, Y+
    3104:	d8 81       	ld	r29, Y
    3106:	c0 2d       	mov	r28, r0
    3108:	20 97       	sbiw	r28, 0x00	; 0
    310a:	a9 f7       	brne	.-22     	; 0x30f6 <process_thread_ctimer_process+0x3c>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;
    310c:	81 e0       	ldi	r24, 0x01	; 1
    310e:	80 93 16 1d 	sts	0x1D16, r24

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    3112:	8a e4       	ldi	r24, 0x4A	; 74
    3114:	90 e0       	ldi	r25, 0x00	; 0
    3116:	f8 01       	movw	r30, r16
    3118:	91 83       	std	Z+1, r25	; 0x01
    311a:	80 83       	st	Z, r24
    311c:	37 c0       	rjmp	.+110    	; 0x318c <process_thread_ctimer_process+0xd2>
    311e:	68 38       	cpi	r22, 0x88	; 136
    3120:	a9 f5       	brne	.+106    	; 0x318c <process_thread_ctimer_process+0xd2>
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    3122:	87 e1       	ldi	r24, 0x17	; 23
    3124:	9d e1       	ldi	r25, 0x1D	; 29
    3126:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    312a:	c8 2e       	mov	r12, r24
    312c:	e6 01       	movw	r28, r12
    312e:	6e 01       	movw	r12, r28
    3130:	d9 2e       	mov	r13, r25
    3132:	e6 01       	movw	r28, r12
    3134:	23 c0       	rjmp	.+70     	; 0x317c <process_thread_ctimer_process+0xc2>
      if(&c->etimer == data) {
    3136:	ce 01       	movw	r24, r28
    3138:	02 96       	adiw	r24, 0x02	; 2
    313a:	e8 16       	cp	r14, r24
    313c:	f9 06       	cpc	r15, r25
    313e:	d9 f4       	brne	.+54     	; 0x3176 <process_thread_ctimer_process+0xbc>
	list_remove(ctimer_list, c);
    3140:	87 e1       	ldi	r24, 0x17	; 23
    3142:	9d e1       	ldi	r25, 0x1D	; 29
    3144:	be 01       	movw	r22, r28
    3146:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
	PROCESS_CONTEXT_BEGIN(c->p);
    314a:	e0 90 64 1c 	lds	r14, 0x1C64
    314e:	f0 90 65 1c 	lds	r15, 0x1C65
    3152:	8a 85       	ldd	r24, Y+10	; 0x0a
    3154:	9b 85       	ldd	r25, Y+11	; 0x0b
    3156:	90 93 65 1c 	sts	0x1C65, r25
    315a:	80 93 64 1c 	sts	0x1C64, r24
	if(c->f != NULL) {
    315e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3160:	fd 85       	ldd	r31, Y+13	; 0x0d
    3162:	30 97       	sbiw	r30, 0x00	; 0
    3164:	19 f0       	breq	.+6      	; 0x316c <process_thread_ctimer_process+0xb2>
	  c->f(c->ptr);
    3166:	8e 85       	ldd	r24, Y+14	; 0x0e
    3168:	9f 85       	ldd	r25, Y+15	; 0x0f
    316a:	09 95       	icall
	}
	PROCESS_CONTEXT_END(c->p);
    316c:	f0 92 65 1c 	sts	0x1C65, r15
    3170:	e0 92 64 1c 	sts	0x1C64, r14
	break;
    3174:	ce cf       	rjmp	.-100    	; 0x3112 <process_thread_ctimer_process+0x58>
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    3176:	09 90       	ld	r0, Y+
    3178:	d8 81       	ld	r29, Y
    317a:	c0 2d       	mov	r28, r0
    317c:	20 97       	sbiw	r28, 0x00	; 0
    317e:	d9 f6       	brne	.-74     	; 0x3136 <process_thread_ctimer_process+0x7c>
    3180:	c8 cf       	rjmp	.-112    	; 0x3112 <process_thread_ctimer_process+0x58>
	PROCESS_CONTEXT_END(c->p);
	break;
      }
    }
  }
  PROCESS_END();
    3182:	f8 01       	movw	r30, r16
    3184:	11 82       	std	Z+1, r1	; 0x01
    3186:	10 82       	st	Z, r1
    3188:	83 e0       	ldi	r24, 0x03	; 3
    318a:	01 c0       	rjmp	.+2      	; 0x318e <process_thread_ctimer_process+0xd4>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    318c:	81 e0       	ldi	r24, 0x01	; 1
	break;
      }
    }
  }
  PROCESS_END();
}
    318e:	df 91       	pop	r29
    3190:	cf 91       	pop	r28
    3192:	1f 91       	pop	r17
    3194:	0f 91       	pop	r16
    3196:	ff 90       	pop	r15
    3198:	ef 90       	pop	r14
    319a:	df 90       	pop	r13
    319c:	cf 90       	pop	r12
    319e:	08 95       	ret

000031a0 <ctimer_init>:
/*---------------------------------------------------------------------------*/
void
ctimer_init(void)
{
  initialized = 0;
    31a0:	10 92 16 1d 	sts	0x1D16, r1
  list_init(ctimer_list);
    31a4:	87 e1       	ldi	r24, 0x17	; 23
    31a6:	9d e1       	ldi	r25, 0x1D	; 29
    31a8:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <list_init>
  process_start(&ctimer_process, NULL);
    31ac:	89 ed       	ldi	r24, 0xD9	; 217
    31ae:	9d e0       	ldi	r25, 0x0D	; 13
    31b0:	60 e0       	ldi	r22, 0x00	; 0
    31b2:	70 e0       	ldi	r23, 0x00	; 0
    31b4:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <process_start>
}
    31b8:	08 95       	ret

000031ba <ctimer_set>:
/*---------------------------------------------------------------------------*/
void
ctimer_set(struct ctimer *c, clock_time_t t,
	   void (*f)(void *), void *ptr)
{
    31ba:	0f 93       	push	r16
    31bc:	1f 93       	push	r17
    31be:	cf 93       	push	r28
    31c0:	df 93       	push	r29
    31c2:	ec 01       	movw	r28, r24
  PRINTF("ctimer_set %p %u\n", c, (unsigned)t);
  c->p = PROCESS_CURRENT();
    31c4:	00 91 64 1c 	lds	r16, 0x1C64
    31c8:	10 91 65 1c 	lds	r17, 0x1C65
    31cc:	1b 87       	std	Y+11, r17	; 0x0b
    31ce:	0a 87       	std	Y+10, r16	; 0x0a
  c->f = f;
    31d0:	5d 87       	std	Y+13, r21	; 0x0d
    31d2:	4c 87       	std	Y+12, r20	; 0x0c
  c->ptr = ptr;
    31d4:	3f 87       	std	Y+15, r19	; 0x0f
    31d6:	2e 87       	std	Y+14, r18	; 0x0e
  if(initialized) {
    31d8:	80 91 16 1d 	lds	r24, 0x1D16
    31dc:	88 23       	and	r24, r24
    31de:	79 f0       	breq	.+30     	; 0x31fe <ctimer_set+0x44>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    31e0:	89 ed       	ldi	r24, 0xD9	; 217
    31e2:	9d e0       	ldi	r25, 0x0D	; 13
    31e4:	90 93 65 1c 	sts	0x1C65, r25
    31e8:	80 93 64 1c 	sts	0x1C64, r24
    etimer_set(&c->etimer, t);
    31ec:	ce 01       	movw	r24, r28
    31ee:	02 96       	adiw	r24, 0x02	; 2
    31f0:	0e 94 d7 17 	call	0x2fae	; 0x2fae <etimer_set>
    PROCESS_CONTEXT_END(&ctimer_process);
    31f4:	10 93 65 1c 	sts	0x1C65, r17
    31f8:	00 93 64 1c 	sts	0x1C64, r16
    31fc:	02 c0       	rjmp	.+4      	; 0x3202 <ctimer_set+0x48>
  } else {
    c->etimer.timer.interval = t;
    31fe:	7d 83       	std	Y+5, r23	; 0x05
    3200:	6c 83       	std	Y+4, r22	; 0x04
  }

  list_remove(ctimer_list, c);
    3202:	87 e1       	ldi	r24, 0x17	; 23
    3204:	9d e1       	ldi	r25, 0x1D	; 29
    3206:	be 01       	movw	r22, r28
    3208:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
  list_add(ctimer_list, c);
    320c:	87 e1       	ldi	r24, 0x17	; 23
    320e:	9d e1       	ldi	r25, 0x1D	; 29
    3210:	be 01       	movw	r22, r28
    3212:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <list_add>
}
    3216:	df 91       	pop	r29
    3218:	cf 91       	pop	r28
    321a:	1f 91       	pop	r17
    321c:	0f 91       	pop	r16
    321e:	08 95       	ret

00003220 <ctimer_reset>:
/*---------------------------------------------------------------------------*/
void
ctimer_reset(struct ctimer *c)
{
    3220:	0f 93       	push	r16
    3222:	1f 93       	push	r17
    3224:	cf 93       	push	r28
    3226:	df 93       	push	r29
    3228:	ec 01       	movw	r28, r24
  if(initialized) {
    322a:	80 91 16 1d 	lds	r24, 0x1D16
    322e:	88 23       	and	r24, r24
    3230:	91 f0       	breq	.+36     	; 0x3256 <ctimer_reset+0x36>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    3232:	00 91 64 1c 	lds	r16, 0x1C64
    3236:	10 91 65 1c 	lds	r17, 0x1C65
    323a:	89 ed       	ldi	r24, 0xD9	; 217
    323c:	9d e0       	ldi	r25, 0x0D	; 13
    323e:	90 93 65 1c 	sts	0x1C65, r25
    3242:	80 93 64 1c 	sts	0x1C64, r24
    etimer_reset(&c->etimer);
    3246:	ce 01       	movw	r24, r28
    3248:	02 96       	adiw	r24, 0x02	; 2
    324a:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <etimer_reset>
    PROCESS_CONTEXT_END(&ctimer_process);
    324e:	10 93 65 1c 	sts	0x1C65, r17
    3252:	00 93 64 1c 	sts	0x1C64, r16
  }

  list_remove(ctimer_list, c);
    3256:	87 e1       	ldi	r24, 0x17	; 23
    3258:	9d e1       	ldi	r25, 0x1D	; 29
    325a:	be 01       	movw	r22, r28
    325c:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
  list_add(ctimer_list, c);
    3260:	87 e1       	ldi	r24, 0x17	; 23
    3262:	9d e1       	ldi	r25, 0x1D	; 29
    3264:	be 01       	movw	r22, r28
    3266:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <list_add>
}
    326a:	df 91       	pop	r29
    326c:	cf 91       	pop	r28
    326e:	1f 91       	pop	r17
    3270:	0f 91       	pop	r16
    3272:	08 95       	ret

00003274 <ctimer_restart>:
/*---------------------------------------------------------------------------*/
void
ctimer_restart(struct ctimer *c)
{
    3274:	0f 93       	push	r16
    3276:	1f 93       	push	r17
    3278:	cf 93       	push	r28
    327a:	df 93       	push	r29
    327c:	ec 01       	movw	r28, r24
  if(initialized) {
    327e:	80 91 16 1d 	lds	r24, 0x1D16
    3282:	88 23       	and	r24, r24
    3284:	91 f0       	breq	.+36     	; 0x32aa <ctimer_restart+0x36>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    3286:	00 91 64 1c 	lds	r16, 0x1C64
    328a:	10 91 65 1c 	lds	r17, 0x1C65
    328e:	89 ed       	ldi	r24, 0xD9	; 217
    3290:	9d e0       	ldi	r25, 0x0D	; 13
    3292:	90 93 65 1c 	sts	0x1C65, r25
    3296:	80 93 64 1c 	sts	0x1C64, r24
    etimer_restart(&c->etimer);
    329a:	ce 01       	movw	r24, r28
    329c:	02 96       	adiw	r24, 0x02	; 2
    329e:	0e 94 ed 17 	call	0x2fda	; 0x2fda <etimer_restart>
    PROCESS_CONTEXT_END(&ctimer_process);
    32a2:	10 93 65 1c 	sts	0x1C65, r17
    32a6:	00 93 64 1c 	sts	0x1C64, r16
  }

  list_remove(ctimer_list, c);
    32aa:	87 e1       	ldi	r24, 0x17	; 23
    32ac:	9d e1       	ldi	r25, 0x1D	; 29
    32ae:	be 01       	movw	r22, r28
    32b0:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
  list_add(ctimer_list, c);
    32b4:	87 e1       	ldi	r24, 0x17	; 23
    32b6:	9d e1       	ldi	r25, 0x1D	; 29
    32b8:	be 01       	movw	r22, r28
    32ba:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <list_add>
}
    32be:	df 91       	pop	r29
    32c0:	cf 91       	pop	r28
    32c2:	1f 91       	pop	r17
    32c4:	0f 91       	pop	r16
    32c6:	08 95       	ret

000032c8 <ctimer_stop>:
/*---------------------------------------------------------------------------*/
void
ctimer_stop(struct ctimer *c)
{
    32c8:	cf 93       	push	r28
    32ca:	df 93       	push	r29
    32cc:	ec 01       	movw	r28, r24
  if(initialized) {
    32ce:	80 91 16 1d 	lds	r24, 0x1D16
    32d2:	88 23       	and	r24, r24
    32d4:	29 f0       	breq	.+10     	; 0x32e0 <ctimer_stop+0x18>
    etimer_stop(&c->etimer);
    32d6:	ce 01       	movw	r24, r28
    32d8:	02 96       	adiw	r24, 0x02	; 2
    32da:	0e 94 35 18 	call	0x306a	; 0x306a <etimer_stop>
    32de:	04 c0       	rjmp	.+8      	; 0x32e8 <ctimer_stop+0x20>
  } else {
    c->etimer.next = NULL;
    32e0:	1f 82       	std	Y+7, r1	; 0x07
    32e2:	1e 82       	std	Y+6, r1	; 0x06
    c->etimer.p = PROCESS_NONE;
    32e4:	19 86       	std	Y+9, r1	; 0x09
    32e6:	18 86       	std	Y+8, r1	; 0x08
  }
  list_remove(ctimer_list, c);
    32e8:	87 e1       	ldi	r24, 0x17	; 23
    32ea:	9d e1       	ldi	r25, 0x1D	; 29
    32ec:	be 01       	movw	r22, r28
    32ee:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
}
    32f2:	df 91       	pop	r29
    32f4:	cf 91       	pop	r28
    32f6:	08 95       	ret

000032f8 <ctimer_expired>:
/*---------------------------------------------------------------------------*/
int
ctimer_expired(struct ctimer *c)
{
    32f8:	cf 93       	push	r28
    32fa:	df 93       	push	r29
    32fc:	ec 01       	movw	r28, r24
  struct ctimer *t;
  if(initialized) {
    32fe:	80 91 16 1d 	lds	r24, 0x1D16
    3302:	88 23       	and	r24, r24
    3304:	31 f0       	breq	.+12     	; 0x3312 <ctimer_expired+0x1a>
    return etimer_expired(&c->etimer);
    3306:	ce 01       	movw	r24, r28
    3308:	02 96       	adiw	r24, 0x02	; 2
    330a:	0e 94 02 18 	call	0x3004	; 0x3004 <etimer_expired>
    330e:	9c 01       	movw	r18, r24
    3310:	14 c0       	rjmp	.+40     	; 0x333a <ctimer_expired+0x42>
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    3312:	87 e1       	ldi	r24, 0x17	; 23
    3314:	9d e1       	ldi	r25, 0x1D	; 29
    3316:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    331a:	e8 2f       	mov	r30, r24
    331c:	f9 2f       	mov	r31, r25
    331e:	06 c0       	rjmp	.+12     	; 0x332c <ctimer_expired+0x34>
    if(t == c) {
    3320:	ec 17       	cp	r30, r28
    3322:	fd 07       	cpc	r31, r29
    3324:	41 f0       	breq	.+16     	; 0x3336 <ctimer_expired+0x3e>
{
  struct ctimer *t;
  if(initialized) {
    return etimer_expired(&c->etimer);
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    3326:	01 90       	ld	r0, Z+
    3328:	f0 81       	ld	r31, Z
    332a:	e0 2d       	mov	r30, r0
    332c:	30 97       	sbiw	r30, 0x00	; 0
    332e:	c1 f7       	brne	.-16     	; 0x3320 <ctimer_expired+0x28>
    if(t == c) {
      return 0;
    }
  }
  return 1;
    3330:	21 e0       	ldi	r18, 0x01	; 1
    3332:	30 e0       	ldi	r19, 0x00	; 0
    3334:	02 c0       	rjmp	.+4      	; 0x333a <ctimer_expired+0x42>
  if(initialized) {
    return etimer_expired(&c->etimer);
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    if(t == c) {
      return 0;
    3336:	20 e0       	ldi	r18, 0x00	; 0
    3338:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 1;
}
    333a:	c9 01       	movw	r24, r18
    333c:	df 91       	pop	r29
    333e:	cf 91       	pop	r28
    3340:	08 95       	ret

00003342 <rng_get_uint8>:
uint8_t
rng_get_uint8(void) {
#if 1
  /* Upper two RSSI reg bits (RND_VALUE) are random in rf231 */
  uint8_t j;
  j = (PHY_RSSI&0xc0) + ((PHY_RSSI>>2)&0x30) + ((PHY_RSSI>>4)&0x0c) + ((PHY_RSSI>>6)&0x03);
    3342:	e6 e4       	ldi	r30, 0x46	; 70
    3344:	f1 e0       	ldi	r31, 0x01	; 1
    3346:	30 81       	ld	r19, Z
    3348:	20 81       	ld	r18, Z
    334a:	90 81       	ld	r25, Z
    334c:	80 81       	ld	r24, Z
    334e:	82 95       	swap	r24
    3350:	86 95       	lsr	r24
    3352:	86 95       	lsr	r24
    3354:	83 70       	andi	r24, 0x03	; 3
    3356:	30 7c       	andi	r19, 0xC0	; 192
    3358:	83 0f       	add	r24, r19
    335a:	26 95       	lsr	r18
    335c:	26 95       	lsr	r18
    335e:	20 73       	andi	r18, 0x30	; 48
    3360:	82 0f       	add	r24, r18
    3362:	92 95       	swap	r25
    3364:	9c 70       	andi	r25, 0x0C	; 12
  }
  ADCSRA=0;                   //Disable ADC
#endif
  PRINTD("rng issues %d\n",j);
  return j;
}
    3366:	89 0f       	add	r24, r25
    3368:	08 95       	ret

0000336a <initialize>:

/*-------------------------Low level initialization------------------------*/
/*------Done in a subroutine to keep main routine stack usage small--------*/
void initialize(void)
{
    336a:	bf 92       	push	r11
    336c:	cf 92       	push	r12
    336e:	df 92       	push	r13
    3370:	ef 92       	push	r14
    3372:	ff 92       	push	r15
    3374:	0f 93       	push	r16
    3376:	1f 93       	push	r17
    3378:	df 93       	push	r29
    337a:	cf 93       	push	r28
    337c:	00 d0       	rcall	.+0      	; 0x337e <initialize+0x14>
    337e:	cd b7       	in	r28, 0x3d	; 61
    3380:	de b7       	in	r29, 0x3e	; 62
  watchdog_init();
    3382:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <watchdog_init>
  watchdog_start();
    3386:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <watchdog_start>
#ifdef RAVEN_LCD_INTERFACE
  rs232_init(RS232_PORT_0, USART_BAUD_38400,USART_PARITY_NONE | USART_STOP_BITS_1 | USART_DATA_BITS_8);
  rs232_set_input(0,raven_lcd_serial_input);
#else
  /* Generic or slip connection on uart0 */
  rs232_init(RS232_PORT_0, USART_BAUD_38400,USART_PARITY_NONE | USART_STOP_BITS_1 | USART_DATA_BITS_8);
    338a:	80 e0       	ldi	r24, 0x00	; 0
    338c:	6c e0       	ldi	r22, 0x0C	; 12
    338e:	46 e0       	ldi	r20, 0x06	; 6
    3390:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <rs232_init>
#endif
#endif

  /* Second rs232 port for debugging or slip alternative */
  rs232_init(RS232_PORT_1, USART_BAUD_57600,USART_PARITY_NONE | USART_STOP_BITS_1 | USART_DATA_BITS_8);
    3394:	81 e0       	ldi	r24, 0x01	; 1
    3396:	68 e0       	ldi	r22, 0x08	; 8
    3398:	46 e0       	ldi	r20, 0x06	; 6
    339a:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <rs232_init>
  /* Redirect stdout */
#if RF230BB_CONF_LEDONPORTE1 || defined(RAVEN_LCD_INTERFACE)
  rs232_redirect_stdout(RS232_PORT_1);
#else
  rs232_redirect_stdout(RS232_PORT_0);
    339e:	80 e0       	ldi	r24, 0x00	; 0
    33a0:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <rs232_redirect_stdout>
#endif
  clock_init();
    33a4:	0e 94 36 1c 	call	0x386c	; 0x386c <clock_init>

  if(MCUSR & (1<<PORF )) PRINTD("Power-on reset.\n");
    33a8:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<EXTRF)) PRINTD("External reset!\n");
    33aa:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<BORF )) PRINTD("Brownout reset!\n");
    33ac:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<WDRF )) PRINTD("Watchdog reset!\n");
    33ae:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<JTRF )) PRINTD("JTAG reset!\n");
    33b0:	84 b7       	in	r24, 0x34	; 52
   * loop. In conjuction with PERIODICPRINTS, never-used stack will be printed
   * every STACKMONITOR seconds.
   */
{
extern uint16_t __bss_end;
uint16_t p=(uint16_t)&__bss_end;
    33b2:	e1 ee       	ldi	r30, 0xE1	; 225
    33b4:	fd e2       	ldi	r31, 0x2D	; 45
    do {
      *(uint16_t *)p = 0x4242;
    33b6:	22 e4       	ldi	r18, 0x42	; 66
    33b8:	32 e4       	ldi	r19, 0x42	; 66
    33ba:	31 83       	std	Z+1, r19	; 0x01
    33bc:	20 83       	st	Z, r18
      p+=10;
    33be:	3a 96       	adiw	r30, 0x0a	; 10
    } while (p<SP-10); //don't overwrite our own stack
    33c0:	8d b7       	in	r24, 0x3d	; 61
    33c2:	9e b7       	in	r25, 0x3e	; 62
    33c4:	0a 97       	sbiw	r24, 0x0a	; 10
    33c6:	e8 17       	cp	r30, r24
    33c8:	f9 07       	cpc	r31, r25
    33ca:	b8 f3       	brcs	.-18     	; 0x33ba <initialize+0x50>
 }
   clock_init();
}
#endif 

  PRINTA("\n*******Booting %s*******\n",CONTIKI_VERSION_STRING);
    33cc:	00 d0       	rcall	.+0      	; 0x33ce <initialize+0x64>
    33ce:	00 d0       	rcall	.+0      	; 0x33d0 <initialize+0x66>
    33d0:	80 eb       	ldi	r24, 0xB0	; 176
    33d2:	91 e0       	ldi	r25, 0x01	; 1
    33d4:	ad b7       	in	r26, 0x3d	; 61
    33d6:	be b7       	in	r27, 0x3e	; 62
    33d8:	12 96       	adiw	r26, 0x02	; 2
    33da:	9c 93       	st	X, r25
    33dc:	8e 93       	st	-X, r24
    33de:	11 97       	sbiw	r26, 0x01	; 1
    33e0:	83 ee       	ldi	r24, 0xE3	; 227
    33e2:	9d e0       	ldi	r25, 0x0D	; 13
    33e4:	14 96       	adiw	r26, 0x04	; 4
    33e6:	9c 93       	st	X, r25
    33e8:	8e 93       	st	-X, r24
    33ea:	13 97       	sbiw	r26, 0x03	; 3
    33ec:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>

/* rtimers needed for radio cycling */
  rtimer_init();
    33f0:	0f 90       	pop	r0
    33f2:	0f 90       	pop	r0
    33f4:	0f 90       	pop	r0
    33f6:	0f 90       	pop	r0
    33f8:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <rtimer_init>

 /* Initialize process subsystem */
  process_init();
    33fc:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <process_init>

  /* etimers must be started before ctimer_init */
  process_start(&etimer_process, NULL);
    3400:	80 ec       	ldi	r24, 0xC0	; 192
    3402:	9d e0       	ldi	r25, 0x0D	; 13
    3404:	60 e0       	ldi	r22, 0x00	; 0
    3406:	70 e0       	ldi	r23, 0x00	; 0
    3408:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <process_start>
  ctimer_init();
    340c:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <ctimer_init>

  /* Start radio and radio receive process */
  NETSTACK_RADIO.init();
    3410:	e0 91 14 0e 	lds	r30, 0x0E14
    3414:	f0 91 15 0e 	lds	r31, 0x0E15
    3418:	09 95       	icall

/* Get a random seed for the 802.15.4 packet sequence number.
 * Some layers will ignore duplicates found in a history (e.g. Contikimac)
 * causing the initial packets to be ignored after a short-cycle restart.
 */
  random_init(rng_get_uint8());
    341a:	0e 94 a1 19 	call	0x3342	; 0x3342 <rng_get_uint8>
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	0e 94 79 31 	call	0x62f2	; 0x62f2 <random_init>

  /* Set addresses BEFORE starting tcpip process */

  rimeaddr_t addr;

  if (params_get_eui64(addr.u8)) {
    3424:	ce 01       	movw	r24, r28
    3426:	01 96       	adiw	r24, 0x01	; 1
    3428:	0e 94 1d 1c 	call	0x383a	; 0x383a <params_get_eui64>
    342c:	88 23       	and	r24, r24
    342e:	59 f0       	breq	.+22     	; 0x3446 <initialize+0xdc>
      PRINTA("Random EUI64 address generated\n");
    3430:	00 d0       	rcall	.+0      	; 0x3432 <initialize+0xc8>
    3432:	80 e9       	ldi	r24, 0x90	; 144
    3434:	91 e0       	ldi	r25, 0x01	; 1
    3436:	ed b7       	in	r30, 0x3d	; 61
    3438:	fe b7       	in	r31, 0x3e	; 62
    343a:	92 83       	std	Z+2, r25	; 0x02
    343c:	81 83       	std	Z+1, r24	; 0x01
    343e:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
    3442:	0f 90       	pop	r0
    3444:	0f 90       	pop	r0
  node_id=get_panaddr_from_eeprom();
  addr.u8[1]=node_id&0xff;
  addr.u8[0]=(node_id&0xff00)>>8;
  PRINTA("Node ID from eeprom: %X\n",node_id);
#endif  
  rimeaddr_set_node_addr(&addr); 
    3446:	8e 01       	movw	r16, r28
    3448:	0f 5f       	subi	r16, 0xFF	; 255
    344a:	1f 4f       	sbci	r17, 0xFF	; 255
    344c:	c8 01       	movw	r24, r16
    344e:	0e 94 24 26 	call	0x4c48	; 0x4c48 <rimeaddr_set_node_addr>

  rf230_set_pan_addr(params_get_panid(),params_get_panaddr(),(uint8_t *)&addr.u8);
    3452:	0e 94 27 1c 	call	0x384e	; 0x384e <params_get_panid>
    3456:	7c 01       	movw	r14, r24
    3458:	0e 94 2c 1c 	call	0x3858	; 0x3858 <params_get_panaddr>
    345c:	bc 01       	movw	r22, r24
    345e:	c7 01       	movw	r24, r14
    3460:	a8 01       	movw	r20, r16
    3462:	0e 94 b1 21 	call	0x4362	; 0x4362 <rf230_set_pan_addr>
  rf230_set_channel(params_get_channel());
    3466:	0e 94 85 1b 	call	0x370a	; 0x370a <params_get_channel>
    346a:	0e 94 96 21 	call	0x432c	; 0x432c <rf230_set_channel>
  rf230_set_txpower(params_get_txpower());
    346e:	0e 94 31 1c 	call	0x3862	; 0x3862 <params_get_txpower>
    3472:	0e 94 39 23 	call	0x4672	; 0x4672 <rf230_set_txpower>

#if UIP_CONF_IPV6
  PRINTA("EUI-64 MAC: %x-%x-%x-%x-%x-%x-%x-%x\n",addr.u8[0],addr.u8[1],addr.u8[2],addr.u8[3],addr.u8[4],addr.u8[5],addr.u8[6],addr.u8[7]);
#else
  PRINTA("MAC address ");
    3476:	00 d0       	rcall	.+0      	; 0x3478 <initialize+0x10e>
    3478:	83 e8       	ldi	r24, 0x83	; 131
    347a:	91 e0       	ldi	r25, 0x01	; 1
    347c:	ad b7       	in	r26, 0x3d	; 61
    347e:	be b7       	in	r27, 0x3e	; 62
    3480:	12 96       	adiw	r26, 0x02	; 2
    3482:	9c 93       	st	X, r25
    3484:	8e 93       	st	-X, r24
    3486:	11 97       	sbiw	r26, 0x01	; 1
    3488:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
  uint8_t i;
  for (i=sizeof(rimeaddr_t); i>0; i--){
    PRINTA("%x:",addr.u8[i-1]);
    348c:	00 d0       	rcall	.+0      	; 0x348e <initialize+0x124>
    348e:	ed b7       	in	r30, 0x3d	; 61
    3490:	fe b7       	in	r31, 0x3e	; 62
    3492:	31 96       	adiw	r30, 0x01	; 1
    3494:	0f e7       	ldi	r16, 0x7F	; 127
    3496:	11 e0       	ldi	r17, 0x01	; 1
    3498:	ad b7       	in	r26, 0x3d	; 61
    349a:	be b7       	in	r27, 0x3e	; 62
    349c:	12 96       	adiw	r26, 0x02	; 2
    349e:	1c 93       	st	X, r17
    34a0:	0e 93       	st	-X, r16
    34a2:	11 97       	sbiw	r26, 0x01	; 1
    34a4:	8a 81       	ldd	r24, Y+2	; 0x02
    34a6:	82 83       	std	Z+2, r24	; 0x02
    34a8:	13 82       	std	Z+3, r1	; 0x03
    34aa:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
    34ae:	ed b7       	in	r30, 0x3d	; 61
    34b0:	fe b7       	in	r31, 0x3e	; 62
    34b2:	31 96       	adiw	r30, 0x01	; 1
    34b4:	ad b7       	in	r26, 0x3d	; 61
    34b6:	be b7       	in	r27, 0x3e	; 62
    34b8:	12 96       	adiw	r26, 0x02	; 2
    34ba:	1c 93       	st	X, r17
    34bc:	0e 93       	st	-X, r16
    34be:	11 97       	sbiw	r26, 0x01	; 1
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
    34c2:	82 83       	std	Z+2, r24	; 0x02
    34c4:	13 82       	std	Z+3, r1	; 0x03
    34c6:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
  }
  PRINTA("\n");
    34ca:	0f 90       	pop	r0
    34cc:	0f 90       	pop	r0
    34ce:	8d e7       	ldi	r24, 0x7D	; 125
    34d0:	91 e0       	ldi	r25, 0x01	; 1
    34d2:	ed b7       	in	r30, 0x3d	; 61
    34d4:	fe b7       	in	r31, 0x3e	; 62
    34d6:	92 83       	std	Z+2, r25	; 0x02
    34d8:	81 83       	std	Z+1, r24	; 0x01
    34da:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
#endif

  /* Initialize stack protocols */
  queuebuf_init();
    34de:	0f 90       	pop	r0
    34e0:	0f 90       	pop	r0
    34e2:	0e 94 57 33 	call	0x66ae	; 0x66ae <queuebuf_init>
  NETSTACK_RDC.init();
    34e6:	e0 91 86 0e 	lds	r30, 0x0E86
    34ea:	f0 91 87 0e 	lds	r31, 0x0E87
    34ee:	09 95       	icall
  NETSTACK_MAC.init();
    34f0:	e0 91 6d 0e 	lds	r30, 0x0E6D
    34f4:	f0 91 6e 0e 	lds	r31, 0x0E6E
    34f8:	09 95       	icall
  NETSTACK_NETWORK.init();
    34fa:	e0 91 42 0e 	lds	r30, 0x0E42
    34fe:	f0 91 43 0e 	lds	r31, 0x0E43
    3502:	09 95       	icall

#if ANNOUNCE_BOOT
  PRINTA("%s %s, channel %u , check rate %u Hz tx power %u\n",NETSTACK_MAC.name, NETSTACK_RDC.name, rf230_get_channel(),
    3504:	00 91 6b 0e 	lds	r16, 0x0E6B
    3508:	10 91 6c 0e 	lds	r17, 0x0E6C
    350c:	c0 90 84 0e 	lds	r12, 0x0E84
    3510:	d0 90 85 0e 	lds	r13, 0x0E85
    3514:	0e 94 93 21 	call	0x4326	; 0x4326 <rf230_get_channel>
    3518:	b8 2e       	mov	r11, r24
    351a:	e0 90 92 0e 	lds	r14, 0x0E92
    351e:	f0 90 93 0e 	lds	r15, 0x0E93
    3522:	f7 01       	movw	r30, r14
    3524:	09 95       	icall
    3526:	00 97       	sbiw	r24, 0x00	; 0
    3528:	49 f0       	breq	.+18     	; 0x353c <initialize+0x1d2>
    352a:	f7 01       	movw	r30, r14
    352c:	09 95       	icall
    352e:	bc 01       	movw	r22, r24
    3530:	80 e8       	ldi	r24, 0x80	; 128
    3532:	90 e0       	ldi	r25, 0x00	; 0
    3534:	0e 94 62 4b 	call	0x96c4	; 0x96c4 <__udivmodhi4>
    3538:	7b 01       	movw	r14, r22
    353a:	03 c0       	rjmp	.+6      	; 0x3542 <initialize+0x1d8>
    353c:	80 e8       	ldi	r24, 0x80	; 128
    353e:	e8 2e       	mov	r14, r24
    3540:	f1 2c       	mov	r15, r1
    3542:	0e 94 3c 23 	call	0x4678	; 0x4678 <rf230_get_txpower>
    3546:	2d b7       	in	r18, 0x3d	; 61
    3548:	3e b7       	in	r19, 0x3e	; 62
    354a:	2c 50       	subi	r18, 0x0C	; 12
    354c:	30 40       	sbci	r19, 0x00	; 0
    354e:	0f b6       	in	r0, 0x3f	; 63
    3550:	f8 94       	cli
    3552:	3e bf       	out	0x3e, r19	; 62
    3554:	0f be       	out	0x3f, r0	; 63
    3556:	2d bf       	out	0x3d, r18	; 61
    3558:	ed b7       	in	r30, 0x3d	; 61
    355a:	fe b7       	in	r31, 0x3e	; 62
    355c:	31 96       	adiw	r30, 0x01	; 1
    355e:	2b e4       	ldi	r18, 0x4B	; 75
    3560:	31 e0       	ldi	r19, 0x01	; 1
    3562:	ad b7       	in	r26, 0x3d	; 61
    3564:	be b7       	in	r27, 0x3e	; 62
    3566:	12 96       	adiw	r26, 0x02	; 2
    3568:	3c 93       	st	X, r19
    356a:	2e 93       	st	-X, r18
    356c:	11 97       	sbiw	r26, 0x01	; 1
    356e:	13 83       	std	Z+3, r17	; 0x03
    3570:	02 83       	std	Z+2, r16	; 0x02
    3572:	d5 82       	std	Z+5, r13	; 0x05
    3574:	c4 82       	std	Z+4, r12	; 0x04
    3576:	b6 82       	std	Z+6, r11	; 0x06
    3578:	17 82       	std	Z+7, r1	; 0x07
    357a:	f1 86       	std	Z+9, r15	; 0x09
    357c:	e0 86       	std	Z+8, r14	; 0x08
    357e:	82 87       	std	Z+10, r24	; 0x0a
    3580:	13 86       	std	Z+11, r1	; 0x0b
    3582:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
  PRINTA("Routing Enabled\n");
#endif

#endif /* ANNOUNCE_BOOT */

  process_start(&tcpip_process, NULL);
    3586:	ed b7       	in	r30, 0x3d	; 61
    3588:	fe b7       	in	r31, 0x3e	; 62
    358a:	3c 96       	adiw	r30, 0x0c	; 12
    358c:	0f b6       	in	r0, 0x3f	; 63
    358e:	f8 94       	cli
    3590:	fe bf       	out	0x3e, r31	; 62
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	ed bf       	out	0x3d, r30	; 61
    3596:	89 eb       	ldi	r24, 0xB9	; 185
    3598:	9e e0       	ldi	r25, 0x0E	; 14
    359a:	60 e0       	ldi	r22, 0x00	; 0
    359c:	70 e0       	ldi	r23, 0x00	; 0
    359e:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <process_start>
#ifdef RAVEN_LCD_INTERFACE
  process_start(&raven_lcd_process, NULL);
#endif

  /* Autostart other processes */
  autostart_start(autostart_processes);
    35a2:	8e e6       	ldi	r24, 0x6E	; 110
    35a4:	92 e0       	ldi	r25, 0x02	; 2
    35a6:	0e 94 92 2d 	call	0x5b24	; 0x5b24 <autostart_start>
#elif COFFEE_FILES==4
   PRINTA(".%s online with dynamic %u KB program memory file system\n",buf,size>>10);
#endif /* COFFEE_FILES */
}
#else
   PRINTA("Online\n");
    35aa:	00 d0       	rcall	.+0      	; 0x35ac <initialize+0x242>
    35ac:	83 e4       	ldi	r24, 0x43	; 67
    35ae:	91 e0       	ldi	r25, 0x01	; 1
    35b0:	ad b7       	in	r26, 0x3d	; 61
    35b2:	be b7       	in	r27, 0x3e	; 62
    35b4:	12 96       	adiw	r26, 0x02	; 2
    35b6:	9c 93       	st	X, r25
    35b8:	8e 93       	st	-X, r24
    35ba:	11 97       	sbiw	r26, 0x01	; 1
    35bc:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
#if RF230BB_CONF_LEDONPORTE1
  /* NB: PORTE1 conflicts with UART0 */
  DDRE|=(1<<DDE1);  //set led pin to output (Micheal Hatrtman board)
  PORTE&=~(1<<PE1); //and low to turn led off
#endif
}
    35c0:	0f 90       	pop	r0
    35c2:	0f 90       	pop	r0
    35c4:	0f 90       	pop	r0
    35c6:	0f 90       	pop	r0
    35c8:	cf 91       	pop	r28
    35ca:	df 91       	pop	r29
    35cc:	1f 91       	pop	r17
    35ce:	0f 91       	pop	r16
    35d0:	ff 90       	pop	r15
    35d2:	ef 90       	pop	r14
    35d4:	df 90       	pop	r13
    35d6:	cf 90       	pop	r12
    35d8:	bf 90       	pop	r11
    35da:	08 95       	ret

000035dc <main>:
/*-------------------------------------------------------------------------*/
/*------------------------- Main Scheduler loop----------------------------*/
/*-------------------------------------------------------------------------*/
int
main(void)
{
    35dc:	af 92       	push	r10
    35de:	bf 92       	push	r11
    35e0:	cf 92       	push	r12
    35e2:	df 92       	push	r13
    35e4:	ef 92       	push	r14
    35e6:	ff 92       	push	r15
    35e8:	0f 93       	push	r16
    35ea:	1f 93       	push	r17
    35ec:	cf 93       	push	r28
    35ee:	df 93       	push	r29
  initialize();
    35f0:	0e 94 b5 19 	call	0x336a	; 0x336a <initialize>
  if (clocktime!=clock_seconds()) {
     clocktime=clock_seconds();
#endif

#if STAMPS
if ((clocktime%STAMPS)==0) {
    35f4:	9c e3       	ldi	r25, 0x3C	; 60
    35f6:	a9 2e       	mov	r10, r25
    35f8:	b1 2c       	mov	r11, r1
    35fa:	c1 2c       	mov	r12, r1
    35fc:	d1 2c       	mov	r13, r1
if ((clocktime%STACKMONITOR)==3) {
  extern uint16_t __bss_end;
  uint16_t p=(uint16_t)&__bss_end;
  do {
    if (*(uint16_t *)p != 0x4242) {
      PRINTF("Never-used stack > %d bytes\n",p-(uint16_t)&__bss_end);
    35fe:	c6 e2       	ldi	r28, 0x26	; 38
    3600:	d1 e0       	ldi	r29, 0x01	; 1
main(void)
{
  initialize();

  while(1) {
    process_run();
    3602:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <process_run>
    watchdog_periodic();
    3606:	0e 94 7a 1e 	call	0x3cf4	; 0x3cf4 <watchdog_periodic>

    /* Turn off LED after a while */
    if (ledtimer) {
    360a:	80 91 2d 25 	lds	r24, 0x252D
    360e:	90 91 2e 25 	lds	r25, 0x252E
    3612:	00 97       	sbiw	r24, 0x00	; 0
    3614:	29 f0       	breq	.+10     	; 0x3620 <main+0x44>
      if (--ledtimer==0) {
    3616:	01 97       	sbiw	r24, 0x01	; 1
    3618:	90 93 2e 25 	sts	0x252E, r25
    361c:	80 93 2d 25 	sts	0x252D, r24
 */
    if (rtimerflag) {
      rtimer_set(&rt, RTIMER_NOW()+ RTIMER_ARCH_SECOND*1UL, 1,(void *) rtimercycle, NULL);
      rtimerflag=0;
#else
  if (clocktime!=clock_seconds()) {
    3620:	e0 90 2f 25 	lds	r14, 0x252F
    3624:	f0 90 30 25 	lds	r15, 0x2530
    3628:	00 91 31 25 	lds	r16, 0x2531
    362c:	10 91 32 25 	lds	r17, 0x2532
    3630:	0e 94 53 1c 	call	0x38a6	; 0x38a6 <clock_seconds>
    3634:	e6 16       	cp	r14, r22
    3636:	f7 06       	cpc	r15, r23
    3638:	08 07       	cpc	r16, r24
    363a:	19 07       	cpc	r17, r25
    363c:	11 f3       	breq	.-60     	; 0x3602 <main+0x26>
     clocktime=clock_seconds();
    363e:	0e 94 53 1c 	call	0x38a6	; 0x38a6 <clock_seconds>
    3642:	60 93 2f 25 	sts	0x252F, r22
    3646:	70 93 30 25 	sts	0x2530, r23
    364a:	80 93 31 25 	sts	0x2531, r24
    364e:	90 93 32 25 	sts	0x2532, r25
#endif

#if STAMPS
if ((clocktime%STAMPS)==0) {
    3652:	a6 01       	movw	r20, r12
    3654:	95 01       	movw	r18, r10
    3656:	0e 94 89 4b 	call	0x9712	; 0x9712 <__udivmodsi4>
    365a:	61 15       	cp	r22, r1
    365c:	71 05       	cpc	r23, r1
    365e:	81 05       	cpc	r24, r1
    3660:	91 05       	cpc	r25, r1
    3662:	11 f4       	brne	.+4      	; 0x3668 <main+0x8c>
#if ENERGEST_CONF_ON
#include "lib/print-stats.h"
	print_stats();
    3664:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <print_stats>
  PRINTF("\n---------\n");
}
#endif

#if STACKMONITOR
if ((clocktime%STACKMONITOR)==3) {
    3668:	80 91 2f 25 	lds	r24, 0x252F
    366c:	90 91 30 25 	lds	r25, 0x2530
    3670:	a0 91 31 25 	lds	r26, 0x2531
    3674:	b0 91 32 25 	lds	r27, 0x2532
    3678:	93 70       	andi	r25, 0x03	; 3
    367a:	a0 70       	andi	r26, 0x00	; 0
    367c:	b0 70       	andi	r27, 0x00	; 0
    367e:	83 30       	cpi	r24, 0x03	; 3
    3680:	91 05       	cpc	r25, r1
    3682:	a1 05       	cpc	r26, r1
    3684:	b1 05       	cpc	r27, r1
    3686:	09 f0       	breq	.+2      	; 0x368a <main+0xae>
    3688:	bc cf       	rjmp	.-136    	; 0x3602 <main+0x26>
  extern uint16_t __bss_end;
  uint16_t p=(uint16_t)&__bss_end;
    368a:	e1 ee       	ldi	r30, 0xE1	; 225
    368c:	fd e2       	ldi	r31, 0x2D	; 45
  do {
    if (*(uint16_t *)p != 0x4242) {
    368e:	80 81       	ld	r24, Z
    3690:	91 81       	ldd	r25, Z+1	; 0x01
    3692:	22 e4       	ldi	r18, 0x42	; 66
    3694:	82 34       	cpi	r24, 0x42	; 66
    3696:	92 07       	cpc	r25, r18
    3698:	a9 f0       	breq	.+42     	; 0x36c4 <main+0xe8>
      PRINTF("Never-used stack > %d bytes\n",p-(uint16_t)&__bss_end);
    369a:	00 d0       	rcall	.+0      	; 0x369c <main+0xc0>
    369c:	00 d0       	rcall	.+0      	; 0x369e <main+0xc2>
    369e:	ad b7       	in	r26, 0x3d	; 61
    36a0:	be b7       	in	r27, 0x3e	; 62
    36a2:	12 96       	adiw	r26, 0x02	; 2
    36a4:	dc 93       	st	X, r29
    36a6:	ce 93       	st	-X, r28
    36a8:	11 97       	sbiw	r26, 0x01	; 1
    36aa:	e1 5e       	subi	r30, 0xE1	; 225
    36ac:	fd 42       	sbci	r31, 0x2D	; 45
    36ae:	14 96       	adiw	r26, 0x04	; 4
    36b0:	fc 93       	st	X, r31
    36b2:	ee 93       	st	-X, r30
    36b4:	13 97       	sbiw	r26, 0x03	; 3
    36b6:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
      break;
    36ba:	0f 90       	pop	r0
    36bc:	0f 90       	pop	r0
    36be:	0f 90       	pop	r0
    36c0:	0f 90       	pop	r0
    36c2:	9f cf       	rjmp	.-194    	; 0x3602 <main+0x26>
    }
    p+=10;
    36c4:	3a 96       	adiw	r30, 0x0a	; 10
  } while (p<RAMEND-10);
    36c6:	b1 e4       	ldi	r27, 0x41	; 65
    36c8:	e5 3f       	cpi	r30, 0xF5	; 245
    36ca:	fb 07       	cpc	r31, r27
    36cc:	00 f3       	brcs	.-64     	; 0x368e <main+0xb2>
    36ce:	99 cf       	rjmp	.-206    	; 0x3602 <main+0x26>

000036d0 <log_message>:

/*---------------------------------------------------------------------------*/

void log_message(char *m1, char *m2)
{
  PRINTF("%s%s\n", m1, m2);
    36d0:	00 d0       	rcall	.+0      	; 0x36d2 <log_message+0x2>
    36d2:	00 d0       	rcall	.+0      	; 0x36d4 <log_message+0x4>
    36d4:	00 d0       	rcall	.+0      	; 0x36d6 <log_message+0x6>
    36d6:	ed b7       	in	r30, 0x3d	; 61
    36d8:	fe b7       	in	r31, 0x3e	; 62
    36da:	31 96       	adiw	r30, 0x01	; 1
    36dc:	20 e2       	ldi	r18, 0x20	; 32
    36de:	31 e0       	ldi	r19, 0x01	; 1
    36e0:	ad b7       	in	r26, 0x3d	; 61
    36e2:	be b7       	in	r27, 0x3e	; 62
    36e4:	12 96       	adiw	r26, 0x02	; 2
    36e6:	3c 93       	st	X, r19
    36e8:	2e 93       	st	-X, r18
    36ea:	11 97       	sbiw	r26, 0x01	; 1
    36ec:	93 83       	std	Z+3, r25	; 0x03
    36ee:	82 83       	std	Z+2, r24	; 0x02
    36f0:	75 83       	std	Z+5, r23	; 0x05
    36f2:	64 83       	std	Z+4, r22	; 0x04
    36f4:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
    36f8:	8d b7       	in	r24, 0x3d	; 61
    36fa:	9e b7       	in	r25, 0x3e	; 62
    36fc:	06 96       	adiw	r24, 0x06	; 6
    36fe:	0f b6       	in	r0, 0x3f	; 63
    3700:	f8 94       	cli
    3702:	9e bf       	out	0x3e, r25	; 62
    3704:	0f be       	out	0x3f, r0	; 63
    3706:	8d bf       	out	0x3d, r24	; 61
}
    3708:	08 95       	ret

0000370a <params_get_channel>:
#if CONTIKI_CONF_RANDOM_MAC
static uint8_t randomeui64;
#endif

uint8_t
params_get_channel(void) {
    370a:	0f 93       	push	r16
    370c:	1f 93       	push	r17
    370e:	df 93       	push	r29
    3710:	cf 93       	push	r28
    3712:	cd b7       	in	r28, 0x3d	; 61
    3714:	de b7       	in	r29, 0x3e	; 62
    3716:	a2 97       	sbiw	r28, 0x22	; 34
    3718:	0f b6       	in	r0, 0x3f	; 63
    371a:	f8 94       	cli
    371c:	de bf       	out	0x3e, r29	; 62
    371e:	0f be       	out	0x3f, r0	; 63
    3720:	cd bf       	out	0x3d, r28	; 61
  uint8_t x[2];
  *(uint16_t *)x = eeprom_read_word ((uint16_t *)&eemem_channel);
    3722:	82 e2       	ldi	r24, 0x22	; 34
    3724:	90 e0       	ldi	r25, 0x00	; 0
    3726:	0e 94 a8 4f 	call	0x9f50	; 0x9f50 <__eerd_word_m128rfa1>
    372a:	89 83       	std	Y+1, r24	; 0x01
    372c:	9a 83       	std	Y+2, r25	; 0x02
/* Don't return an invalid channel number */
  if( (x[0]<11) || (x[0] > 26)) x[1]=x[0];
    372e:	98 2f       	mov	r25, r24
    3730:	9b 50       	subi	r25, 0x0B	; 11
    3732:	90 31       	cpi	r25, 0x10	; 16
    3734:	08 f0       	brcs	.+2      	; 0x3738 <params_get_channel+0x2e>
    3736:	8a 83       	std	Y+2, r24	; 0x02
/* Do exclusive or test on the two values read */
  if((uint8_t)x[0]!=(uint8_t)~x[1]) {//~x[1] can promote comparison to 16 bit
    3738:	9a 81       	ldd	r25, Y+2	; 0x02
    373a:	90 95       	com	r25
    373c:	89 17       	cp	r24, r25
    373e:	09 f4       	brne	.+2      	; 0x3742 <params_get_channel+0x38>
    3740:	70 c0       	rjmp	.+224    	; 0x3822 <params_get_channel+0x118>
/* Verification fails, rewrite everything */
    uint8_t i,buffer[32];
    PRINTD("EEPROM is corrupt, rewriting with defaults.\n");
    3742:	00 d0       	rcall	.+0      	; 0x3744 <params_get_channel+0x3a>
    3744:	8b ee       	ldi	r24, 0xEB	; 235
    3746:	91 e0       	ldi	r25, 0x01	; 1
    3748:	ad b7       	in	r26, 0x3d	; 61
    374a:	be b7       	in	r27, 0x3e	; 62
    374c:	12 96       	adiw	r26, 0x02	; 2
    374e:	9c 93       	st	X, r25
    3750:	8e 93       	st	-X, r24
    3752:	11 97       	sbiw	r26, 0x01	; 1
    3754:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
    3758:	8e 01       	movw	r16, r28
    375a:	0d 5f       	subi	r16, 0xFD	; 253
    375c:	1f 4f       	sbci	r17, 0xFF	; 255
    375e:	0f 90       	pop	r0
    3760:	0f 90       	pop	r0
    3762:	d8 01       	movw	r26, r16
    3764:	80 e0       	ldi	r24, 0x00	; 0
    3766:	90 e0       	ldi	r25, 0x00	; 0
#if CONTIKI_CONF_RANDOM_MAC
    PRINTD("Generating random EUI64 MAC\n");
    generate_new_eui64(&buffer);
    randomeui64=1;
#else
    for (i=0;i<sizeof(default_mac_address);i++) buffer[i] = pgm_read_byte_near(default_mac_address+i);
    3768:	fc 01       	movw	r30, r24
    376a:	e5 53       	subi	r30, 0x35	; 53
    376c:	fe 4f       	sbci	r31, 0xFE	; 254
    376e:	e4 91       	lpm	r30, Z+
    3770:	ed 93       	st	X+, r30
    3772:	01 96       	adiw	r24, 0x01	; 1
    3774:	88 30       	cpi	r24, 0x08	; 8
    3776:	91 05       	cpc	r25, r1
    3778:	b9 f7       	brne	.-18     	; 0x3768 <params_get_channel+0x5e>
#endif
/* eeprom_write_block should not be interrupted */
    cli();
    377a:	f8 94       	cli
    eeprom_write_block(&buffer,  &eemem_mac_address, sizeof(eemem_mac_address));
    377c:	ce 01       	movw	r24, r28
    377e:	03 96       	adiw	r24, 0x03	; 3
    3780:	60 e0       	ldi	r22, 0x00	; 0
    3782:	70 e0       	ldi	r23, 0x00	; 0
    3784:	48 e0       	ldi	r20, 0x08	; 8
    3786:	50 e0       	ldi	r21, 0x00	; 0
    3788:	0e 94 ae 4f 	call	0x9f5c	; 0x9f5c <__eewr_block_m128rfa1>
    378c:	d8 01       	movw	r26, r16
    378e:	80 e0       	ldi	r24, 0x00	; 0
    3790:	90 e0       	ldi	r25, 0x00	; 0
    for (i=0;i<sizeof(default_server_name);i++) buffer[i] = pgm_read_byte_near(default_server_name+i);
    3792:	fc 01       	movw	r30, r24
    3794:	ed 52       	subi	r30, 0x2D	; 45
    3796:	fe 4f       	sbci	r31, 0xFE	; 254
    3798:	e4 91       	lpm	r30, Z+
    379a:	ed 93       	st	X+, r30
    379c:	01 96       	adiw	r24, 0x01	; 1
    379e:	8e 30       	cpi	r24, 0x0E	; 14
    37a0:	91 05       	cpc	r25, r1
    37a2:	b9 f7       	brne	.-18     	; 0x3792 <params_get_channel+0x88>
    eeprom_write_block(&buffer,  &eemem_server_name, sizeof(eemem_server_name));
    37a4:	ce 01       	movw	r24, r28
    37a6:	03 96       	adiw	r24, 0x03	; 3
    37a8:	68 e0       	ldi	r22, 0x08	; 8
    37aa:	70 e0       	ldi	r23, 0x00	; 0
    37ac:	4e e0       	ldi	r20, 0x0E	; 14
    37ae:	50 e0       	ldi	r21, 0x00	; 0
    37b0:	0e 94 ae 4f 	call	0x9f5c	; 0x9f5c <__eewr_block_m128rfa1>
    37b4:	80 e0       	ldi	r24, 0x00	; 0
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    for (i=0;i<sizeof(default_domain_name);i++) buffer[i] = pgm_read_byte_near(default_domain_name+i);
    37b8:	fc 01       	movw	r30, r24
    37ba:	ef 51       	subi	r30, 0x1F	; 31
    37bc:	fe 4f       	sbci	r31, 0xFE	; 254
    37be:	e4 91       	lpm	r30, Z+
    37c0:	d8 01       	movw	r26, r16
    37c2:	ed 93       	st	X+, r30
    37c4:	8d 01       	movw	r16, r26
    37c6:	01 96       	adiw	r24, 0x01	; 1
    37c8:	8a 30       	cpi	r24, 0x0A	; 10
    37ca:	91 05       	cpc	r25, r1
    37cc:	a9 f7       	brne	.-22     	; 0x37b8 <params_get_channel+0xae>
    eeprom_write_block(&buffer,  &eemem_domain_name, sizeof(eemem_domain_name));
    37ce:	ce 01       	movw	r24, r28
    37d0:	03 96       	adiw	r24, 0x03	; 3
    37d2:	66 e1       	ldi	r22, 0x16	; 22
    37d4:	70 e0       	ldi	r23, 0x00	; 0
    37d6:	4a e0       	ldi	r20, 0x0A	; 10
    37d8:	50 e0       	ldi	r21, 0x00	; 0
    37da:	0e 94 ae 4f 	call	0x9f5c	; 0x9f5c <__eewr_block_m128rfa1>
    eeprom_write_word(&eemem_panid  , PARAMS_PANID);
    37de:	84 e2       	ldi	r24, 0x24	; 36
    37e0:	90 e0       	ldi	r25, 0x00	; 0
    37e2:	6d ec       	ldi	r22, 0xCD	; 205
    37e4:	7b ea       	ldi	r23, 0xAB	; 171
    37e6:	0e 94 c6 4f 	call	0x9f8c	; 0x9f8c <__eewr_word_m128rfa1>
    eeprom_write_word(&eemem_panaddr, PARAMS_PANADDR);
    37ea:	86 e2       	ldi	r24, 0x26	; 38
    37ec:	90 e0       	ldi	r25, 0x00	; 0
    37ee:	60 e0       	ldi	r22, 0x00	; 0
    37f0:	70 e0       	ldi	r23, 0x00	; 0
    37f2:	0e 94 c6 4f 	call	0x9f8c	; 0x9f8c <__eewr_word_m128rfa1>
    eeprom_write_byte(&eemem_txpower, PARAMS_TXPOWER);
    37f6:	88 e2       	ldi	r24, 0x28	; 40
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	60 e0       	ldi	r22, 0x00	; 0
    37fc:	0e 94 b8 4f 	call	0x9f70	; 0x9f70 <__eewr_byte_m128rfa1>
    eeprom_write_word(&eemem_nodeid, PARAMS_NODEID);
    3800:	80 e2       	ldi	r24, 0x20	; 32
    3802:	90 e0       	ldi	r25, 0x00	; 0
    3804:	60 e0       	ldi	r22, 0x00	; 0
    3806:	70 e0       	ldi	r23, 0x00	; 0
    3808:	0e 94 c6 4f 	call	0x9f8c	; 0x9f8c <__eewr_word_m128rfa1>
    x[0] = PARAMS_CHANNEL;
    380c:	8a e1       	ldi	r24, 0x1A	; 26
    380e:	89 83       	std	Y+1, r24	; 0x01
    x[1]= ~x[0];
    3810:	85 ee       	ldi	r24, 0xE5	; 229
    3812:	8a 83       	std	Y+2, r24	; 0x02
    eeprom_write_word((uint16_t *)&eemem_channel, *(uint16_t *)x);
    3814:	69 81       	ldd	r22, Y+1	; 0x01
    3816:	7a 81       	ldd	r23, Y+2	; 0x02
    3818:	82 e2       	ldi	r24, 0x22	; 34
    381a:	90 e0       	ldi	r25, 0x00	; 0
    381c:	0e 94 c6 4f 	call	0x9f8c	; 0x9f8c <__eewr_word_m128rfa1>
    sei();
    3820:	78 94       	sei
  }
/* Always returns a valid channel */
  return x[0];
}
    3822:	89 81       	ldd	r24, Y+1	; 0x01
    3824:	a2 96       	adiw	r28, 0x22	; 34
    3826:	0f b6       	in	r0, 0x3f	; 63
    3828:	f8 94       	cli
    382a:	de bf       	out	0x3e, r29	; 62
    382c:	0f be       	out	0x3f, r0	; 63
    382e:	cd bf       	out	0x3d, r28	; 61
    3830:	cf 91       	pop	r28
    3832:	df 91       	pop	r29
    3834:	1f 91       	pop	r17
    3836:	0f 91       	pop	r16
    3838:	08 95       	ret

0000383a <params_get_eui64>:
uint8_t
params_get_eui64(uint8_t *eui64) {
  cli();
    383a:	f8 94       	cli
  eeprom_read_block ((void *)eui64, &eemem_mac_address, sizeof(rimeaddr_t));
    383c:	60 e0       	ldi	r22, 0x00	; 0
    383e:	70 e0       	ldi	r23, 0x00	; 0
    3840:	42 e0       	ldi	r20, 0x02	; 2
    3842:	50 e0       	ldi	r21, 0x00	; 0
    3844:	0e 94 90 4f 	call	0x9f20	; 0x9f20 <__eerd_block_m128rfa1>
  sei();
    3848:	78 94       	sei
#if CONTIKI_CONF_RANDOM_MAC
  return randomeui64;
#else
  return 0;
#endif
}
    384a:	80 e0       	ldi	r24, 0x00	; 0
    384c:	08 95       	ret

0000384e <params_get_panid>:
uint16_t
params_get_panid(void) {
  return eeprom_read_word(&eemem_panid);
    384e:	84 e2       	ldi	r24, 0x24	; 36
    3850:	90 e0       	ldi	r25, 0x00	; 0
    3852:	0e 94 a8 4f 	call	0x9f50	; 0x9f50 <__eerd_word_m128rfa1>
}
    3856:	08 95       	ret

00003858 <params_get_panaddr>:
uint16_t
params_get_panaddr(void) {
  return eeprom_read_word (&eemem_panaddr);
    3858:	86 e2       	ldi	r24, 0x26	; 38
    385a:	90 e0       	ldi	r25, 0x00	; 0
    385c:	0e 94 a8 4f 	call	0x9f50	; 0x9f50 <__eerd_word_m128rfa1>
}
    3860:	08 95       	ret

00003862 <params_get_txpower>:
uint8_t
params_get_txpower(void)
{
  return eeprom_read_byte(&eemem_txpower);
    3862:	88 e2       	ldi	r24, 0x28	; 40
    3864:	90 e0       	ldi	r25, 0x00	; 0
    3866:	0e 94 a0 4f 	call	0x9f40	; 0x9f40 <__eerd_byte_m128rfa1>
}
    386a:	08 95       	ret

0000386c <clock_init>:
 * Start the clock by enabling the timer comparison interrupts. 
 */
void
clock_init(void)
{
  cli ();
    386c:	f8 94       	cli
  OCRSetup();
    386e:	10 92 b6 00 	sts	0x00B6, r1
    3872:	16 bc       	out	0x26, r1	; 38
    3874:	83 ef       	ldi	r24, 0xF3	; 243
    3876:	87 bd       	out	0x27, r24	; 39
    3878:	82 e0       	ldi	r24, 0x02	; 2
    387a:	84 bd       	out	0x24, r24	; 36
    387c:	94 e0       	ldi	r25, 0x04	; 4
    387e:	95 bd       	out	0x25, r25	; 37
    3880:	95 b3       	in	r25, 0x15	; 21
    3882:	95 bb       	out	0x15, r25	; 21
    3884:	80 93 6e 00 	sts	0x006E, r24
  sei ();
    3888:	78 94       	sei
}
    388a:	08 95       	ret

0000388c <clock_time>:
clock_time_t
clock_time(void)
{
  clock_time_t tmp;
  do {
    tmp = count;
    388c:	20 91 19 1d 	lds	r18, 0x1D19
    3890:	30 91 1a 1d 	lds	r19, 0x1D1A
  } while(tmp != count);
    3894:	80 91 19 1d 	lds	r24, 0x1D19
    3898:	90 91 1a 1d 	lds	r25, 0x1D1A
    389c:	28 17       	cp	r18, r24
    389e:	39 07       	cpc	r19, r25
    38a0:	a9 f7       	brne	.-22     	; 0x388c <clock_time>
  return tmp;
}
    38a2:	c9 01       	movw	r24, r18
    38a4:	08 95       	ret

000038a6 <clock_seconds>:
unsigned long
clock_seconds(void)
{
  unsigned long tmp;
  do {
    tmp = seconds;
    38a6:	20 91 3b 25 	lds	r18, 0x253B
    38aa:	30 91 3c 25 	lds	r19, 0x253C
    38ae:	40 91 3d 25 	lds	r20, 0x253D
    38b2:	50 91 3e 25 	lds	r21, 0x253E
  } while(tmp != seconds);
    38b6:	80 91 3b 25 	lds	r24, 0x253B
    38ba:	90 91 3c 25 	lds	r25, 0x253C
    38be:	a0 91 3d 25 	lds	r26, 0x253D
    38c2:	b0 91 3e 25 	lds	r27, 0x253E
    38c6:	28 17       	cp	r18, r24
    38c8:	39 07       	cpc	r19, r25
    38ca:	4a 07       	cpc	r20, r26
    38cc:	5b 07       	cpc	r21, r27
    38ce:	59 f7       	brne	.-42     	; 0x38a6 <clock_seconds>
  return tmp;
}
    38d0:	b9 01       	movw	r22, r18
    38d2:	ca 01       	movw	r24, r20
    38d4:	08 95       	ret

000038d6 <clock_set_seconds>:
 * Set seconds, e.g. to a standard epoch for an absolute date/time.
 */
void
clock_set_seconds(unsigned long sec)
{
  seconds = sec;
    38d6:	60 93 3b 25 	sts	0x253B, r22
    38da:	70 93 3c 25 	sts	0x253C, r23
    38de:	80 93 3d 25 	sts	0x253D, r24
    38e2:	90 93 3e 25 	sts	0x253E, r25
}
    38e6:	08 95       	ret

000038e8 <clock_wait>:
/**
 * Wait for a number of clock ticks.
 */
void
clock_wait(clock_time_t t)
{
    38e8:	cf 93       	push	r28
    38ea:	df 93       	push	r29
    38ec:	ec 01       	movw	r28, r24
  clock_time_t endticks = clock_time() + t;
    38ee:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    38f2:	c8 0f       	add	r28, r24
    38f4:	d9 1f       	adc	r29, r25
  if (sizeof(clock_time_t) == 1) {
    while ((signed char )(clock_time() - endticks) < 0) {;}
  } else if (sizeof(clock_time_t) == 2) {
    while ((signed short)(clock_time() - endticks) < 0) {;}
    38f6:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    38fa:	8c 1b       	sub	r24, r28
    38fc:	9d 0b       	sbc	r25, r29
    38fe:	97 fd       	sbrc	r25, 7
    3900:	fa cf       	rjmp	.-12     	; 0x38f6 <clock_wait+0xe>
  } else {
    while ((signed long )(clock_time() - endticks) < 0) {;}
  }
}
    3902:	df 91       	pop	r29
    3904:	cf 91       	pop	r28
    3906:	08 95       	ret

00003908 <clock_delay_usec>:
#elif F_CPU >= 12000000UL
  if(howlong<2) return;
  howlong-=(uint16_t) (3*12000000/F_CPU);
  my_delay_loop_2((howlong*(uint16_t)(F_CPU/3250000)));
#elif F_CPU >= 8000000UL
  if(howlong<4) return;
    3908:	84 30       	cpi	r24, 0x04	; 4
    390a:	91 05       	cpc	r25, r1
    390c:	48 f0       	brcs	.+18     	; 0x3920 <clock_delay_usec+0x18>
  howlong-=(uint16_t) (3*8000000/F_CPU);
    390e:	03 97       	sbiw	r24, 0x03	; 3
  my_delay_loop_2((howlong*(uint16_t)(F_CPU/2000000))/2);
    3910:	88 0f       	add	r24, r24
    3912:	99 1f       	adc	r25, r25
    3914:	88 0f       	add	r24, r24
    3916:	99 1f       	adc	r25, r25
    3918:	96 95       	lsr	r25
    391a:	87 95       	ror	r24
 */
static inline void my_delay_loop_2(uint16_t __count) __attribute__((always_inline));
void
my_delay_loop_2(uint16_t __count)
{
  __asm__ volatile (
    391c:	01 97       	sbiw	r24, 0x01	; 1
    391e:	f1 f7       	brne	.-4      	; 0x391c <clock_delay_usec+0x14>
    3920:	08 95       	ret

00003922 <clock_delay_msec>:
 * Platforms are not required to implement this call.
 * \note This will break for CPUs clocked above 260 MHz.
 */
void
clock_delay_msec(uint16_t howlong)
{
    3922:	cf 93       	push	r28
    3924:	df 93       	push	r29
    3926:	ec 01       	movw	r28, r24

#if F_CPU>=16000000
  while(howlong--) clock_delay_usec(1000);
#elif F_CPU>=8000000
  uint16_t i=996;
    3928:	84 ee       	ldi	r24, 0xE4	; 228
    392a:	93 e0       	ldi	r25, 0x03	; 3
  while(howlong--) {clock_delay_usec(i);i=999;}
    392c:	05 c0       	rjmp	.+10     	; 0x3938 <clock_delay_msec+0x16>
    392e:	0e 94 84 1c 	call	0x3908	; 0x3908 <clock_delay_usec>
    3932:	21 97       	sbiw	r28, 0x01	; 1
    3934:	87 ee       	ldi	r24, 0xE7	; 231
    3936:	93 e0       	ldi	r25, 0x03	; 3
    3938:	20 97       	sbiw	r28, 0x00	; 0
    393a:	c9 f7       	brne	.-14     	; 0x392e <clock_delay_msec+0xc>
  while(howlong--) {clock_delay_usec(i);i=999;}
#else
  uint16_t i=983;
  while(howlong--) {clock_delay_usec(i);i=999;}
#endif
}
    393c:	df 91       	pop	r29
    393e:	cf 91       	pop	r28
    3940:	08 95       	ret

00003942 <clock_adjust_ticks>:
 * clock_seconds will increment if necessary to reflect the tick addition.
  * Leap ticks or seconds can (rarely) be introduced if the ISR is not blocked.
 */
void
clock_adjust_ticks(clock_time_t howmany)
{
    3942:	0f 93       	push	r16
    3944:	1f 93       	push	r17
  uint8_t sreg = SREG;cli();
    3946:	1f b7       	in	r17, 0x3f	; 63
    3948:	f8 94       	cli
  count  += howmany;
    394a:	20 91 19 1d 	lds	r18, 0x1D19
    394e:	30 91 1a 1d 	lds	r19, 0x1D1A
    3952:	28 0f       	add	r18, r24
    3954:	39 1f       	adc	r19, r25
    3956:	30 93 1a 1d 	sts	0x1D1A, r19
    395a:	20 93 19 1d 	sts	0x1D19, r18
#if TWO_COUNTERS
  howmany+= scount;
    395e:	20 91 1b 1d 	lds	r18, 0x1D1B
    3962:	fc 01       	movw	r30, r24
    3964:	e2 0f       	add	r30, r18
    3966:	f1 1d       	adc	r31, r1
  while(howmany >= CLOCK_SECOND) {
    howmany -= CLOCK_SECOND;
    seconds++;
    sleepseconds++;
#if RADIOSTATS
    if (RF230_receive_on) radioontime += 1;
    3968:	00 91 da 26 	lds	r16, 0x26DA
    396c:	60 91 37 25 	lds	r22, 0x2537
    3970:	70 91 38 25 	lds	r23, 0x2538
    3974:	80 91 39 25 	lds	r24, 0x2539
    3978:	90 91 3a 25 	lds	r25, 0x253A
clock_adjust_ticks(clock_time_t howmany)
{
  uint8_t sreg = SREG;cli();
  count  += howmany;
#if TWO_COUNTERS
  howmany+= scount;
    397c:	df 01       	movw	r26, r30
#endif
  while(howmany >= CLOCK_SECOND) {
    397e:	2c c0       	rjmp	.+88     	; 0x39d8 <clock_adjust_ticks+0x96>
    howmany -= CLOCK_SECOND;
    3980:	a0 58       	subi	r26, 0x80	; 128
    3982:	b0 40       	sbci	r27, 0x00	; 0
    seconds++;
    3984:	20 91 3b 25 	lds	r18, 0x253B
    3988:	30 91 3c 25 	lds	r19, 0x253C
    398c:	40 91 3d 25 	lds	r20, 0x253D
    3990:	50 91 3e 25 	lds	r21, 0x253E
    3994:	2f 5f       	subi	r18, 0xFF	; 255
    3996:	3f 4f       	sbci	r19, 0xFF	; 255
    3998:	4f 4f       	sbci	r20, 0xFF	; 255
    399a:	5f 4f       	sbci	r21, 0xFF	; 255
    399c:	20 93 3b 25 	sts	0x253B, r18
    39a0:	30 93 3c 25 	sts	0x253C, r19
    39a4:	40 93 3d 25 	sts	0x253D, r20
    39a8:	50 93 3e 25 	sts	0x253E, r21
    sleepseconds++;
#if RADIOSTATS
    if (RF230_receive_on) radioontime += 1;
    39ac:	00 23       	and	r16, r16
    39ae:	a1 f0       	breq	.+40     	; 0x39d8 <clock_adjust_ticks+0x96>
    39b0:	20 91 33 25 	lds	r18, 0x2533
    39b4:	30 91 34 25 	lds	r19, 0x2534
    39b8:	40 91 35 25 	lds	r20, 0x2535
    39bc:	50 91 36 25 	lds	r21, 0x2536
    39c0:	2f 5f       	subi	r18, 0xFF	; 255
    39c2:	3f 4f       	sbci	r19, 0xFF	; 255
    39c4:	4f 4f       	sbci	r20, 0xFF	; 255
    39c6:	5f 4f       	sbci	r21, 0xFF	; 255
    39c8:	20 93 33 25 	sts	0x2533, r18
    39cc:	30 93 34 25 	sts	0x2534, r19
    39d0:	40 93 35 25 	sts	0x2535, r20
    39d4:	50 93 36 25 	sts	0x2536, r21
  uint8_t sreg = SREG;cli();
  count  += howmany;
#if TWO_COUNTERS
  howmany+= scount;
#endif
  while(howmany >= CLOCK_SECOND) {
    39d8:	a0 38       	cpi	r26, 0x80	; 128
    39da:	b1 05       	cpc	r27, r1
    39dc:	88 f6       	brcc	.-94     	; 0x3980 <clock_adjust_ticks+0x3e>
 * Typically used to add ticks after an MCU sleep
 * clock_seconds will increment if necessary to reflect the tick addition.
  * Leap ticks or seconds can (rarely) be introduced if the ISR is not blocked.
 */
void
clock_adjust_ticks(clock_time_t howmany)
    39de:	9f 01       	movw	r18, r30
    39e0:	22 0f       	add	r18, r18
    39e2:	23 2f       	mov	r18, r19
    39e4:	22 1f       	adc	r18, r18
    39e6:	33 0b       	sbc	r19, r19
    39e8:	31 95       	neg	r19
    39ea:	40 e0       	ldi	r20, 0x00	; 0
    39ec:	50 e0       	ldi	r21, 0x00	; 0
  uint8_t sreg = SREG;cli();
  count  += howmany;
#if TWO_COUNTERS
  howmany+= scount;
#endif
  while(howmany >= CLOCK_SECOND) {
    39ee:	26 0f       	add	r18, r22
    39f0:	37 1f       	adc	r19, r23
    39f2:	48 1f       	adc	r20, r24
    39f4:	59 1f       	adc	r21, r25
    39f6:	20 93 37 25 	sts	0x2537, r18
    39fa:	30 93 38 25 	sts	0x2538, r19
    39fe:	40 93 39 25 	sts	0x2539, r20
    3a02:	50 93 3a 25 	sts	0x253A, r21
#if RADIOSTATS
    if (RF230_receive_on) radioontime += 1;
#endif
  }
#if TWO_COUNTERS
  scount = howmany;
    3a06:	ef 77       	andi	r30, 0x7F	; 127
    3a08:	f0 70       	andi	r31, 0x00	; 0
    3a0a:	e0 93 1b 1d 	sts	0x1D1B, r30
#endif
  SREG=sreg;
    3a0e:	1f bf       	out	0x3f, r17	; 63
}
    3a10:	1f 91       	pop	r17
    3a12:	0f 91       	pop	r16
    3a14:	08 95       	ret

00003a16 <__vector_21>:
 *  clock-avr.h for the particular MCU.
 */
void AVR_OUTPUT_COMPARE_INT(void);
#else
ISR(AVR_OUTPUT_COMPARE_INT)
{
    3a16:	1f 92       	push	r1
    3a18:	0f 92       	push	r0
    3a1a:	0f b6       	in	r0, 0x3f	; 63
    3a1c:	0f 92       	push	r0
    3a1e:	0b b6       	in	r0, 0x3b	; 59
    3a20:	0f 92       	push	r0
    3a22:	11 24       	eor	r1, r1
    3a24:	2f 93       	push	r18
    3a26:	3f 93       	push	r19
    3a28:	4f 93       	push	r20
    3a2a:	5f 93       	push	r21
    3a2c:	6f 93       	push	r22
    3a2e:	7f 93       	push	r23
    3a30:	8f 93       	push	r24
    3a32:	9f 93       	push	r25
    3a34:	af 93       	push	r26
    3a36:	bf 93       	push	r27
    3a38:	ef 93       	push	r30
    3a3a:	ff 93       	push	r31
    count++;
    3a3c:	80 91 19 1d 	lds	r24, 0x1D19
    3a40:	90 91 1a 1d 	lds	r25, 0x1D1A
    3a44:	01 96       	adiw	r24, 0x01	; 1
    3a46:	90 93 1a 1d 	sts	0x1D1A, r25
    3a4a:	80 93 19 1d 	sts	0x1D19, r24
#if TWO_COUNTERS
  if(++scount >= CLOCK_SECOND) {
    3a4e:	80 91 1b 1d 	lds	r24, 0x1D1B
    3a52:	8f 5f       	subi	r24, 0xFF	; 255
    3a54:	80 93 1b 1d 	sts	0x1D1B, r24
    3a58:	80 91 1b 1d 	lds	r24, 0x1D1B
    3a5c:	87 ff       	sbrs	r24, 7
    3a5e:	15 c0       	rjmp	.+42     	; 0x3a8a <__vector_21+0x74>
    scount = 0;
    3a60:	10 92 1b 1d 	sts	0x1D1B, r1
#else
  if(count%CLOCK_SECOND==0) {
#endif
    seconds++;
    3a64:	80 91 3b 25 	lds	r24, 0x253B
    3a68:	90 91 3c 25 	lds	r25, 0x253C
    3a6c:	a0 91 3d 25 	lds	r26, 0x253D
    3a70:	b0 91 3e 25 	lds	r27, 0x253E
    3a74:	01 96       	adiw	r24, 0x01	; 1
    3a76:	a1 1d       	adc	r26, r1
    3a78:	b1 1d       	adc	r27, r1
    3a7a:	80 93 3b 25 	sts	0x253B, r24
    3a7e:	90 93 3c 25 	sts	0x253C, r25
    3a82:	a0 93 3d 25 	sts	0x253D, r26
    3a86:	b0 93 3e 25 	sts	0x253E, r27

  }

#if RADIOSTATS
   /* Sample radio on time. Less accurate than ENERGEST but a smaller footprint */
  if (RF230_receive_on) {
    3a8a:	80 91 da 26 	lds	r24, 0x26DA
    3a8e:	88 23       	and	r24, r24
    3a90:	f1 f0       	breq	.+60     	; 0x3ace <__vector_21+0xb8>
    if (++rcount >= CLOCK_SECOND) {
    3a92:	80 91 1c 1d 	lds	r24, 0x1D1C
    3a96:	8f 5f       	subi	r24, 0xFF	; 255
    3a98:	80 93 1c 1d 	sts	0x1D1C, r24
    3a9c:	80 91 1c 1d 	lds	r24, 0x1D1C
    3aa0:	87 ff       	sbrs	r24, 7
    3aa2:	15 c0       	rjmp	.+42     	; 0x3ace <__vector_21+0xb8>
      rcount=0;
    3aa4:	10 92 1c 1d 	sts	0x1D1C, r1
      radioontime++;
    3aa8:	80 91 33 25 	lds	r24, 0x2533
    3aac:	90 91 34 25 	lds	r25, 0x2534
    3ab0:	a0 91 35 25 	lds	r26, 0x2535
    3ab4:	b0 91 36 25 	lds	r27, 0x2536
    3ab8:	01 96       	adiw	r24, 0x01	; 1
    3aba:	a1 1d       	adc	r26, r1
    3abc:	b1 1d       	adc	r27, r1
    3abe:	80 93 33 25 	sts	0x2533, r24
    3ac2:	90 93 34 25 	sts	0x2534, r25
    3ac6:	a0 93 35 25 	sts	0x2535, r26
    3aca:	b0 93 36 25 	sts	0x2536, r27
}
#endif

#if 1
/*  gcc will save all registers on the stack if an external routine is called */
  if(etimer_pending()) {
    3ace:	0e 94 1a 18 	call	0x3034	; 0x3034 <etimer_pending>
    3ad2:	00 97       	sbiw	r24, 0x00	; 0
    3ad4:	11 f0       	breq	.+4      	; 0x3ada <__vector_21+0xc4>
    etimer_request_poll();
    3ad6:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <etimer_request_poll>
      etimer_process.needspoll = 1;
      poll_requested = 1;
    }
  }
#endif
}
    3ada:	ff 91       	pop	r31
    3adc:	ef 91       	pop	r30
    3ade:	bf 91       	pop	r27
    3ae0:	af 91       	pop	r26
    3ae2:	9f 91       	pop	r25
    3ae4:	8f 91       	pop	r24
    3ae6:	7f 91       	pop	r23
    3ae8:	6f 91       	pop	r22
    3aea:	5f 91       	pop	r21
    3aec:	4f 91       	pop	r20
    3aee:	3f 91       	pop	r19
    3af0:	2f 91       	pop	r18
    3af2:	0f 90       	pop	r0
    3af4:	0b be       	out	0x3b, r0	; 59
    3af6:	0f 90       	pop	r0
    3af8:	0f be       	out	0x3f, r0	; 63
    3afa:	0f 90       	pop	r0
    3afc:	1f 90       	pop	r1
    3afe:	18 95       	reti

00003b00 <__vector_25>:
#endif

#if NUMPORTS > 0
int (* input_handler_0)(unsigned char);
ISR(D_USART0_RX_vect)
{
    3b00:	1f 92       	push	r1
    3b02:	0f 92       	push	r0
    3b04:	0f b6       	in	r0, 0x3f	; 63
    3b06:	0f 92       	push	r0
    3b08:	0b b6       	in	r0, 0x3b	; 59
    3b0a:	0f 92       	push	r0
    3b0c:	11 24       	eor	r1, r1
    3b0e:	2f 93       	push	r18
    3b10:	3f 93       	push	r19
    3b12:	4f 93       	push	r20
    3b14:	5f 93       	push	r21
    3b16:	6f 93       	push	r22
    3b18:	7f 93       	push	r23
    3b1a:	8f 93       	push	r24
    3b1c:	9f 93       	push	r25
    3b1e:	af 93       	push	r26
    3b20:	bf 93       	push	r27
    3b22:	ef 93       	push	r30
    3b24:	ff 93       	push	r31
  unsigned char c;
  c = D_UDR0;
    3b26:	80 91 c6 00 	lds	r24, 0x00C6
  if (input_handler_0 != NULL) input_handler_0(c);
    3b2a:	e0 91 41 25 	lds	r30, 0x2541
    3b2e:	f0 91 42 25 	lds	r31, 0x2542
    3b32:	30 97       	sbiw	r30, 0x00	; 0
    3b34:	09 f0       	breq	.+2      	; 0x3b38 <__vector_25+0x38>
    3b36:	09 95       	icall
}
    3b38:	ff 91       	pop	r31
    3b3a:	ef 91       	pop	r30
    3b3c:	bf 91       	pop	r27
    3b3e:	af 91       	pop	r26
    3b40:	9f 91       	pop	r25
    3b42:	8f 91       	pop	r24
    3b44:	7f 91       	pop	r23
    3b46:	6f 91       	pop	r22
    3b48:	5f 91       	pop	r21
    3b4a:	4f 91       	pop	r20
    3b4c:	3f 91       	pop	r19
    3b4e:	2f 91       	pop	r18
    3b50:	0f 90       	pop	r0
    3b52:	0b be       	out	0x3b, r0	; 59
    3b54:	0f 90       	pop	r0
    3b56:	0f be       	out	0x3f, r0	; 63
    3b58:	0f 90       	pop	r0
    3b5a:	1f 90       	pop	r1
    3b5c:	18 95       	reti

00003b5e <__vector_36>:
#endif

#if NUMPORTS > 1
int (* input_handler_1)(unsigned char);
ISR(D_USART1_RX_vect)
{
    3b5e:	1f 92       	push	r1
    3b60:	0f 92       	push	r0
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	0f 92       	push	r0
    3b66:	0b b6       	in	r0, 0x3b	; 59
    3b68:	0f 92       	push	r0
    3b6a:	11 24       	eor	r1, r1
    3b6c:	2f 93       	push	r18
    3b6e:	3f 93       	push	r19
    3b70:	4f 93       	push	r20
    3b72:	5f 93       	push	r21
    3b74:	6f 93       	push	r22
    3b76:	7f 93       	push	r23
    3b78:	8f 93       	push	r24
    3b7a:	9f 93       	push	r25
    3b7c:	af 93       	push	r26
    3b7e:	bf 93       	push	r27
    3b80:	ef 93       	push	r30
    3b82:	ff 93       	push	r31
  unsigned char c;
  c = D_UDR1;
    3b84:	80 91 ce 00 	lds	r24, 0x00CE
  if (input_handler_1 != NULL) input_handler_1(c);
    3b88:	e0 91 3f 25 	lds	r30, 0x253F
    3b8c:	f0 91 40 25 	lds	r31, 0x2540
    3b90:	30 97       	sbiw	r30, 0x00	; 0
    3b92:	09 f0       	breq	.+2      	; 0x3b96 <__vector_36+0x38>
    3b94:	09 95       	icall
}
    3b96:	ff 91       	pop	r31
    3b98:	ef 91       	pop	r30
    3b9a:	bf 91       	pop	r27
    3b9c:	af 91       	pop	r26
    3b9e:	9f 91       	pop	r25
    3ba0:	8f 91       	pop	r24
    3ba2:	7f 91       	pop	r23
    3ba4:	6f 91       	pop	r22
    3ba6:	5f 91       	pop	r21
    3ba8:	4f 91       	pop	r20
    3baa:	3f 91       	pop	r19
    3bac:	2f 91       	pop	r18
    3bae:	0f 90       	pop	r0
    3bb0:	0b be       	out	0x3b, r0	; 59
    3bb2:	0f 90       	pop	r0
    3bb4:	0f be       	out	0x3f, r0	; 63
    3bb6:	0f 90       	pop	r0
    3bb8:	1f 90       	pop	r1
    3bba:	18 95       	reti

00003bbc <rs232_init>:
/*---------------------------------------------------------------------------*/
void
rs232_init (uint8_t port, uint8_t bd, uint8_t ffmt)
{
#if NUMPORTS > 0
 if (port == 0) {
    3bbc:	88 23       	and	r24, r24
    3bbe:	71 f4       	brne	.+28     	; 0x3bdc <rs232_init+0x20>
   D_UBRR0H = (uint8_t)(bd>>8);
    3bc0:	10 92 c5 00 	sts	0x00C5, r1
   D_UBRR0L = (uint8_t)bd;
    3bc4:	60 93 c4 00 	sts	0x00C4, r22
#if RS232_TX_INTERRUPTS
   txwait_0 = 0;
   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#else
   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | \
    3bc8:	88 e9       	ldi	r24, 0x98	; 152
    3bca:	80 93 c1 00 	sts	0x00C1, r24
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#endif
   D_UCSR0C = USART_UCSRC_SEL | ffmt;
    3bce:	40 93 c2 00 	sts	0x00C2, r20
   input_handler_0 = NULL;
    3bd2:	10 92 42 25 	sts	0x2542, r1
    3bd6:	10 92 41 25 	sts	0x2541, r1
    3bda:	08 95       	ret

#if NUMPORTS > 1
 } else if (port == 1) {
    3bdc:	81 30       	cpi	r24, 0x01	; 1
    3bde:	69 f4       	brne	.+26     	; 0x3bfa <rs232_init+0x3e>
   D_UBRR1H = (uint8_t)(bd>>8);
    3be0:	10 92 cd 00 	sts	0x00CD, r1
   D_UBRR1L = (uint8_t)bd;
    3be4:	60 93 cc 00 	sts	0x00CC, r22
#if RS232_TX_INTERRUPTS
   txwait_1 = 0;
   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#else
   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | \
    3be8:	88 e9       	ldi	r24, 0x98	; 152
    3bea:	80 93 c9 00 	sts	0x00C9, r24
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#endif
   D_UCSR1C = USART_UCSRC_SEL | ffmt;
    3bee:	40 93 ca 00 	sts	0x00CA, r20
   input_handler_1 = NULL;
    3bf2:	10 92 40 25 	sts	0x2540, r1
    3bf6:	10 92 3f 25 	sts	0x253F, r1
    3bfa:	08 95       	ret

00003bfc <rs232_send>:
  }
#endif
#else /* RS232_TX_INTERRUPTS */
  /* Block until tx ready and output character */
#if NUMPORTS > 0
  if (port == 0 ) {
    3bfc:	88 23       	and	r24, r24
    3bfe:	39 f4       	brne	.+14     	; 0x3c0e <rs232_send+0x12>
    while (!(D_UCSR0A & D_UDRE0M));
    3c00:	80 91 c0 00 	lds	r24, 0x00C0
    3c04:	85 ff       	sbrs	r24, 5
    3c06:	fc cf       	rjmp	.-8      	; 0x3c00 <rs232_send+0x4>
    D_UDR0 = c;
    3c08:	60 93 c6 00 	sts	0x00C6, r22
    3c0c:	08 95       	ret
#if NUMPORTS > 1
  } else if (port == 1) {
    3c0e:	81 30       	cpi	r24, 0x01	; 1
    3c10:	31 f4       	brne	.+12     	; 0x3c1e <rs232_send+0x22>
    while (!(D_UCSR1A & D_UDRE1M));
    3c12:	80 91 c8 00 	lds	r24, 0x00C8
    3c16:	85 ff       	sbrs	r24, 5
    3c18:	fc cf       	rjmp	.-8      	; 0x3c12 <rs232_send+0x16>
    D_UDR1 = c;
    3c1a:	60 93 ce 00 	sts	0x00CE, r22
    3c1e:	08 95       	ret

00003c20 <rs232_stdout_putchar>:
static FILE rs232_stdout = FDEV_SETUP_STREAM(rs232_stdout_putchar,
					     NULL,
					     _FDEV_SETUP_WRITE);

int rs232_stdout_putchar(char c, FILE *stream)
{
    3c20:	1f 93       	push	r17
    3c22:	18 2f       	mov	r17, r24
#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
  if(c=='\n') rs232_send(stdout_rs232_port, '\r');
    3c24:	8a 30       	cpi	r24, 0x0A	; 10
    3c26:	31 f4       	brne	.+12     	; 0x3c34 <rs232_stdout_putchar+0x14>
    3c28:	80 91 1d 1d 	lds	r24, 0x1D1D
    3c2c:	6d e0       	ldi	r22, 0x0D	; 13
    3c2e:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>
    3c32:	02 c0       	rjmp	.+4      	; 0x3c38 <rs232_stdout_putchar+0x18>
  if(c!='\r') rs232_send (stdout_rs232_port, c);
    3c34:	8d 30       	cpi	r24, 0x0D	; 13
    3c36:	29 f0       	breq	.+10     	; 0x3c42 <rs232_stdout_putchar+0x22>
    3c38:	80 91 1d 1d 	lds	r24, 0x1D1D
    3c3c:	61 2f       	mov	r22, r17
    3c3e:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>
#else
  rs232_send (stdout_rs232_port, c);
#endif
  return 0;
}
    3c42:	80 e0       	ldi	r24, 0x00	; 0
    3c44:	90 e0       	ldi	r25, 0x00	; 0
    3c46:	1f 91       	pop	r17
    3c48:	08 95       	ret

00003c4a <rs232_set_input>:
/*---------------------------------------------------------------------------*/
void
rs232_set_input(uint8_t port, int (*f)(unsigned char))
{
#if NUMPORTS > 0
  if (port == 0) {
    3c4a:	88 23       	and	r24, r24
    3c4c:	29 f4       	brne	.+10     	; 0x3c58 <rs232_set_input+0xe>
    input_handler_0 = f;
    3c4e:	70 93 42 25 	sts	0x2542, r23
    3c52:	60 93 41 25 	sts	0x2541, r22
    3c56:	08 95       	ret
#if NUMPORTS > 1
  } else if (port == 1) {
    3c58:	81 30       	cpi	r24, 0x01	; 1
    3c5a:	21 f4       	brne	.+8      	; 0x3c64 <rs232_set_input+0x1a>
    input_handler_1 = f;
    3c5c:	70 93 40 25 	sts	0x2540, r23
    3c60:	60 93 3f 25 	sts	0x253F, r22
    3c64:	08 95       	ret

00003c66 <rs232_print>:
}

/*---------------------------------------------------------------------------*/
void
rs232_print(uint8_t port, char *buf)
{
    3c66:	ef 92       	push	r14
    3c68:	ff 92       	push	r15
    3c6a:	1f 93       	push	r17
    3c6c:	cf 93       	push	r28
    3c6e:	df 93       	push	r29
    3c70:	18 2f       	mov	r17, r24
    3c72:	e6 2e       	mov	r14, r22
    3c74:	e7 01       	movw	r28, r14
    3c76:	7e 01       	movw	r14, r28
    3c78:	f7 2e       	mov	r15, r23
    3c7a:	e7 01       	movw	r28, r14
  while(*buf) {
    3c7c:	0c c0       	rjmp	.+24     	; 0x3c96 <rs232_print+0x30>
#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
    if(*buf=='\n') rs232_send(port, '\r');
    3c7e:	8a 30       	cpi	r24, 0x0A	; 10
    3c80:	21 f4       	brne	.+8      	; 0x3c8a <rs232_print+0x24>
    3c82:	81 2f       	mov	r24, r17
    3c84:	6d e0       	ldi	r22, 0x0D	; 13
    3c86:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>
	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
    3c8a:	69 91       	ld	r22, Y+
    3c8c:	6d 30       	cpi	r22, 0x0D	; 13
    3c8e:	19 f0       	breq	.+6      	; 0x3c96 <rs232_print+0x30>
    3c90:	81 2f       	mov	r24, r17
    3c92:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>

/*---------------------------------------------------------------------------*/
void
rs232_print(uint8_t port, char *buf)
{
  while(*buf) {
    3c96:	88 81       	ld	r24, Y
    3c98:	88 23       	and	r24, r24
    3c9a:	89 f7       	brne	.-30     	; 0x3c7e <rs232_print+0x18>
	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
#else
    rs232_send(port, *buf++);
#endif
  }
}
    3c9c:	df 91       	pop	r29
    3c9e:	cf 91       	pop	r28
    3ca0:	1f 91       	pop	r17
    3ca2:	ff 90       	pop	r15
    3ca4:	ef 90       	pop	r14
    3ca6:	08 95       	ret

00003ca8 <slip_arch_writeb>:
}
#endif
/*---------------------------------------------------------------------------*/
void
slip_arch_writeb(unsigned char c)
{
    3ca8:	68 2f       	mov	r22, r24
  rs232_send(SLIP_PORT, c);
    3caa:	80 e0       	ldi	r24, 0x00	; 0
    3cac:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <rs232_send>
}
    3cb0:	08 95       	ret

00003cb2 <rs232_redirect_stdout>:
#endif
  return 0;
}
/*---------------------------------------------------------------------------*/
void rs232_redirect_stdout (uint8_t port) {
  stdout_rs232_port = port;
    3cb2:	80 93 1d 1d 	sts	0x1D1D, r24
  stdout = &rs232_stdout;
    3cb6:	8f ee       	ldi	r24, 0xEF	; 239
    3cb8:	9d e0       	ldi	r25, 0x0D	; 13
    3cba:	90 93 de 2d 	sts	0x2DDE, r25
    3cbe:	80 93 dd 2d 	sts	0x2DDD, r24
}
    3cc2:	08 95       	ret

00003cc4 <watchdog_init>:
watchdog_init(void)
{
/*  Clear startup bit and disable the wdt, whether or not it will be used.
    Random code may have caused the last reset.
 */
	MCUSR&=~(1<<WDRF);
    3cc4:	84 b7       	in	r24, 0x34	; 52
    3cc6:	87 7f       	andi	r24, 0xF7	; 247
    3cc8:	84 bf       	out	0x34, r24	; 52
    wdt_disable();
    3cca:	88 e1       	ldi	r24, 0x18	; 24
    3ccc:	0f b6       	in	r0, 0x3f	; 63
    3cce:	f8 94       	cli
    3cd0:	80 93 60 00 	sts	0x0060, r24
    3cd4:	10 92 60 00 	sts	0x0060, r1
    3cd8:	0f be       	out	0x3f, r0	; 63
#if WATCHDOG_CONF_BALANCE && WATCHDOG_CONF_TIMEOUT >= 0
	stopped = 1;
#endif
}
    3cda:	08 95       	ret

00003cdc <watchdog_start>:
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	stopped--;
	if(!stopped)
#endif
		wdt_enable(WATCHDOG_CONF_TIMEOUT);
    3cdc:	2f e0       	ldi	r18, 0x0F	; 15
    3cde:	88 e1       	ldi	r24, 0x18	; 24
    3ce0:	90 e0       	ldi	r25, 0x00	; 0
    3ce2:	0f b6       	in	r0, 0x3f	; 63
    3ce4:	f8 94       	cli
    3ce6:	a8 95       	wdr
    3ce8:	80 93 60 00 	sts	0x0060, r24
    3cec:	0f be       	out	0x3f, r0	; 63
    3cee:	20 93 60 00 	sts	0x0060, r18
#endif  
}
    3cf2:	08 95       	ret

00003cf4 <watchdog_periodic>:
{
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	if(!stopped)
#endif
		wdt_reset();
    3cf4:	a8 95       	wdr
#endif
}
    3cf6:	08 95       	ret

00003cf8 <watchdog_stop>:
{
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	stopped++;
#endif
	wdt_disable();
    3cf8:	88 e1       	ldi	r24, 0x18	; 24
    3cfa:	0f b6       	in	r0, 0x3f	; 63
    3cfc:	f8 94       	cli
    3cfe:	80 93 60 00 	sts	0x0060, r24
    3d02:	10 92 60 00 	sts	0x0060, r1
    3d06:	0f be       	out	0x3f, r0	; 63
#endif
}
    3d08:	08 95       	ret

00003d0a <watchdog_reboot>:
/*---------------------------------------------------------------------------*/
void
watchdog_reboot(void)
{
	cli();
    3d0a:	f8 94       	cli
	wdt_enable(WDTO_15MS); //wd on,250ms 
    3d0c:	28 e0       	ldi	r18, 0x08	; 8
    3d0e:	88 e1       	ldi	r24, 0x18	; 24
    3d10:	90 e0       	ldi	r25, 0x00	; 0
    3d12:	0f b6       	in	r0, 0x3f	; 63
    3d14:	f8 94       	cli
    3d16:	a8 95       	wdr
    3d18:	80 93 60 00 	sts	0x0060, r24
    3d1c:	0f be       	out	0x3f, r0	; 63
    3d1e:	20 93 60 00 	sts	0x0060, r18
    3d22:	ff cf       	rjmp	.-2      	; 0x3d22 <watchdog_reboot+0x18>

00003d24 <flushrx>:


static void
flushrx(void)
{
  rxframe[rxframe_head].length=0;
    3d24:	80 91 4e 25 	lds	r24, 0x254E
    3d28:	90 e0       	ldi	r25, 0x00	; 0
    3d2a:	fc 01       	movw	r30, r24
    3d2c:	ee 0f       	add	r30, r30
    3d2e:	ff 1f       	adc	r31, r31
    3d30:	96 95       	lsr	r25
    3d32:	98 2f       	mov	r25, r24
    3d34:	88 27       	eor	r24, r24
    3d36:	97 95       	ror	r25
    3d38:	87 95       	ror	r24
    3d3a:	e8 0f       	add	r30, r24
    3d3c:	f9 1f       	adc	r31, r25
    3d3e:	e1 5b       	subi	r30, 0xB1	; 177
    3d40:	fa 4d       	sbci	r31, 0xDA	; 218
    3d42:	10 82       	st	Z, r1
}
    3d44:	08 95       	ret

00003d46 <rf230_pending_packet>:
rf230_pending_packet(void)
{
#if RF230_INSERTACK
    if(ack_pending == 1) return 1;
#endif
  return rf230_pending;
    3d46:	80 91 48 25 	lds	r24, 0x2548
}
    3d4a:	90 e0       	ldi	r25, 0x00	; 0
    3d4c:	08 95       	ret

00003d4e <rf230_isidle>:
{
  uint8_t radio_state;
  /* Contikimac can turn the radio off during an interrupt, so we always check
   * slptr before doing the SPI transfer. The caller must also make this test
   * if it could otherwise hang waiting for idle! */
  if (hal_get_slptr()) {
    3d4e:	80 91 39 01 	lds	r24, 0x0139
    3d52:	81 fd       	sbrc	r24, 1
    3d54:	12 c0       	rjmp	.+36     	; 0x3d7a <rf230_isidle+0x2c>
    if (RF230_receive_on) DEBUGFLOW('-');
	  return 1;
  }
  else {
    radio_state = hal_subregister_read(SR_TRX_STATUS);
    3d56:	81 e4       	ldi	r24, 0x41	; 65
    3d58:	91 e0       	ldi	r25, 0x01	; 1
    3d5a:	6f e1       	ldi	r22, 0x1F	; 31
    3d5c:	40 e0       	ldi	r20, 0x00	; 0
    3d5e:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <hal_subregister_read>
    3d62:	98 2f       	mov	r25, r24
    if (radio_state != BUSY_TX_ARET &&
    3d64:	81 51       	subi	r24, 0x11	; 17
    3d66:	82 30       	cpi	r24, 0x02	; 2
    3d68:	50 f0       	brcs	.+20     	; 0x3d7e <rf230_isidle+0x30>
      radio_state != BUSY_RX_AACK &&
    3d6a:	9f 31       	cpi	r25, 0x1F	; 31
    3d6c:	41 f0       	breq	.+16     	; 0x3d7e <rf230_isidle+0x30>
      radio_state != STATE_TRANSITION &&
    3d6e:	91 30       	cpi	r25, 0x01	; 1
    3d70:	41 f0       	breq	.+16     	; 0x3d82 <rf230_isidle+0x34>
    hal_subregister_write(SR_TRX_CMD, CMD_FORCE_TRX_OFF);
    delay_us(TIME_CMD_FORCE_TRX_OFF);
}
/*---------------------------------------------------------------------------*/
static char
rf230_isidle(void)
    3d72:	81 e0       	ldi	r24, 0x01	; 1
    3d74:	92 30       	cpi	r25, 0x02	; 2
    3d76:	31 f4       	brne	.+12     	; 0x3d84 <rf230_isidle+0x36>
    3d78:	02 c0       	rjmp	.+4      	; 0x3d7e <rf230_isidle+0x30>
  /* Contikimac can turn the radio off during an interrupt, so we always check
   * slptr before doing the SPI transfer. The caller must also make this test
   * if it could otherwise hang waiting for idle! */
  if (hal_get_slptr()) {
    if (RF230_receive_on) DEBUGFLOW('-');
	  return 1;
    3d7a:	81 e0       	ldi	r24, 0x01	; 1
    3d7c:	08 95       	ret
      radio_state != BUSY_RX && 
      radio_state != BUSY_TX) {
      return(1);
    }
    else {
      return(0);
    3d7e:	80 e0       	ldi	r24, 0x00	; 0
    3d80:	08 95       	ret
    3d82:	80 e0       	ldi	r24, 0x00	; 0
    }
  }
}
    3d84:	08 95       	ret

00003d86 <rf230_waitidle>:
static void
rf230_waitidle(void)
{
  /* TX_ARET with multiple csma retries can take a very long time to finish */
  while (1) {
    if (hal_get_slptr()) return;
    3d86:	80 91 39 01 	lds	r24, 0x0139
    3d8a:	81 fd       	sbrc	r24, 1
    3d8c:	04 c0       	rjmp	.+8      	; 0x3d96 <rf230_waitidle+0x10>
    if (rf230_isidle()) break;
    3d8e:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <rf230_isidle>
    3d92:	88 23       	and	r24, r24
    3d94:	c1 f3       	breq	.-16     	; 0x3d86 <rf230_waitidle>
    3d96:	08 95       	ret

00003d98 <rf230_receiving_packet>:
/*---------------------------------------------------------------------------*/
int
rf230_receiving_packet(void)
{
  uint8_t radio_state;
  if (hal_get_slptr()) {
    3d98:	80 91 39 01 	lds	r24, 0x0139
    3d9c:	81 fd       	sbrc	r24, 1
    3d9e:	0c c0       	rjmp	.+24     	; 0x3db8 <rf230_receiving_packet+0x20>
    DEBUGFLOW('=');
  } else {  
    radio_state = hal_subregister_read(SR_TRX_STATUS);
    3da0:	81 e4       	ldi	r24, 0x41	; 65
    3da2:	91 e0       	ldi	r25, 0x01	; 1
    3da4:	6f e1       	ldi	r22, 0x1F	; 31
    3da6:	40 e0       	ldi	r20, 0x00	; 0
    3da8:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <hal_subregister_read>
    if ((radio_state==BUSY_RX) || (radio_state==BUSY_RX_AACK)) {
    3dac:	81 30       	cpi	r24, 0x01	; 1
    3dae:	39 f0       	breq	.+14     	; 0x3dbe <rf230_receiving_packet+0x26>
	 return 0;
   }
}
/*---------------------------------------------------------------------------*/
int
rf230_receiving_packet(void)
    3db0:	21 e0       	ldi	r18, 0x01	; 1
    3db2:	30 e0       	ldi	r19, 0x00	; 0
    3db4:	81 31       	cpi	r24, 0x11	; 17
    3db6:	29 f0       	breq	.+10     	; 0x3dc2 <rf230_receiving_packet+0x2a>
    if ((radio_state==BUSY_RX) || (radio_state==BUSY_RX_AACK)) {
//      DEBUGFLOW('8');
      return 1;
    }
  }
  return 0;
    3db8:	20 e0       	ldi	r18, 0x00	; 0
    3dba:	30 e0       	ldi	r19, 0x00	; 0
    3dbc:	02 c0       	rjmp	.+4      	; 0x3dc2 <rf230_receiving_packet+0x2a>
    DEBUGFLOW('=');
  } else {  
    radio_state = hal_subregister_read(SR_TRX_STATUS);
    if ((radio_state==BUSY_RX) || (radio_state==BUSY_RX_AACK)) {
//      DEBUGFLOW('8');
      return 1;
    3dbe:	21 e0       	ldi	r18, 0x01	; 1
    3dc0:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 0;
}
    3dc2:	c9 01       	movw	r24, r18
    3dc4:	08 95       	ret

00003dc6 <radio_reset_state_machine>:
    /* The data sheet is not clear on what happens when slptr is raised in RX on
     * states, it "remains in the new state and returns to the preceding state
     * when slptr is lowered". Possibly that is why there is an undocumented
     * TIME_NOCLK_TO_WAKE delay here?
     */
    if (hal_get_slptr()) {
    3dc6:	80 91 39 01 	lds	r24, 0x0139
    3dca:	81 ff       	sbrs	r24, 1
    3dcc:	09 c0       	rjmp	.+18     	; 0x3de0 <radio_reset_state_machine+0x1a>
        DEBUGFLOW('V');
        hal_set_slptr_low();
    3dce:	80 91 39 01 	lds	r24, 0x0139
    3dd2:	8d 7f       	andi	r24, 0xFD	; 253
    3dd4:	80 93 39 01 	sts	0x0139, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3dd8:	8d e0       	ldi	r24, 0x0D	; 13
    3dda:	90 e0       	ldi	r25, 0x00	; 0
    3ddc:	01 97       	sbiw	r24, 0x01	; 1
    3dde:	f1 f7       	brne	.-4      	; 0x3ddc <radio_reset_state_machine+0x16>
        delay_us(TIME_NOCLK_TO_WAKE);
    }

    hal_subregister_write(SR_TRX_CMD, CMD_FORCE_TRX_OFF);
    3de0:	82 e4       	ldi	r24, 0x42	; 66
    3de2:	91 e0       	ldi	r25, 0x01	; 1
    3de4:	6f e1       	ldi	r22, 0x1F	; 31
    3de6:	40 e0       	ldi	r20, 0x00	; 0
    3de8:	23 e0       	ldi	r18, 0x03	; 3
    3dea:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
    3dee:	83 e0       	ldi	r24, 0x03	; 3
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    3df2:	01 97       	sbiw	r24, 0x01	; 1
    3df4:	f1 f7       	brne	.-4      	; 0x3df2 <radio_reset_state_machine+0x2c>
    delay_us(TIME_CMD_FORCE_TRX_OFF);
}
    3df6:	08 95       	ret

00003df8 <radio_off>:
  rf230_waitidle();
}
static void
radio_off(void)
{
  RF230_receive_on = 0;
    3df8:	10 92 da 26 	sts	0x26DA, r1
  if (hal_get_slptr()) {
    3dfc:	80 91 39 01 	lds	r24, 0x0139
    3e00:	81 fd       	sbrc	r24, 1
    3e02:	8f c0       	rjmp	.+286    	; 0x3f22 <radio_off+0x12a>
#ifdef RF230BB_HOOK_RADIO_OFF
  RF230BB_HOOK_RADIO_OFF();
#endif

  /* Wait for any transmission to end */
  rf230_waitidle(); 
    3e04:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <rf230_waitidle>
/* Do not transmit autoacks when stack thinks radio is off */
  radio_set_trx_state(RX_ON);
#else 
  /* Force the device into TRX_OFF.
   * First make sure an interrupt did not initiate a sleep. */
  if (hal_get_slptr()) {
    3e08:	80 91 39 01 	lds	r24, 0x0139
    3e0c:	81 fd       	sbrc	r24, 1
    3e0e:	89 c0       	rjmp	.+274    	; 0x3f22 <radio_off+0x12a>
    DEBUGFLOW('?');
    return;
  }
  radio_reset_state_machine();
    3e10:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <radio_reset_state_machine>
#if RADIOSLEEPSWHENOFF
  /* Sleep Radio */
  hal_set_slptr_high();
    3e14:	80 91 39 01 	lds	r24, 0x0139
    3e18:	82 60       	ori	r24, 0x02	; 2
    3e1a:	80 93 39 01 	sts	0x0139, r24
  ENERGEST_OFF(ENERGEST_TYPE_LED_RED);
    3e1e:	80 91 5c 27 	lds	r24, 0x275C
    3e22:	88 23       	and	r24, r24
    3e24:	e9 f1       	breq	.+122    	; 0x3ea0 <radio_off+0xa8>
    3e26:	80 91 94 00 	lds	r24, 0x0094
    3e2a:	90 91 95 00 	lds	r25, 0x0095
    3e2e:	20 91 6d 27 	lds	r18, 0x276D
    3e32:	30 91 6e 27 	lds	r19, 0x276E
    3e36:	82 17       	cp	r24, r18
    3e38:	93 07       	cpc	r25, r19
    3e3a:	a0 f4       	brcc	.+40     	; 0x3e64 <radio_off+0x6c>
    3e3c:	80 91 39 27 	lds	r24, 0x2739
    3e40:	90 91 3a 27 	lds	r25, 0x273A
    3e44:	a0 91 3b 27 	lds	r26, 0x273B
    3e48:	b0 91 3c 27 	lds	r27, 0x273C
    3e4c:	8c 57       	subi	r24, 0x7C	; 124
    3e4e:	91 4e       	sbci	r25, 0xE1	; 225
    3e50:	af 4f       	sbci	r26, 0xFF	; 255
    3e52:	bf 4f       	sbci	r27, 0xFF	; 255
    3e54:	80 93 39 27 	sts	0x2739, r24
    3e58:	90 93 3a 27 	sts	0x273A, r25
    3e5c:	a0 93 3b 27 	sts	0x273B, r26
    3e60:	b0 93 3c 27 	sts	0x273C, r27
    3e64:	80 91 94 00 	lds	r24, 0x0094
    3e68:	90 91 95 00 	lds	r25, 0x0095
    3e6c:	82 1b       	sub	r24, r18
    3e6e:	93 0b       	sbc	r25, r19
    3e70:	a0 e0       	ldi	r26, 0x00	; 0
    3e72:	b0 e0       	ldi	r27, 0x00	; 0
    3e74:	20 91 39 27 	lds	r18, 0x2739
    3e78:	30 91 3a 27 	lds	r19, 0x273A
    3e7c:	40 91 3b 27 	lds	r20, 0x273B
    3e80:	50 91 3c 27 	lds	r21, 0x273C
    3e84:	82 0f       	add	r24, r18
    3e86:	93 1f       	adc	r25, r19
    3e88:	a4 1f       	adc	r26, r20
    3e8a:	b5 1f       	adc	r27, r21
    3e8c:	80 93 39 27 	sts	0x2739, r24
    3e90:	90 93 3a 27 	sts	0x273A, r25
    3e94:	a0 93 3b 27 	sts	0x273B, r26
    3e98:	b0 93 3c 27 	sts	0x273C, r27
    3e9c:	10 92 5c 27 	sts	0x275C, r1
#endif
#endif /* RADIOALWAYSON */

   ENERGEST_OFF(ENERGEST_TYPE_LISTEN);
    3ea0:	80 91 5e 27 	lds	r24, 0x275E
    3ea4:	88 23       	and	r24, r24
    3ea6:	e9 f1       	breq	.+122    	; 0x3f22 <radio_off+0x12a>
    3ea8:	80 91 94 00 	lds	r24, 0x0094
    3eac:	90 91 95 00 	lds	r25, 0x0095
    3eb0:	20 91 71 27 	lds	r18, 0x2771
    3eb4:	30 91 72 27 	lds	r19, 0x2772
    3eb8:	82 17       	cp	r24, r18
    3eba:	93 07       	cpc	r25, r19
    3ebc:	a0 f4       	brcc	.+40     	; 0x3ee6 <radio_off+0xee>
    3ebe:	80 91 41 27 	lds	r24, 0x2741
    3ec2:	90 91 42 27 	lds	r25, 0x2742
    3ec6:	a0 91 43 27 	lds	r26, 0x2743
    3eca:	b0 91 44 27 	lds	r27, 0x2744
    3ece:	8c 57       	subi	r24, 0x7C	; 124
    3ed0:	91 4e       	sbci	r25, 0xE1	; 225
    3ed2:	af 4f       	sbci	r26, 0xFF	; 255
    3ed4:	bf 4f       	sbci	r27, 0xFF	; 255
    3ed6:	80 93 41 27 	sts	0x2741, r24
    3eda:	90 93 42 27 	sts	0x2742, r25
    3ede:	a0 93 43 27 	sts	0x2743, r26
    3ee2:	b0 93 44 27 	sts	0x2744, r27
    3ee6:	80 91 94 00 	lds	r24, 0x0094
    3eea:	90 91 95 00 	lds	r25, 0x0095
    3eee:	82 1b       	sub	r24, r18
    3ef0:	93 0b       	sbc	r25, r19
    3ef2:	a0 e0       	ldi	r26, 0x00	; 0
    3ef4:	b0 e0       	ldi	r27, 0x00	; 0
    3ef6:	20 91 41 27 	lds	r18, 0x2741
    3efa:	30 91 42 27 	lds	r19, 0x2742
    3efe:	40 91 43 27 	lds	r20, 0x2743
    3f02:	50 91 44 27 	lds	r21, 0x2744
    3f06:	82 0f       	add	r24, r18
    3f08:	93 1f       	adc	r25, r19
    3f0a:	a4 1f       	adc	r26, r20
    3f0c:	b5 1f       	adc	r27, r21
    3f0e:	80 93 41 27 	sts	0x2741, r24
    3f12:	90 93 42 27 	sts	0x2742, r25
    3f16:	a0 93 43 27 	sts	0x2743, r26
    3f1a:	b0 93 44 27 	sts	0x2744, r27
    3f1e:	10 92 5e 27 	sts	0x275E, r1
    3f22:	08 95       	ret

00003f24 <rf230_off>:
/*---------------------------------------------------------------------------*/
static int
rf230_off(void)
{
  /* Don't do anything if we are already turned off. */
  if(RF230_receive_on == 0) {
    3f24:	80 91 da 26 	lds	r24, 0x26DA
    3f28:	88 23       	and	r24, r24
    3f2a:	21 f0       	breq	.+8      	; 0x3f34 <rf230_off+0x10>

  /* If we are currently receiving a packet, we still call radio_off(),
     as that routine waits until Rx is complete (packet uploaded in ISR
     so no worries about losing it). The transmit routine may also turn
+     the radio off on a return to sleep. rf230_isidle checks for that. */
  if (!rf230_isidle()) {
    3f2c:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <rf230_isidle>
  //DEBUGFLOW('X');DEBUGFLOW('X');DEBUGFLOW('A'+hal_subregister_read(SR_TRX_STATUS));
    PRINTF("rf230_off: busy receiving\r\n");
    //return 1;
  }

  radio_off();
    3f30:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <radio_off>
  return 0;
}
    3f34:	80 e0       	ldi	r24, 0x00	; 0
    3f36:	90 e0       	ldi	r25, 0x00	; 0
    3f38:	08 95       	ret

00003f3a <set_txpower>:
set_txpower(uint8_t power)
{
  if (power > TX_PWR_17_2DBM){
    power=TX_PWR_17_2DBM;
  }
  if (hal_get_slptr()) {
    3f3a:	90 91 39 01 	lds	r25, 0x0139
    3f3e:	91 fd       	sbrc	r25, 1
    3f40:	0a c0       	rjmp	.+20     	; 0x3f56 <set_txpower+0x1c>
    DEBUGFLOW('f');
    PRINTF("rf230_set_txpower:Sleeping");  //happens with cxmac
  } else {
    //DEBUGFLOW('g');
    hal_subregister_write(SR_TX_PWR, power);
    3f42:	28 2f       	mov	r18, r24
    3f44:	80 31       	cpi	r24, 0x10	; 16
    3f46:	08 f0       	brcs	.+2      	; 0x3f4a <set_txpower+0x10>
    3f48:	2f e0       	ldi	r18, 0x0F	; 15
    3f4a:	85 e4       	ldi	r24, 0x45	; 69
    3f4c:	91 e0       	ldi	r25, 0x01	; 1
    3f4e:	6f e0       	ldi	r22, 0x0F	; 15
    3f50:	40 e0       	ldi	r20, 0x00	; 0
    3f52:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
    3f56:	08 95       	ret

00003f58 <rf230_prepare>:
  return tx_result;
}
/*---------------------------------------------------------------------------*/
static int
rf230_prepare(const void *payload, unsigned short payload_len)
{
    3f58:	b8 2f       	mov	r27, r24
    3f5a:	a9 2f       	mov	r26, r25
    3f5c:	f6 2f       	mov	r31, r22
    3f5e:	e7 2f       	mov	r30, r23
  DEBUGFLOW('p');

//  PRINTF("rf230: sending %d bytes\n", payload_len);
//  PRINTSHORT("s%d ",payload_len);

  RIMESTATS_ADD(tx);
    3f60:	20 91 dd 26 	lds	r18, 0x26DD
    3f64:	30 91 de 26 	lds	r19, 0x26DE
    3f68:	40 91 df 26 	lds	r20, 0x26DF
    3f6c:	50 91 e0 26 	lds	r21, 0x26E0
    3f70:	2f 5f       	subi	r18, 0xFF	; 255
    3f72:	3f 4f       	sbci	r19, 0xFF	; 255
    3f74:	4f 4f       	sbci	r20, 0xFF	; 255
    3f76:	5f 4f       	sbci	r21, 0xFF	; 255
    3f78:	20 93 dd 26 	sts	0x26DD, r18
    3f7c:	30 93 de 26 	sts	0x26DE, r19
    3f80:	40 93 df 26 	sts	0x26DF, r20
    3f84:	50 93 e0 26 	sts	0x26E0, r21
#if RF230_CONF_CHECKSUM
  checksum = crc16_data(payload, payload_len, 0);
#endif
 
  /* Copy payload to RAM buffer */
  total_len = payload_len + AUX_LEN;
    3f88:	86 2f       	mov	r24, r22
    3f8a:	8e 5f       	subi	r24, 0xFE	; 254
  if (total_len > RF230_MAX_TX_FRAME_LENGTH){
    3f8c:	87 ff       	sbrs	r24, 7
    3f8e:	0c c0       	rjmp	.+24     	; 0x3fa8 <rf230_prepare+0x50>
#if RADIOSTATS
    RF230_sendfail++;
    3f90:	80 91 d8 26 	lds	r24, 0x26D8
    3f94:	90 91 d9 26 	lds	r25, 0x26D9
    3f98:	01 96       	adiw	r24, 0x01	; 1
    3f9a:	90 93 d9 26 	sts	0x26D9, r25
    3f9e:	80 93 d8 26 	sts	0x26D8, r24
#endif
    PRINTF("rf230_prepare: packet too large (%d, max: %d)\n",total_len,RF230_MAX_TX_FRAME_LENGTH);
    ret = -1;
    3fa2:	2f ef       	ldi	r18, 0xFF	; 255
    3fa4:	3f ef       	ldi	r19, 0xFF	; 255
    goto bail;
    3fa6:	0b c0       	rjmp	.+22     	; 0x3fbe <rf230_prepare+0x66>
  }
  pbuf=&buffer[0];
  memcpy(pbuf,payload,payload_len);
    3fa8:	2e e1       	ldi	r18, 0x1E	; 30
    3faa:	3d e1       	ldi	r19, 0x1D	; 29
    3fac:	c9 01       	movw	r24, r18
    3fae:	6b 2f       	mov	r22, r27
    3fb0:	7a 2f       	mov	r23, r26
    3fb2:	4f 2f       	mov	r20, r31
    3fb4:	5e 2f       	mov	r21, r30
    3fb6:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
}
/*---------------------------------------------------------------------------*/
static int
rf230_prepare(const void *payload, unsigned short payload_len)
{
  int ret = 0;
    3fba:	20 e0       	ldi	r18, 0x00	; 0
    3fbc:	30 e0       	ldi	r19, 0x00	; 0
#endif
  

bail:
  return ret;
}
    3fbe:	c9 01       	movw	r24, r18
    3fc0:	08 95       	ret

00003fc2 <radio_get_trx_state>:
 */
//static uint8_t
uint8_t
radio_get_trx_state(void)
{
    return hal_subregister_read(SR_TRX_STATUS);
    3fc2:	81 e4       	ldi	r24, 0x41	; 65
    3fc4:	91 e0       	ldi	r25, 0x01	; 1
    3fc6:	6f e1       	ldi	r22, 0x1F	; 31
    3fc8:	40 e0       	ldi	r20, 0x00	; 0
    3fca:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <hal_subregister_read>
}
    3fce:	08 95       	ret

00003fd0 <radio_set_trx_state>:
 *  \retval    RADIO_TIMED_OUT        The state transition could not be completed
 *                                  within resonable time.
 */
static radio_status_t
radio_set_trx_state(uint8_t new_state)
{
    3fd0:	0f 93       	push	r16
    3fd2:	1f 93       	push	r17
    3fd4:	18 2f       	mov	r17, r24
    uint8_t current_state;

    /*Check function parameter and current state of the radio transceiver.*/
    if (!((new_state == TRX_OFF)    ||
    3fd6:	88 30       	cpi	r24, 0x08	; 8
    3fd8:	49 f0       	breq	.+18     	; 0x3fec <radio_set_trx_state+0x1c>
    3fda:	86 30       	cpi	r24, 0x06	; 6
    3fdc:	39 f0       	breq	.+14     	; 0x3fec <radio_set_trx_state+0x1c>
          (new_state == RX_ON)      ||
    3fde:	89 30       	cpi	r24, 0x09	; 9
    3fe0:	29 f0       	breq	.+10     	; 0x3fec <radio_set_trx_state+0x1c>
          (new_state == PLL_ON)     ||
    3fe2:	86 31       	cpi	r24, 0x16	; 22
    3fe4:	19 f0       	breq	.+6      	; 0x3fec <radio_set_trx_state+0x1c>
radio_set_trx_state(uint8_t new_state)
{
    uint8_t current_state;

    /*Check function parameter and current state of the radio transceiver.*/
    if (!((new_state == TRX_OFF)    ||
    3fe6:	89 31       	cpi	r24, 0x19	; 25
    3fe8:	09 f0       	breq	.+2      	; 0x3fec <radio_set_trx_state+0x1c>
    3fea:	45 c0       	rjmp	.+138    	; 0x4076 <radio_set_trx_state+0xa6>
          (new_state == RX_AACK_ON) ||
          (new_state == TX_ARET_ON))){
        return RADIO_INVALID_ARGUMENT;
    }

	  if (hal_get_slptr()) {
    3fec:	80 91 39 01 	lds	r24, 0x0139
    3ff0:	81 fd       	sbrc	r24, 1
    3ff2:	44 c0       	rjmp	.+136    	; 0x407c <radio_set_trx_state+0xac>
	      DEBUGFLOW('W');
        return RADIO_WRONG_STATE;
    }

    /* Wait for radio to finish previous operation */
    rf230_waitidle();
    3ff4:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <rf230_waitidle>
    current_state = radio_get_trx_state();
    3ff8:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <radio_get_trx_state>
    3ffc:	08 2f       	mov	r16, r24

    if (new_state == current_state){
    3ffe:	18 17       	cp	r17, r24
    4000:	09 f4       	brne	.+2      	; 0x4004 <radio_set_trx_state+0x34>
    4002:	42 c0       	rjmp	.+132    	; 0x4088 <radio_set_trx_state+0xb8>
    /* At this point it is clear that the requested new_state is: */
    /* TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON. */

    /* The radio transceiver can be in one of the following states: */
    /* TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON, TX_ARET_ON. */
    if(new_state == TRX_OFF){
    4004:	18 30       	cpi	r17, 0x08	; 8
    4006:	29 f4       	brne	.+10     	; 0x4012 <radio_set_trx_state+0x42>
        if (hal_get_slptr()) DEBUGFLOW('K');DEBUGFLOW('K');DEBUGFLOW('A'+hal_subregister_read(SR_TRX_STATUS));
    4008:	80 91 39 01 	lds	r24, 0x0139
        radio_reset_state_machine(); /* Go to TRX_OFF from any state. */
    400c:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <radio_reset_state_machine>
    4010:	24 c0       	rjmp	.+72     	; 0x405a <radio_set_trx_state+0x8a>
    } else {
        /* It is not allowed to go from RX_AACK_ON or TX_AACK_ON and directly to */
        /* TX_AACK_ON or RX_AACK_ON respectively. Need to go via PLL_ON. */
        /* (Old datasheets allowed other transitions, but this code complies with */
        /* the current specification for RF230, RF231 and 128RFA1.) */
        if (((new_state == TX_ARET_ON) && (current_state == RX_AACK_ON)) ||
    4012:	19 31       	cpi	r17, 0x19	; 25
    4014:	19 f4       	brne	.+6      	; 0x401c <radio_set_trx_state+0x4c>
    4016:	86 31       	cpi	r24, 0x16	; 22
    4018:	81 f4       	brne	.+32     	; 0x403a <radio_set_trx_state+0x6a>
    401a:	04 c0       	rjmp	.+8      	; 0x4024 <radio_set_trx_state+0x54>
    401c:	16 31       	cpi	r17, 0x16	; 22
    401e:	69 f4       	brne	.+26     	; 0x403a <radio_set_trx_state+0x6a>
            ((new_state == RX_AACK_ON) && (current_state == TX_ARET_ON))){
    4020:	89 31       	cpi	r24, 0x19	; 25
    4022:	59 f4       	brne	.+22     	; 0x403a <radio_set_trx_state+0x6a>
            /* First do intermediate state transition to PLL_ON. */
            /* The final state transition is handled after the if-else if. */
            hal_subregister_write(SR_TRX_CMD, PLL_ON);
    4024:	82 e4       	ldi	r24, 0x42	; 66
    4026:	91 e0       	ldi	r25, 0x01	; 1
    4028:	6f e1       	ldi	r22, 0x1F	; 31
    402a:	40 e0       	ldi	r20, 0x00	; 0
    402c:	29 e0       	ldi	r18, 0x09	; 9
    402e:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
    4032:	e3 e0       	ldi	r30, 0x03	; 3
    4034:	f0 e0       	ldi	r31, 0x00	; 0
    4036:	31 97       	sbiw	r30, 0x01	; 1
    4038:	f1 f7       	brne	.-4      	; 0x4036 <radio_set_trx_state+0x66>
            delay_us(TIME_STATE_TRANSITION_PLL_ACTIVE);
        }

        /* Any other state transition can be done directly. */
        hal_subregister_write(SR_TRX_CMD, new_state);
    403a:	82 e4       	ldi	r24, 0x42	; 66
    403c:	91 e0       	ldi	r25, 0x01	; 1
    403e:	6f e1       	ldi	r22, 0x1F	; 31
    4040:	40 e0       	ldi	r20, 0x00	; 0
    4042:	21 2f       	mov	r18, r17
    4044:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>

        /* When the PLL is active most states can be reached in 1us. However, from */
        /* TRX_OFF the PLL needs time to activate. */
        if (current_state == TRX_OFF){
    4048:	08 30       	cpi	r16, 0x08	; 8
    404a:	19 f4       	brne	.+6      	; 0x4052 <radio_set_trx_state+0x82>
    404c:	e9 e6       	ldi	r30, 0x69	; 105
    404e:	f1 e0       	ldi	r31, 0x01	; 1
    4050:	02 c0       	rjmp	.+4      	; 0x4056 <radio_set_trx_state+0x86>
    4052:	e3 e0       	ldi	r30, 0x03	; 3
    4054:	f0 e0       	ldi	r31, 0x00	; 0
    4056:	31 97       	sbiw	r30, 0x01	; 1
    4058:	f1 f7       	brne	.-4      	; 0x4056 <radio_set_trx_state+0x86>
    } /*  end: if(new_state == TRX_OFF) ... */

    /* Verify state transition.
     * Radio could have already switched to an RX_BUSY state, at least in cooja.
     * Don't know what the hardware does but this would not be an error.*/
    current_state = radio_get_trx_state();
    405a:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <radio_get_trx_state>
    if (current_state != new_state) {
    405e:	81 17       	cp	r24, r17
    4060:	99 f0       	breq	.+38     	; 0x4088 <radio_set_trx_state+0xb8>
        if (((new_state == RX_ON) && (current_state == BUSY_RX)) ||
    4062:	16 30       	cpi	r17, 0x06	; 6
    4064:	19 f4       	brne	.+6      	; 0x406c <radio_set_trx_state+0x9c>
    4066:	81 30       	cpi	r24, 0x01	; 1
    4068:	61 f4       	brne	.+24     	; 0x4082 <radio_set_trx_state+0xb2>
    406a:	0e c0       	rjmp	.+28     	; 0x4088 <radio_set_trx_state+0xb8>
    406c:	16 31       	cpi	r17, 0x16	; 22
    406e:	49 f4       	brne	.+18     	; 0x4082 <radio_set_trx_state+0xb2>
            ((new_state == RX_AACK_ON) && (current_state == BUSY_RX_AACK))) {
    4070:	81 31       	cpi	r24, 0x11	; 17
    4072:	39 f4       	brne	.+14     	; 0x4082 <radio_set_trx_state+0xb2>
    4074:	09 c0       	rjmp	.+18     	; 0x4088 <radio_set_trx_state+0xb8>
    if (!((new_state == TRX_OFF)    ||
          (new_state == RX_ON)      ||
          (new_state == PLL_ON)     ||
          (new_state == RX_AACK_ON) ||
          (new_state == TX_ARET_ON))){
        return RADIO_INVALID_ARGUMENT;
    4076:	22 e4       	ldi	r18, 0x42	; 66
    4078:	30 e0       	ldi	r19, 0x00	; 0
    407a:	08 c0       	rjmp	.+16     	; 0x408c <radio_set_trx_state+0xbc>
    }

	  if (hal_get_slptr()) {
	      DEBUGFLOW('W');
        return RADIO_WRONG_STATE;
    407c:	24 e4       	ldi	r18, 0x44	; 68
    407e:	30 e0       	ldi	r19, 0x00	; 0
    4080:	05 c0       	rjmp	.+10     	; 0x408c <radio_set_trx_state+0xbc>
        if (((new_state == RX_ON) && (current_state == BUSY_RX)) ||
            ((new_state == RX_AACK_ON) && (current_state == BUSY_RX_AACK))) {
           /* This is OK. */
        } else {
            DEBUGFLOW('N');DEBUGFLOW('A'+new_state);DEBUGFLOW('A'+radio_get_trx_state());DEBUGFLOW('N');
            return RADIO_TIMED_OUT;
    4082:	23 e4       	ldi	r18, 0x43	; 67
    4084:	30 e0       	ldi	r19, 0x00	; 0
    4086:	02 c0       	rjmp	.+4      	; 0x408c <radio_set_trx_state+0xbc>
        }
    }

    return RADIO_SUCCESS;
    4088:	20 e4       	ldi	r18, 0x40	; 64
    408a:	30 e0       	ldi	r19, 0x00	; 0
}
    408c:	c9 01       	movw	r24, r18
    408e:	1f 91       	pop	r17
    4090:	0f 91       	pop	r16
    4092:	08 95       	ret

00004094 <radio_on>:
/*---------------------------------------------------------------------------*/
static void
radio_on(void)
{
//   ENERGEST_OFF(ENERGEST_TYPE_LISTEN);//testing
  ENERGEST_ON(ENERGEST_TYPE_LISTEN);
    4094:	80 91 94 00 	lds	r24, 0x0094
    4098:	90 91 95 00 	lds	r25, 0x0095
    409c:	90 93 72 27 	sts	0x2772, r25
    40a0:	80 93 71 27 	sts	0x2771, r24
    40a4:	21 e0       	ldi	r18, 0x01	; 1
    40a6:	20 93 5e 27 	sts	0x275E, r18
  RF230_receive_on = 1;
    40aa:	20 93 da 26 	sts	0x26DA, r18
#ifdef RF230BB_HOOK_RADIO_ON
  RF230BB_HOOK_RADIO_ON();
#endif

/* If radio is off (slptr high), turn it on */
  if (hal_get_slptr()) {
    40ae:	80 91 39 01 	lds	r24, 0x0139
    40b2:	81 ff       	sbrs	r24, 1
    40b4:	1e c0       	rjmp	.+60     	; 0x40f2 <radio_on+0x5e>
    ENERGEST_ON(ENERGEST_TYPE_LED_RED);
    40b6:	80 91 94 00 	lds	r24, 0x0094
    40ba:	90 91 95 00 	lds	r25, 0x0095
    40be:	90 93 6e 27 	sts	0x276E, r25
    40c2:	80 93 6d 27 	sts	0x276D, r24
    40c6:	20 93 5c 27 	sts	0x275C, r18
#if RF230BB_CONF_LEDONPORTE1
    PORTE|=(1<<PE1); //ledon
#endif
#if defined(__AVR_ATmega128RFA1__)
    /* Use the poweron interrupt for delay */
    rf230_wakewait=1;
    40ca:	20 93 d5 26 	sts	0x26D5, r18
    {
      uint8_t sreg = SREG;
    40ce:	2f b7       	in	r18, 0x3f	; 63
      sei();
    40d0:	78 94       	sei
      if (hal_get_slptr() == 0) DEBUGFLOW('$');
    40d2:	80 91 39 01 	lds	r24, 0x0139
      hal_set_slptr_low();
    40d6:	80 91 39 01 	lds	r24, 0x0139
    40da:	8d 7f       	andi	r24, 0xFD	; 253
    40dc:	80 93 39 01 	sts	0x0139, r24
    40e0:	80 e1       	ldi	r24, 0x10	; 16
    40e2:	97 e2       	ldi	r25, 0x27	; 39
      {
        int i;
        for (i=0;i<10000;i++) {
          if (!rf230_wakewait) break;
    40e4:	30 91 d5 26 	lds	r19, 0x26D5
    40e8:	33 23       	and	r19, r19
    40ea:	11 f0       	breq	.+4      	; 0x40f0 <radio_on+0x5c>
    40ec:	01 97       	sbiw	r24, 0x01	; 1
      sei();
      if (hal_get_slptr() == 0) DEBUGFLOW('$');
      hal_set_slptr_low();
      {
        int i;
        for (i=0;i<10000;i++) {
    40ee:	d1 f7       	brne	.-12     	; 0x40e4 <radio_on+0x50>
          if (!rf230_wakewait) break;
        }
        if (i>=10000) {DEBUGFLOW('G');DEBUGFLOW('g');DEBUGFLOW('A'+hal_subregister_read(SR_TRX_STATUS));}
      }
      SREG = sreg;
    40f0:	2f bf       	out	0x3f, r18	; 63
#endif
  }

#if RF230_CONF_AUTOACK
 // radio_set_trx_state(is_promiscuous?RX_ON:RX_AACK_ON);
  radio_set_trx_state(RX_AACK_ON);
    40f2:	86 e1       	ldi	r24, 0x16	; 22
    40f4:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <radio_set_trx_state>
#else
  radio_set_trx_state(RX_ON);
#endif
  rf230_waitidle();
    40f8:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <rf230_waitidle>
}
    40fc:	08 95       	ret

000040fe <rf230_on>:
}
/*---------------------------------------------------------------------------*/
static int
rf230_on(void)
{
  if(RF230_receive_on) {
    40fe:	80 91 da 26 	lds	r24, 0x26DA
    4102:	88 23       	and	r24, r24
    4104:	11 f4       	brne	.+4      	; 0x410a <rf230_on+0xc>
    //if (hal_get_slptr()) DEBUGFLOW('Q');//Cooja TODO: shows sleeping occasionally
    return 1;
  }

  radio_on();
    4106:	0e 94 4a 20 	call	0x4094	; 0x4094 <radio_on>
  return 1;
}
    410a:	81 e0       	ldi	r24, 0x01	; 1
    410c:	90 e0       	ldi	r25, 0x00	; 0
    410e:	08 95       	ret

00004110 <rf230_cca>:
}

/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
{
    4110:	0f 93       	push	r16
    4112:	1f 93       	push	r17
    4114:	df 93       	push	r29
    4116:	cf 93       	push	r28
    4118:	0f 92       	push	r0
    411a:	cd b7       	in	r28, 0x3d	; 61
    411c:	de b7       	in	r29, 0x3e	; 62
  uint8_t radio_was_off = 0;

  /* Turn radio on if necessary. If radio is currently busy return busy channel */
  /* This may happen when testing radio duty cycling with RADIOALWAYSON,
   * or because a packet just started. */
  if(RF230_receive_on) {
    411e:	80 91 da 26 	lds	r24, 0x26DA
    4122:	88 23       	and	r24, r24
    4124:	59 f0       	breq	.+22     	; 0x413c <rf230_cca+0x2c>
    if (hal_get_slptr()) {  //should not be sleeping!
    4126:	80 91 39 01 	lds	r24, 0x0139
    412a:	81 fd       	sbrc	r24, 1
    412c:	7d c0       	rjmp	.+250    	; 0x4228 <__stack+0x29>
	  DEBUGFLOW('<');
	  goto busyexit;
	} else {
      if (!rf230_isidle()) {
    412e:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <rf230_isidle>
    4132:	88 23       	and	r24, r24
    4134:	09 f4       	brne	.+2      	; 0x4138 <rf230_cca+0x28>
    4136:	78 c0       	rjmp	.+240    	; 0x4228 <__stack+0x29>
/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
{
  uint8_t cca=0;
  uint8_t radio_was_off = 0;
    4138:	00 e0       	ldi	r16, 0x00	; 0
    413a:	03 c0       	rjmp	.+6      	; 0x4142 <rf230_cca+0x32>
        goto busyexit;
      }
	}
  } else {
    radio_was_off = 1;
    rf230_on();
    413c:	0e 94 7f 20 	call	0x40fe	; 0x40fe <rf230_on>
        //DEBUGFLOW('2');
        goto busyexit;
      }
	}
  } else {
    radio_was_off = 1;
    4140:	01 e0       	ldi	r16, 0x01	; 1
    rf230_on();
  }

  ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW);
    4142:	80 91 94 00 	lds	r24, 0x0094
    4146:	90 91 95 00 	lds	r25, 0x0095
    414a:	90 93 6c 27 	sts	0x276C, r25
    414e:	80 93 6b 27 	sts	0x276B, r24
    4152:	11 e0       	ldi	r17, 0x01	; 1
    4154:	10 93 5b 27 	sts	0x275B, r17
    /* Disable rx transitions to busy (RX_PDT_BIT) */
    /* Note: for speed this resets rx threshold to the compiled default */
#ifdef RF230_MIN_RX_POWER
    hal_register_write(RG_RX_SYN, RF230_MIN_RX_POWER/6 + 0x81);
#else
    hal_register_write(RG_RX_SYN, 0x80);
    4158:	80 e8       	ldi	r24, 0x80	; 128
    415a:	80 93 55 01 	sts	0x0155, r24
#endif
   /* Switch to RX_ON for measurement. This will wait if a packet is being received */
   radio_set_trx_state(RX_ON);
    415e:	86 e0       	ldi	r24, 0x06	; 6
    4160:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <radio_set_trx_state>

    rf230_ccawait=1;
    4164:	10 93 49 25 	sts	0x2549, r17
//CCA_REQUEST is supposed to trigger the interrupt but it doesn't
//  hal_subregister_write(SR_CCA_REQUEST,1);

    /* Write to ED_LEVEL register to start CCA */
    {
      uint8_t volatile saved_sreg = SREG;
    4168:	8f b7       	in	r24, 0x3f	; 63
    416a:	89 83       	std	Y+1, r24	; 0x01
      sei( );
    416c:	78 94       	sei
      hal_register_write(PHY_ED_LEVEL,0);
    416e:	10 92 47 01 	sts	0x0147, r1
      while (rf230_ccawait) {}
    4172:	80 91 49 25 	lds	r24, 0x2549
    4176:	88 23       	and	r24, r24
    4178:	e1 f7       	brne	.-8      	; 0x4172 <rf230_cca+0x62>
      SREG = saved_sreg;
    417a:	89 81       	ldd	r24, Y+1	; 0x01
    417c:	8f bf       	out	0x3f, r24	; 63

    /* Use ED register to determine result. 77dBm is poweron csma default.*/
#ifdef RF230_CONF_CCA_THRES
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91+RF230_CONF_CCA_THRES) cca=0xff;
#else
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91-77)) cca=0xff;
    417e:	80 91 47 01 	lds	r24, 0x0147
    4182:	8e 30       	cpi	r24, 0x0E	; 14
    4184:	10 f0       	brcs	.+4      	; 0x418a <rf230_cca+0x7a>

/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
{
  uint8_t cca=0;
    4186:	10 e0       	ldi	r17, 0x00	; 0
    4188:	01 c0       	rjmp	.+2      	; 0x418c <rf230_cca+0x7c>

    /* Use ED register to determine result. 77dBm is poweron csma default.*/
#ifdef RF230_CONF_CCA_THRES
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91+RF230_CONF_CCA_THRES) cca=0xff;
#else
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91-77)) cca=0xff;
    418a:	1f ef       	ldi	r17, 0xFF	; 255
#endif
//TODO:see if the status register works!
//   cca=hal_register_read(RG_TRX_STATUS);
#if RF230_CONF_AUTOACK
    radio_set_trx_state(RX_AACK_ON);
    418c:	86 e1       	ldi	r24, 0x16	; 22
    418e:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <radio_set_trx_state>

    /* Enable packet reception */
#ifdef RF230_MIN_RX_POWER
    hal_register_write(RG_RX_SYN, RF230_MIN_RX_POWER/6 + 0x01);
#else
    hal_register_write(RG_RX_SYN, 0x00);
    4192:	10 92 55 01 	sts	0x0155, r1
    cca=hal_register_read(RG_TRX_STATUS);
  }
  SREG=saved_sreg;
}
#endif
  ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW); 
    4196:	80 91 5b 27 	lds	r24, 0x275B
    419a:	88 23       	and	r24, r24
    419c:	e9 f1       	breq	.+122    	; 0x4218 <__stack+0x19>
    419e:	80 91 94 00 	lds	r24, 0x0094
    41a2:	90 91 95 00 	lds	r25, 0x0095
    41a6:	20 91 6b 27 	lds	r18, 0x276B
    41aa:	30 91 6c 27 	lds	r19, 0x276C
    41ae:	82 17       	cp	r24, r18
    41b0:	93 07       	cpc	r25, r19
    41b2:	a0 f4       	brcc	.+40     	; 0x41dc <rf230_cca+0xcc>
    41b4:	80 91 35 27 	lds	r24, 0x2735
    41b8:	90 91 36 27 	lds	r25, 0x2736
    41bc:	a0 91 37 27 	lds	r26, 0x2737
    41c0:	b0 91 38 27 	lds	r27, 0x2738
    41c4:	8c 57       	subi	r24, 0x7C	; 124
    41c6:	91 4e       	sbci	r25, 0xE1	; 225
    41c8:	af 4f       	sbci	r26, 0xFF	; 255
    41ca:	bf 4f       	sbci	r27, 0xFF	; 255
    41cc:	80 93 35 27 	sts	0x2735, r24
    41d0:	90 93 36 27 	sts	0x2736, r25
    41d4:	a0 93 37 27 	sts	0x2737, r26
    41d8:	b0 93 38 27 	sts	0x2738, r27
    41dc:	80 91 94 00 	lds	r24, 0x0094
    41e0:	90 91 95 00 	lds	r25, 0x0095
    41e4:	82 1b       	sub	r24, r18
    41e6:	93 0b       	sbc	r25, r19
    41e8:	a0 e0       	ldi	r26, 0x00	; 0
    41ea:	b0 e0       	ldi	r27, 0x00	; 0
    41ec:	20 91 35 27 	lds	r18, 0x2735
    41f0:	30 91 36 27 	lds	r19, 0x2736
    41f4:	40 91 37 27 	lds	r20, 0x2737
    41f8:	50 91 38 27 	lds	r21, 0x2738
    41fc:	82 0f       	add	r24, r18
    41fe:	93 1f       	adc	r25, r19
    4200:	a4 1f       	adc	r26, r20
    4202:	b5 1f       	adc	r27, r21
    4204:	80 93 35 27 	sts	0x2735, r24
    4208:	90 93 36 27 	sts	0x2736, r25
    420c:	a0 93 37 27 	sts	0x2737, r26
    4210:	b0 93 38 27 	sts	0x2738, r27
    4214:	10 92 5b 27 	sts	0x275B, r1
  if(radio_was_off) {
    4218:	00 23       	and	r16, r16
    421a:	11 f0       	breq	.+4      	; 0x4220 <__stack+0x21>
    rf230_off();
    421c:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <rf230_off>
  return rssi;
}

/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
    4220:	21 e0       	ldi	r18, 0x01	; 1
    4222:	30 e0       	ldi	r19, 0x00	; 0
    4224:	16 fd       	sbrc	r17, 6
    4226:	02 c0       	rjmp	.+4      	; 0x422c <__stack+0x2d>
//   DEBUGFLOW('5');
	 return 1;
   } else {
//  DEBUGFLOW('6');
 busyexit:
	 return 0;
    4228:	20 e0       	ldi	r18, 0x00	; 0
    422a:	30 e0       	ldi	r19, 0x00	; 0
   }
}
    422c:	c9 01       	movw	r24, r18
    422e:	0f 90       	pop	r0
    4230:	cf 91       	pop	r28
    4232:	df 91       	pop	r29
    4234:	1f 91       	pop	r17
    4236:	0f 91       	pop	r16
    4238:	08 95       	ret

0000423a <rf230_set_promiscuous_mode>:
}

void
rf230_set_promiscuous_mode(bool isPromiscuous) {
#if RF230_CONF_AUTOACK
    is_promiscuous = isPromiscuous;
    423a:	80 93 a0 1d 	sts	0x1DA0, r24
/* TODO: Figure out when to pass promisc state to 802.15.4 */
//    radio_set_trx_state(is_promiscuous?RX_ON:RX_AACK_ON);
#endif
}
    423e:	08 95       	ret

00004240 <rf230_is_ready_to_send>:

bool
rf230_is_ready_to_send() {
	switch(radio_get_trx_state()) {
    4240:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <radio_get_trx_state>
    4244:	82 50       	subi	r24, 0x02	; 2
    4246:	81 31       	cpi	r24, 0x11	; 17
    4248:	30 f4       	brcc	.+12     	; 0x4256 <rf230_is_ready_to_send+0x16>
    424a:	e8 2f       	mov	r30, r24
    424c:	f0 e0       	ldi	r31, 0x00	; 0
    424e:	e8 5d       	subi	r30, 0xD8	; 216
    4250:	f1 4f       	sbci	r31, 0xF1	; 241
    4252:	80 81       	ld	r24, Z
    4254:	08 95       	ret
    4256:	81 e0       	ldi	r24, 0x01	; 1
		case BUSY_TX_ARET:
			return false;
	}
	
	return true;
}
    4258:	08 95       	ret

0000425a <rf230_setpendingbit>:
    //DEBUGFLOW('g');
    hal_subregister_write(SR_TX_PWR, power);
  }
}
void rf230_setpendingbit(uint8_t value)
{
    425a:	28 2f       	mov	r18, r24
  hal_subregister_write(SR_AACK_SET_PD, value);
    425c:	8e e6       	ldi	r24, 0x6E	; 110
    425e:	91 e0       	ldi	r25, 0x01	; 1
    4260:	60 e2       	ldi	r22, 0x20	; 32
    4262:	45 e0       	ldi	r20, 0x05	; 5
    4264:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
}
    4268:	08 95       	ret

0000426a <rf230_warm_reset>:
#warning Manipulating PORTB pins for RF230 Sneezer mode!
  PORTB &= ~(1<<7);
  DDRB  &= ~(1<<7);
#endif
  
  hal_register_write(RG_IRQ_MASK, RF230_SUPPORTED_INTERRUPT_MASK);
    426a:	8f ef       	ldi	r24, 0xFF	; 255
    426c:	80 93 4e 01 	sts	0x014E, r24

  /* Set up number of automatic retries 0-15
   * (0 implies PLL_ON sends instead of the extended TX_ARET mode */
  hal_subregister_write(SR_MAX_FRAME_RETRIES,
    4270:	8c e6       	ldi	r24, 0x6C	; 108
    4272:	91 e0       	ldi	r25, 0x01	; 1
    4274:	60 ef       	ldi	r22, 0xF0	; 240
    4276:	44 e0       	ldi	r20, 0x04	; 4
    4278:	21 e0       	ldi	r18, 0x01	; 1
    427a:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
      (RF230_CONF_FRAME_RETRIES > 0) ? (RF230_CONF_FRAME_RETRIES - 1) : 0 );
 
 /* Set up carrier sense/clear channel assesment parameters for extended operating mode */
  hal_subregister_write(SR_MAX_CSMA_RETRIES, RF230_CONF_CSMA_RETRIES );//highest allowed retries
    427e:	8c e6       	ldi	r24, 0x6C	; 108
    4280:	91 e0       	ldi	r25, 0x01	; 1
    4282:	6e e0       	ldi	r22, 0x0E	; 14
    4284:	41 e0       	ldi	r20, 0x01	; 1
    4286:	25 e0       	ldi	r18, 0x05	; 5
    4288:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
  hal_register_write(RG_CSMA_BE, 0x80);       //min backoff exponent 0, max 8 (highest allowed)
    428c:	80 e8       	ldi	r24, 0x80	; 128
    428e:	80 93 6f 01 	sts	0x016F, r24
  hal_register_write(RG_CSMA_SEED_0,hal_register_read(RG_PHY_RSSI) );//upper two RSSI reg bits RND_VALUE are random in rf231
    4292:	80 91 46 01 	lds	r24, 0x0146
    4296:	80 93 6d 01 	sts	0x016D, r24

  /* Use automatic CRC unless manual is specified */
#if RF230_CONF_CHECKSUM
  hal_subregister_write(SR_TX_AUTO_CRC_ON, 0);
#else
  hal_subregister_write(SR_TX_AUTO_CRC_ON, 1);
    429a:	84 e4       	ldi	r24, 0x44	; 68
    429c:	91 e0       	ldi	r25, 0x01	; 1
    429e:	60 e2       	ldi	r22, 0x20	; 32
    42a0:	45 e0       	ldi	r20, 0x05	; 5
    42a2:	21 e0       	ldi	r18, 0x01	; 1
    42a4:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>

/* Limit tx power for testing miniature Raven mesh */
#ifdef RF230_MAX_TX_POWER
  set_txpower(RF230_MAX_TX_POWER);  //0=3dbm 15=-17.2dbm
#endif
}
    42a8:	08 95       	ret

000042aa <rf230_init>:
}
#endif
/*---------------------------------------------------------------------------*/
int
rf230_init(void)
{
    42aa:	cf 93       	push	r28
    42ac:	df 93       	push	r29
    42ae:	cd ef       	ldi	r28, 0xFD	; 253
    42b0:	d3 e0       	ldi	r29, 0x03	; 3
    42b2:	ce 01       	movw	r24, r28
    42b4:	01 97       	sbiw	r24, 0x01	; 1
    42b6:	f1 f7       	brne	.-4      	; 0x42b4 <rf230_init+0xa>
  uint8_t i;
  DEBUGFLOW('i');
  /* Wait in case VCC just applied */
  delay_us(TIME_TO_ENTER_P_ON);
  /* Initialize Hardware Abstraction Layer */
  hal_init();
    42b8:	0e 94 14 25 	call	0x4a28	; 0x4a28 <hal_init>
 // calibrate_rc_osc_32k();
 // printf_P(PSTR("After calibration OSCCAL=%x\n"),OSCCAL); 

  /* Set receive buffers empty and point to the first */
  for (i=0;i<RF230_CONF_RX_BUFFERS;i++) {
      rxframe[i].length=0;
    42bc:	10 92 4f 25 	sts	0x254F, r1
    42c0:	10 92 d1 25 	sts	0x25D1, r1
    42c4:	10 92 53 26 	sts	0x2653, r1
  }
  rxframe_head=0;rxframe_tail=0;
    42c8:	10 92 4e 25 	sts	0x254E, r1
    42cc:	10 92 4d 25 	sts	0x254D, r1
  
  /* Do full rf230 Reset */
  hal_set_rst_low();
    42d0:	e9 e3       	ldi	r30, 0x39	; 57
    42d2:	f1 e0       	ldi	r31, 0x01	; 1
    42d4:	80 81       	ld	r24, Z
    42d6:	8e 7f       	andi	r24, 0xFE	; 254
    42d8:	80 83       	st	Z, r24
  hal_set_slptr_low();
    42da:	80 81       	ld	r24, Z
    42dc:	8d 7f       	andi	r24, 0xFD	; 253
    42de:	80 83       	st	Z, r24
    42e0:	81 ec       	ldi	r24, 0xC1	; 193
    42e2:	9d e0       	ldi	r25, 0x0D	; 13
    42e4:	01 97       	sbiw	r24, 0x01	; 1
    42e6:	f1 f7       	brne	.-4      	; 0x42e4 <rf230_init+0x3a>
   * Wake time depends on board capacitance; use 2x the nominal delay for safety.
   * See www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=78725
   */
  delay_us(2*TIME_SLEEP_TO_TRX_OFF);
  //delay_us(TIME_RESET); /* Old impl. */
  hal_set_rst_high();
    42e8:	80 81       	ld	r24, Z
    42ea:	81 60       	ori	r24, 0x01	; 1
    42ec:	80 83       	st	Z, r24

  /* Force transition to TRX_OFF */
  hal_subregister_write(SR_TRX_CMD, CMD_FORCE_TRX_OFF);
    42ee:	82 e4       	ldi	r24, 0x42	; 66
    42f0:	91 e0       	ldi	r25, 0x01	; 1
    42f2:	6f e1       	ldi	r22, 0x1F	; 31
    42f4:	40 e0       	ldi	r20, 0x00	; 0
    42f6:	23 e0       	ldi	r18, 0x03	; 3
    42f8:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
    42fc:	21 97       	sbiw	r28, 0x01	; 1
    42fe:	f1 f7       	brne	.-4      	; 0x42fc <rf230_init+0x52>
  delay_us(TIME_P_ON_TO_TRX_OFF);
  
  /* Verify that it is a supported version */
  /* Note gcc optimizes this away if DEBUG is not set! */
  //ATMEGA128RFA1 - version 4, ID 31
  uint8_t tvers = hal_register_read(RG_VERSION_NUM);
    4300:	80 91 5d 01 	lds	r24, 0x015D
  uint8_t tmanu = hal_register_read(RG_MAN_ID_0);
    4304:	80 91 5e 01 	lds	r24, 0x015E
  if (tmanu != SUPPORTED_MANUFACTURER_ID) 
    PRINTF("rf230: Unsupported manufacturer ID %u\n",tmanu);

  PRINTF("rf230: Version %u, ID %u\n",tvers,tmanu);
  
  rf230_warm_reset();
    4308:	0e 94 35 21 	call	0x426a	; 0x426a <rf230_warm_reset>
 
 /* Start the packet receive process */
  process_start(&rf230_process, NULL);
    430c:	8a e0       	ldi	r24, 0x0A	; 10
    430e:	9e e0       	ldi	r25, 0x0E	; 14
    4310:	60 e0       	ldi	r22, 0x00	; 0
    4312:	70 e0       	ldi	r23, 0x00	; 0
    4314:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <process_start>
 
 /* Leave radio in on state (?)*/
  radio_on();
    4318:	0e 94 4a 20 	call	0x4094	; 0x4094 <radio_on>

  return 1;
}
    431c:	81 e0       	ldi	r24, 0x01	; 1
    431e:	90 e0       	ldi	r25, 0x00	; 0
    4320:	df 91       	pop	r29
    4322:	cf 91       	pop	r28
    4324:	08 95       	ret

00004326 <rf230_get_channel>:
rf230_get_channel(void)
{
//jackdaw reads zero channel, raven reads correct channel?
//return hal_subregister_read(SR_CHANNEL);
  return channel;
}
    4326:	80 91 9f 1d 	lds	r24, 0x1D9F
    432a:	08 95       	ret

0000432c <rf230_set_channel>:
/*---------------------------------------------------------------------------*/
void
rf230_set_channel(uint8_t c)
{
    432c:	df 93       	push	r29
    432e:	cf 93       	push	r28
    4330:	0f 92       	push	r0
    4332:	cd b7       	in	r28, 0x3d	; 61
    4334:	de b7       	in	r29, 0x3e	; 62
 /* Wait for any transmission to end. */
  PRINTF("rf230: Set Channel %u\n",c);
  rf230_waitidle();
    4336:	89 83       	std	Y+1, r24	; 0x01
    4338:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <rf230_waitidle>
  channel=c;
    433c:	29 81       	ldd	r18, Y+1	; 0x01
    433e:	20 93 9f 1d 	sts	0x1D9F, r18
  hal_subregister_write(SR_CHANNEL, c);
    4342:	88 e4       	ldi	r24, 0x48	; 72
    4344:	91 e0       	ldi	r25, 0x01	; 1
    4346:	6f e1       	ldi	r22, 0x1F	; 31
    4348:	40 e0       	ldi	r20, 0x00	; 0
    434a:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <hal_subregister_write>
}
    434e:	0f 90       	pop	r0
    4350:	cf 91       	pop	r28
    4352:	df 91       	pop	r29
    4354:	08 95       	ret

00004356 <rf230_listen_channel>:
void
rf230_listen_channel(uint8_t c)
{
 /* Same as set channel but forces RX_ON state for sniffer or energy scan */
//  PRINTF("rf230: Listen Channel %u\n",c);
  rf230_set_channel(c);
    4356:	0e 94 96 21 	call	0x432c	; 0x432c <rf230_set_channel>
  radio_set_trx_state(RX_ON);
    435a:	86 e0       	ldi	r24, 0x06	; 6
    435c:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <radio_set_trx_state>
}
    4360:	08 95       	ret

00004362 <rf230_set_pan_addr>:
{
  PRINTF("rf230: PAN=%x Short Addr=%x\n",pan,addr);
  
  uint8_t abyte;
  abyte = pan & 0xFF;
  hal_register_write(RG_PAN_ID_0,abyte);
    4362:	80 93 62 01 	sts	0x0162, r24
  abyte = (pan >> 8*1) & 0xFF;
  hal_register_write(RG_PAN_ID_1, abyte);
    4366:	90 93 63 01 	sts	0x0163, r25

  abyte = addr & 0xFF;
  hal_register_write(RG_SHORT_ADDR_0, abyte);
    436a:	60 93 60 01 	sts	0x0160, r22
  abyte = (addr >> 8*1) & 0xFF;
  hal_register_write(RG_SHORT_ADDR_1, abyte);  
    436e:	70 93 61 01 	sts	0x0161, r23

  if (ieee_addr != NULL) {
    4372:	41 15       	cp	r20, r1
    4374:	51 05       	cpc	r21, r1
    4376:	31 f1       	breq	.+76     	; 0x43c4 <rf230_set_pan_addr+0x62>
    PRINTF("MAC=%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_7, *ieee_addr++);
    4378:	fa 01       	movw	r30, r20
    437a:	81 91       	ld	r24, Z+
    437c:	80 93 6b 01 	sts	0x016B, r24
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_6, *ieee_addr++);
    4380:	da 01       	movw	r26, r20
    4382:	11 96       	adiw	r26, 0x01	; 1
    4384:	8c 91       	ld	r24, X
    4386:	80 93 6a 01 	sts	0x016A, r24
    438a:	df 01       	movw	r26, r30
    438c:	11 96       	adiw	r26, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_5, *ieee_addr++);
    438e:	81 81       	ldd	r24, Z+1	; 0x01
    4390:	80 93 69 01 	sts	0x0169, r24
    4394:	fd 01       	movw	r30, r26
    4396:	31 96       	adiw	r30, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_4, *ieee_addr++);
    4398:	11 96       	adiw	r26, 0x01	; 1
    439a:	8c 91       	ld	r24, X
    439c:	80 93 68 01 	sts	0x0168, r24
    43a0:	df 01       	movw	r26, r30
    43a2:	11 96       	adiw	r26, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_3, *ieee_addr++);
    43a4:	81 81       	ldd	r24, Z+1	; 0x01
    43a6:	80 93 67 01 	sts	0x0167, r24
    43aa:	fd 01       	movw	r30, r26
    43ac:	31 96       	adiw	r30, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_2, *ieee_addr++);
    43ae:	11 96       	adiw	r26, 0x01	; 1
    43b0:	8c 91       	ld	r24, X
    43b2:	11 97       	sbiw	r26, 0x01	; 1
    43b4:	80 93 66 01 	sts	0x0166, r24
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_1, *ieee_addr++);
    43b8:	81 81       	ldd	r24, Z+1	; 0x01
    43ba:	80 93 65 01 	sts	0x0165, r24
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_0, *ieee_addr);
    43be:	82 81       	ldd	r24, Z+2	; 0x02
    43c0:	80 93 64 01 	sts	0x0164, r24
    43c4:	08 95       	ret

000043c6 <rf230_interrupt>:
#if RF230_CONF_TIMESTAMPS
  interrupt_time = timesynch_time();
  interrupt_time_set = 1;
#endif /* RF230_CONF_TIMESTAMPS */

  process_poll(&rf230_process);
    43c6:	8a e0       	ldi	r24, 0x0A	; 10
    43c8:	9e e0       	ldi	r25, 0x0E	; 14
    43ca:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <process_poll>
#if RF230_TIMETABLE_PROFILING
  timetable_clear(&rf230_timetable);
  TIMETABLE_TIMESTAMP(rf230_timetable, "interrupt");
#endif /* RF230_TIMETABLE_PROFILING */

  rf230_pending = 1;
    43ce:	81 e0       	ldi	r24, 0x01	; 1
    43d0:	80 93 48 25 	sts	0x2548, r24
  
#if RADIOSTATS //TODO:This will double count buffered packets
  RF230_receivepackets++;
    43d4:	80 91 4a 25 	lds	r24, 0x254A
    43d8:	90 91 4b 25 	lds	r25, 0x254B
    43dc:	01 96       	adiw	r24, 0x01	; 1
    43de:	90 93 4b 25 	sts	0x254B, r25
    43e2:	80 93 4a 25 	sts	0x254A, r24
#endif
  RIMESTATS_ADD(llrx);
    43e6:	80 91 21 27 	lds	r24, 0x2721
    43ea:	90 91 22 27 	lds	r25, 0x2722
    43ee:	a0 91 23 27 	lds	r26, 0x2723
    43f2:	b0 91 24 27 	lds	r27, 0x2724
    43f6:	01 96       	adiw	r24, 0x01	; 1
    43f8:	a1 1d       	adc	r26, r1
    43fa:	b1 1d       	adc	r27, r1
    43fc:	80 93 21 27 	sts	0x2721, r24
    4400:	90 93 22 27 	sts	0x2722, r25
    4404:	a0 93 23 27 	sts	0x2723, r26
    4408:	b0 93 24 27 	sts	0x2724, r27
  DEBUGFLOW('-');
  rxframe[rxframe_head].length=0;
}
#endif
  return 1;
}
    440c:	81 e0       	ldi	r24, 0x01	; 1
    440e:	90 e0       	ldi	r25, 0x00	; 0
    4410:	08 95       	ret

00004412 <rf230_read>:
 * As a result, PRINTF cannot be used in here.
 */
/*---------------------------------------------------------------------------*/
static int
rf230_read(void *buf, unsigned short bufsize)
{
    4412:	ef 92       	push	r14
    4414:	ff 92       	push	r15
    4416:	cf 93       	push	r28
    4418:	df 93       	push	r29
    return bufsize;
 }
#endif

  /* The length includes the twp-byte checksum but not the LQI byte */
  len=rxframe[rxframe_head].length;
    441a:	50 91 4e 25 	lds	r21, 0x254E
    441e:	25 2f       	mov	r18, r21
    4420:	30 e0       	ldi	r19, 0x00	; 0
    4422:	f9 01       	movw	r30, r18
    4424:	ee 0f       	add	r30, r30
    4426:	ff 1f       	adc	r31, r31
    4428:	36 95       	lsr	r19
    442a:	32 2f       	mov	r19, r18
    442c:	22 27       	eor	r18, r18
    442e:	37 95       	ror	r19
    4430:	27 95       	ror	r18
    4432:	e2 0f       	add	r30, r18
    4434:	f3 1f       	adc	r31, r19
    4436:	e1 5b       	subi	r30, 0xB1	; 177
    4438:	fa 4d       	sbci	r31, 0xDA	; 218
    443a:	40 81       	ld	r20, Z
  if (len==0) {
    443c:	44 23       	and	r20, r20
    443e:	09 f4       	brne	.+2      	; 0x4442 <rf230_read+0x30>
    4440:	c8 c0       	rjmp	.+400    	; 0x45d2 <rf230_read+0x1c0>
    rf230_time_of_arrival = 0;
  }
  rf230_time_of_departure = 0;
#endif /* RF230_CONF_TIMESTAMPS */

  if(len > RF230_MAX_TX_FRAME_LENGTH) {
    4442:	47 ff       	sbrs	r20, 7
    4444:	16 c0       	rjmp	.+44     	; 0x4472 <rf230_read+0x60>
    /* Oops, we must be out of sync. */
    DEBUGFLOW('u');
    flushrx();
    4446:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <flushrx>
    RIMESTATS_ADD(badsynch);
    444a:	80 91 0d 27 	lds	r24, 0x270D
    444e:	90 91 0e 27 	lds	r25, 0x270E
    4452:	a0 91 0f 27 	lds	r26, 0x270F
    4456:	b0 91 10 27 	lds	r27, 0x2710
    445a:	01 96       	adiw	r24, 0x01	; 1
    445c:	a1 1d       	adc	r26, r1
    445e:	b1 1d       	adc	r27, r1
    4460:	80 93 0d 27 	sts	0x270D, r24
    4464:	90 93 0e 27 	sts	0x270E, r25
    4468:	a0 93 0f 27 	sts	0x270F, r26
    446c:	b0 93 10 27 	sts	0x2710, r27
    4470:	b0 c0       	rjmp	.+352    	; 0x45d2 <rf230_read+0x1c0>
    return 0;
  }

  if(len <= AUX_LEN) {
    4472:	43 30       	cpi	r20, 0x03	; 3
    4474:	b0 f4       	brcc	.+44     	; 0x44a2 <rf230_read+0x90>
    DEBUGFLOW('s');
    //PRINTF("len <= AUX_LEN\n");
    flushrx();
    4476:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <flushrx>
    RIMESTATS_ADD(tooshort);
    447a:	80 91 09 27 	lds	r24, 0x2709
    447e:	90 91 0a 27 	lds	r25, 0x270A
    4482:	a0 91 0b 27 	lds	r26, 0x270B
    4486:	b0 91 0c 27 	lds	r27, 0x270C
    448a:	01 96       	adiw	r24, 0x01	; 1
    448c:	a1 1d       	adc	r26, r1
    448e:	b1 1d       	adc	r27, r1
    4490:	80 93 09 27 	sts	0x2709, r24
    4494:	90 93 0a 27 	sts	0x270A, r25
    4498:	a0 93 0b 27 	sts	0x270B, r26
    449c:	b0 93 0c 27 	sts	0x270C, r27
    44a0:	98 c0       	rjmp	.+304    	; 0x45d2 <rf230_read+0x1c0>
    return 0;
  }

  if(len - AUX_LEN > bufsize) {
    44a2:	c4 2f       	mov	r28, r20
    44a4:	d0 e0       	ldi	r29, 0x00	; 0
    44a6:	22 97       	sbiw	r28, 0x02	; 2
    44a8:	6c 17       	cp	r22, r28
    44aa:	7d 07       	cpc	r23, r29
    44ac:	b0 f4       	brcc	.+44     	; 0x44da <rf230_read+0xc8>
    DEBUGFLOW('v');
    //PRINTF("len - AUX_LEN > bufsize\n");
    flushrx();
    44ae:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <flushrx>
    RIMESTATS_ADD(toolong);
    44b2:	80 91 05 27 	lds	r24, 0x2705
    44b6:	90 91 06 27 	lds	r25, 0x2706
    44ba:	a0 91 07 27 	lds	r26, 0x2707
    44be:	b0 91 08 27 	lds	r27, 0x2708
    44c2:	01 96       	adiw	r24, 0x01	; 1
    44c4:	a1 1d       	adc	r26, r1
    44c6:	b1 1d       	adc	r27, r1
    44c8:	80 93 05 27 	sts	0x2705, r24
    44cc:	90 93 06 27 	sts	0x2706, r25
    44d0:	a0 93 07 27 	sts	0x2707, r26
    44d4:	b0 93 08 27 	sts	0x2708, r27
    44d8:	7c c0       	rjmp	.+248    	; 0x45d2 <rf230_read+0x1c0>
    return 0;
  }

 /* Transfer the frame, stripping the footer, but copying the checksum */
  framep=&(rxframe[rxframe_head].data[0]);
    44da:	65 2f       	mov	r22, r21
    44dc:	70 e0       	ldi	r23, 0x00	; 0
    44de:	9b 01       	movw	r18, r22
    44e0:	22 0f       	add	r18, r18
    44e2:	33 1f       	adc	r19, r19
    44e4:	76 95       	lsr	r23
    44e6:	76 2f       	mov	r23, r22
    44e8:	66 27       	eor	r22, r22
    44ea:	77 95       	ror	r23
    44ec:	67 95       	ror	r22
    44ee:	26 0f       	add	r18, r22
    44f0:	37 1f       	adc	r19, r23
    44f2:	20 5b       	subi	r18, 0xB0	; 176
    44f4:	3a 4d       	sbci	r19, 0xDA	; 218
  memcpy(buf,framep,len-AUX_LEN+CHECKSUM_LEN);
    44f6:	b9 01       	movw	r22, r18
    44f8:	50 e0       	ldi	r21, 0x00	; 0
    44fa:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
  rf230_last_correlation = rxframe[rxframe_head].lqi;
    44fe:	20 91 4e 25 	lds	r18, 0x254E
    4502:	82 2f       	mov	r24, r18
    4504:	90 e0       	ldi	r25, 0x00	; 0
    4506:	fc 01       	movw	r30, r24
    4508:	ee 0f       	add	r30, r30
    450a:	ff 1f       	adc	r31, r31
    450c:	96 95       	lsr	r25
    450e:	98 2f       	mov	r25, r24
    4510:	88 27       	eor	r24, r24
    4512:	97 95       	ror	r25
    4514:	87 95       	ror	r24
    4516:	e8 0f       	add	r30, r24
    4518:	f9 1f       	adc	r31, r25
    451a:	e1 53       	subi	r30, 0x31	; 49
    451c:	fa 4d       	sbci	r31, 0xDA	; 218
    451e:	80 81       	ld	r24, Z
    4520:	80 93 43 25 	sts	0x2543, r24

  /* Clear the length field to allow buffering of the next packet */
  rxframe[rxframe_head].length=0;
    4524:	82 2f       	mov	r24, r18
    4526:	90 e0       	ldi	r25, 0x00	; 0
    4528:	fc 01       	movw	r30, r24
    452a:	ee 0f       	add	r30, r30
    452c:	ff 1f       	adc	r31, r31
    452e:	96 95       	lsr	r25
    4530:	98 2f       	mov	r25, r24
    4532:	88 27       	eor	r24, r24
    4534:	97 95       	ror	r25
    4536:	87 95       	ror	r24
    4538:	e8 0f       	add	r30, r24
    453a:	f9 1f       	adc	r31, r25
    453c:	e1 5b       	subi	r30, 0xB1	; 177
    453e:	fa 4d       	sbci	r31, 0xDA	; 218
    4540:	10 82       	st	Z, r1
  rxframe_head++;
    4542:	2f 5f       	subi	r18, 0xFF	; 255
    4544:	20 93 4e 25 	sts	0x254E, r18
  if (rxframe_head >= RF230_CONF_RX_BUFFERS) {
    4548:	23 30       	cpi	r18, 0x03	; 3
    454a:	10 f0       	brcs	.+4      	; 0x4550 <rf230_read+0x13e>
    rxframe_head=0;
    454c:	10 92 4e 25 	sts	0x254E, r1
  }
  /* If another packet has been buffered, schedule another receive poll */
  if (rxframe[rxframe_head].length) {
    4550:	80 91 4e 25 	lds	r24, 0x254E
    4554:	90 e0       	ldi	r25, 0x00	; 0
    4556:	fc 01       	movw	r30, r24
    4558:	ee 0f       	add	r30, r30
    455a:	ff 1f       	adc	r31, r31
    455c:	96 95       	lsr	r25
    455e:	98 2f       	mov	r25, r24
    4560:	88 27       	eor	r24, r24
    4562:	97 95       	ror	r25
    4564:	87 95       	ror	r24
    4566:	e8 0f       	add	r30, r24
    4568:	f9 1f       	adc	r31, r25
    456a:	e1 5b       	subi	r30, 0xB1	; 177
    456c:	fa 4d       	sbci	r31, 0xDA	; 218
    456e:	80 81       	ld	r24, Z
    4570:	88 23       	and	r24, r24
    4572:	19 f0       	breq	.+6      	; 0x457a <rf230_read+0x168>
    rf230_interrupt();
    4574:	0e 94 e3 21 	call	0x43c6	; 0x43c6 <rf230_interrupt>
    4578:	02 c0       	rjmp	.+4      	; 0x457e <rf230_read+0x16c>
  }
  else {
    rf230_pending = 0;
    457a:	10 92 48 25 	sts	0x2548, r1
#if 0   //more general
    rf230_last_rssi = rf230_get_raw_rssi();
#else   //faster
#if RF230_CONF_AUTOACK
 //   rf230_last_rssi = hal_subregister_read(SR_ED_LEVEL);  //0-84 resolution 1 dB
    rf230_last_rssi = hal_register_read(RG_PHY_ED_LEVEL);  //0-84, resolution 1 dB
    457e:	60 91 47 01 	lds	r22, 0x0147
    4582:	60 93 44 25 	sts	0x2544, r22
//  rf230_last_rssi = 3*hal_subregister_read(SR_RSSI);    //0-28 resolution 3 dB
#endif
#endif /* speed vs. generality */

  /* Save the smallest rssi. The display routine can reset by setting it to zero */
  if ((rf230_smallest_rssi==0) || (rf230_last_rssi<rf230_smallest_rssi))
    4586:	80 91 47 25 	lds	r24, 0x2547
    458a:	88 23       	and	r24, r24
    458c:	11 f0       	breq	.+4      	; 0x4592 <rf230_read+0x180>
    458e:	68 17       	cp	r22, r24
    4590:	10 f4       	brcc	.+4      	; 0x4596 <rf230_read+0x184>
     rf230_smallest_rssi=rf230_last_rssi;
    4592:	60 93 47 25 	sts	0x2547, r22

 //   rf230_last_correlation = rxframe[rxframe_head].lqi;
    packetbuf_set_attr(PACKETBUF_ATTR_RSSI, rf230_last_rssi);
    4596:	84 e0       	ldi	r24, 0x04	; 4
    4598:	70 e0       	ldi	r23, 0x00	; 0
    459a:	0e 94 31 33 	call	0x6662	; 0x6662 <packetbuf_set_attr>
    packetbuf_set_attr(PACKETBUF_ATTR_LINK_QUALITY, rf230_last_correlation);
    459e:	60 91 43 25 	lds	r22, 0x2543
    45a2:	83 e0       	ldi	r24, 0x03	; 3
    45a4:	70 e0       	ldi	r23, 0x00	; 0
    45a6:	0e 94 31 33 	call	0x6662	; 0x6662 <packetbuf_set_attr>

    RIMESTATS_ADD(rx);
    45aa:	80 91 e1 26 	lds	r24, 0x26E1
    45ae:	90 91 e2 26 	lds	r25, 0x26E2
    45b2:	a0 91 e3 26 	lds	r26, 0x26E3
    45b6:	b0 91 e4 26 	lds	r27, 0x26E4
    45ba:	01 96       	adiw	r24, 0x01	; 1
    45bc:	a1 1d       	adc	r26, r1
    45be:	b1 1d       	adc	r27, r1
    45c0:	80 93 e1 26 	sts	0x26E1, r24
    45c4:	90 93 e2 26 	sts	0x26E2, r25
    45c8:	a0 93 e3 26 	sts	0x26E3, r26
    45cc:	b0 93 e4 26 	sts	0x26E4, r27
#ifdef RF230BB_HOOK_RX_PACKET
  RF230BB_HOOK_RX_PACKET(buf,len);
#endif

  /* Here return just the data length. The checksum is however still in the buffer for packet sniffing */
  return len - AUX_LEN;
    45d0:	02 c0       	rjmp	.+4      	; 0x45d6 <rf230_read+0x1c4>
  len=rxframe[rxframe_head].length;
  if (len==0) {
#if RADIOALWAYSON && DEBUGFLOWSIZE
   if (RF230_receive_on==0) {if (debugflow[debugflowsize-1]!='z') DEBUGFLOW('z');} //cxmac calls with radio off?
#endif
    return 0;
    45d2:	c0 e0       	ldi	r28, 0x00	; 0
    45d4:	d0 e0       	ldi	r29, 0x00	; 0
  RF230BB_HOOK_RX_PACKET(buf,len);
#endif

  /* Here return just the data length. The checksum is however still in the buffer for packet sniffing */
  return len - AUX_LEN;
}
    45d6:	ce 01       	movw	r24, r28
    45d8:	df 91       	pop	r29
    45da:	cf 91       	pop	r28
    45dc:	ff 90       	pop	r15
    45de:	ef 90       	pop	r14
    45e0:	08 95       	ret

000045e2 <process_thread_rf230_process>:
#else
#define RF230PROCESSFLAG(arg)
#endif

PROCESS_THREAD(rf230_process, ev, data)
{
    45e2:	0f 93       	push	r16
    45e4:	1f 93       	push	r17
    45e6:	df 93       	push	r29
    45e8:	cf 93       	push	r28
    45ea:	0f 92       	push	r0
    45ec:	cd b7       	in	r28, 0x3d	; 61
    45ee:	de b7       	in	r29, 0x3e	; 62
    45f0:	8c 01       	movw	r16, r24
  int len;
  PROCESS_BEGIN();
    45f2:	fc 01       	movw	r30, r24
    45f4:	80 81       	ld	r24, Z
    45f6:	91 81       	ldd	r25, Z+1	; 0x01
    45f8:	00 97       	sbiw	r24, 0x00	; 0
    45fa:	29 f0       	breq	.+10     	; 0x4606 <process_thread_rf230_process+0x24>
    45fc:	f5 e0       	ldi	r31, 0x05	; 5
    45fe:	8a 33       	cpi	r24, 0x3A	; 58
    4600:	9f 07       	cpc	r25, r31
    4602:	59 f5       	brne	.+86     	; 0x465a <process_thread_rf230_process+0x78>
    4604:	06 c0       	rjmp	.+12     	; 0x4612 <process_thread_rf230_process+0x30>
  RF230PROCESSFLAG(99);

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
    4606:	8a e3       	ldi	r24, 0x3A	; 58
    4608:	95 e0       	ldi	r25, 0x05	; 5
    460a:	f8 01       	movw	r30, r16
    460c:	91 83       	std	Z+1, r25	; 0x01
    460e:	80 83       	st	Z, r24
    4610:	29 c0       	rjmp	.+82     	; 0x4664 <process_thread_rf230_process+0x82>
    4612:	62 38       	cpi	r22, 0x82	; 130
    4614:	39 f5       	brne	.+78     	; 0x4664 <process_thread_rf230_process+0x82>
    RF230PROCESSFLAG(42);
#if RF230_TIMETABLE_PROFILING
    TIMETABLE_TIMESTAMP(rf230_timetable, "poll");
#endif /* RF230_TIMETABLE_PROFILING */

    packetbuf_clear();
    4616:	0e 94 ab 32 	call	0x6556	; 0x6556 <packetbuf_clear>

    /* Turn off interrupts to avoid ISR writing to the same buffers we are reading. */
    HAL_ENTER_CRITICAL_REGION();
    461a:	8f b7       	in	r24, 0x3f	; 63
    461c:	89 83       	std	Y+1, r24	; 0x01
    461e:	f8 94       	cli

    len = rf230_read(packetbuf_dataptr(), PACKETBUF_SIZE);
    4620:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    4624:	60 e8       	ldi	r22, 0x80	; 128
    4626:	70 e0       	ldi	r23, 0x00	; 0
    4628:	0e 94 09 22 	call	0x4412	; 0x4412 <rf230_read>

    /* Restore interrupts. */
    HAL_LEAVE_CRITICAL_REGION();
    462c:	29 81       	ldd	r18, Y+1	; 0x01
    462e:	2f bf       	out	0x3f, r18	; 63
      }
#endif


    RF230PROCESSFLAG(1);
    if(len > 0) {
    4630:	18 16       	cp	r1, r24
    4632:	19 06       	cpc	r1, r25
    4634:	44 f4       	brge	.+16     	; 0x4646 <process_thread_rf230_process+0x64>
      packetbuf_set_datalen(len);
    4636:	0e 94 03 32 	call	0x6406	; 0x6406 <packetbuf_set_datalen>
      RF230PROCESSFLAG(2);
      NETSTACK_RDC.input();
    463a:	e0 91 8c 0e 	lds	r30, 0x0E8C
    463e:	f0 91 8d 0e 	lds	r31, 0x0E8D
    4642:	09 95       	icall
    4644:	e0 cf       	rjmp	.-64     	; 0x4606 <process_thread_rf230_process+0x24>
                                           &rf230_timetable);
      timetable_clear(&rf230_timetable);
#endif /* RF230_TIMETABLE_PROFILING */
    } else {
#if RADIOSTATS
       RF230_receivefail++;
    4646:	80 91 45 25 	lds	r24, 0x2545
    464a:	90 91 46 25 	lds	r25, 0x2546
    464e:	01 96       	adiw	r24, 0x01	; 1
    4650:	90 93 46 25 	sts	0x2546, r25
    4654:	80 93 45 25 	sts	0x2545, r24
    4658:	d6 cf       	rjmp	.-84     	; 0x4606 <process_thread_rf230_process+0x24>
#endif
    }
  }

  PROCESS_END();
    465a:	f8 01       	movw	r30, r16
    465c:	11 82       	std	Z+1, r1	; 0x01
    465e:	10 82       	st	Z, r1
    4660:	83 e0       	ldi	r24, 0x03	; 3
    4662:	01 c0       	rjmp	.+2      	; 0x4666 <process_thread_rf230_process+0x84>
  int len;
  PROCESS_BEGIN();
  RF230PROCESSFLAG(99);

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
    4664:	81 e0       	ldi	r24, 0x01	; 1
#endif
    }
  }

  PROCESS_END();
}
    4666:	0f 90       	pop	r0
    4668:	cf 91       	pop	r28
    466a:	df 91       	pop	r29
    466c:	1f 91       	pop	r17
    466e:	0f 91       	pop	r16
    4670:	08 95       	ret

00004672 <rf230_set_txpower>:
}
/*---------------------------------------------------------------------------*/
void
rf230_set_txpower(uint8_t power)
{
  set_txpower(power);
    4672:	0e 94 9d 1f 	call	0x3f3a	; 0x3f3a <set_txpower>
}
    4676:	08 95       	ret

00004678 <rf230_get_txpower>:
/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_txpower(void)
{
	uint8_t power = TX_PWR_UNDEFINED;
	if (hal_get_slptr()) {
    4678:	80 91 39 01 	lds	r24, 0x0139
    467c:	81 fd       	sbrc	r24, 1
    467e:	07 c0       	rjmp	.+14     	; 0x468e <rf230_get_txpower+0x16>
		PRINTF("rf230_get_txpower:Sleeping");
	} else {
		power = hal_subregister_read(SR_TX_PWR);
    4680:	85 e4       	ldi	r24, 0x45	; 69
    4682:	91 e0       	ldi	r25, 0x01	; 1
    4684:	6f e0       	ldi	r22, 0x0F	; 15
    4686:	40 e0       	ldi	r20, 0x00	; 0
    4688:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <hal_subregister_read>
    468c:	08 95       	ret
}
/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_txpower(void)
{
	uint8_t power = TX_PWR_UNDEFINED;
    468e:	80 e1       	ldi	r24, 0x10	; 16
		PRINTF("rf230_get_txpower:Sleeping");
	} else {
		power = hal_subregister_read(SR_TX_PWR);
	}
	return power;
}
    4690:	08 95       	ret

00004692 <rf230_transmit>:
/*---------------------------------------------------------------------------*/
static uint8_t buffer[RF230_MAX_TX_FRAME_LENGTH+AUX_LEN];

static int
rf230_transmit(unsigned short payload_len)
{
    4692:	df 92       	push	r13
    4694:	ef 92       	push	r14
    4696:	ff 92       	push	r15
    4698:	0f 93       	push	r16
    469a:	1f 93       	push	r17
    469c:	df 93       	push	r29
    469e:	cf 93       	push	r28
    46a0:	0f 92       	push	r0
    46a2:	cd b7       	in	r28, 0x3d	; 61
    46a4:	de b7       	in	r29, 0x3e	; 62
    46a6:	d8 2e       	mov	r13, r24
  struct timestamp timestamp;
#endif /* RF230_CONF_TIMESTAMPS */

  /* If radio is sleeping we have to turn it on first */
  /* This automatically does the PLL calibrations */
  if (hal_get_slptr()) {
    46a8:	80 91 39 01 	lds	r24, 0x0139
    46ac:	81 ff       	sbrs	r24, 1
    46ae:	1a c0       	rjmp	.+52     	; 0x46e4 <rf230_transmit+0x52>
#if defined(__AVR_ATmega128RFA1__)
	ENERGEST_ON(ENERGEST_TYPE_LED_RED);
    46b0:	80 91 94 00 	lds	r24, 0x0094
    46b4:	90 91 95 00 	lds	r25, 0x0095
    46b8:	90 93 6e 27 	sts	0x276E, r25
    46bc:	80 93 6d 27 	sts	0x276D, r24
    46c0:	81 e0       	ldi	r24, 0x01	; 1
    46c2:	80 93 5c 27 	sts	0x275C, r24
#if RF230BB_CONF_LEDONPORTE1
    PORTE|=(1<<PE1); //ledon
#endif
    rf230_wakewait=1;
    46c6:	80 93 d5 26 	sts	0x26D5, r24
	  hal_set_slptr_low();
    46ca:	80 91 39 01 	lds	r24, 0x0139
    46ce:	8d 7f       	andi	r24, 0xFD	; 253
    46d0:	80 93 39 01 	sts	0x0139, r24
    46d4:	80 e1       	ldi	r24, 0x10	; 16
    46d6:	97 e2       	ldi	r25, 0x27	; 39
    {
      int i;
      for (i=0;i<10000;i++) {
        if (!rf230_wakewait) break;
    46d8:	20 91 d5 26 	lds	r18, 0x26D5
    46dc:	22 23       	and	r18, r18
    46de:	11 f0       	breq	.+4      	; 0x46e4 <rf230_transmit+0x52>
    46e0:	01 97       	sbiw	r24, 0x01	; 1
#endif
    rf230_wakewait=1;
	  hal_set_slptr_low();
    {
      int i;
      for (i=0;i<10000;i++) {
    46e2:	d1 f7       	brne	.-12     	; 0x46d8 <rf230_transmit+0x46>
    }
#endif
  }
 
  /* Wait for any previous operation or state transition to finish */
  rf230_waitidle();
    46e4:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <rf230_waitidle>
  if(RF230_receive_on) {
    46e8:	80 91 da 26 	lds	r24, 0x26DA
    46ec:	88 23       	and	r24, r24
    46ee:	09 f4       	brne	.+2      	; 0x46f2 <rf230_transmit+0x60>
    46f0:	41 c0       	rjmp	.+130    	; 0x4774 <rf230_transmit+0xe2>
    ENERGEST_OFF(ENERGEST_TYPE_LISTEN);
    46f2:	80 91 5e 27 	lds	r24, 0x275E
    46f6:	88 23       	and	r24, r24
    46f8:	e9 f1       	breq	.+122    	; 0x4774 <rf230_transmit+0xe2>
    46fa:	20 91 94 00 	lds	r18, 0x0094
    46fe:	30 91 95 00 	lds	r19, 0x0095
    4702:	80 91 71 27 	lds	r24, 0x2771
    4706:	90 91 72 27 	lds	r25, 0x2772
    470a:	28 17       	cp	r18, r24
    470c:	39 07       	cpc	r19, r25
    470e:	a0 f4       	brcc	.+40     	; 0x4738 <rf230_transmit+0xa6>
    4710:	20 91 41 27 	lds	r18, 0x2741
    4714:	30 91 42 27 	lds	r19, 0x2742
    4718:	40 91 43 27 	lds	r20, 0x2743
    471c:	50 91 44 27 	lds	r21, 0x2744
    4720:	2c 57       	subi	r18, 0x7C	; 124
    4722:	31 4e       	sbci	r19, 0xE1	; 225
    4724:	4f 4f       	sbci	r20, 0xFF	; 255
    4726:	5f 4f       	sbci	r21, 0xFF	; 255
    4728:	20 93 41 27 	sts	0x2741, r18
    472c:	30 93 42 27 	sts	0x2742, r19
    4730:	40 93 43 27 	sts	0x2743, r20
    4734:	50 93 44 27 	sts	0x2744, r21
    4738:	20 91 94 00 	lds	r18, 0x0094
    473c:	30 91 95 00 	lds	r19, 0x0095
    4740:	28 1b       	sub	r18, r24
    4742:	39 0b       	sbc	r19, r25
    4744:	40 e0       	ldi	r20, 0x00	; 0
    4746:	50 e0       	ldi	r21, 0x00	; 0
    4748:	e0 90 41 27 	lds	r14, 0x2741
    474c:	f0 90 42 27 	lds	r15, 0x2742
    4750:	00 91 43 27 	lds	r16, 0x2743
    4754:	10 91 44 27 	lds	r17, 0x2744
    4758:	2e 0d       	add	r18, r14
    475a:	3f 1d       	adc	r19, r15
    475c:	40 1f       	adc	r20, r16
    475e:	51 1f       	adc	r21, r17
    4760:	20 93 41 27 	sts	0x2741, r18
    4764:	30 93 42 27 	sts	0x2742, r19
    4768:	40 93 43 27 	sts	0x2743, r20
    476c:	50 93 44 27 	sts	0x2744, r21
    4770:	10 92 5e 27 	sts	0x275E, r1
  }
  /* Prepare to transmit */
#if RF230_CONF_FRAME_RETRIES
  radio_set_trx_state(TX_ARET_ON);
    4774:	89 e1       	ldi	r24, 0x19	; 25
    4776:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <radio_set_trx_state>
  DEBUGFLOW('T');
#endif

  txpower = 0;
  
  if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    477a:	86 e0       	ldi	r24, 0x06	; 6
    477c:	0e 94 3c 33 	call	0x6678	; 0x6678 <packetbuf_attr>
    4780:	00 97       	sbiw	r24, 0x00	; 0
    4782:	51 f0       	breq	.+20     	; 0x4798 <rf230_transmit+0x106>
    /* Remember the current transmission power */
    txpower = rf230_get_txpower();
    4784:	0e 94 3c 23 	call	0x4678	; 0x4678 <rf230_get_txpower>
    4788:	08 2f       	mov	r16, r24
    /* Set the specified transmission power */
    set_txpower(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) - 1);
    478a:	86 e0       	ldi	r24, 0x06	; 6
    478c:	0e 94 3c 33 	call	0x6678	; 0x6678 <packetbuf_attr>
    4790:	81 50       	subi	r24, 0x01	; 1
    4792:	0e 94 9d 1f 	call	0x3f3a	; 0x3f3a <set_txpower>
    4796:	02 c0       	rjmp	.+4      	; 0x479c <rf230_transmit+0x10a>
#else
  radio_set_trx_state(PLL_ON);
  DEBUGFLOW('T');
#endif

  txpower = 0;
    4798:	00 e0       	ldi	r16, 0x00	; 0
    479a:	10 e0       	ldi	r17, 0x00	; 0

#if RF230_CONF_TIMESTAMPS
  rtimer_clock_t txtime = timesynch_time();
#endif /* RF230_CONF_TIMESTAMPS */

  ENERGEST_ON(ENERGEST_TYPE_TRANSMIT);
    479c:	80 91 94 00 	lds	r24, 0x0094
    47a0:	90 91 95 00 	lds	r25, 0x0095
    47a4:	90 93 70 27 	sts	0x2770, r25
    47a8:	80 93 6f 27 	sts	0x276F, r24
    47ac:	81 e0       	ldi	r24, 0x01	; 1
    47ae:	80 93 5d 27 	sts	0x275D, r24
  
/* No interrupts across frame download! */
  HAL_ENTER_CRITICAL_REGION();
    47b2:	8f b7       	in	r24, 0x3f	; 63
    47b4:	89 83       	std	Y+1, r24	; 0x01
    47b6:	f8 94       	cli

  /* Toggle the SLP_TR pin to initiate the frame transmission */
  hal_set_slptr_high();
    47b8:	80 91 39 01 	lds	r24, 0x0139
    47bc:	82 60       	ori	r24, 0x02	; 2
    47be:	80 93 39 01 	sts	0x0139, r24
  hal_set_slptr_low();
    47c2:	80 91 39 01 	lds	r24, 0x0139
    47c6:	8d 7f       	andi	r24, 0xFD	; 253
    47c8:	80 93 39 01 	sts	0x0139, r24
    txpower = rf230_get_txpower();
    /* Set the specified transmission power */
    set_txpower(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) - 1);
  }

  total_len = payload_len + AUX_LEN;
    47cc:	6d 2d       	mov	r22, r13
    47ce:	6e 5f       	subi	r22, 0xFE	; 254
  HAL_ENTER_CRITICAL_REGION();

  /* Toggle the SLP_TR pin to initiate the frame transmission */
  hal_set_slptr_high();
  hal_set_slptr_low();
  hal_frame_write(buffer, total_len);
    47d0:	8e e1       	ldi	r24, 0x1E	; 30
    47d2:	9d e1       	ldi	r25, 0x1D	; 29
    47d4:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <hal_frame_write>

  HAL_LEAVE_CRITICAL_REGION();
    47d8:	89 81       	ldd	r24, Y+1	; 0x01
    47da:	8f bf       	out	0x3f, r24	; 63
    PRINTF("\n");
  }
#endif

#if RADIOSTATS
  RF230_sendpackets++;
    47dc:	80 91 d6 26 	lds	r24, 0x26D6
    47e0:	90 91 d7 26 	lds	r25, 0x26D7
    47e4:	01 96       	adiw	r24, 0x01	; 1
    47e6:	90 93 d7 26 	sts	0x26D7, r25
    47ea:	80 93 d6 26 	sts	0x26D6, r24
#endif
 
 /* We wait until transmission has ended so that we get an
     accurate measurement of the transmission time.*/
  rf230_waitidle();
    47ee:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <rf230_waitidle>

 /* Get the transmission result */  
#if RF230_CONF_FRAME_RETRIES
  tx_result = hal_subregister_read(SR_TRAC_STATUS);
    47f2:	82 e4       	ldi	r24, 0x42	; 66
    47f4:	91 e0       	ldi	r25, 0x01	; 1
    47f6:	60 ee       	ldi	r22, 0xE0	; 224
    47f8:	45 e0       	ldi	r20, 0x05	; 5
    47fa:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <hal_subregister_read>
    47fe:	e8 2e       	mov	r14, r24
#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
  ENERGEST_OFF_LEVEL(ENERGEST_TYPE_TRANSMIT,rf230_get_txpower());
#endif

 /* Restore the transmission power */
 if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    4800:	86 e0       	ldi	r24, 0x06	; 6
    4802:	0e 94 3c 33 	call	0x6678	; 0x6678 <packetbuf_attr>
    4806:	00 97       	sbiw	r24, 0x00	; 0
    4808:	19 f0       	breq	.+6      	; 0x4810 <rf230_transmit+0x17e>
    set_txpower(txpower & 0xff);
    480a:	80 2f       	mov	r24, r16
    480c:	0e 94 9d 1f 	call	0x3f3a	; 0x3f3a <set_txpower>
    num_transmissions++;
  }

#endif /* RF230_CONF_TIMESTAMPS */

  ENERGEST_OFF(ENERGEST_TYPE_TRANSMIT);
    4810:	80 91 5d 27 	lds	r24, 0x275D
    4814:	88 23       	and	r24, r24
    4816:	e9 f1       	breq	.+122    	; 0x4892 <rf230_transmit+0x200>
    4818:	20 91 94 00 	lds	r18, 0x0094
    481c:	30 91 95 00 	lds	r19, 0x0095
    4820:	80 91 6f 27 	lds	r24, 0x276F
    4824:	90 91 70 27 	lds	r25, 0x2770
    4828:	28 17       	cp	r18, r24
    482a:	39 07       	cpc	r19, r25
    482c:	a0 f4       	brcc	.+40     	; 0x4856 <rf230_transmit+0x1c4>
    482e:	20 91 3d 27 	lds	r18, 0x273D
    4832:	30 91 3e 27 	lds	r19, 0x273E
    4836:	40 91 3f 27 	lds	r20, 0x273F
    483a:	50 91 40 27 	lds	r21, 0x2740
    483e:	2c 57       	subi	r18, 0x7C	; 124
    4840:	31 4e       	sbci	r19, 0xE1	; 225
    4842:	4f 4f       	sbci	r20, 0xFF	; 255
    4844:	5f 4f       	sbci	r21, 0xFF	; 255
    4846:	20 93 3d 27 	sts	0x273D, r18
    484a:	30 93 3e 27 	sts	0x273E, r19
    484e:	40 93 3f 27 	sts	0x273F, r20
    4852:	50 93 40 27 	sts	0x2740, r21
    4856:	20 91 94 00 	lds	r18, 0x0094
    485a:	30 91 95 00 	lds	r19, 0x0095
    485e:	28 1b       	sub	r18, r24
    4860:	39 0b       	sbc	r19, r25
    4862:	40 e0       	ldi	r20, 0x00	; 0
    4864:	50 e0       	ldi	r21, 0x00	; 0
    4866:	60 91 3d 27 	lds	r22, 0x273D
    486a:	70 91 3e 27 	lds	r23, 0x273E
    486e:	80 91 3f 27 	lds	r24, 0x273F
    4872:	90 91 40 27 	lds	r25, 0x2740
    4876:	26 0f       	add	r18, r22
    4878:	37 1f       	adc	r19, r23
    487a:	48 1f       	adc	r20, r24
    487c:	59 1f       	adc	r21, r25
    487e:	20 93 3d 27 	sts	0x273D, r18
    4882:	30 93 3e 27 	sts	0x273E, r19
    4886:	40 93 3f 27 	sts	0x273F, r20
    488a:	50 93 40 27 	sts	0x2740, r21
    488e:	10 92 5d 27 	sts	0x275D, r1
  if(RF230_receive_on) {
    4892:	80 91 da 26 	lds	r24, 0x26DA
    4896:	88 23       	and	r24, r24
    4898:	71 f0       	breq	.+28     	; 0x48b6 <rf230_transmit+0x224>
    DEBUGFLOW('l');
    ENERGEST_ON(ENERGEST_TYPE_LISTEN);
    489a:	80 91 94 00 	lds	r24, 0x0094
    489e:	90 91 95 00 	lds	r25, 0x0095
    48a2:	90 93 72 27 	sts	0x2772, r25
    48a6:	80 93 71 27 	sts	0x2771, r24
    48aa:	81 e0       	ldi	r24, 0x01	; 1
    48ac:	80 93 5e 27 	sts	0x275E, r24
    radio_on();
    48b0:	0e 94 4a 20 	call	0x4094	; 0x4094 <radio_on>
    48b4:	02 c0       	rjmp	.+4      	; 0x48ba <rf230_transmit+0x228>
  } else {
#if RADIOALWAYSON
    /* Enable reception */
    radio_on();
#else
    radio_off();
    48b6:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <radio_off>

#if RF230_INSERTACK
   ack_pending = 0;
#endif

  if (tx_result==1) {        //success, data pending from addressee
    48ba:	8e 2d       	mov	r24, r14
    48bc:	81 30       	cpi	r24, 0x01	; 1
    48be:	11 f0       	breq	.+4      	; 0x48c4 <rf230_transmit+0x232>
    tx_result=RADIO_TX_OK;           //handle as ordinary success
  }

  if (tx_result==RADIO_TX_OK) {
    48c0:	ee 20       	and	r14, r14
    48c2:	69 f5       	brne	.+90     	; 0x491e <rf230_transmit+0x28c>
    RIMESTATS_ADD(lltx);
    48c4:	80 91 1d 27 	lds	r24, 0x271D
    48c8:	90 91 1e 27 	lds	r25, 0x271E
    48cc:	a0 91 1f 27 	lds	r26, 0x271F
    48d0:	b0 91 20 27 	lds	r27, 0x2720
    48d4:	01 96       	adiw	r24, 0x01	; 1
    48d6:	a1 1d       	adc	r26, r1
    48d8:	b1 1d       	adc	r27, r1
    48da:	80 93 1d 27 	sts	0x271D, r24
    48de:	90 93 1e 27 	sts	0x271E, r25
    48e2:	a0 93 1f 27 	sts	0x271F, r26
    48e6:	b0 93 20 27 	sts	0x2720, r27
    if(packetbuf_attr(PACKETBUF_ATTR_RELIABLE))
    48ea:	8c e0       	ldi	r24, 0x0C	; 12
    48ec:	0e 94 3c 33 	call	0x6678	; 0x6678 <packetbuf_attr>
    48f0:	00 97       	sbiw	r24, 0x00	; 0
    48f2:	09 f4       	brne	.+2      	; 0x48f6 <rf230_transmit+0x264>
    48f4:	4a c0       	rjmp	.+148    	; 0x498a <rf230_transmit+0x2f8>
      RIMESTATS_ADD(ackrx);		//ack was requested and received
    48f6:	80 91 f9 26 	lds	r24, 0x26F9
    48fa:	90 91 fa 26 	lds	r25, 0x26FA
    48fe:	a0 91 fb 26 	lds	r26, 0x26FB
    4902:	b0 91 fc 26 	lds	r27, 0x26FC
    4906:	01 96       	adiw	r24, 0x01	; 1
    4908:	a1 1d       	adc	r26, r1
    490a:	b1 1d       	adc	r27, r1
    490c:	80 93 f9 26 	sts	0x26F9, r24
    4910:	90 93 fa 26 	sts	0x26FA, r25
    4914:	a0 93 fb 26 	sts	0x26FB, r26
    4918:	b0 93 fc 26 	sts	0x26FC, r27
    491c:	36 c0       	rjmp	.+108    	; 0x498a <rf230_transmit+0x2f8>
  /* Not PAN broadcast to FFFF, and ACK was requested and received */
  if (!((buffer[5]==0xff) && (buffer[6]==0xff)) && (buffer[0]&(1<<6)))
    ack_pending=1;
#endif

  } else if (tx_result==3) {        //CSMA channel access failure
    491e:	8e 2d       	mov	r24, r14
    4920:	83 30       	cpi	r24, 0x03	; 3
    4922:	b1 f4       	brne	.+44     	; 0x4950 <rf230_transmit+0x2be>
    DEBUGFLOW('m');
    RIMESTATS_ADD(contentiondrop);
    4924:	80 91 15 27 	lds	r24, 0x2715
    4928:	90 91 16 27 	lds	r25, 0x2716
    492c:	a0 91 17 27 	lds	r26, 0x2717
    4930:	b0 91 18 27 	lds	r27, 0x2718
    4934:	01 96       	adiw	r24, 0x01	; 1
    4936:	a1 1d       	adc	r26, r1
    4938:	b1 1d       	adc	r27, r1
    493a:	80 93 15 27 	sts	0x2715, r24
    493e:	90 93 16 27 	sts	0x2716, r25
    4942:	a0 93 17 27 	sts	0x2717, r26
    4946:	b0 93 18 27 	sts	0x2718, r27
    PRINTF("rf230_transmit: Transmission never started\n");
    tx_result = RADIO_TX_COLLISION;
    494a:	02 e0       	ldi	r16, 0x02	; 2
    494c:	e0 2e       	mov	r14, r16
    494e:	21 c0       	rjmp	.+66     	; 0x4992 <rf230_transmit+0x300>
  } else if (tx_result==5) {        //Expected ACK, none received
    4950:	8e 2d       	mov	r24, r14
    4952:	85 30       	cpi	r24, 0x05	; 5
    4954:	b1 f4       	brne	.+44     	; 0x4982 <rf230_transmit+0x2f0>
    DEBUGFLOW('n');
    tx_result = RADIO_TX_NOACK;
    PRINTF("rf230_transmit: ACK not received\n");
    RIMESTATS_ADD(badackrx);		//ack was requested but not received
    4956:	80 91 01 27 	lds	r24, 0x2701
    495a:	90 91 02 27 	lds	r25, 0x2702
    495e:	a0 91 03 27 	lds	r26, 0x2703
    4962:	b0 91 04 27 	lds	r27, 0x2704
    4966:	01 96       	adiw	r24, 0x01	; 1
    4968:	a1 1d       	adc	r26, r1
    496a:	b1 1d       	adc	r27, r1
    496c:	80 93 01 27 	sts	0x2701, r24
    4970:	90 93 02 27 	sts	0x2702, r25
    4974:	a0 93 03 27 	sts	0x2703, r26
    4978:	b0 93 04 27 	sts	0x2704, r27
    RIMESTATS_ADD(contentiondrop);
    PRINTF("rf230_transmit: Transmission never started\n");
    tx_result = RADIO_TX_COLLISION;
  } else if (tx_result==5) {        //Expected ACK, none received
    DEBUGFLOW('n');
    tx_result = RADIO_TX_NOACK;
    497c:	13 e0       	ldi	r17, 0x03	; 3
    497e:	e1 2e       	mov	r14, r17
    4980:	08 c0       	rjmp	.+16     	; 0x4992 <rf230_transmit+0x300>
    PRINTF("rf230_transmit: ACK not received\n");
    RIMESTATS_ADD(badackrx);		//ack was requested but not received
  } else if (tx_result==7) {        //Invalid (Can't happen since waited for idle above?)
    4982:	8e 2d       	mov	r24, r14
    4984:	87 30       	cpi	r24, 0x07	; 7
    4986:	29 f4       	brne	.+10     	; 0x4992 <rf230_transmit+0x300>
    4988:	02 c0       	rjmp	.+4      	; 0x498e <rf230_transmit+0x2fc>
    tx_result=RADIO_TX_OK;           //handle as ordinary success
  }

  if (tx_result==RADIO_TX_OK) {
    RIMESTATS_ADD(lltx);
    if(packetbuf_attr(PACKETBUF_ATTR_RELIABLE))
    498a:	ee 24       	eor	r14, r14
    498c:	02 c0       	rjmp	.+4      	; 0x4992 <rf230_transmit+0x300>
    tx_result = RADIO_TX_NOACK;
    PRINTF("rf230_transmit: ACK not received\n");
    RIMESTATS_ADD(badackrx);		//ack was requested but not received
  } else if (tx_result==7) {        //Invalid (Can't happen since waited for idle above?)
    DEBUGFLOW('o');
    tx_result = RADIO_TX_ERR;
    498e:	ee 24       	eor	r14, r14
    4990:	e3 94       	inc	r14
  }

  return tx_result;
}
    4992:	8e 2d       	mov	r24, r14
    4994:	90 e0       	ldi	r25, 0x00	; 0
    4996:	0f 90       	pop	r0
    4998:	cf 91       	pop	r28
    499a:	df 91       	pop	r29
    499c:	1f 91       	pop	r17
    499e:	0f 91       	pop	r16
    49a0:	ff 90       	pop	r15
    49a2:	ef 90       	pop	r14
    49a4:	df 90       	pop	r13
    49a6:	08 95       	ret

000049a8 <rf230_send>:
  return ret;
}
/*---------------------------------------------------------------------------*/
static int
rf230_send(const void *payload, unsigned short payload_len)
{
    49a8:	cf 93       	push	r28
    49aa:	df 93       	push	r29
    49ac:	eb 01       	movw	r28, r22
	if(!RF230BB_HOOK_IS_SEND_ENABLED()) {
		goto bail;
	}
#endif
	
	if((ret=rf230_prepare(payload, payload_len))) {
    49ae:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <rf230_prepare>
    49b2:	9c 01       	movw	r18, r24
    49b4:	00 97       	sbiw	r24, 0x00	; 0
    49b6:	31 f4       	brne	.+12     	; 0x49c4 <rf230_send+0x1c>
	    PRINTF("rf230_send: Unable to send, prep failed (%d)\n",ret);
		goto bail;
	}

	ret = rf230_transmit(payload_len);
    49b8:	ce 01       	movw	r24, r28
    49ba:	0e 94 49 23 	call	0x4692	; 0x4692 <rf230_transmit>
    49be:	9c 01       	movw	r18, r24
	
bail:
#if RADIOSTATS
    if (ret) RF230_sendfail++;
    49c0:	00 97       	sbiw	r24, 0x00	; 0
    49c2:	49 f0       	breq	.+18     	; 0x49d6 <rf230_send+0x2e>
    49c4:	80 91 d8 26 	lds	r24, 0x26D8
    49c8:	90 91 d9 26 	lds	r25, 0x26D9
    49cc:	01 96       	adiw	r24, 0x01	; 1
    49ce:	90 93 d9 26 	sts	0x26D9, r25
    49d2:	80 93 d8 26 	sts	0x26D8, r24
#endif
	return ret;
}
    49d6:	c9 01       	movw	r24, r18
    49d8:	df 91       	pop	r29
    49da:	cf 91       	pop	r28
    49dc:	08 95       	ret

000049de <rf230_get_raw_rssi>:
}

/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_raw_rssi(void)
{
    49de:	0f 93       	push	r16
    49e0:	1f 93       	push	r17
  uint8_t rssi,state;
  bool radio_was_off = 0;

  /*The RSSI measurement should only be done in RX_ON or BUSY_RX.*/
  if(!RF230_receive_on) {
    49e2:	80 91 da 26 	lds	r24, 0x26DA
    49e6:	88 23       	and	r24, r24
    49e8:	21 f4       	brne	.+8      	; 0x49f2 <rf230_get_raw_rssi+0x14>
    radio_was_off = 1;
    rf230_on();
    49ea:	0e 94 7f 20 	call	0x40fe	; 0x40fe <rf230_on>
  uint8_t rssi,state;
  bool radio_was_off = 0;

  /*The RSSI measurement should only be done in RX_ON or BUSY_RX.*/
  if(!RF230_receive_on) {
    radio_was_off = 1;
    49ee:	11 e0       	ldi	r17, 0x01	; 1
    49f0:	01 c0       	rjmp	.+2      	; 0x49f4 <rf230_get_raw_rssi+0x16>
/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_raw_rssi(void)
{
  uint8_t rssi,state;
  bool radio_was_off = 0;
    49f2:	10 e0       	ldi	r17, 0x00	; 0
    rf230_on();
  }

/* The energy detect register is used in extended mode (since RSSI will read 0) */
/* The rssi register is multiplied by 3 to a consistent value from either register */
  state=radio_get_trx_state();
    49f4:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <radio_get_trx_state>
  if ((state==RX_AACK_ON) || (state==BUSY_RX_AACK)) {
    49f8:	86 31       	cpi	r24, 0x16	; 22
    49fa:	11 f0       	breq	.+4      	; 0x4a00 <rf230_get_raw_rssi+0x22>
    49fc:	81 31       	cpi	r24, 0x11	; 17
    49fe:	19 f4       	brne	.+6      	; 0x4a06 <rf230_get_raw_rssi+0x28>
 //  rssi = hal_subregister_read(SR_ED_LEVEL);  //0-84, resolution 1 dB
     rssi = hal_register_read(RG_PHY_ED_LEVEL);  //0-84, resolution 1 dB
    4a00:	00 91 47 01 	lds	r16, 0x0147
    4a04:	09 c0       	rjmp	.+18     	; 0x4a18 <rf230_get_raw_rssi+0x3a>
#if 0   // 3-clock shift and add is faster on machines with no hardware multiply
/* avr-gcc may have an -Os bug that uses the general subroutine for multiplying by 3 */
     rssi = hal_subregister_read(SR_RSSI);      //0-28, resolution 3 dB
     rssi = (rssi << 1)  + rssi;                //*3
#else  // 1 or 2 clock multiply, or compiler with correct optimization
     rssi = 3 * hal_subregister_read(SR_RSSI);
    4a06:	86 e4       	ldi	r24, 0x46	; 70
    4a08:	91 e0       	ldi	r25, 0x01	; 1
    4a0a:	6f e1       	ldi	r22, 0x1F	; 31
    4a0c:	40 e0       	ldi	r20, 0x00	; 0
    4a0e:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <hal_subregister_read>
    4a12:	08 2f       	mov	r16, r24
    4a14:	00 0f       	add	r16, r16
    4a16:	08 0f       	add	r16, r24
#endif

  }

  if(radio_was_off) {
    4a18:	11 23       	and	r17, r17
    4a1a:	11 f0       	breq	.+4      	; 0x4a20 <rf230_get_raw_rssi+0x42>
    rf230_off();
    4a1c:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <rf230_off>
  }
  return rssi;
}
    4a20:	80 2f       	mov	r24, r16
    4a22:	1f 91       	pop	r17
    4a24:	0f 91       	pop	r16
    4a26:	08 95       	ret

00004a28 <hal_init>:
void
hal_init(void)
{
    /*Reset variables used in file.*/
    /* (none at the moment) */
}
    4a28:	08 95       	ret

00004a2a <hal_subregister_read>:
   
 */
uint8_t
hal_subregister_read(uint16_t address, uint8_t mask, uint8_t position)
{
    return (_SFR_MEM8(address)&mask)>>position;
    4a2a:	fc 01       	movw	r30, r24
    4a2c:	80 81       	ld	r24, Z
    4a2e:	86 23       	and	r24, r22
    4a30:	90 e0       	ldi	r25, 0x00	; 0
    4a32:	02 c0       	rjmp	.+4      	; 0x4a38 <hal_subregister_read+0xe>
    4a34:	95 95       	asr	r25
    4a36:	87 95       	ror	r24
    4a38:	4a 95       	dec	r20
    4a3a:	e2 f7       	brpl	.-8      	; 0x4a34 <hal_subregister_read+0xa>
}
    4a3c:	08 95       	ret

00004a3e <hal_subregister_write>:
void
hal_subregister_write(uint16_t address, uint8_t mask, uint8_t position,
                            uint8_t value)
{
    4a3e:	df 93       	push	r29
    4a40:	cf 93       	push	r28
    4a42:	0f 92       	push	r0
    4a44:	cd b7       	in	r28, 0x3d	; 61
    4a46:	de b7       	in	r29, 0x3e	; 62
    HAL_ENTER_CRITICAL_REGION();
    4a48:	3f b7       	in	r19, 0x3f	; 63
    4a4a:	39 83       	std	Y+1, r19	; 0x01
    4a4c:	f8 94       	cli

    uint8_t register_value = _SFR_MEM8(address);
    4a4e:	fc 01       	movw	r30, r24
    4a50:	90 81       	ld	r25, Z
    register_value &= ~mask;
    4a52:	86 2f       	mov	r24, r22
    4a54:	80 95       	com	r24
    4a56:	89 23       	and	r24, r25
    value <<= position;
    4a58:	30 e0       	ldi	r19, 0x00	; 0
    4a5a:	02 c0       	rjmp	.+4      	; 0x4a60 <hal_subregister_write+0x22>
    4a5c:	22 0f       	add	r18, r18
    4a5e:	33 1f       	adc	r19, r19
    4a60:	4a 95       	dec	r20
    4a62:	e2 f7       	brpl	.-8      	; 0x4a5c <hal_subregister_write+0x1e>
    value &= mask;
    4a64:	26 23       	and	r18, r22
    value |= register_value;
    4a66:	28 2b       	or	r18, r24
    _SFR_MEM8(address) = value;
    4a68:	20 83       	st	Z, r18

    HAL_LEAVE_CRITICAL_REGION();
    4a6a:	89 81       	ldd	r24, Y+1	; 0x01
    4a6c:	8f bf       	out	0x3f, r24	; 63
}
    4a6e:	0f 90       	pop	r0
    4a70:	cf 91       	pop	r28
    4a72:	df 91       	pop	r29
    4a74:	08 95       	ret

00004a76 <hal_frame_read>:
    uint8_t frame_length,*rx_data,*rx_buffer;
 
    /* Get length from the TXT_RX_LENGTH register, not including LQI
     * Bypassing the length check can result in overrun if buffer is < 256 bytes.
     */
    frame_length = TST_RX_LENGTH;
    4a76:	20 91 7b 01 	lds	r18, 0x017B
    if ((frame_length < HAL_MIN_FRAME_LENGTH) || (frame_length > HAL_MAX_FRAME_LENGTH)) {
    4a7a:	32 2f       	mov	r19, r18
    4a7c:	33 50       	subi	r19, 0x03	; 3
    4a7e:	3d 37       	cpi	r19, 0x7D	; 125
    4a80:	58 f0       	brcs	.+22     	; 0x4a98 <hal_frame_read+0x22>
        /* Length test failed */
        rx_frame->length = 0;
    4a82:	dc 01       	movw	r26, r24
    4a84:	1c 92       	st	X, r1
        rx_frame->lqi    = 0;
    4a86:	fc 01       	movw	r30, r24
    4a88:	e0 58       	subi	r30, 0x80	; 128
    4a8a:	ff 4f       	sbci	r31, 0xFF	; 255
    4a8c:	10 82       	st	Z, r1
        rx_frame->crc    = false;
    4a8e:	8f 57       	subi	r24, 0x7F	; 127
    4a90:	9f 4f       	sbci	r25, 0xFF	; 255
    4a92:	fc 01       	movw	r30, r24
    4a94:	10 82       	st	Z, r1
        return;
    4a96:	08 95       	ret
    }
    rx_frame->length = frame_length;
    4a98:	fc 01       	movw	r30, r24
    4a9a:	21 93       	st	Z+, r18
 *          are set to zero.
 *
 *  \param  rx_frame    Pointer to the data structure where the frame is stored.
 */
void
hal_frame_read(hal_rx_frame_t *rx_frame)
    4a9c:	21 50       	subi	r18, 0x01	; 1
    4a9e:	30 e0       	ldi	r19, 0x00	; 0
    4aa0:	a9 01       	movw	r20, r18
    4aa2:	4f 57       	subi	r20, 0x7F	; 127
    4aa4:	5e 4f       	sbci	r21, 0xFE	; 254
        return;
    }
    rx_frame->length = frame_length;

    /* Start of buffer in I/O space, pointer to RAM buffer */
    rx_buffer=(uint8_t *)0x180;
    4aa6:	a0 e8       	ldi	r26, 0x80	; 128
    4aa8:	b1 e0       	ldi	r27, 0x01	; 1
    rx_data = (rx_frame->data);

    do{
        *rx_data++ = _SFR_MEM8(rx_buffer++);
    4aaa:	6d 91       	ld	r22, X+
    4aac:	61 93       	st	Z+, r22
    } while (--frame_length > 0);
    4aae:	a4 17       	cp	r26, r20
    4ab0:	b5 07       	cpc	r27, r21
    4ab2:	d9 f7       	brne	.-10     	; 0x4aaa <hal_frame_read+0x34>

    /*Read LQI value for this frame.*/
    rx_frame->lqi = *rx_buffer;
    4ab4:	fc 01       	movw	r30, r24
    4ab6:	e0 58       	subi	r30, 0x80	; 128
    4ab8:	ff 4f       	sbci	r31, 0xFF	; 255
    4aba:	2f 57       	subi	r18, 0x7F	; 127
    4abc:	3e 4f       	sbci	r19, 0xFE	; 254
    4abe:	d9 01       	movw	r26, r18
    4ac0:	2c 91       	ld	r18, X
    4ac2:	20 83       	st	Z, r18

    /* If crc was calculated set crc field in hal_rx_frame_t accordingly.
     * Else show the crc has passed the hardware check.
     */
    rx_frame->crc   = true;
    4ac4:	8f 57       	subi	r24, 0x7F	; 127
    4ac6:	9f 4f       	sbci	r25, 0xFF	; 255
    4ac8:	21 e0       	ldi	r18, 0x01	; 1
    4aca:	fc 01       	movw	r30, r24
    4acc:	20 83       	st	Z, r18
    4ace:	08 95       	ret

00004ad0 <hal_frame_write>:
 *  \param  write_buffer    Pointer to data that is to be written to frame buffer.
 *  \param  length          Length of data. The maximum length is 127 bytes.
 */
void
hal_frame_write(uint8_t *write_buffer, uint8_t length)
{
    4ad0:	fc 01       	movw	r30, r24
    tx_buffer=(uint8_t *)0x180;  //start of fifo in i/o space
    /* Write frame length, including the two byte checksum */
    /* The top bit of the length field shall be set to 0 for IEEE 802.15.4 compliant frames */
    /* It should already be clear, so bypassing the masking is sanity check of the uip stack */
//  length &= 0x7f;
    _SFR_MEM8(tx_buffer++) = length;
    4ad2:	60 93 80 01 	sts	0x0180, r22
 *
 *  \param  write_buffer    Pointer to data that is to be written to frame buffer.
 *  \param  length          Length of data. The maximum length is 127 bytes.
 */
void
hal_frame_write(uint8_t *write_buffer, uint8_t length)
    4ad6:	01 96       	adiw	r24, 0x01	; 1
    4ad8:	63 50       	subi	r22, 0x03	; 3
    4ada:	86 0f       	add	r24, r22
    4adc:	91 1d       	adc	r25, r1
    tx_buffer=(uint8_t *)0x180;  //start of fifo in i/o space
    /* Write frame length, including the two byte checksum */
    /* The top bit of the length field shall be set to 0 for IEEE 802.15.4 compliant frames */
    /* It should already be clear, so bypassing the masking is sanity check of the uip stack */
//  length &= 0x7f;
    _SFR_MEM8(tx_buffer++) = length;
    4ade:	a1 e8       	ldi	r26, 0x81	; 129
    4ae0:	b1 e0       	ldi	r27, 0x01	; 1
     * since they will be overwritten.
     */
#if !RF230_CONF_CHECKSUM
    length -= 2;
#endif
    do  _SFR_MEM8(tx_buffer++)= *write_buffer++; while (--length);
    4ae2:	21 91       	ld	r18, Z+
    4ae4:	2d 93       	st	X+, r18
    4ae6:	e8 17       	cp	r30, r24
    4ae8:	f9 07       	cpc	r31, r25
    4aea:	d9 f7       	brne	.-10     	; 0x4ae2 <hal_frame_write+0x12>
#endif
    do HAL_SPI_TRANSFER(*write_buffer++); while (--length);

    HAL_SPI_TRANSFER_CLOSE();
#endif /* defined(__AVR_ATmega128RFA1__) */
}
    4aec:	08 95       	ret

00004aee <__vector_60>:
/* The atmega128rfa1 has individual interrupts for the integrated radio'
 * Whichever are enabled by the RF230 driver must be present even if not used!
 */
/* Received packet interrupt */
ISR(TRX24_RX_END_vect)
{
    4aee:	1f 92       	push	r1
    4af0:	0f 92       	push	r0
    4af2:	0f b6       	in	r0, 0x3f	; 63
    4af4:	0f 92       	push	r0
    4af6:	0b b6       	in	r0, 0x3b	; 59
    4af8:	0f 92       	push	r0
    4afa:	11 24       	eor	r1, r1
    4afc:	2f 93       	push	r18
    4afe:	3f 93       	push	r19
    4b00:	4f 93       	push	r20
    4b02:	5f 93       	push	r21
    4b04:	6f 93       	push	r22
    4b06:	7f 93       	push	r23
    4b08:	8f 93       	push	r24
    4b0a:	9f 93       	push	r25
    4b0c:	af 93       	push	r26
    4b0e:	bf 93       	push	r27
    4b10:	ef 93       	push	r30
    4b12:	ff 93       	push	r31
/* Get the rssi from ED if extended mode */
#if RF230_CONF_AUTOACK
	rf230_last_rssi=hal_register_read(RG_PHY_ED_LEVEL);
    4b14:	80 91 47 01 	lds	r24, 0x0147
    4b18:	80 93 44 25 	sts	0x2544, r24
	if (rf230_last_rssi >= RF230_MIN_RX_POWER) {
#else
	if (1) {
#endif
//		DEBUGFLOW('2');
		hal_frame_read(&rxframe[rxframe_tail]);
    4b1c:	20 91 4d 25 	lds	r18, 0x254D
    4b20:	30 e0       	ldi	r19, 0x00	; 0
    4b22:	c9 01       	movw	r24, r18
    4b24:	88 0f       	add	r24, r24
    4b26:	99 1f       	adc	r25, r25
    4b28:	36 95       	lsr	r19
    4b2a:	32 2f       	mov	r19, r18
    4b2c:	22 27       	eor	r18, r18
    4b2e:	37 95       	ror	r19
    4b30:	27 95       	ror	r18
    4b32:	82 0f       	add	r24, r18
    4b34:	93 1f       	adc	r25, r19
    4b36:	81 5b       	subi	r24, 0xB1	; 177
    4b38:	9a 4d       	sbci	r25, 0xDA	; 218
    4b3a:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <hal_frame_read>
		rxframe_tail++;if (rxframe_tail >= RF230_CONF_RX_BUFFERS) rxframe_tail=0;
    4b3e:	80 91 4d 25 	lds	r24, 0x254D
    4b42:	8f 5f       	subi	r24, 0xFF	; 255
    4b44:	80 93 4d 25 	sts	0x254D, r24
    4b48:	83 30       	cpi	r24, 0x03	; 3
    4b4a:	10 f0       	brcs	.+4      	; 0x4b50 <__vector_60+0x62>
    4b4c:	10 92 4d 25 	sts	0x254D, r1
		rf230_interrupt();
    4b50:	0e 94 e3 21 	call	0x43c6	; 0x43c6 <rf230_interrupt>
	}
}
    4b54:	ff 91       	pop	r31
    4b56:	ef 91       	pop	r30
    4b58:	bf 91       	pop	r27
    4b5a:	af 91       	pop	r26
    4b5c:	9f 91       	pop	r25
    4b5e:	8f 91       	pop	r24
    4b60:	7f 91       	pop	r23
    4b62:	6f 91       	pop	r22
    4b64:	5f 91       	pop	r21
    4b66:	4f 91       	pop	r20
    4b68:	3f 91       	pop	r19
    4b6a:	2f 91       	pop	r18
    4b6c:	0f 90       	pop	r0
    4b6e:	0b be       	out	0x3b, r0	; 59
    4b70:	0f 90       	pop	r0
    4b72:	0f be       	out	0x3f, r0	; 63
    4b74:	0f 90       	pop	r0
    4b76:	1f 90       	pop	r1
    4b78:	18 95       	reti

00004b7a <__vector_59>:
/* Preamble detected, starting frame reception */
ISR(TRX24_RX_START_vect)
{
    4b7a:	1f 92       	push	r1
    4b7c:	0f 92       	push	r0
    4b7e:	0f b6       	in	r0, 0x3f	; 63
    4b80:	0f 92       	push	r0
    4b82:	11 24       	eor	r1, r1
/* Save RSSI for this packet if not in extended mode, scaling to 1dB resolution */
#if !RF230_CONF_AUTOACK
    rf230_last_rssi = 3 * hal_subregister_read(SR_RSSI);
#endif

}
    4b84:	0f 90       	pop	r0
    4b86:	0f be       	out	0x3f, r0	; 63
    4b88:	0f 90       	pop	r0
    4b8a:	1f 90       	pop	r1
    4b8c:	18 95       	reti

00004b8e <__vector_57>:

/* PLL has locked, either from a transition out of TRX_OFF or a channel change while on */
ISR(TRX24_PLL_LOCK_vect)
{
    4b8e:	1f 92       	push	r1
    4b90:	0f 92       	push	r0
    4b92:	0f b6       	in	r0, 0x3f	; 63
    4b94:	0f 92       	push	r0
    4b96:	11 24       	eor	r1, r1
//	DEBUGFLOW('4');
}
    4b98:	0f 90       	pop	r0
    4b9a:	0f be       	out	0x3f, r0	; 63
    4b9c:	0f 90       	pop	r0
    4b9e:	1f 90       	pop	r1
    4ba0:	18 95       	reti

00004ba2 <__vector_58>:

/* PLL has unexpectedly unlocked */
ISR(TRX24_PLL_UNLOCK_vect)
{
    4ba2:	1f 92       	push	r1
    4ba4:	0f 92       	push	r0
    4ba6:	0f b6       	in	r0, 0x3f	; 63
    4ba8:	0f 92       	push	r0
    4baa:	11 24       	eor	r1, r1
	DEBUGFLOW('5');
}
    4bac:	0f 90       	pop	r0
    4bae:	0f be       	out	0x3f, r0	; 63
    4bb0:	0f 90       	pop	r0
    4bb2:	1f 90       	pop	r1
    4bb4:	18 95       	reti

00004bb6 <__vector_64>:
/* Flag is set by the following interrupts */
extern volatile uint8_t rf230_wakewait, rf230_txendwait,rf230_ccawait;

/* Wake has finished */
ISR(TRX24_AWAKE_vect)
{
    4bb6:	1f 92       	push	r1
    4bb8:	0f 92       	push	r0
    4bba:	0f b6       	in	r0, 0x3f	; 63
    4bbc:	0f 92       	push	r0
    4bbe:	11 24       	eor	r1, r1
//	DEBUGFLOW('6');
  rf230_wakewait=0;
    4bc0:	10 92 d5 26 	sts	0x26D5, r1
}
    4bc4:	0f 90       	pop	r0
    4bc6:	0f be       	out	0x3f, r0	; 63
    4bc8:	0f 90       	pop	r0
    4bca:	1f 90       	pop	r1
    4bcc:	18 95       	reti

00004bce <__vector_63>:

/* Transmission has ended */
ISR(TRX24_TX_END_vect)
{
    4bce:	1f 92       	push	r1
    4bd0:	0f 92       	push	r0
    4bd2:	0f b6       	in	r0, 0x3f	; 63
    4bd4:	0f 92       	push	r0
    4bd6:	11 24       	eor	r1, r1
//	DEBUGFLOW('7');
  rf230_txendwait=0;
    4bd8:	10 92 4c 25 	sts	0x254C, r1
}
    4bdc:	0f 90       	pop	r0
    4bde:	0f be       	out	0x3f, r0	; 63
    4be0:	0f 90       	pop	r0
    4be2:	1f 90       	pop	r1
    4be4:	18 95       	reti

00004be6 <__vector_62>:

/* Frame address has matched ours */
ISR(TRX24_XAH_AMI_vect)
{
    4be6:	1f 92       	push	r1
    4be8:	0f 92       	push	r0
    4bea:	0f b6       	in	r0, 0x3f	; 63
    4bec:	0f 92       	push	r0
    4bee:	11 24       	eor	r1, r1
//	DEBUGFLOW('8');
}
    4bf0:	0f 90       	pop	r0
    4bf2:	0f be       	out	0x3f, r0	; 63
    4bf4:	0f 90       	pop	r0
    4bf6:	1f 90       	pop	r1
    4bf8:	18 95       	reti

00004bfa <__vector_61>:

/* CCAED measurement has completed */
ISR(TRX24_CCA_ED_DONE_vect)
{
    4bfa:	1f 92       	push	r1
    4bfc:	0f 92       	push	r0
    4bfe:	0f b6       	in	r0, 0x3f	; 63
    4c00:	0f 92       	push	r0
    4c02:	11 24       	eor	r1, r1
	DEBUGFLOW('4');
	rf230_ccawait=0;
    4c04:	10 92 49 25 	sts	0x2549, r1
}
    4c08:	0f 90       	pop	r0
    4c0a:	0f be       	out	0x3f, r0	; 63
    4c0c:	0f 90       	pop	r0
    4c0e:	1f 90       	pop	r1
    4c10:	18 95       	reti

00004c12 <rimeaddr_copy>:


/*---------------------------------------------------------------------------*/
void
rimeaddr_copy(rimeaddr_t *dest, const rimeaddr_t *src)
{
    4c12:	fc 01       	movw	r30, r24
    4c14:	db 01       	movw	r26, r22
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    dest->u8[i] = src->u8[i];
    4c16:	8c 91       	ld	r24, X
    4c18:	80 83       	st	Z, r24
    4c1a:	11 96       	adiw	r26, 0x01	; 1
    4c1c:	8c 91       	ld	r24, X
    4c1e:	11 97       	sbiw	r26, 0x01	; 1
    4c20:	81 83       	std	Z+1, r24	; 0x01
  }
}
    4c22:	08 95       	ret

00004c24 <rimeaddr_cmp>:
/*---------------------------------------------------------------------------*/
int
rimeaddr_cmp(const rimeaddr_t *addr1, const rimeaddr_t *addr2)
{
    4c24:	fc 01       	movw	r30, r24
    4c26:	db 01       	movw	r26, r22
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    if(addr1->u8[i] != addr2->u8[i]) {
    4c28:	90 81       	ld	r25, Z
    4c2a:	8c 91       	ld	r24, X
    4c2c:	98 17       	cp	r25, r24
    4c2e:	41 f4       	brne	.+16     	; 0x4c40 <rimeaddr_cmp+0x1c>
      return 0;
    4c30:	21 e0       	ldi	r18, 0x01	; 1
    4c32:	30 e0       	ldi	r19, 0x00	; 0
    4c34:	91 81       	ldd	r25, Z+1	; 0x01
    4c36:	11 96       	adiw	r26, 0x01	; 1
    4c38:	8c 91       	ld	r24, X
    4c3a:	11 97       	sbiw	r26, 0x01	; 1
    4c3c:	98 17       	cp	r25, r24
    4c3e:	11 f0       	breq	.+4      	; 0x4c44 <rimeaddr_cmp+0x20>
    4c40:	20 e0       	ldi	r18, 0x00	; 0
    4c42:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 1;
}
    4c44:	c9 01       	movw	r24, r18
    4c46:	08 95       	ret

00004c48 <rimeaddr_set_node_addr>:
/*---------------------------------------------------------------------------*/
void
rimeaddr_set_node_addr(rimeaddr_t *t)
{
    4c48:	fc 01       	movw	r30, r24
void
rimeaddr_copy(rimeaddr_t *dest, const rimeaddr_t *src)
{
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    dest->u8[i] = src->u8[i];
    4c4a:	80 81       	ld	r24, Z
    4c4c:	80 93 db 26 	sts	0x26DB, r24
    4c50:	81 81       	ldd	r24, Z+1	; 0x01
    4c52:	80 93 dc 26 	sts	0x26DC, r24
/*---------------------------------------------------------------------------*/
void
rimeaddr_set_node_addr(rimeaddr_t *t)
{
  rimeaddr_copy(&rimeaddr_node_addr, t);
}
    4c56:	08 95       	ret

00004c58 <input>:
  list_remove(sniffers, s);
}
/*---------------------------------------------------------------------------*/
static void
input(void)
{
    4c58:	0f 93       	push	r16
    4c5a:	1f 93       	push	r17
    4c5c:	cf 93       	push	r28
    4c5e:	df 93       	push	r29
  struct rime_sniffer *s;
  struct channel *c;

  RIMESTATS_ADD(rx);
    4c60:	80 91 e1 26 	lds	r24, 0x26E1
    4c64:	90 91 e2 26 	lds	r25, 0x26E2
    4c68:	a0 91 e3 26 	lds	r26, 0x26E3
    4c6c:	b0 91 e4 26 	lds	r27, 0x26E4
    4c70:	01 96       	adiw	r24, 0x01	; 1
    4c72:	a1 1d       	adc	r26, r1
    4c74:	b1 1d       	adc	r27, r1
    4c76:	80 93 e1 26 	sts	0x26E1, r24
    4c7a:	90 93 e2 26 	sts	0x26E2, r25
    4c7e:	a0 93 e3 26 	sts	0x26E3, r26
    4c82:	b0 93 e4 26 	sts	0x26E4, r27
  c = chameleon_parse();
    4c86:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <chameleon_parse>
    4c8a:	ec 01       	movw	r28, r24
  
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4c8c:	81 ea       	ldi	r24, 0xA1	; 161
    4c8e:	9d e1       	ldi	r25, 0x1D	; 29
    4c90:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    4c94:	0b c0       	rjmp	.+22     	; 0x4cac <input+0x54>
    if(s->input_callback != NULL) {
    4c96:	d8 01       	movw	r26, r16
    4c98:	12 96       	adiw	r26, 0x02	; 2
    4c9a:	ed 91       	ld	r30, X+
    4c9c:	fc 91       	ld	r31, X
    4c9e:	13 97       	sbiw	r26, 0x03	; 3
    4ca0:	30 97       	sbiw	r30, 0x00	; 0
    4ca2:	09 f0       	breq	.+2      	; 0x4ca6 <input+0x4e>
      s->input_callback();
    4ca4:	09 95       	icall
  struct channel *c;

  RIMESTATS_ADD(rx);
  c = chameleon_parse();
  
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4ca6:	c8 01       	movw	r24, r16
    4ca8:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <list_item_next>
    4cac:	08 2f       	mov	r16, r24
    4cae:	19 2f       	mov	r17, r25
    4cb0:	01 15       	cp	r16, r1
    4cb2:	11 05       	cpc	r17, r1
    4cb4:	81 f7       	brne	.-32     	; 0x4c96 <input+0x3e>
    if(s->input_callback != NULL) {
      s->input_callback();
    }
  }
  
  if(c != NULL) {
    4cb6:	20 97       	sbiw	r28, 0x00	; 0
    4cb8:	19 f0       	breq	.+6      	; 0x4cc0 <input+0x68>
    abc_input(c);
    4cba:	ce 01       	movw	r24, r28
    4cbc:	0e 94 3f 29 	call	0x527e	; 0x527e <abc_input>
  }
}
    4cc0:	df 91       	pop	r29
    4cc2:	cf 91       	pop	r28
    4cc4:	1f 91       	pop	r17
    4cc6:	0f 91       	pop	r16
    4cc8:	08 95       	ret

00004cca <init>:
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  queuebuf_init();
    4cca:	0e 94 57 33 	call	0x66ae	; 0x66ae <queuebuf_init>
  packetbuf_clear();
    4cce:	0e 94 ab 32 	call	0x6556	; 0x6556 <packetbuf_clear>
  announcement_init();
    4cd2:	0e 94 e1 26 	call	0x4dc2	; 0x4dc2 <announcement_init>

  chameleon_init();
    4cd6:	0e 94 57 29 	call	0x52ae	; 0x52ae <chameleon_init>
   * either be configurable, or derived from some MAC layer property
   * (duty cycle, sleep time, or something similar). But this is OK
   * for now, and should at least get us started with experimenting
   * with announcements.
   */
  broadcast_announcement_init(BROADCAST_ANNOUNCEMENT_CHANNEL,
    4cda:	82 e0       	ldi	r24, 0x02	; 2
    4cdc:	90 e0       	ldi	r25, 0x00	; 0
    4cde:	60 e0       	ldi	r22, 0x00	; 0
    4ce0:	72 e0       	ldi	r23, 0x02	; 2
    4ce2:	40 e0       	ldi	r20, 0x00	; 0
    4ce4:	5e e1       	ldi	r21, 0x1E	; 30
    4ce6:	2f ef       	ldi	r18, 0xFF	; 255
    4ce8:	31 e0       	ldi	r19, 0x01	; 1
    4cea:	0e 94 7e 28 	call	0x50fc	; 0x50fc <broadcast_announcement_init>
                              BROADCAST_ANNOUNCEMENT_BUMP_TIME,
                              BROADCAST_ANNOUNCEMENT_MIN_TIME,
                              BROADCAST_ANNOUNCEMENT_MAX_TIME);
}
    4cee:	08 95       	ret

00004cf0 <packet_sent>:
/*---------------------------------------------------------------------------*/
static void
packet_sent(void *ptr, int status, int num_tx)
{
    4cf0:	cf 92       	push	r12
    4cf2:	df 92       	push	r13
    4cf4:	ef 92       	push	r14
    4cf6:	ff 92       	push	r15
    4cf8:	0f 93       	push	r16
    4cfa:	1f 93       	push	r17
    4cfc:	cf 93       	push	r28
    4cfe:	df 93       	push	r29
    4d00:	6c 01       	movw	r12, r24
    4d02:	eb 01       	movw	r28, r22
    4d04:	8a 01       	movw	r16, r20
  default:
    PRINTF("rime: error %d after %d tx\n", status, num_tx);
  }

  /* Call sniffers, pass along the MAC status code. */
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4d06:	81 ea       	ldi	r24, 0xA1	; 161
    4d08:	9d e1       	ldi	r25, 0x1D	; 29
    4d0a:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    4d0e:	0c c0       	rjmp	.+24     	; 0x4d28 <packet_sent+0x38>
    if(s->output_callback != NULL) {
    4d10:	d7 01       	movw	r26, r14
    4d12:	14 96       	adiw	r26, 0x04	; 4
    4d14:	ed 91       	ld	r30, X+
    4d16:	fc 91       	ld	r31, X
    4d18:	15 97       	sbiw	r26, 0x05	; 5
    4d1a:	30 97       	sbiw	r30, 0x00	; 0
    4d1c:	11 f0       	breq	.+4      	; 0x4d22 <packet_sent+0x32>
      s->output_callback(status);
    4d1e:	ce 01       	movw	r24, r28
    4d20:	09 95       	icall
  default:
    PRINTF("rime: error %d after %d tx\n", status, num_tx);
  }

  /* Call sniffers, pass along the MAC status code. */
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4d22:	c7 01       	movw	r24, r14
    4d24:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <list_item_next>
    4d28:	e8 2e       	mov	r14, r24
    4d2a:	f9 2e       	mov	r15, r25
    4d2c:	e1 14       	cp	r14, r1
    4d2e:	f1 04       	cpc	r15, r1
    4d30:	79 f7       	brne	.-34     	; 0x4d10 <packet_sent+0x20>
    if(s->output_callback != NULL) {
      s->output_callback(status);
    }
  }

  abc_sent(c, status, num_tx);
    4d32:	c6 01       	movw	r24, r12
    4d34:	be 01       	movw	r22, r28
    4d36:	a8 01       	movw	r20, r16
    4d38:	0e 94 4b 29 	call	0x5296	; 0x5296 <abc_sent>
}
    4d3c:	df 91       	pop	r29
    4d3e:	cf 91       	pop	r28
    4d40:	1f 91       	pop	r17
    4d42:	0f 91       	pop	r16
    4d44:	ff 90       	pop	r15
    4d46:	ef 90       	pop	r14
    4d48:	df 90       	pop	r13
    4d4a:	cf 90       	pop	r12
    4d4c:	08 95       	ret

00004d4e <rime_sniffer_add>:
LIST(sniffers);

/*---------------------------------------------------------------------------*/
void
rime_sniffer_add(struct rime_sniffer *s)
{
    4d4e:	bc 01       	movw	r22, r24
  list_add(sniffers, s);
    4d50:	81 ea       	ldi	r24, 0xA1	; 161
    4d52:	9d e1       	ldi	r25, 0x1D	; 29
    4d54:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <list_add>
}
    4d58:	08 95       	ret

00004d5a <rime_sniffer_remove>:
/*---------------------------------------------------------------------------*/
void
rime_sniffer_remove(struct rime_sniffer *s)
{
    4d5a:	bc 01       	movw	r22, r24
  list_remove(sniffers, s);
    4d5c:	81 ea       	ldi	r24, 0xA1	; 161
    4d5e:	9d e1       	ldi	r25, 0x1D	; 29
    4d60:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
}
    4d64:	08 95       	ret

00004d66 <rime_output>:
  abc_sent(c, status, num_tx);
}
/*---------------------------------------------------------------------------*/
int
rime_output(struct channel *c)
{
    4d66:	cf 93       	push	r28
    4d68:	df 93       	push	r29
    4d6a:	ec 01       	movw	r28, r24
  RIMESTATS_ADD(tx);
    4d6c:	80 91 dd 26 	lds	r24, 0x26DD
    4d70:	90 91 de 26 	lds	r25, 0x26DE
    4d74:	a0 91 df 26 	lds	r26, 0x26DF
    4d78:	b0 91 e0 26 	lds	r27, 0x26E0
    4d7c:	01 96       	adiw	r24, 0x01	; 1
    4d7e:	a1 1d       	adc	r26, r1
    4d80:	b1 1d       	adc	r27, r1
    4d82:	80 93 dd 26 	sts	0x26DD, r24
    4d86:	90 93 de 26 	sts	0x26DE, r25
    4d8a:	a0 93 df 26 	sts	0x26DF, r26
    4d8e:	b0 93 e0 26 	sts	0x26E0, r27
  if(chameleon_create(c)) {
    4d92:	ce 01       	movw	r24, r28
    4d94:	0e 94 71 29 	call	0x52e2	; 0x52e2 <chameleon_create>
    4d98:	00 97       	sbiw	r24, 0x00	; 0
    4d9a:	69 f0       	breq	.+26     	; 0x4db6 <rime_output+0x50>
    packetbuf_compact();
    4d9c:	0e 94 25 32 	call	0x644a	; 0x644a <packetbuf_compact>

    NETSTACK_MAC.send(packet_sent, c);
    4da0:	e0 91 6f 0e 	lds	r30, 0x0E6F
    4da4:	f0 91 70 0e 	lds	r31, 0x0E70
    4da8:	88 e7       	ldi	r24, 0x78	; 120
    4daa:	96 e2       	ldi	r25, 0x26	; 38
    4dac:	be 01       	movw	r22, r28
    4dae:	09 95       	icall
    return 1;
    4db0:	21 e0       	ldi	r18, 0x01	; 1
    4db2:	30 e0       	ldi	r19, 0x00	; 0
    4db4:	02 c0       	rjmp	.+4      	; 0x4dba <rime_output+0x54>
  }
  return 0;
    4db6:	20 e0       	ldi	r18, 0x00	; 0
    4db8:	30 e0       	ldi	r19, 0x00	; 0
}
    4dba:	c9 01       	movw	r24, r18
    4dbc:	df 91       	pop	r29
    4dbe:	cf 91       	pop	r28
    4dc0:	08 95       	ret

00004dc2 <announcement_init>:

/*---------------------------------------------------------------------------*/
void
announcement_init(void)
{
  list_init(announcements);
    4dc2:	83 ea       	ldi	r24, 0xA3	; 163
    4dc4:	9d e1       	ldi	r25, 0x1D	; 29
    4dc6:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <list_init>
}
    4dca:	08 95       	ret

00004dcc <announcement_register>:
/*---------------------------------------------------------------------------*/
void
announcement_register(struct announcement *a, uint16_t id,
		      announcement_callback_t callback)
{
    4dcc:	0f 93       	push	r16
    4dce:	cf 93       	push	r28
    4dd0:	df 93       	push	r29
    4dd2:	ec 01       	movw	r28, r24
  a->id = id;
    4dd4:	7b 83       	std	Y+3, r23	; 0x03
    4dd6:	6a 83       	std	Y+2, r22	; 0x02
  a->has_value = 0;
    4dd8:	18 86       	std	Y+8, r1	; 0x08
  a->callback = callback;
    4dda:	5f 83       	std	Y+7, r21	; 0x07
    4ddc:	4e 83       	std	Y+6, r20	; 0x06
  list_add(announcements, a);
    4dde:	83 ea       	ldi	r24, 0xA3	; 163
    4de0:	9d e1       	ldi	r25, 0x1D	; 29
    4de2:	be 01       	movw	r22, r28
    4de4:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <list_add>
  if(observer_callback) {
    4de8:	e0 91 a5 1d 	lds	r30, 0x1DA5
    4dec:	f0 91 a6 1d 	lds	r31, 0x1DA6
    4df0:	30 97       	sbiw	r30, 0x00	; 0
    4df2:	49 f0       	breq	.+18     	; 0x4e06 <announcement_register+0x3a>
    observer_callback(a->id, a->has_value,
    4df4:	4c 81       	ldd	r20, Y+4	; 0x04
    4df6:	5d 81       	ldd	r21, Y+5	; 0x05
    4df8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    4dfc:	68 85       	ldd	r22, Y+8	; 0x08
    4dfe:	20 e0       	ldi	r18, 0x00	; 0
    4e00:	30 e0       	ldi	r19, 0x00	; 0
    4e02:	01 e0       	ldi	r16, 0x01	; 1
    4e04:	09 95       	icall
                      a->value, 0, ANNOUNCEMENT_BUMP);
  }
}
    4e06:	df 91       	pop	r29
    4e08:	cf 91       	pop	r28
    4e0a:	0f 91       	pop	r16
    4e0c:	08 95       	ret

00004e0e <announcement_remove>:
/*---------------------------------------------------------------------------*/
void
announcement_remove(struct announcement *a)
{
    4e0e:	bc 01       	movw	r22, r24
  list_remove(announcements, a);
    4e10:	83 ea       	ldi	r24, 0xA3	; 163
    4e12:	9d e1       	ldi	r25, 0x1D	; 29
    4e14:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
}
    4e18:	08 95       	ret

00004e1a <announcement_remove_value>:
/*---------------------------------------------------------------------------*/
void
announcement_remove_value(struct announcement *a)
{
    4e1a:	0f 93       	push	r16
    4e1c:	dc 01       	movw	r26, r24
  a->has_value = 0;
    4e1e:	18 96       	adiw	r26, 0x08	; 8
    4e20:	1c 92       	st	X, r1
    4e22:	18 97       	sbiw	r26, 0x08	; 8
  if(observer_callback) {
    4e24:	e0 91 a5 1d 	lds	r30, 0x1DA5
    4e28:	f0 91 a6 1d 	lds	r31, 0x1DA6
    4e2c:	30 97       	sbiw	r30, 0x00	; 0
    4e2e:	59 f0       	breq	.+22     	; 0x4e46 <announcement_remove_value+0x2c>
    observer_callback(a->id, 0, 0, 0, ANNOUNCEMENT_NOBUMP);
    4e30:	12 96       	adiw	r26, 0x02	; 2
    4e32:	8d 91       	ld	r24, X+
    4e34:	9c 91       	ld	r25, X
    4e36:	13 97       	sbiw	r26, 0x03	; 3
    4e38:	60 e0       	ldi	r22, 0x00	; 0
    4e3a:	40 e0       	ldi	r20, 0x00	; 0
    4e3c:	50 e0       	ldi	r21, 0x00	; 0
    4e3e:	20 e0       	ldi	r18, 0x00	; 0
    4e40:	30 e0       	ldi	r19, 0x00	; 0
    4e42:	00 e0       	ldi	r16, 0x00	; 0
    4e44:	09 95       	icall
  }

}
    4e46:	0f 91       	pop	r16
    4e48:	08 95       	ret

00004e4a <announcement_set_value>:
/*---------------------------------------------------------------------------*/
void
announcement_set_value(struct announcement *a, uint16_t value)
{
    4e4a:	0f 93       	push	r16
    4e4c:	dc 01       	movw	r26, r24
    4e4e:	ab 01       	movw	r20, r22
  uint16_t oldvalue = a->value;
    4e50:	14 96       	adiw	r26, 0x04	; 4
    4e52:	2d 91       	ld	r18, X+
    4e54:	3c 91       	ld	r19, X
    4e56:	15 97       	sbiw	r26, 0x05	; 5

  a->has_value = 1;
    4e58:	81 e0       	ldi	r24, 0x01	; 1
    4e5a:	18 96       	adiw	r26, 0x08	; 8
    4e5c:	8c 93       	st	X, r24
    4e5e:	18 97       	sbiw	r26, 0x08	; 8
  a->value = value;
    4e60:	15 96       	adiw	r26, 0x05	; 5
    4e62:	7c 93       	st	X, r23
    4e64:	6e 93       	st	-X, r22
    4e66:	14 97       	sbiw	r26, 0x04	; 4
  if(observer_callback) {
    4e68:	e0 91 a5 1d 	lds	r30, 0x1DA5
    4e6c:	f0 91 a6 1d 	lds	r31, 0x1DA6
    4e70:	30 97       	sbiw	r30, 0x00	; 0
    4e72:	39 f0       	breq	.+14     	; 0x4e82 <announcement_set_value+0x38>
    observer_callback(a->id, a->has_value,
    4e74:	12 96       	adiw	r26, 0x02	; 2
    4e76:	8d 91       	ld	r24, X+
    4e78:	9c 91       	ld	r25, X
    4e7a:	13 97       	sbiw	r26, 0x03	; 3
    4e7c:	61 e0       	ldi	r22, 0x01	; 1
    4e7e:	00 e0       	ldi	r16, 0x00	; 0
    4e80:	09 95       	icall
                      value, oldvalue, ANNOUNCEMENT_NOBUMP);
  }
}
    4e82:	0f 91       	pop	r16
    4e84:	08 95       	ret

00004e86 <announcement_bump>:
/*---------------------------------------------------------------------------*/
void
announcement_bump(struct announcement *a)
{
    4e86:	0f 93       	push	r16
    4e88:	dc 01       	movw	r26, r24
  if(observer_callback) {
    4e8a:	e0 91 a5 1d 	lds	r30, 0x1DA5
    4e8e:	f0 91 a6 1d 	lds	r31, 0x1DA6
    4e92:	30 97       	sbiw	r30, 0x00	; 0
    4e94:	69 f0       	breq	.+26     	; 0x4eb0 <announcement_bump+0x2a>
    observer_callback(a->id, a->has_value,
    4e96:	14 96       	adiw	r26, 0x04	; 4
    4e98:	2d 91       	ld	r18, X+
    4e9a:	3c 91       	ld	r19, X
    4e9c:	15 97       	sbiw	r26, 0x05	; 5
    4e9e:	12 96       	adiw	r26, 0x02	; 2
    4ea0:	8d 91       	ld	r24, X+
    4ea2:	9c 91       	ld	r25, X
    4ea4:	13 97       	sbiw	r26, 0x03	; 3
    4ea6:	18 96       	adiw	r26, 0x08	; 8
    4ea8:	6c 91       	ld	r22, X
    4eaa:	a9 01       	movw	r20, r18
    4eac:	01 e0       	ldi	r16, 0x01	; 1
    4eae:	09 95       	icall
                      a->value, a->value, ANNOUNCEMENT_BUMP);
  }
}
    4eb0:	0f 91       	pop	r16
    4eb2:	08 95       	ret

00004eb4 <announcement_listen>:
/*---------------------------------------------------------------------------*/
void
announcement_listen(int time)
{
  if(listen_callback) {
    4eb4:	e0 91 a7 1d 	lds	r30, 0x1DA7
    4eb8:	f0 91 a8 1d 	lds	r31, 0x1DA8
    4ebc:	30 97       	sbiw	r30, 0x00	; 0
    4ebe:	09 f0       	breq	.+2      	; 0x4ec2 <announcement_listen+0xe>
    listen_callback(time);
    4ec0:	09 95       	icall
    4ec2:	08 95       	ret

00004ec4 <announcement_register_listen_callback>:
}
/*---------------------------------------------------------------------------*/
void
announcement_register_listen_callback(void (*callback)(int time))
{
  listen_callback = callback;
    4ec4:	90 93 a8 1d 	sts	0x1DA8, r25
    4ec8:	80 93 a7 1d 	sts	0x1DA7, r24
}
    4ecc:	08 95       	ret

00004ece <announcement_register_observer_callback>:
/*---------------------------------------------------------------------------*/
void
announcement_register_observer_callback(announcement_observer callback)
{
  observer_callback = callback;
    4ece:	90 93 a6 1d 	sts	0x1DA6, r25
    4ed2:	80 93 a5 1d 	sts	0x1DA5, r24
}
    4ed6:	08 95       	ret

00004ed8 <announcement_list>:
/*---------------------------------------------------------------------------*/
struct announcement *
announcement_list(void)
{
  return list_head(announcements);
    4ed8:	83 ea       	ldi	r24, 0xA3	; 163
    4eda:	9d e1       	ldi	r25, 0x1D	; 29
    4edc:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
}
    4ee0:	08 95       	ret

00004ee2 <announcement_heard>:
/*---------------------------------------------------------------------------*/
void
announcement_heard(const rimeaddr_t *from, uint16_t id, uint16_t value)
{
    4ee2:	ef 92       	push	r14
    4ee4:	ff 92       	push	r15
    4ee6:	0f 93       	push	r16
    4ee8:	1f 93       	push	r17
    4eea:	cf 93       	push	r28
    4eec:	df 93       	push	r29
    4eee:	8c 01       	movw	r16, r24
    4ef0:	eb 01       	movw	r28, r22
    4ef2:	7a 01       	movw	r14, r20
  struct announcement *a;
  for(a = list_head(announcements); a != NULL; a = list_item_next(a)) {
    4ef4:	83 ea       	ldi	r24, 0xA3	; 163
    4ef6:	9d e1       	ldi	r25, 0x1D	; 29
    4ef8:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    4efc:	15 c0       	rjmp	.+42     	; 0x4f28 <announcement_heard+0x46>
    if(a->id == id) {
    4efe:	dc 01       	movw	r26, r24
    4f00:	12 96       	adiw	r26, 0x02	; 2
    4f02:	2d 91       	ld	r18, X+
    4f04:	3c 91       	ld	r19, X
    4f06:	13 97       	sbiw	r26, 0x03	; 3
    4f08:	2c 17       	cp	r18, r28
    4f0a:	3d 07       	cpc	r19, r29
    4f0c:	59 f4       	brne	.+22     	; 0x4f24 <announcement_heard+0x42>
      if(a->callback != NULL) {
    4f0e:	16 96       	adiw	r26, 0x06	; 6
    4f10:	ed 91       	ld	r30, X+
    4f12:	fc 91       	ld	r31, X
    4f14:	17 97       	sbiw	r26, 0x07	; 7
    4f16:	30 97       	sbiw	r30, 0x00	; 0
    4f18:	61 f0       	breq	.+24     	; 0x4f32 <announcement_heard+0x50>
	a->callback(a, from, id, value);
    4f1a:	b8 01       	movw	r22, r16
    4f1c:	ae 01       	movw	r20, r28
    4f1e:	97 01       	movw	r18, r14
    4f20:	09 95       	icall
    4f22:	07 c0       	rjmp	.+14     	; 0x4f32 <announcement_heard+0x50>
/*---------------------------------------------------------------------------*/
void
announcement_heard(const rimeaddr_t *from, uint16_t id, uint16_t value)
{
  struct announcement *a;
  for(a = list_head(announcements); a != NULL; a = list_item_next(a)) {
    4f24:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <list_item_next>
    4f28:	28 2f       	mov	r18, r24
    4f2a:	39 2f       	mov	r19, r25
    4f2c:	c9 01       	movw	r24, r18
    4f2e:	00 97       	sbiw	r24, 0x00	; 0
    4f30:	31 f7       	brne	.-52     	; 0x4efe <announcement_heard+0x1c>
	a->callback(a, from, id, value);
      }
      return;
    }
  }
}
    4f32:	df 91       	pop	r29
    4f34:	cf 91       	pop	r28
    4f36:	1f 91       	pop	r17
    4f38:	0f 91       	pop	r16
    4f3a:	ff 90       	pop	r15
    4f3c:	ef 90       	pop	r14
    4f3e:	08 95       	ret

00004f40 <adv_packet_sent>:
}
/*---------------------------------------------------------------------------*/
static void
adv_packet_sent(struct broadcast_conn *bc, int status, int num_tx)
{
}
    4f40:	08 95       	ret

00004f42 <adv_packet_received>:
	 c.val);
}
/*---------------------------------------------------------------------------*/
static void
adv_packet_received(struct broadcast_conn *ibc, const rimeaddr_t *from)
{
    4f42:	af 92       	push	r10
    4f44:	bf 92       	push	r11
    4f46:	cf 92       	push	r12
    4f48:	df 92       	push	r13
    4f4a:	ef 92       	push	r14
    4f4c:	ff 92       	push	r15
    4f4e:	0f 93       	push	r16
    4f50:	1f 93       	push	r17
    4f52:	df 93       	push	r29
    4f54:	cf 93       	push	r28
    4f56:	00 d0       	rcall	.+0      	; 0x4f58 <adv_packet_received+0x16>
    4f58:	cd b7       	in	r28, 0x3d	; 61
    4f5a:	de b7       	in	r29, 0x3e	; 62
    4f5c:	5b 01       	movw	r10, r22
  struct announcement_msg adata;
  struct announcement_data data;
  uint8_t *ptr;
  int i;

  ptr = packetbuf_dataptr();
    4f5e:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    4f62:	8c 01       	movw	r16, r24

  /* Copy number of announcements */
  memcpy(&adata, ptr, sizeof(struct announcement_msg));
    4f64:	fc 01       	movw	r30, r24
    4f66:	e0 80       	ld	r14, Z
    4f68:	f1 80       	ldd	r15, Z+1	; 0x01
    4f6a:	fa 82       	std	Y+2, r15	; 0x02
    4f6c:	e9 82       	std	Y+1, r14	; 0x01
  PRINTF("%d.%d: adv_packet_received from %d.%d with %d announcements\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	 from->u8[0], from->u8[1], adata.num);

  if(ANNOUNCEMENT_MSG_HEADERLEN + adata.num * sizeof(struct announcement_data) > packetbuf_datalen()) {
    4f6e:	0e 94 5a 32 	call	0x64b4	; 0x64b4 <packetbuf_datalen>
    4f72:	97 01       	movw	r18, r14
    4f74:	22 0f       	add	r18, r18
    4f76:	33 1f       	adc	r19, r19
    4f78:	22 0f       	add	r18, r18
    4f7a:	33 1f       	adc	r19, r19
    4f7c:	2e 5f       	subi	r18, 0xFE	; 254
    4f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f80:	82 17       	cp	r24, r18
    4f82:	93 07       	cpc	r25, r19
    4f84:	98 f0       	brcs	.+38     	; 0x4fac <adv_packet_received+0x6a>
    PRINTF("adata.num way out there: %d\n", adata.num);
    return;
  }

  ptr += ANNOUNCEMENT_MSG_HEADERLEN;
  for(i = 0; i < adata.num; ++i) {
    4f86:	cc 24       	eor	r12, r12
    4f88:	dd 24       	eor	r13, r13
    4f8a:	0d c0       	rjmp	.+26     	; 0x4fa6 <adv_packet_received+0x64>
    /* Copy announcements */
    memcpy(&data, ptr, sizeof(struct announcement_data));
    announcement_heard(from, data.id, data.value);
    4f8c:	f8 01       	movw	r30, r16
    4f8e:	62 81       	ldd	r22, Z+2	; 0x02
    4f90:	73 81       	ldd	r23, Z+3	; 0x03
    4f92:	44 81       	ldd	r20, Z+4	; 0x04
    4f94:	55 81       	ldd	r21, Z+5	; 0x05
    4f96:	c5 01       	movw	r24, r10
    4f98:	0e 94 71 27 	call	0x4ee2	; 0x4ee2 <announcement_heard>
    PRINTF("adata.num way out there: %d\n", adata.num);
    return;
  }

  ptr += ANNOUNCEMENT_MSG_HEADERLEN;
  for(i = 0; i < adata.num; ++i) {
    4f9c:	08 94       	sec
    4f9e:	c1 1c       	adc	r12, r1
    4fa0:	d1 1c       	adc	r13, r1
    4fa2:	0c 5f       	subi	r16, 0xFC	; 252
    4fa4:	1f 4f       	sbci	r17, 0xFF	; 255
    4fa6:	ce 14       	cp	r12, r14
    4fa8:	df 04       	cpc	r13, r15
    4faa:	80 f3       	brcs	.-32     	; 0x4f8c <adv_packet_received+0x4a>
    /* Copy announcements */
    memcpy(&data, ptr, sizeof(struct announcement_data));
    announcement_heard(from, data.id, data.value);
    ptr += sizeof(struct announcement_data);
  }
}
    4fac:	0f 90       	pop	r0
    4fae:	0f 90       	pop	r0
    4fb0:	cf 91       	pop	r28
    4fb2:	df 91       	pop	r29
    4fb4:	1f 91       	pop	r17
    4fb6:	0f 91       	pop	r16
    4fb8:	ff 90       	pop	r15
    4fba:	ef 90       	pop	r14
    4fbc:	df 90       	pop	r13
    4fbe:	cf 90       	pop	r12
    4fc0:	bf 90       	pop	r11
    4fc2:	af 90       	pop	r10
    4fc4:	08 95       	ret

00004fc6 <set_timers>:
/*---------------------------------------------------------------------------*/
static void send_timer(void *ptr);

static void
set_timers(void)
{
    4fc6:	cf 93       	push	r28
    4fc8:	df 93       	push	r29
  ctimer_set(&c.interval_timer, c.current_interval, send_timer, NULL);
    4fca:	c4 ec       	ldi	r28, 0xC4	; 196
    4fcc:	dd e1       	ldi	r29, 0x1D	; 29
    4fce:	60 91 da 1d 	lds	r22, 0x1DDA
    4fd2:	70 91 db 1d 	lds	r23, 0x1DDB
    4fd6:	ce 01       	movw	r24, r28
    4fd8:	45 e1       	ldi	r20, 0x15	; 21
    4fda:	58 e2       	ldi	r21, 0x28	; 40
    4fdc:	20 e0       	ldi	r18, 0x00	; 0
    4fde:	30 e0       	ldi	r19, 0x00	; 0
    4fe0:	0e 94 dd 18 	call	0x31ba	; 0x31ba <ctimer_set>
  ctimer_set(&c.send_timer, random_rand() % c.current_interval,
    4fe4:	0e 94 7c 31 	call	0x62f8	; 0x62f8 <random_rand>
    4fe8:	60 91 da 1d 	lds	r22, 0x1DDA
    4fec:	70 91 db 1d 	lds	r23, 0x1DDB
    4ff0:	0e 94 62 4b 	call	0x96c4	; 0x96c4 <__udivmodhi4>
    4ff4:	bc 01       	movw	r22, r24
    4ff6:	ce 01       	movw	r24, r28
    4ff8:	40 97       	sbiw	r24, 0x10	; 16
    4ffa:	4a e2       	ldi	r20, 0x2A	; 42
    4ffc:	58 e2       	ldi	r21, 0x28	; 40
    4ffe:	20 e0       	ldi	r18, 0x00	; 0
    5000:	30 e0       	ldi	r19, 0x00	; 0
    5002:	0e 94 dd 18 	call	0x31ba	; 0x31ba <ctimer_set>
             send_adv, NULL);
}
    5006:	df 91       	pop	r29
    5008:	cf 91       	pop	r28
    500a:	08 95       	ret

0000500c <new_announcement>:
}
/*---------------------------------------------------------------------------*/
static void
new_announcement(uint16_t id, uint8_t has_value,
                 uint16_t newval, uint16_t oldval, uint8_t bump)
{
    500c:	0f 93       	push	r16
  if(bump == ANNOUNCEMENT_BUMP) {
    500e:	01 30       	cpi	r16, 0x01	; 1
    5010:	51 f4       	brne	.+20     	; 0x5026 <new_announcement+0x1a>
    c.current_interval = c.initial_interval;
    5012:	80 91 d4 1d 	lds	r24, 0x1DD4
    5016:	90 91 d5 1d 	lds	r25, 0x1DD5
    501a:	90 93 db 1d 	sts	0x1DDB, r25
    501e:	80 93 da 1d 	sts	0x1DDA, r24
    set_timers();
    5022:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <set_timers>
    /*  } else if(newval != oldval) {
    c.current_interval = c.min_interval;
    set_timers();*/
  }
}
    5026:	0f 91       	pop	r16
    5028:	08 95       	ret

0000502a <send_timer>:
static void
send_timer(void *ptr)
{
  clock_time_t interval;

  interval = c.current_interval * 2;
    502a:	80 91 da 1d 	lds	r24, 0x1DDA
    502e:	90 91 db 1d 	lds	r25, 0x1DDB

  if(interval > c.max_interval) {
    interval = c.max_interval;
  }

  c.current_interval = interval;
    5032:	20 91 d8 1d 	lds	r18, 0x1DD8
    5036:	30 91 d9 1d 	lds	r19, 0x1DD9
    503a:	88 0f       	add	r24, r24
    503c:	99 1f       	adc	r25, r25
    503e:	28 17       	cp	r18, r24
    5040:	39 07       	cpc	r19, r25
    5042:	08 f4       	brcc	.+2      	; 0x5046 <send_timer+0x1c>
    5044:	c9 01       	movw	r24, r18
    5046:	90 93 db 1d 	sts	0x1DDB, r25
    504a:	80 93 da 1d 	sts	0x1DDA, r24

  /*  printf("current_interval %lu\n", (long unsigned int) interval);*/

  set_timers();
    504e:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <set_timers>
}
    5052:	08 95       	ret

00005054 <send_adv>:
#define MIN(a, b) ((a)<(b)?(a):(b))

/*---------------------------------------------------------------------------*/
static void
send_adv(void *ptr)
{
    5054:	ef 92       	push	r14
    5056:	ff 92       	push	r15
    5058:	cf 93       	push	r28
    505a:	df 93       	push	r29
  struct announcement_msg *adata;
  struct announcement *a;

  packetbuf_clear();
    505c:	0e 94 ab 32 	call	0x6556	; 0x6556 <packetbuf_clear>
  adata = packetbuf_dataptr();
    5060:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    5064:	e8 2e       	mov	r14, r24
    5066:	e7 01       	movw	r28, r14
    5068:	7e 01       	movw	r14, r28
    506a:	f9 2e       	mov	r15, r25
    506c:	e7 01       	movw	r28, r14
  adata->num = 0;
    506e:	19 82       	std	Y+1, r1	; 0x01
    5070:	18 82       	st	Y, r1
  for(a = announcement_list(); a != NULL && a->has_value; a = list_item_next(a)) {
    5072:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <announcement_list>
    5076:	26 c0       	rjmp	.+76     	; 0x50c4 <send_adv+0x70>
    adata->data[adata->num].id = a->id;
    5078:	28 81       	ld	r18, Y
    507a:	39 81       	ldd	r19, Y+1	; 0x01
    507c:	f9 01       	movw	r30, r18
    507e:	ee 0f       	add	r30, r30
    5080:	ff 1f       	adc	r31, r31
    5082:	ee 0f       	add	r30, r30
    5084:	ff 1f       	adc	r31, r31
    5086:	ec 0f       	add	r30, r28
    5088:	fd 1f       	adc	r31, r29
    508a:	dc 01       	movw	r26, r24
    508c:	12 96       	adiw	r26, 0x02	; 2
    508e:	4d 91       	ld	r20, X+
    5090:	5c 91       	ld	r21, X
    5092:	13 97       	sbiw	r26, 0x03	; 3
    5094:	53 83       	std	Z+3, r21	; 0x03
    5096:	42 83       	std	Z+2, r20	; 0x02
    adata->data[adata->num].value = a->value;
    5098:	2f 5f       	subi	r18, 0xFF	; 255
    509a:	3f 4f       	sbci	r19, 0xFF	; 255
    509c:	f9 01       	movw	r30, r18
    509e:	ee 0f       	add	r30, r30
    50a0:	ff 1f       	adc	r31, r31
    50a2:	ee 0f       	add	r30, r30
    50a4:	ff 1f       	adc	r31, r31
    50a6:	ec 0f       	add	r30, r28
    50a8:	fd 1f       	adc	r31, r29
    50aa:	14 96       	adiw	r26, 0x04	; 4
    50ac:	4d 91       	ld	r20, X+
    50ae:	5c 91       	ld	r21, X
    50b0:	15 97       	sbiw	r26, 0x05	; 5
    50b2:	51 83       	std	Z+1, r21	; 0x01
    50b4:	40 83       	st	Z, r20
    adata->num++;
    50b6:	39 83       	std	Y+1, r19	; 0x01
    50b8:	28 83       	st	Y, r18
  struct announcement *a;

  packetbuf_clear();
  adata = packetbuf_dataptr();
  adata->num = 0;
  for(a = announcement_list(); a != NULL && a->has_value; a = list_item_next(a)) {
    50ba:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <list_item_next>
    50be:	28 2f       	mov	r18, r24
    50c0:	39 2f       	mov	r19, r25
    50c2:	c9 01       	movw	r24, r18
    50c4:	00 97       	sbiw	r24, 0x00	; 0
    50c6:	21 f0       	breq	.+8      	; 0x50d0 <send_adv+0x7c>
    50c8:	fc 01       	movw	r30, r24
    50ca:	20 85       	ldd	r18, Z+8	; 0x08
    50cc:	22 23       	and	r18, r18
    50ce:	a1 f6       	brne	.-88     	; 0x5078 <send_adv+0x24>
    adata->data[adata->num].value = a->value;
    adata->num++;
  }

  packetbuf_set_datalen(ANNOUNCEMENT_MSG_HEADERLEN +
		      sizeof(struct announcement_data) * adata->num);
    50d0:	88 81       	ld	r24, Y
    50d2:	99 81       	ldd	r25, Y+1	; 0x01
    50d4:	88 0f       	add	r24, r24
    50d6:	99 1f       	adc	r25, r25
    50d8:	88 0f       	add	r24, r24
    50da:	99 1f       	adc	r25, r25
    adata->data[adata->num].id = a->id;
    adata->data[adata->num].value = a->value;
    adata->num++;
  }

  packetbuf_set_datalen(ANNOUNCEMENT_MSG_HEADERLEN +
    50dc:	02 96       	adiw	r24, 0x02	; 2
    50de:	0e 94 03 32 	call	0x6406	; 0x6406 <packetbuf_set_datalen>
		      sizeof(struct announcement_data) * adata->num);

  PRINTF("%d.%d: sending neighbor advertisement with %d announcements\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1], adata->num);

  if(adata->num > 0) {
    50e2:	88 81       	ld	r24, Y
    50e4:	99 81       	ldd	r25, Y+1	; 0x01
    50e6:	00 97       	sbiw	r24, 0x00	; 0
    50e8:	21 f0       	breq	.+8      	; 0x50f2 <send_adv+0x9e>
    /* Send the packet only if it contains more than zero announcements. */
    broadcast_send(&c.c);
    50ea:	89 ea       	ldi	r24, 0xA9	; 169
    50ec:	9d e1       	ldi	r25, 0x1D	; 29
    50ee:	0e 94 12 29 	call	0x5224	; 0x5224 <broadcast_send>
  }
  PRINTF("%d.%d: sending neighbor advertisement with val %d\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	 c.val);
}
    50f2:	df 91       	pop	r29
    50f4:	cf 91       	pop	r28
    50f6:	ff 90       	pop	r15
    50f8:	ef 90       	pop	r14
    50fa:	08 95       	ret

000050fc <broadcast_announcement_init>:
void
broadcast_announcement_init(uint16_t channel,
                            clock_time_t initial,
                            clock_time_t min,
                            clock_time_t max)
{
    50fc:	ef 92       	push	r14
    50fe:	ff 92       	push	r15
    5100:	0f 93       	push	r16
    5102:	1f 93       	push	r17
    5104:	cf 93       	push	r28
    5106:	df 93       	push	r29
    5108:	fc 01       	movw	r30, r24
    510a:	8b 01       	movw	r16, r22
    510c:	7a 01       	movw	r14, r20
    510e:	e9 01       	movw	r28, r18
  broadcast_open(&c.c, channel, &broadcast_callbacks);
    5110:	89 ea       	ldi	r24, 0xA9	; 169
    5112:	9d e1       	ldi	r25, 0x1D	; 29
    5114:	bf 01       	movw	r22, r30
    5116:	46 e4       	ldi	r20, 0x46	; 70
    5118:	5e e0       	ldi	r21, 0x0E	; 14
    511a:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <broadcast_open>
  c.initial_interval = initial;
    511e:	10 93 d5 1d 	sts	0x1DD5, r17
    5122:	00 93 d4 1d 	sts	0x1DD4, r16
  c.min_interval = min;
    5126:	f0 92 d7 1d 	sts	0x1DD7, r15
    512a:	e0 92 d6 1d 	sts	0x1DD6, r14
  c.max_interval = max;
    512e:	d0 93 d9 1d 	sts	0x1DD9, r29
    5132:	c0 93 d8 1d 	sts	0x1DD8, r28

  announcement_register_observer_callback(new_announcement);
    5136:	86 e0       	ldi	r24, 0x06	; 6
    5138:	98 e2       	ldi	r25, 0x28	; 40
    513a:	0e 94 67 27 	call	0x4ece	; 0x4ece <announcement_register_observer_callback>
}
    513e:	df 91       	pop	r29
    5140:	cf 91       	pop	r28
    5142:	1f 91       	pop	r17
    5144:	0f 91       	pop	r16
    5146:	ff 90       	pop	r15
    5148:	ef 90       	pop	r14
    514a:	08 95       	ret

0000514c <broadcast_announcement_stop>:
/*---------------------------------------------------------------------------*/
void
broadcast_announcement_stop(void)
{
    514c:	cf 93       	push	r28
    514e:	df 93       	push	r29
  ctimer_stop(&c.interval_timer);
    5150:	c4 ec       	ldi	r28, 0xC4	; 196
    5152:	dd e1       	ldi	r29, 0x1D	; 29
    5154:	ce 01       	movw	r24, r28
    5156:	0e 94 64 19 	call	0x32c8	; 0x32c8 <ctimer_stop>
  ctimer_stop(&c.send_timer);
    515a:	ce 01       	movw	r24, r28
    515c:	40 97       	sbiw	r24, 0x10	; 16
    515e:	0e 94 64 19 	call	0x32c8	; 0x32c8 <ctimer_stop>
  broadcast_close(&c.c);
    5162:	ce 01       	movw	r24, r28
    5164:	4b 97       	sbiw	r24, 0x1b	; 27
    5166:	0e 94 0f 29 	call	0x521e	; 0x521e <broadcast_close>
}
    516a:	df 91       	pop	r29
    516c:	cf 91       	pop	r28
    516e:	08 95       	ret

00005170 <broadcast_announcement_beacon_interval>:
/*---------------------------------------------------------------------------*/
clock_time_t
broadcast_announcement_beacon_interval(void)
{
  return c.current_interval;
}
    5170:	80 91 da 1d 	lds	r24, 0x1DDA
    5174:	90 91 db 1d 	lds	r25, 0x1DDB
    5178:	08 95       	ret

0000517a <sent_by_abc>:
}
/*---------------------------------------------------------------------------*/
static void
sent_by_abc(struct abc_conn *bc, int status, int num_tx)
{
  struct broadcast_conn *c = (struct broadcast_conn *)bc;
    517a:	dc 01       	movw	r26, r24
  PRINTF("%d.%d: sent to %d.%d status %d num_tx %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 packetbuf_addr(PACKETBUF_ADDR_SENDER)->u8[0],
         packetbuf_addr(PACKETBUF_ADDR_SENDER)->u8[1],
         status, num_tx);
  if(c->u->sent) {
    517c:	19 96       	adiw	r26, 0x09	; 9
    517e:	ed 91       	ld	r30, X+
    5180:	fc 91       	ld	r31, X
    5182:	1a 97       	sbiw	r26, 0x0a	; 10
    5184:	02 80       	ldd	r0, Z+2	; 0x02
    5186:	f3 81       	ldd	r31, Z+3	; 0x03
    5188:	e0 2d       	mov	r30, r0
    518a:	30 97       	sbiw	r30, 0x00	; 0
    518c:	09 f0       	breq	.+2      	; 0x5190 <sent_by_abc+0x16>
    c->u->sent(c, status, num_tx);
    518e:	09 95       	icall
    5190:	08 95       	ret

00005192 <recv_from_abc>:
#endif

/*---------------------------------------------------------------------------*/
static void
recv_from_abc(struct abc_conn *bc)
{
    5192:	ef 92       	push	r14
    5194:	ff 92       	push	r15
    5196:	0f 93       	push	r16
    5198:	1f 93       	push	r17
    519a:	df 93       	push	r29
    519c:	cf 93       	push	r28
    519e:	00 d0       	rcall	.+0      	; 0x51a0 <recv_from_abc+0xe>
    51a0:	cd b7       	in	r28, 0x3d	; 61
    51a2:	de b7       	in	r29, 0x3e	; 62
  rimeaddr_t sender;
  struct broadcast_conn *c = (struct broadcast_conn *)bc;
    51a4:	8c 01       	movw	r16, r24

  rimeaddr_copy(&sender, packetbuf_addr(PACKETBUF_ADDR_SENDER));
    51a6:	88 e1       	ldi	r24, 0x18	; 24
    51a8:	0e 94 4f 33 	call	0x669e	; 0x669e <packetbuf_addr>
    51ac:	bc 01       	movw	r22, r24
    51ae:	7e 01       	movw	r14, r28
    51b0:	08 94       	sec
    51b2:	e1 1c       	adc	r14, r1
    51b4:	f1 1c       	adc	r15, r1
    51b6:	c7 01       	movw	r24, r14
    51b8:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
  
  PRINTF("%d.%d: broadcast: from %d.%d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 sender.u8[0], sender.u8[1]);
  if(c->u->recv) {
    51bc:	d8 01       	movw	r26, r16
    51be:	19 96       	adiw	r26, 0x09	; 9
    51c0:	ed 91       	ld	r30, X+
    51c2:	fc 91       	ld	r31, X
    51c4:	1a 97       	sbiw	r26, 0x0a	; 10
    51c6:	01 90       	ld	r0, Z+
    51c8:	f0 81       	ld	r31, Z
    51ca:	e0 2d       	mov	r30, r0
    51cc:	30 97       	sbiw	r30, 0x00	; 0
    51ce:	19 f0       	breq	.+6      	; 0x51d6 <recv_from_abc+0x44>
    c->u->recv(c, &sender);
    51d0:	c8 01       	movw	r24, r16
    51d2:	b7 01       	movw	r22, r14
    51d4:	09 95       	icall
  }
}
    51d6:	0f 90       	pop	r0
    51d8:	0f 90       	pop	r0
    51da:	cf 91       	pop	r28
    51dc:	df 91       	pop	r29
    51de:	1f 91       	pop	r17
    51e0:	0f 91       	pop	r16
    51e2:	ff 90       	pop	r15
    51e4:	ef 90       	pop	r14
    51e6:	08 95       	ret

000051e8 <broadcast_open>:
static const struct abc_callbacks broadcast = {recv_from_abc, sent_by_abc};
/*---------------------------------------------------------------------------*/
void
broadcast_open(struct broadcast_conn *c, uint16_t channel,
	  const struct broadcast_callbacks *u)
{
    51e8:	ef 92       	push	r14
    51ea:	ff 92       	push	r15
    51ec:	0f 93       	push	r16
    51ee:	1f 93       	push	r17
    51f0:	cf 93       	push	r28
    51f2:	df 93       	push	r29
    51f4:	ec 01       	movw	r28, r24
    51f6:	8b 01       	movw	r16, r22
    51f8:	7a 01       	movw	r14, r20
  abc_open(&c->c, channel, &broadcast);
    51fa:	4a e4       	ldi	r20, 0x4A	; 74
    51fc:	5e e0       	ldi	r21, 0x0E	; 14
    51fe:	0e 94 20 29 	call	0x5240	; 0x5240 <abc_open>
  c->u = u;
    5202:	fa 86       	std	Y+10, r15	; 0x0a
    5204:	e9 86       	std	Y+9, r14	; 0x09
  channel_set_attributes(channel, attributes);
    5206:	c8 01       	movw	r24, r16
    5208:	6e e4       	ldi	r22, 0x4E	; 78
    520a:	7e e0       	ldi	r23, 0x0E	; 14
    520c:	0e 94 c0 29 	call	0x5380	; 0x5380 <channel_set_attributes>
}
    5210:	df 91       	pop	r29
    5212:	cf 91       	pop	r28
    5214:	1f 91       	pop	r17
    5216:	0f 91       	pop	r16
    5218:	ff 90       	pop	r15
    521a:	ef 90       	pop	r14
    521c:	08 95       	ret

0000521e <broadcast_close>:
/*---------------------------------------------------------------------------*/
void
broadcast_close(struct broadcast_conn *c)
{
  abc_close(&c->c);
    521e:	0e 94 39 29 	call	0x5272	; 0x5272 <abc_close>
}
    5222:	08 95       	ret

00005224 <broadcast_send>:
/*---------------------------------------------------------------------------*/
int
broadcast_send(struct broadcast_conn *c)
{
    5224:	cf 93       	push	r28
    5226:	df 93       	push	r29
    5228:	ec 01       	movw	r28, r24
  PRINTF("%d.%d: broadcast_send\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
  packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &rimeaddr_node_addr);
    522a:	88 e1       	ldi	r24, 0x18	; 24
    522c:	6b ed       	ldi	r22, 0xDB	; 219
    522e:	76 e2       	ldi	r23, 0x26	; 38
    5230:	0e 94 45 33 	call	0x668a	; 0x668a <packetbuf_set_addr>
  return abc_send(&c->c);
    5234:	ce 01       	movw	r24, r28
    5236:	0e 94 3c 29 	call	0x5278	; 0x5278 <abc_send>
}
    523a:	df 91       	pop	r29
    523c:	cf 91       	pop	r28
    523e:	08 95       	ret

00005240 <abc_open>:

/*---------------------------------------------------------------------------*/
void
abc_open(struct abc_conn *c, uint16_t channelno,
	  const struct abc_callbacks *callbacks)
{
    5240:	ef 92       	push	r14
    5242:	ff 92       	push	r15
    5244:	0f 93       	push	r16
    5246:	1f 93       	push	r17
    5248:	cf 93       	push	r28
    524a:	df 93       	push	r29
    524c:	ec 01       	movw	r28, r24
    524e:	8b 01       	movw	r16, r22
    5250:	7a 01       	movw	r14, r20
  channel_open(&c->channel, channelno);
    5252:	0e 94 99 29 	call	0x5332	; 0x5332 <channel_open>
  c->u = callbacks;
    5256:	f8 86       	std	Y+8, r15	; 0x08
    5258:	ef 82       	std	Y+7, r14	; 0x07
  channel_set_attributes(channelno, attributes);
    525a:	c8 01       	movw	r24, r16
    525c:	62 e5       	ldi	r22, 0x52	; 82
    525e:	7e e0       	ldi	r23, 0x0E	; 14
    5260:	0e 94 c0 29 	call	0x5380	; 0x5380 <channel_set_attributes>
}
    5264:	df 91       	pop	r29
    5266:	cf 91       	pop	r28
    5268:	1f 91       	pop	r17
    526a:	0f 91       	pop	r16
    526c:	ff 90       	pop	r15
    526e:	ef 90       	pop	r14
    5270:	08 95       	ret

00005272 <abc_close>:
/*---------------------------------------------------------------------------*/
void
abc_close(struct abc_conn *c)
{
  channel_close(&c->channel);
    5272:	0e 94 a2 29 	call	0x5344	; 0x5344 <channel_close>
}
    5276:	08 95       	ret

00005278 <abc_send>:
abc_send(struct abc_conn *c)
{
  PRINTF("%d.%d: abc: abc_send on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 c->channel.channelno);
  return rime_output(&c->channel);
    5278:	0e 94 b3 26 	call	0x4d66	; 0x4d66 <rime_output>
}
    527c:	08 95       	ret

0000527e <abc_input>:
/*---------------------------------------------------------------------------*/
void
abc_input(struct channel *channel)
{
  struct abc_conn *c = (struct abc_conn *)channel;
    527e:	fc 01       	movw	r30, r24
  PRINTF("%d.%d: abc: abc_input_packet on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 channel->channelno);

  if(c->u->recv) {
    5280:	a7 81       	ldd	r26, Z+7	; 0x07
    5282:	b0 85       	ldd	r27, Z+8	; 0x08
    5284:	2d 91       	ld	r18, X+
    5286:	3c 91       	ld	r19, X
    5288:	11 97       	sbiw	r26, 0x01	; 1
    528a:	21 15       	cp	r18, r1
    528c:	31 05       	cpc	r19, r1
    528e:	11 f0       	breq	.+4      	; 0x5294 <abc_input+0x16>
    c->u->recv(c);
    5290:	f9 01       	movw	r30, r18
    5292:	09 95       	icall
    5294:	08 95       	ret

00005296 <abc_sent>:
}
/*---------------------------------------------------------------------------*/
void
abc_sent(struct channel *channel, int status, int num_tx)
{
  struct abc_conn *c = (struct abc_conn *)channel;
    5296:	dc 01       	movw	r26, r24
  PRINTF("%d.%d: abc: abc_sent on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 channel->channelno);

  if(c->u->sent) {
    5298:	17 96       	adiw	r26, 0x07	; 7
    529a:	ed 91       	ld	r30, X+
    529c:	fc 91       	ld	r31, X
    529e:	18 97       	sbiw	r26, 0x08	; 8
    52a0:	02 80       	ldd	r0, Z+2	; 0x02
    52a2:	f3 81       	ldd	r31, Z+3	; 0x03
    52a4:	e0 2d       	mov	r30, r0
    52a6:	30 97       	sbiw	r30, 0x00	; 0
    52a8:	09 f0       	breq	.+2      	; 0x52ac <abc_sent+0x16>
    c->u->sent(c, status, num_tx);
    52aa:	09 95       	icall
    52ac:	08 95       	ret

000052ae <chameleon_init>:

/*---------------------------------------------------------------------------*/
void
chameleon_init(void)
{
  channel_init();
    52ae:	0e 94 94 29 	call	0x5328	; 0x5328 <channel_init>
}
    52b2:	08 95       	ret

000052b4 <chameleon_parse>:
}
#endif /* DEBUG */
/*---------------------------------------------------------------------------*/
struct channel *
chameleon_parse(void)
{
    52b4:	ef 92       	push	r14
    52b6:	ff 92       	push	r15
    52b8:	cf 93       	push	r28
    52ba:	df 93       	push	r29
  PRINTF("%d.%d: chameleon_input\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
#if DEBUG
  printhdr(packetbuf_dataptr(), packetbuf_datalen());
#endif /* DEBUG */
  c = CHAMELEON_MODULE.input();
    52bc:	e0 91 54 0e 	lds	r30, 0x0E54
    52c0:	f0 91 55 0e 	lds	r31, 0x0E55
    52c4:	09 95       	icall
    52c6:	ec 01       	movw	r28, r24
  if(c != NULL) {
    52c8:	00 97       	sbiw	r24, 0x00	; 0
    52ca:	29 f0       	breq	.+10     	; 0x52d6 <chameleon_parse+0x22>
    PRINTF("%d.%d: chameleon_input channel %d\n",
           rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
           c->channelno);
    packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c->channelno);
    52cc:	6a 81       	ldd	r22, Y+2	; 0x02
    52ce:	7b 81       	ldd	r23, Y+3	; 0x03
    52d0:	81 e0       	ldi	r24, 0x01	; 1
    52d2:	0e 94 31 33 	call	0x6662	; 0x6662 <packetbuf_set_attr>
  } else {
    PRINTF("%d.%d: chameleon_input channel not found for incoming packet\n",
           rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
  }
  return c;
}
    52d6:	ce 01       	movw	r24, r28
    52d8:	df 91       	pop	r29
    52da:	cf 91       	pop	r28
    52dc:	ff 90       	pop	r15
    52de:	ef 90       	pop	r14
    52e0:	08 95       	ret

000052e2 <chameleon_create>:
/*---------------------------------------------------------------------------*/
int
chameleon_create(struct channel *c)
{
    52e2:	0f 93       	push	r16
    52e4:	1f 93       	push	r17
    52e6:	cf 93       	push	r28
    52e8:	df 93       	push	r29
    52ea:	8c 01       	movw	r16, r24

  PRINTF("%d.%d: chameleon_output channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 c->channelno);

  ret = CHAMELEON_MODULE.output(c);
    52ec:	e0 91 56 0e 	lds	r30, 0x0E56
    52f0:	f0 91 57 0e 	lds	r31, 0x0E57
    52f4:	09 95       	icall
    52f6:	ec 01       	movw	r28, r24
  packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c->channelno);
    52f8:	f8 01       	movw	r30, r16
    52fa:	62 81       	ldd	r22, Z+2	; 0x02
    52fc:	73 81       	ldd	r23, Z+3	; 0x03
    52fe:	81 e0       	ldi	r24, 0x01	; 1
    5300:	0e 94 31 33 	call	0x6662	; 0x6662 <packetbuf_set_attr>
#if DEBUG
  printhdr(packetbuf_hdrptr(), packetbuf_hdrlen());
#endif /* DEBUG */
  if(ret) {
    return 1;
    5304:	21 e0       	ldi	r18, 0x01	; 1
    5306:	30 e0       	ldi	r19, 0x00	; 0
    5308:	20 97       	sbiw	r28, 0x00	; 0
    530a:	11 f4       	brne	.+4      	; 0x5310 <chameleon_create+0x2e>
    530c:	20 e0       	ldi	r18, 0x00	; 0
    530e:	30 e0       	ldi	r19, 0x00	; 0
  }
  return 0;
}
    5310:	c9 01       	movw	r24, r18
    5312:	df 91       	pop	r29
    5314:	cf 91       	pop	r28
    5316:	1f 91       	pop	r17
    5318:	0f 91       	pop	r16
    531a:	08 95       	ret

0000531c <chameleon_hdrsize>:
/*---------------------------------------------------------------------------*/
int
chameleon_hdrsize(const struct packetbuf_attrlist attrlist[])
{
  return CHAMELEON_MODULE.hdrsize(attrlist);
    531c:	e0 91 58 0e 	lds	r30, 0x0E58
    5320:	f0 91 59 0e 	lds	r31, 0x0E59
    5324:	09 95       	icall
}
    5326:	08 95       	ret

00005328 <channel_init>:

/*---------------------------------------------------------------------------*/
void
channel_init(void)
{
  list_init(channel_list);
    5328:	8e ed       	ldi	r24, 0xDE	; 222
    532a:	9d e1       	ldi	r25, 0x1D	; 29
    532c:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <list_init>
}
    5330:	08 95       	ret

00005332 <channel_open>:
  }
}
/*---------------------------------------------------------------------------*/
void
channel_open(struct channel *c, uint16_t channelno)
{
    5332:	fc 01       	movw	r30, r24
  c->channelno = channelno;
    5334:	73 83       	std	Z+3, r23	; 0x03
    5336:	62 83       	std	Z+2, r22	; 0x02
  list_add(channel_list, c);
    5338:	8e ed       	ldi	r24, 0xDE	; 222
    533a:	9d e1       	ldi	r25, 0x1D	; 29
    533c:	bf 01       	movw	r22, r30
    533e:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <list_add>
}
    5342:	08 95       	ret

00005344 <channel_close>:
/*---------------------------------------------------------------------------*/
void
channel_close(struct channel *c)
{
    5344:	bc 01       	movw	r22, r24
  list_remove(channel_list, c);
    5346:	8e ed       	ldi	r24, 0xDE	; 222
    5348:	9d e1       	ldi	r25, 0x1D	; 29
    534a:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>
}
    534e:	08 95       	ret

00005350 <channel_lookup>:
/*---------------------------------------------------------------------------*/
struct channel *
channel_lookup(uint16_t channelno)
{
    5350:	cf 93       	push	r28
    5352:	df 93       	push	r29
    5354:	ec 01       	movw	r28, r24
  struct channel *c;
  for(c = list_head(channel_list); c != NULL; c = list_item_next(c)) {
    5356:	8e ed       	ldi	r24, 0xDE	; 222
    5358:	9d e1       	ldi	r25, 0x1D	; 29
    535a:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <list_head>
    535e:	08 c0       	rjmp	.+16     	; 0x5370 <channel_lookup+0x20>
    if(c->channelno == channelno) {
    5360:	82 81       	ldd	r24, Z+2	; 0x02
    5362:	93 81       	ldd	r25, Z+3	; 0x03
    5364:	8c 17       	cp	r24, r28
    5366:	9d 07       	cpc	r25, r29
    5368:	39 f0       	breq	.+14     	; 0x5378 <channel_lookup+0x28>
/*---------------------------------------------------------------------------*/
struct channel *
channel_lookup(uint16_t channelno)
{
  struct channel *c;
  for(c = list_head(channel_list); c != NULL; c = list_item_next(c)) {
    536a:	cf 01       	movw	r24, r30
    536c:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <list_item_next>
    5370:	e8 2f       	mov	r30, r24
    5372:	f9 2f       	mov	r31, r25
    5374:	30 97       	sbiw	r30, 0x00	; 0
    5376:	a1 f7       	brne	.-24     	; 0x5360 <channel_lookup+0x10>
    if(c->channelno == channelno) {
      return c;
    }
  }
  return NULL;
}
    5378:	cf 01       	movw	r24, r30
    537a:	df 91       	pop	r29
    537c:	cf 91       	pop	r28
    537e:	08 95       	ret

00005380 <channel_set_attributes>:
}
/*---------------------------------------------------------------------------*/
void
channel_set_attributes(uint16_t channelno,
		       const struct packetbuf_attrlist attrlist[])
{
    5380:	0f 93       	push	r16
    5382:	1f 93       	push	r17
    5384:	cf 93       	push	r28
    5386:	df 93       	push	r29
    5388:	8b 01       	movw	r16, r22
  struct channel *c;
  c = channel_lookup(channelno);
    538a:	0e 94 a8 29 	call	0x5350	; 0x5350 <channel_lookup>
    538e:	ec 01       	movw	r28, r24
  if(c != NULL) {
    5390:	00 97       	sbiw	r24, 0x00	; 0
    5392:	31 f0       	breq	.+12     	; 0x53a0 <channel_set_attributes+0x20>
    c->attrlist = attrlist;
    5394:	1d 83       	std	Y+5, r17	; 0x05
    5396:	0c 83       	std	Y+4, r16	; 0x04
    c->hdrsize = chameleon_hdrsize(attrlist);
    5398:	c8 01       	movw	r24, r16
    539a:	0e 94 8e 29 	call	0x531c	; 0x531c <chameleon_hdrsize>
    539e:	8e 83       	std	Y+6, r24	; 0x06
  }
}
    53a0:	df 91       	pop	r29
    53a2:	cf 91       	pop	r28
    53a4:	1f 91       	pop	r17
    53a6:	0f 91       	pop	r16
    53a8:	08 95       	ret

000053aa <header_size>:
  }
}
/*---------------------------------------------------------------------------*/
static int
header_size(const struct packetbuf_attrlist *a)
{
    53aa:	fc 01       	movw	r30, r24
  int size, len;
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */
  
  size = 0;
    53ac:	20 e0       	ldi	r18, 0x00	; 0
    53ae:	30 e0       	ldi	r19, 0x00	; 0
  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {
    53b0:	04 c0       	rjmp	.+8      	; 0x53ba <header_size+0x10>
      continue;
    }
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    /*    PRINTF("chameleon header_size: header type %d len %d\n",
	   a->type, a->len);*/
    len = a->len;
    53b2:	81 81       	ldd	r24, Z+1	; 0x01
    /*    if(len < 8) {
      len = 8;
      }*/
    size += len;
    53b4:	28 0f       	add	r18, r24
    53b6:	31 1d       	adc	r19, r1
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */
  
  size = 0;
  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {
    53b8:	32 96       	adiw	r30, 0x02	; 2
    53ba:	80 81       	ld	r24, Z
    53bc:	88 23       	and	r24, r24
    53be:	c9 f7       	brne	.-14     	; 0x53b2 <header_size+0x8>
      len = 8;
      }*/
    size += len;
  }
  return size;
}
    53c0:	c9 01       	movw	r24, r18
    53c2:	08 95       	ret

000053c4 <get_bits_in_byte>:
#endif

/*---------------------------------------------------------------------------*/
uint8_t CC_INLINE
get_bits_in_byte(uint8_t *from, int bitpos, int vallen)
{
    53c4:	fc 01       	movw	r30, r24
  uint16_t shifted_val;

  shifted_val = (from[0] << 8) | from[1];
    53c6:	81 81       	ldd	r24, Z+1	; 0x01
    53c8:	90 e0       	ldi	r25, 0x00	; 0
    53ca:	30 81       	ld	r19, Z
    53cc:	20 e0       	ldi	r18, 0x00	; 0
    53ce:	82 2b       	or	r24, r18
    53d0:	93 2b       	or	r25, r19
	from[0], from[1], shifted_val,
	(((shifted_val << bitpos) >> 8) & bitmask[vallen]) >> (8 - vallen),
	vallen
	);*/
  
  return (((shifted_val << bitpos) >> 8) & bitmask[vallen]) >> (8 - vallen);
    53d2:	02 c0       	rjmp	.+4      	; 0x53d8 <get_bits_in_byte+0x14>
    53d4:	88 0f       	add	r24, r24
    53d6:	99 1f       	adc	r25, r25
    53d8:	6a 95       	dec	r22
    53da:	e2 f7       	brpl	.-8      	; 0x53d4 <get_bits_in_byte+0x10>
    53dc:	89 2f       	mov	r24, r25
    53de:	99 27       	eor	r25, r25
    53e0:	fa 01       	movw	r30, r20
    53e2:	e6 5a       	subi	r30, 0xA6	; 166
    53e4:	f1 4f       	sbci	r31, 0xF1	; 241
    53e6:	20 81       	ld	r18, Z
    53e8:	30 e0       	ldi	r19, 0x00	; 0
    53ea:	82 23       	and	r24, r18
    53ec:	93 23       	and	r25, r19
    53ee:	28 e0       	ldi	r18, 0x08	; 8
    53f0:	30 e0       	ldi	r19, 0x00	; 0
    53f2:	24 1b       	sub	r18, r20
    53f4:	35 0b       	sbc	r19, r21
    53f6:	02 c0       	rjmp	.+4      	; 0x53fc <get_bits_in_byte+0x38>
    53f8:	96 95       	lsr	r25
    53fa:	87 95       	ror	r24
    53fc:	2a 95       	dec	r18
    53fe:	e2 f7       	brpl	.-8      	; 0x53f8 <get_bits_in_byte+0x34>
}
    5400:	08 95       	ret

00005402 <get_bits>:
/*---------------------------------------------------------------------------*/
void
get_bits(uint8_t *to, uint8_t *from, int bitpos, int vallen)
{
    5402:	6f 92       	push	r6
    5404:	7f 92       	push	r7
    5406:	8f 92       	push	r8
    5408:	9f 92       	push	r9
    540a:	af 92       	push	r10
    540c:	bf 92       	push	r11
    540e:	cf 92       	push	r12
    5410:	df 92       	push	r13
    5412:	ef 92       	push	r14
    5414:	ff 92       	push	r15
    5416:	0f 93       	push	r16
    5418:	1f 93       	push	r17
    541a:	cf 93       	push	r28
    541c:	df 93       	push	r29
    541e:	6c 01       	movw	r12, r24
    5420:	7b 01       	movw	r14, r22
    5422:	5a 01       	movw	r10, r20
    5424:	89 01       	movw	r16, r18
  int i, bits;
  
  
  if(vallen < 8) {
    5426:	28 30       	cpi	r18, 0x08	; 8
    5428:	31 05       	cpc	r19, r1
    542a:	44 f4       	brge	.+16     	; 0x543c <get_bits+0x3a>
    *to = get_bits_in_byte(from, bitpos, vallen);
    542c:	cb 01       	movw	r24, r22
    542e:	ba 01       	movw	r22, r20
    5430:	a9 01       	movw	r20, r18
    5432:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <get_bits_in_byte>
    5436:	f6 01       	movw	r30, r12
    5438:	80 83       	st	Z, r24
    543a:	41 c0       	rjmp	.+130    	; 0x54be <get_bits+0xbc>
    543c:	39 01       	movw	r6, r18
    543e:	33 e0       	ldi	r19, 0x03	; 3
    5440:	75 94       	asr	r7
    5442:	67 94       	ror	r6
    5444:	3a 95       	dec	r19
    5446:	e1 f7       	brne	.-8      	; 0x5440 <get_bits+0x3e>
  } else {
    if(bitpos == 0) {
    5448:	41 15       	cp	r20, r1
    544a:	51 05       	cpc	r21, r1
    544c:	21 f0       	breq	.+8      	; 0x5456 <get_bits+0x54>
      bits = vallen & 7;
      if(bits) {
	to[i] = get_bits_in_byte(&from[i], 0, bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    544e:	4c 01       	movw	r8, r24
    5450:	c0 e0       	ldi	r28, 0x00	; 0
    5452:	d0 e0       	ldi	r29, 0x00	; 0
    5454:	16 c0       	rjmp	.+44     	; 0x5482 <get_bits+0x80>
  
  if(vallen < 8) {
    *to = get_bits_in_byte(from, bitpos, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5456:	db 01       	movw	r26, r22
    5458:	fc 01       	movw	r30, r24
    545a:	c0 e0       	ldi	r28, 0x00	; 0
    545c:	d0 e0       	ldi	r29, 0x00	; 0
	/*	PRINTF("get_bits i %d val 0x%02x\n",
		i, from[i]);*/
	to[i] = from[i];
    545e:	8d 91       	ld	r24, X+
    5460:	81 93       	st	Z+, r24
  
  if(vallen < 8) {
    *to = get_bits_in_byte(from, bitpos, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5462:	21 96       	adiw	r28, 0x01	; 1
    5464:	c6 15       	cp	r28, r6
    5466:	d7 05       	cpc	r29, r7
    5468:	d4 f3       	brlt	.-12     	; 0x545e <get_bits+0x5c>
	/*	PRINTF("get_bits i %d val 0x%02x\n",
		i, from[i]);*/
	to[i] = from[i];
      }
      bits = vallen & 7;
    546a:	a8 01       	movw	r20, r16
    546c:	47 70       	andi	r20, 0x07	; 7
    546e:	50 70       	andi	r21, 0x00	; 0
      if(bits) {
    5470:	41 15       	cp	r20, r1
    5472:	51 05       	cpc	r21, r1
    5474:	21 f1       	breq	.+72     	; 0x54be <get_bits+0xbc>
	to[i] = get_bits_in_byte(&from[i], 0, bits);
    5476:	c7 01       	movw	r24, r14
    5478:	8c 0f       	add	r24, r28
    547a:	9d 1f       	adc	r25, r29
    547c:	60 e0       	ldi	r22, 0x00	; 0
    547e:	70 e0       	ldi	r23, 0x00	; 0
    5480:	19 c0       	rjmp	.+50     	; 0x54b4 <get_bits+0xb2>
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
	/*	PRINTF("get_bits i %d val 0x%02x bitpos %d\n",
		i, from[i], bitpos);*/
	to[i] = get_bits_in_byte(&from[i], bitpos, 8);
    5482:	c7 01       	movw	r24, r14
    5484:	8c 0f       	add	r24, r28
    5486:	9d 1f       	adc	r25, r29
    5488:	b5 01       	movw	r22, r10
    548a:	48 e0       	ldi	r20, 0x08	; 8
    548c:	50 e0       	ldi	r21, 0x00	; 0
    548e:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <get_bits_in_byte>
    5492:	f4 01       	movw	r30, r8
    5494:	81 93       	st	Z+, r24
    5496:	4f 01       	movw	r8, r30
      bits = vallen & 7;
      if(bits) {
	to[i] = get_bits_in_byte(&from[i], 0, bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    5498:	21 96       	adiw	r28, 0x01	; 1
    549a:	c6 15       	cp	r28, r6
    549c:	d7 05       	cpc	r29, r7
    549e:	8c f3       	brlt	.-30     	; 0x5482 <get_bits+0x80>
	/*	PRINTF("get_bits i %d val 0x%02x bitpos %d\n",
		i, from[i], bitpos);*/
	to[i] = get_bits_in_byte(&from[i], bitpos, 8);
      }
      bits = vallen & 7;
    54a0:	a8 01       	movw	r20, r16
    54a2:	47 70       	andi	r20, 0x07	; 7
    54a4:	50 70       	andi	r21, 0x00	; 0
      if(bits) {
    54a6:	41 15       	cp	r20, r1
    54a8:	51 05       	cpc	r21, r1
    54aa:	49 f0       	breq	.+18     	; 0x54be <get_bits+0xbc>
	to[i] = get_bits_in_byte(&from[i], bitpos, bits);
    54ac:	c7 01       	movw	r24, r14
    54ae:	8c 0f       	add	r24, r28
    54b0:	9d 1f       	adc	r25, r29
    54b2:	b5 01       	movw	r22, r10
    54b4:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <get_bits_in_byte>
    54b8:	cc 0d       	add	r28, r12
    54ba:	dd 1d       	adc	r29, r13
    54bc:	88 83       	st	Y, r24
      }
    }
  }
}
    54be:	df 91       	pop	r29
    54c0:	cf 91       	pop	r28
    54c2:	1f 91       	pop	r17
    54c4:	0f 91       	pop	r16
    54c6:	ff 90       	pop	r15
    54c8:	ef 90       	pop	r14
    54ca:	df 90       	pop	r13
    54cc:	cf 90       	pop	r12
    54ce:	bf 90       	pop	r11
    54d0:	af 90       	pop	r10
    54d2:	9f 90       	pop	r9
    54d4:	8f 90       	pop	r8
    54d6:	7f 90       	pop	r7
    54d8:	6f 90       	pop	r6
    54da:	08 95       	ret

000054dc <unpack_header>:
  return 1; /* Send out packet */
}
/*---------------------------------------------------------------------------*/
static struct channel *
unpack_header(void)
{
    54dc:	4f 92       	push	r4
    54de:	5f 92       	push	r5
    54e0:	6f 92       	push	r6
    54e2:	7f 92       	push	r7
    54e4:	8f 92       	push	r8
    54e6:	9f 92       	push	r9
    54e8:	af 92       	push	r10
    54ea:	bf 92       	push	r11
    54ec:	cf 92       	push	r12
    54ee:	df 92       	push	r13
    54f0:	ef 92       	push	r14
    54f2:	ff 92       	push	r15
    54f4:	0f 93       	push	r16
    54f6:	1f 93       	push	r17
    54f8:	df 93       	push	r29
    54fa:	cf 93       	push	r28
    54fc:	00 d0       	rcall	.+0      	; 0x54fe <unpack_header+0x22>
    54fe:	00 d0       	rcall	.+0      	; 0x5500 <unpack_header+0x24>
    5500:	cd b7       	in	r28, 0x3d	; 61
    5502:	de b7       	in	r29, 0x3e	; 62
  struct channel *c;
  

  /* The packet has a header that tells us what channel the packet is
     for. */
  hdr = (struct bitopt_hdr *)packetbuf_dataptr();
    5504:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    5508:	e8 2e       	mov	r14, r24
    550a:	09 2f       	mov	r16, r25
  if(packetbuf_hdrreduce(sizeof(struct bitopt_hdr)) == 0) {
    550c:	82 e0       	ldi	r24, 0x02	; 2
    550e:	90 e0       	ldi	r25, 0x00	; 0
    5510:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <packetbuf_hdrreduce>
    5514:	00 97       	sbiw	r24, 0x00	; 0
    5516:	09 f4       	brne	.+2      	; 0x551a <unpack_header+0x3e>
    5518:	64 c0       	rjmp	.+200    	; 0x55e2 <unpack_header+0x106>
  struct channel *c;
  

  /* The packet has a header that tells us what channel the packet is
     for. */
  hdr = (struct bitopt_hdr *)packetbuf_dataptr();
    551a:	ee 2d       	mov	r30, r14
    551c:	f0 2f       	mov	r31, r16
  if(packetbuf_hdrreduce(sizeof(struct bitopt_hdr)) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  c = channel_lookup((hdr->channel[1] << 8) + hdr->channel[0]);
    551e:	91 81       	ldd	r25, Z+1	; 0x01
    5520:	80 e0       	ldi	r24, 0x00	; 0
    5522:	20 81       	ld	r18, Z
    5524:	82 0f       	add	r24, r18
    5526:	91 1d       	adc	r25, r1
    5528:	0e 94 a8 29 	call	0x5350	; 0x5350 <channel_lookup>
    552c:	7c 01       	movw	r14, r24
  if(c == NULL) {
    552e:	00 97       	sbiw	r24, 0x00	; 0
    5530:	09 f4       	brne	.+2      	; 0x5534 <unpack_header+0x58>
    5532:	59 c0       	rjmp	.+178    	; 0x55e6 <unpack_header+0x10a>
    PRINTF("chameleon-bitopt: input: channel %u not found\n",
           (hdr->channel[1] << 8) + hdr->channel[0]);
    return NULL;
  }

  hdrptr = packetbuf_dataptr();
    5534:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    5538:	3c 01       	movw	r6, r24
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
    553a:	f7 01       	movw	r30, r14
    553c:	46 81       	ldd	r20, Z+6	; 0x06
    553e:	24 2f       	mov	r18, r20
    5540:	30 e0       	ldi	r19, 0x00	; 0
    5542:	27 70       	andi	r18, 0x07	; 7
    5544:	30 70       	andi	r19, 0x00	; 0
    5546:	81 e0       	ldi	r24, 0x01	; 1
    5548:	90 e0       	ldi	r25, 0x00	; 0
    554a:	21 15       	cp	r18, r1
    554c:	31 05       	cpc	r19, r1
    554e:	11 f4       	brne	.+4      	; 0x5554 <unpack_header+0x78>
    5550:	80 e0       	ldi	r24, 0x00	; 0
    5552:	90 e0       	ldi	r25, 0x00	; 0
    5554:	46 95       	lsr	r20
    5556:	46 95       	lsr	r20
    5558:	46 95       	lsr	r20
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    555a:	84 0f       	add	r24, r20
    555c:	91 1d       	adc	r25, r1
    555e:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <packetbuf_hdrreduce>
    5562:	00 97       	sbiw	r24, 0x00	; 0
    5564:	f1 f1       	breq	.+124    	; 0x55e2 <unpack_header+0x106>
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    5566:	f7 01       	movw	r30, r14
    5568:	04 81       	ldd	r16, Z+4	; 0x04
    556a:	15 81       	ldd	r17, Z+5	; 0x05
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
    556c:	cc 24       	eor	r12, r12
    556e:	dd 24       	eor	r13, r13
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, addr.u8[0], addr.u8[1]);
      packetbuf_set_addr(a->type, &addr);
    } else {
      packetbuf_attr_t val = 0;
      get_bits((uint8_t *)&val, &hdrptr[byteptr], bitptr & 7, len);
    5570:	53 e0       	ldi	r21, 0x03	; 3
    5572:	45 2e       	mov	r4, r21
    5574:	51 2c       	mov	r5, r1
    5576:	4c 0e       	add	r4, r28
    5578:	5d 1e       	adc	r5, r29
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    byteptr = bitptr / 8;
    if(PACKETBUF_IS_ADDR(a->type)) {
      rimeaddr_t addr;
      get_bits((uint8_t *)&addr, &hdrptr[byteptr], bitptr & 7, len);
    557a:	4e 01       	movw	r8, r28
    557c:	08 94       	sec
    557e:	81 1c       	adc	r8, r1
    5580:	91 1c       	adc	r9, r1
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    5582:	2a c0       	rjmp	.+84     	; 0x55d8 <unpack_header+0xfc>
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    PRINTF("%d.%d: unpack_header type %d, len %d, bitptr %d\n",
	   rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    5584:	f8 01       	movw	r30, r16
    5586:	a1 80       	ldd	r10, Z+1	; 0x01
    5588:	bb 24       	eor	r11, r11
    byteptr = bitptr / 8;
    558a:	b6 01       	movw	r22, r12
    558c:	43 e0       	ldi	r20, 0x03	; 3
    558e:	75 95       	asr	r23
    5590:	67 95       	ror	r22
    5592:	4a 95       	dec	r20
    5594:	e1 f7       	brne	.-8      	; 0x558e <unpack_header+0xb2>
    5596:	66 0d       	add	r22, r6
    5598:	77 1d       	adc	r23, r7
    559a:	a6 01       	movw	r20, r12
    559c:	47 70       	andi	r20, 0x07	; 7
    559e:	50 70       	andi	r21, 0x00	; 0
    if(PACKETBUF_IS_ADDR(a->type)) {
    55a0:	88 31       	cpi	r24, 0x18	; 24
    55a2:	50 f0       	brcs	.+20     	; 0x55b8 <unpack_header+0xdc>
      rimeaddr_t addr;
      get_bits((uint8_t *)&addr, &hdrptr[byteptr], bitptr & 7, len);
    55a4:	c4 01       	movw	r24, r8
    55a6:	95 01       	movw	r18, r10
    55a8:	0e 94 01 2a 	call	0x5402	; 0x5402 <get_bits>
      PRINTF("%d.%d: unpack_header type %d, addr %d.%d\n",
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, addr.u8[0], addr.u8[1]);
      packetbuf_set_addr(a->type, &addr);
    55ac:	f8 01       	movw	r30, r16
    55ae:	80 81       	ld	r24, Z
    55b0:	b4 01       	movw	r22, r8
    55b2:	0e 94 45 33 	call	0x668a	; 0x668a <packetbuf_set_addr>
    55b6:	0c c0       	rjmp	.+24     	; 0x55d0 <unpack_header+0xf4>
    } else {
      packetbuf_attr_t val = 0;
    55b8:	1c 82       	std	Y+4, r1	; 0x04
    55ba:	1b 82       	std	Y+3, r1	; 0x03
      get_bits((uint8_t *)&val, &hdrptr[byteptr], bitptr & 7, len);
    55bc:	c2 01       	movw	r24, r4
    55be:	95 01       	movw	r18, r10
    55c0:	0e 94 01 2a 	call	0x5402	; 0x5402 <get_bits>

      packetbuf_set_attr(a->type, val);
    55c4:	6b 81       	ldd	r22, Y+3	; 0x03
    55c6:	7c 81       	ldd	r23, Y+4	; 0x04
    55c8:	f8 01       	movw	r30, r16
    55ca:	80 81       	ld	r24, Z
    55cc:	0e 94 31 33 	call	0x6662	; 0x6662 <packetbuf_set_attr>
      PRINTF("%d.%d: unpack_header type %d, val %d\n",
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, val);
    }
    /*    byteptr += len / 8;*/
    bitptr += len;
    55d0:	ca 0c       	add	r12, r10
    55d2:	db 1c       	adc	r13, r11
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    55d4:	0e 5f       	subi	r16, 0xFE	; 254
    55d6:	1f 4f       	sbci	r17, 0xFF	; 255
    55d8:	f8 01       	movw	r30, r16
    55da:	80 81       	ld	r24, Z
    55dc:	88 23       	and	r24, r24
    55de:	91 f6       	brne	.-92     	; 0x5584 <unpack_header+0xa8>
    55e0:	02 c0       	rjmp	.+4      	; 0x55e6 <unpack_header+0x10a>

  hdrptr = packetbuf_dataptr();
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
    55e2:	ee 24       	eor	r14, r14
    55e4:	ff 24       	eor	r15, r15
    }
    /*    byteptr += len / 8;*/
    bitptr += len;
  }
  return c;
}
    55e6:	c7 01       	movw	r24, r14
    55e8:	0f 90       	pop	r0
    55ea:	0f 90       	pop	r0
    55ec:	0f 90       	pop	r0
    55ee:	0f 90       	pop	r0
    55f0:	cf 91       	pop	r28
    55f2:	df 91       	pop	r29
    55f4:	1f 91       	pop	r17
    55f6:	0f 91       	pop	r16
    55f8:	ff 90       	pop	r15
    55fa:	ef 90       	pop	r14
    55fc:	df 90       	pop	r13
    55fe:	cf 90       	pop	r12
    5600:	bf 90       	pop	r11
    5602:	af 90       	pop	r10
    5604:	9f 90       	pop	r9
    5606:	8f 90       	pop	r8
    5608:	7f 90       	pop	r7
    560a:	6f 90       	pop	r6
    560c:	5f 90       	pop	r5
    560e:	4f 90       	pop	r4
    5610:	08 95       	ret

00005612 <set_bits_in_byte>:
  return size;
}
/*---------------------------------------------------------------------------*/
void CC_INLINE
set_bits_in_byte(uint8_t *target, int bitpos, uint8_t val, int vallen)
{
    5612:	fc 01       	movw	r30, r24
  unsigned short shifted_val;
  shifted_val = val << (8 - bitpos + 8 - vallen);
    5614:	50 e0       	ldi	r21, 0x00	; 0
    5616:	80 e1       	ldi	r24, 0x10	; 16
    5618:	90 e0       	ldi	r25, 0x00	; 0
    561a:	86 1b       	sub	r24, r22
    561c:	97 0b       	sbc	r25, r23
    561e:	82 1b       	sub	r24, r18
    5620:	93 0b       	sbc	r25, r19
    5622:	02 c0       	rjmp	.+4      	; 0x5628 <set_bits_in_byte+0x16>
    5624:	44 0f       	add	r20, r20
    5626:	55 1f       	adc	r21, r21
    5628:	8a 95       	dec	r24
    562a:	e2 f7       	brpl	.-8      	; 0x5624 <set_bits_in_byte+0x12>
  /*  printf("set_bits_in_byte before target[0] 0x%02x target[1] 0x%02x shifted_val 0x%04x val 0x%02x vallen %d\n",
      target[0], target[1], shifted_val, val, vallen);*/
  target[0] |= shifted_val >> 8;
    562c:	80 81       	ld	r24, Z
    562e:	85 2b       	or	r24, r21
    5630:	80 83       	st	Z, r24
  target[1] |= shifted_val & 0xff;
    5632:	81 81       	ldd	r24, Z+1	; 0x01
    5634:	84 2b       	or	r24, r20
    5636:	81 83       	std	Z+1, r24	; 0x01
}
    5638:	08 95       	ret

0000563a <set_bits>:
/*---------------------------------------------------------------------------*/
void
set_bits(uint8_t *ptr, int bitpos, uint8_t *val, int vallen)
{
    563a:	6f 92       	push	r6
    563c:	7f 92       	push	r7
    563e:	8f 92       	push	r8
    5640:	9f 92       	push	r9
    5642:	af 92       	push	r10
    5644:	bf 92       	push	r11
    5646:	cf 92       	push	r12
    5648:	df 92       	push	r13
    564a:	ef 92       	push	r14
    564c:	ff 92       	push	r15
    564e:	0f 93       	push	r16
    5650:	1f 93       	push	r17
    5652:	cf 93       	push	r28
    5654:	df 93       	push	r29
    5656:	8c 01       	movw	r16, r24
    5658:	5b 01       	movw	r10, r22
    565a:	6a 01       	movw	r12, r20
    565c:	79 01       	movw	r14, r18
  int i, bits;

  /*  PRINTF("set_bits %p bitpos %d, val %p len %d\n",
      ptr, bitpos, val, vallen);*/

  if(vallen < 8) {
    565e:	28 30       	cpi	r18, 0x08	; 8
    5660:	31 05       	cpc	r19, r1
    5662:	24 f4       	brge	.+8      	; 0x566c <set_bits+0x32>
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
    5664:	c8 01       	movw	r24, r16
    5666:	fa 01       	movw	r30, r20
    5668:	40 81       	ld	r20, Z
    566a:	56 c0       	rjmp	.+172    	; 0x5718 <set_bits+0xde>
    566c:	39 01       	movw	r6, r18
    566e:	63 e0       	ldi	r22, 0x03	; 3
    5670:	75 94       	asr	r7
    5672:	67 94       	ror	r6
    5674:	6a 95       	dec	r22
    5676:	e1 f7       	brne	.-8      	; 0x5670 <set_bits+0x36>
  } else {
    if(bitpos == 0) {
    5678:	a1 14       	cp	r10, r1
    567a:	b1 04       	cpc	r11, r1
    567c:	21 f0       	breq	.+8      	; 0x5686 <set_bits+0x4c>
      bits = vallen & 7;
      if(bits) {
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    567e:	4a 01       	movw	r8, r20
    5680:	c0 e0       	ldi	r28, 0x00	; 0
    5682:	d0 e0       	ldi	r29, 0x00	; 0
    5684:	21 c0       	rjmp	.+66     	; 0x56c8 <set_bits+0x8e>

  if(vallen < 8) {
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5686:	da 01       	movw	r26, r20
    5688:	f8 01       	movw	r30, r16
    568a:	80 e0       	ldi	r24, 0x00	; 0
    568c:	90 e0       	ldi	r25, 0x00	; 0
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	ptr[i] = val[i];
    568e:	2d 91       	ld	r18, X+
    5690:	21 93       	st	Z+, r18

  if(vallen < 8) {
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5692:	01 96       	adiw	r24, 0x01	; 1
    5694:	86 15       	cp	r24, r6
    5696:	97 05       	cpc	r25, r7
    5698:	d4 f3       	brlt	.-12     	; 0x568e <set_bits+0x54>
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	ptr[i] = val[i];
      }
      bits = vallen & 7;
    569a:	97 01       	movw	r18, r14
    569c:	27 70       	andi	r18, 0x07	; 7
    569e:	30 70       	andi	r19, 0x00	; 0
      if(bits) {
    56a0:	21 15       	cp	r18, r1
    56a2:	31 05       	cpc	r19, r1
    56a4:	d9 f1       	breq	.+118    	; 0x571c <set_bits+0xe2>
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
    56a6:	f6 01       	movw	r30, r12
    56a8:	e8 0f       	add	r30, r24
    56aa:	f9 1f       	adc	r31, r25
    56ac:	40 81       	ld	r20, Z
    56ae:	50 e0       	ldi	r21, 0x00	; 0
    56b0:	68 e0       	ldi	r22, 0x08	; 8
    56b2:	70 e0       	ldi	r23, 0x00	; 0
    56b4:	62 1b       	sub	r22, r18
    56b6:	73 0b       	sbc	r23, r19
    56b8:	02 c0       	rjmp	.+4      	; 0x56be <set_bits+0x84>
    56ba:	55 95       	asr	r21
    56bc:	47 95       	ror	r20
    56be:	6a 95       	dec	r22
    56c0:	e2 f7       	brpl	.-8      	; 0x56ba <set_bits+0x80>
    56c2:	80 0f       	add	r24, r16
    56c4:	91 1f       	adc	r25, r17
    56c6:	26 c0       	rjmp	.+76     	; 0x5714 <set_bits+0xda>
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	set_bits_in_byte(&ptr[i], bitpos, val[i], 8);
    56c8:	f4 01       	movw	r30, r8
    56ca:	41 91       	ld	r20, Z+
    56cc:	4f 01       	movw	r8, r30
    56ce:	c8 01       	movw	r24, r16
    56d0:	8c 0f       	add	r24, r28
    56d2:	9d 1f       	adc	r25, r29
    56d4:	b5 01       	movw	r22, r10
    56d6:	28 e0       	ldi	r18, 0x08	; 8
    56d8:	30 e0       	ldi	r19, 0x00	; 0
    56da:	0e 94 09 2b 	call	0x5612	; 0x5612 <set_bits_in_byte>
      bits = vallen & 7;
      if(bits) {
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    56de:	21 96       	adiw	r28, 0x01	; 1
    56e0:	c6 15       	cp	r28, r6
    56e2:	d7 05       	cpc	r29, r7
    56e4:	8c f3       	brlt	.-30     	; 0x56c8 <set_bits+0x8e>
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	set_bits_in_byte(&ptr[i], bitpos, val[i], 8);
      }
      bits = vallen & 7;
    56e6:	97 01       	movw	r18, r14
    56e8:	27 70       	andi	r18, 0x07	; 7
    56ea:	30 70       	andi	r19, 0x00	; 0
      if(bits) {
    56ec:	21 15       	cp	r18, r1
    56ee:	31 05       	cpc	r19, r1
    56f0:	a9 f0       	breq	.+42     	; 0x571c <set_bits+0xe2>
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits + bitpos), bits);
    56f2:	f6 01       	movw	r30, r12
    56f4:	ec 0f       	add	r30, r28
    56f6:	fd 1f       	adc	r31, r29
    56f8:	40 81       	ld	r20, Z
    56fa:	50 e0       	ldi	r21, 0x00	; 0
    56fc:	c5 01       	movw	r24, r10
    56fe:	08 96       	adiw	r24, 0x08	; 8
    5700:	82 1b       	sub	r24, r18
    5702:	93 0b       	sbc	r25, r19
    5704:	02 c0       	rjmp	.+4      	; 0x570a <set_bits+0xd0>
    5706:	55 95       	asr	r21
    5708:	47 95       	ror	r20
    570a:	8a 95       	dec	r24
    570c:	e2 f7       	brpl	.-8      	; 0x5706 <set_bits+0xcc>
    570e:	c8 01       	movw	r24, r16
    5710:	8c 0f       	add	r24, r28
    5712:	9d 1f       	adc	r25, r29
    5714:	60 e0       	ldi	r22, 0x00	; 0
    5716:	70 e0       	ldi	r23, 0x00	; 0
    5718:	0e 94 09 2b 	call	0x5612	; 0x5612 <set_bits_in_byte>
      }
    }
  }
}
    571c:	df 91       	pop	r29
    571e:	cf 91       	pop	r28
    5720:	1f 91       	pop	r17
    5722:	0f 91       	pop	r16
    5724:	ff 90       	pop	r15
    5726:	ef 90       	pop	r14
    5728:	df 90       	pop	r13
    572a:	cf 90       	pop	r12
    572c:	bf 90       	pop	r11
    572e:	af 90       	pop	r10
    5730:	9f 90       	pop	r9
    5732:	8f 90       	pop	r8
    5734:	7f 90       	pop	r7
    5736:	6f 90       	pop	r6
    5738:	08 95       	ret

0000573a <pack_header>:
}
#endif
/*---------------------------------------------------------------------------*/
static int
pack_header(struct channel *c)
{
    573a:	4f 92       	push	r4
    573c:	5f 92       	push	r5
    573e:	6f 92       	push	r6
    5740:	7f 92       	push	r7
    5742:	8f 92       	push	r8
    5744:	9f 92       	push	r9
    5746:	af 92       	push	r10
    5748:	bf 92       	push	r11
    574a:	cf 92       	push	r12
    574c:	df 92       	push	r13
    574e:	ef 92       	push	r14
    5750:	ff 92       	push	r15
    5752:	0f 93       	push	r16
    5754:	1f 93       	push	r17
    5756:	df 93       	push	r29
    5758:	cf 93       	push	r28
    575a:	00 d0       	rcall	.+0      	; 0x575c <pack_header+0x22>
    575c:	cd b7       	in	r28, 0x3d	; 61
    575e:	de b7       	in	r29, 0x3e	; 62
    5760:	8c 01       	movw	r16, r24
  struct bitopt_hdr *hdr;
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */

  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
    5762:	dc 01       	movw	r26, r24
    5764:	16 96       	adiw	r26, 0x06	; 6
    5766:	4c 91       	ld	r20, X
    5768:	16 97       	sbiw	r26, 0x06	; 6
    576a:	84 2f       	mov	r24, r20
    576c:	90 e0       	ldi	r25, 0x00	; 0
    576e:	87 70       	andi	r24, 0x07	; 7
    5770:	90 70       	andi	r25, 0x00	; 0
    5772:	21 e0       	ldi	r18, 0x01	; 1
    5774:	30 e0       	ldi	r19, 0x00	; 0
    5776:	00 97       	sbiw	r24, 0x00	; 0
    5778:	11 f4       	brne	.+4      	; 0x577e <pack_header+0x44>
    577a:	20 e0       	ldi	r18, 0x00	; 0
    577c:	30 e0       	ldi	r19, 0x00	; 0
    577e:	46 95       	lsr	r20
    5780:	46 95       	lsr	r20
    5782:	46 95       	lsr	r20
    5784:	79 01       	movw	r14, r18
    5786:	e4 0e       	add	r14, r20
    5788:	f1 1c       	adc	r15, r1
  if(packetbuf_hdralloc(hdrbytesize + sizeof(struct bitopt_hdr)) == 0) {
    578a:	c7 01       	movw	r24, r14
    578c:	02 96       	adiw	r24, 0x02	; 2
    578e:	0e 94 70 32 	call	0x64e0	; 0x64e0 <packetbuf_hdralloc>
    5792:	00 97       	sbiw	r24, 0x00	; 0
    5794:	09 f4       	brne	.+2      	; 0x5798 <pack_header+0x5e>
    5796:	53 c0       	rjmp	.+166    	; 0x583e <pack_header+0x104>
    PRINTF("chameleon-bitopt: insufficient space for headers\n");
    return 0;
  }
  hdr = (struct bitopt_hdr *)packetbuf_hdrptr();
    5798:	0e 94 10 32 	call	0x6420	; 0x6420 <packetbuf_hdrptr>
    579c:	fc 01       	movw	r30, r24
  hdr->channel[0] = c->channelno & 0xff;
    579e:	d8 01       	movw	r26, r16
    57a0:	12 96       	adiw	r26, 0x02	; 2
    57a2:	8c 91       	ld	r24, X
    57a4:	12 97       	sbiw	r26, 0x02	; 2
    57a6:	80 83       	st	Z, r24
  hdr->channel[1] = (c->channelno >> 8) & 0xff;
    57a8:	13 96       	adiw	r26, 0x03	; 3
    57aa:	8c 91       	ld	r24, X
    57ac:	81 83       	std	Z+1, r24	; 0x01

  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
    57ae:	0e 94 10 32 	call	0x6420	; 0x6420 <packetbuf_hdrptr>
    57b2:	f2 e0       	ldi	r31, 0x02	; 2
    57b4:	6f 2e       	mov	r6, r31
    57b6:	71 2c       	mov	r7, r1
    57b8:	68 0e       	add	r6, r24
    57ba:	79 1e       	adc	r7, r25
  memset(hdrptr, 0, hdrbytesize);
    57bc:	c3 01       	movw	r24, r6
    57be:	60 e0       	ldi	r22, 0x00	; 0
    57c0:	70 e0       	ldi	r23, 0x00	; 0
    57c2:	a7 01       	movw	r20, r14
    57c4:	0e 94 56 4c 	call	0x98ac	; 0x98ac <memset>
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    57c8:	f8 01       	movw	r30, r16
    57ca:	c4 80       	ldd	r12, Z+4	; 0x04
    57cc:	d5 80       	ldd	r13, Z+5	; 0x05
  hdr->channel[1] = (c->channelno >> 8) & 0xff;

  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
    57ce:	00 e0       	ldi	r16, 0x00	; 0
    57d0:	10 e0       	ldi	r17, 0x00	; 0
	    ((uint8_t *)packetbuf_addr(a->type))[0],
	    ((uint8_t *)packetbuf_addr(a->type))[1]);
    } else {
      packetbuf_attr_t val;
      val = packetbuf_attr(a->type);
      set_bits(&hdrptr[byteptr], bitptr & 7,
    57d2:	2e 01       	movw	r4, r28
    57d4:	08 94       	sec
    57d6:	41 1c       	adc	r4, r1
    57d8:	51 1c       	adc	r5, r1
  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    57da:	2a c0       	rjmp	.+84     	; 0x5830 <pack_header+0xf6>
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    PRINTF("%d.%d: pack_header type %d, len %d, bitptr %d, ",
	   rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    57dc:	d6 01       	movw	r26, r12
    57de:	11 96       	adiw	r26, 0x01	; 1
    57e0:	8c 90       	ld	r8, X
    57e2:	11 97       	sbiw	r26, 0x01	; 1
    57e4:	99 24       	eor	r9, r9
    byteptr = bitptr / 8;
    57e6:	78 01       	movw	r14, r16
    57e8:	e3 e0       	ldi	r30, 0x03	; 3
    57ea:	f5 94       	asr	r15
    57ec:	e7 94       	ror	r14
    57ee:	ea 95       	dec	r30
    57f0:	e1 f7       	brne	.-8      	; 0x57ea <pack_header+0xb0>
    57f2:	e6 0c       	add	r14, r6
    57f4:	f7 1c       	adc	r15, r7
    57f6:	77 e0       	ldi	r23, 0x07	; 7
    57f8:	a7 2e       	mov	r10, r23
    57fa:	b1 2c       	mov	r11, r1
    57fc:	a0 22       	and	r10, r16
    57fe:	b1 22       	and	r11, r17
    if(PACKETBUF_IS_ADDR(a->type)) {
    5800:	88 31       	cpi	r24, 0x18	; 24
    5802:	30 f0       	brcs	.+12     	; 0x5810 <pack_header+0xd6>
      set_bits(&hdrptr[byteptr], bitptr & 7,
	       (uint8_t *)packetbuf_addr(a->type), len);
    5804:	0e 94 4f 33 	call	0x669e	; 0x669e <packetbuf_addr>
    5808:	ac 01       	movw	r20, r24
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    byteptr = bitptr / 8;
    if(PACKETBUF_IS_ADDR(a->type)) {
      set_bits(&hdrptr[byteptr], bitptr & 7,
    580a:	c7 01       	movw	r24, r14
    580c:	b5 01       	movw	r22, r10
    580e:	07 c0       	rjmp	.+14     	; 0x581e <pack_header+0xe4>
	    /*	    rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],*/
	    ((uint8_t *)packetbuf_addr(a->type))[0],
	    ((uint8_t *)packetbuf_addr(a->type))[1]);
    } else {
      packetbuf_attr_t val;
      val = packetbuf_attr(a->type);
    5810:	0e 94 3c 33 	call	0x6678	; 0x6678 <packetbuf_attr>
    5814:	9a 83       	std	Y+2, r25	; 0x02
    5816:	89 83       	std	Y+1, r24	; 0x01
      set_bits(&hdrptr[byteptr], bitptr & 7,
    5818:	c7 01       	movw	r24, r14
    581a:	b5 01       	movw	r22, r10
    581c:	a2 01       	movw	r20, r4
    581e:	94 01       	movw	r18, r8
    5820:	0e 94 1d 2b 	call	0x563a	; 0x563a <set_bits>
      PRINTF("value %d\n",
	    /*rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],*/
	    val);
    }
    /*    printhdr(hdrptr, hdrbytesize);*/
    bitptr += len;
    5824:	08 0d       	add	r16, r8
    5826:	19 1d       	adc	r17, r9
  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    5828:	e2 e0       	ldi	r30, 0x02	; 2
    582a:	f0 e0       	ldi	r31, 0x00	; 0
    582c:	ce 0e       	add	r12, r30
    582e:	df 1e       	adc	r13, r31
    5830:	d6 01       	movw	r26, r12
    5832:	8c 91       	ld	r24, X
    5834:	88 23       	and	r24, r24
    5836:	91 f6       	brne	.-92     	; 0x57dc <pack_header+0xa2>
    /*    printhdr(hdrptr, hdrbytesize);*/
    bitptr += len;
  }
  /*  printhdr(hdrptr, hdrbytesize);*/

  return 1; /* Send out packet */
    5838:	21 e0       	ldi	r18, 0x01	; 1
    583a:	30 e0       	ldi	r19, 0x00	; 0
    583c:	02 c0       	rjmp	.+4      	; 0x5842 <pack_header+0x108>
     all attributes that are used on this channel. */

  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdralloc(hdrbytesize + sizeof(struct bitopt_hdr)) == 0) {
    PRINTF("chameleon-bitopt: insufficient space for headers\n");
    return 0;
    583e:	20 e0       	ldi	r18, 0x00	; 0
    5840:	30 e0       	ldi	r19, 0x00	; 0
    bitptr += len;
  }
  /*  printhdr(hdrptr, hdrbytesize);*/

  return 1; /* Send out packet */
}
    5842:	c9 01       	movw	r24, r18
    5844:	0f 90       	pop	r0
    5846:	0f 90       	pop	r0
    5848:	cf 91       	pop	r28
    584a:	df 91       	pop	r29
    584c:	1f 91       	pop	r17
    584e:	0f 91       	pop	r16
    5850:	ff 90       	pop	r15
    5852:	ef 90       	pop	r14
    5854:	df 90       	pop	r13
    5856:	cf 90       	pop	r12
    5858:	bf 90       	pop	r11
    585a:	af 90       	pop	r10
    585c:	9f 90       	pop	r9
    585e:	8f 90       	pop	r8
    5860:	7f 90       	pop	r7
    5862:	6f 90       	pop	r6
    5864:	5f 90       	pop	r5
    5866:	4f 90       	pop	r4
    5868:	08 95       	ret

0000586a <send_packet>:

/*---------------------------------------------------------------------------*/
static void
send_packet(mac_callback_t sent, void *ptr)
{
  NETSTACK_RDC.send(sent, ptr);
    586a:	e0 91 88 0e 	lds	r30, 0x0E88
    586e:	f0 91 89 0e 	lds	r31, 0x0E89
    5872:	09 95       	icall
}
    5874:	08 95       	ret

00005876 <packet_input>:
/*---------------------------------------------------------------------------*/
static void
packet_input(void)
{
  NETSTACK_NETWORK.input();
    5876:	e0 91 44 0e 	lds	r30, 0x0E44
    587a:	f0 91 45 0e 	lds	r31, 0x0E45
    587e:	09 95       	icall
}
    5880:	08 95       	ret

00005882 <on>:
/*---------------------------------------------------------------------------*/
static int
on(void)
{
  return NETSTACK_RDC.on();
    5882:	e0 91 8e 0e 	lds	r30, 0x0E8E
    5886:	f0 91 8f 0e 	lds	r31, 0x0E8F
    588a:	09 95       	icall
}
    588c:	08 95       	ret

0000588e <off>:
/*---------------------------------------------------------------------------*/
static int
off(int keep_radio_on)
{
  return NETSTACK_RDC.off(keep_radio_on);
    588e:	e0 91 90 0e 	lds	r30, 0x0E90
    5892:	f0 91 91 0e 	lds	r31, 0x0E91
    5896:	09 95       	icall
}
    5898:	08 95       	ret

0000589a <channel_check_interval>:
/*---------------------------------------------------------------------------*/
static unsigned short
channel_check_interval(void)
{
  return 0;
}
    589a:	80 e0       	ldi	r24, 0x00	; 0
    589c:	90 e0       	ldi	r25, 0x00	; 0
    589e:	08 95       	ret

000058a0 <init>:
/*---------------------------------------------------------------------------*/
static void
init(void)
{
}
    58a0:	08 95       	ret

000058a2 <on>:
}
/*---------------------------------------------------------------------------*/
static int
on(void)
{
  return NETSTACK_RADIO.on();
    58a2:	e0 91 24 0e 	lds	r30, 0x0E24
    58a6:	f0 91 25 0e 	lds	r31, 0x0E25
    58aa:	09 95       	icall
}
    58ac:	08 95       	ret

000058ae <off>:
/*---------------------------------------------------------------------------*/
static int
off(int keep_radio_on)
{
  if(keep_radio_on) {
    58ae:	00 97       	sbiw	r24, 0x00	; 0
    58b0:	31 f0       	breq	.+12     	; 0x58be <off+0x10>
    return NETSTACK_RADIO.on();
    58b2:	e0 91 24 0e 	lds	r30, 0x0E24
    58b6:	f0 91 25 0e 	lds	r31, 0x0E25
    58ba:	09 95       	icall
    58bc:	08 95       	ret
  } else {
    return NETSTACK_RADIO.off();
    58be:	e0 91 26 0e 	lds	r30, 0x0E26
    58c2:	f0 91 27 0e 	lds	r31, 0x0E27
    58c6:	09 95       	icall
  }
}
    58c8:	08 95       	ret

000058ca <channel_check_interval>:
/*---------------------------------------------------------------------------*/
static unsigned short
channel_check_interval(void)
{
  return 0;
}
    58ca:	80 e0       	ldi	r24, 0x00	; 0
    58cc:	90 e0       	ldi	r25, 0x00	; 0
    58ce:	08 95       	ret

000058d0 <input_packet>:
  }
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
{
    58d0:	0f 93       	push	r16
    58d2:	1f 93       	push	r17
    58d4:	df 93       	push	r29
    58d6:	cf 93       	push	r28
    58d8:	cd b7       	in	r28, 0x3d	; 61
    58da:	de b7       	in	r29, 0x3e	; 62
    58dc:	e0 97       	sbiw	r28, 0x30	; 48
    58de:	0f b6       	in	r0, 0x3f	; 63
    58e0:	f8 94       	cli
    58e2:	de bf       	out	0x3e, r29	; 62
    58e4:	0f be       	out	0x3f, r0	; 63
    58e6:	cd bf       	out	0x3d, r28	; 61
  frame802154_t frame;
  int len;

  len = packetbuf_datalen();
    58e8:	0e 94 5a 32 	call	0x64b4	; 0x64b4 <packetbuf_datalen>
    58ec:	8c 01       	movw	r16, r24

  if(frame802154_parse(packetbuf_dataptr(), len, &frame) &&
    58ee:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    58f2:	60 2f       	mov	r22, r16
    58f4:	ae 01       	movw	r20, r28
    58f6:	4f 5f       	subi	r20, 0xFF	; 255
    58f8:	5f 4f       	sbci	r21, 0xFF	; 255
    58fa:	0e 94 f0 39 	call	0x73e0	; 0x73e0 <frame802154_parse>
    58fe:	88 23       	and	r24, r24
    5900:	09 f4       	brne	.+2      	; 0x5904 <input_packet+0x34>
    5902:	45 c0       	rjmp	.+138    	; 0x598e <input_packet+0xbe>
     packetbuf_hdrreduce(len - frame.payload_len)) {
    5904:	88 a9       	ldd	r24, Y+48	; 0x30
    5906:	98 01       	movw	r18, r16
    5908:	28 1b       	sub	r18, r24
    590a:	31 09       	sbc	r19, r1
    590c:	c9 01       	movw	r24, r18
    590e:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <packetbuf_hdrreduce>
  frame802154_t frame;
  int len;

  len = packetbuf_datalen();

  if(frame802154_parse(packetbuf_dataptr(), len, &frame) &&
    5912:	00 97       	sbiw	r24, 0x00	; 0
    5914:	e1 f1       	breq	.+120    	; 0x598e <input_packet+0xbe>
     packetbuf_hdrreduce(len - frame.payload_len)) {
    if(frame.fcf.dest_addr_mode) {
    5916:	2e 81       	ldd	r18, Y+6	; 0x06
    5918:	22 23       	and	r18, r18
    591a:	71 f1       	breq	.+92     	; 0x5978 <input_packet+0xa8>
      if(frame.dest_pid != mac_src_pan_id &&
    591c:	8a 85       	ldd	r24, Y+10	; 0x0a
    591e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5920:	3b ea       	ldi	r19, 0xAB	; 171
    5922:	8d 3c       	cpi	r24, 0xCD	; 205
    5924:	93 07       	cpc	r25, r19
    5926:	21 f0       	breq	.+8      	; 0x5930 <input_packet+0x60>
    5928:	3f ef       	ldi	r19, 0xFF	; 255
    592a:	8f 3f       	cpi	r24, 0xFF	; 255
    592c:	93 07       	cpc	r25, r19
    592e:	79 f5       	brne	.+94     	; 0x598e <input_packet+0xbe>

/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
    5930:	22 30       	cpi	r18, 0x02	; 2
    5932:	41 f0       	breq	.+16     	; 0x5944 <input_packet+0x74>
    5934:	88 e0       	ldi	r24, 0x08	; 8
    5936:	90 e0       	ldi	r25, 0x00	; 0
    5938:	07 c0       	rjmp	.+14     	; 0x5948 <input_packet+0x78>
  while(i-- > 0) {
    593a:	01 97       	sbiw	r24, 0x01	; 1
    if(addr[i] != 0xff) {
    593c:	22 91       	ld	r18, -Z
    593e:	2f 3f       	cpi	r18, 0xFF	; 255
    5940:	41 f0       	breq	.+16     	; 0x5952 <input_packet+0x82>
    5942:	0b c0       	rjmp	.+22     	; 0x595a <input_packet+0x8a>

/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
    5944:	82 e0       	ldi	r24, 0x02	; 2
    5946:	90 e0       	ldi	r25, 0x00	; 0
    send_packet(sent, ptr);
  }
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
    5948:	fe 01       	movw	r30, r28
    594a:	e8 0f       	add	r30, r24
    594c:	f9 1f       	adc	r31, r25
    594e:	3c 96       	adiw	r30, 0x0c	; 12
    5950:	f4 cf       	rjmp	.-24     	; 0x593a <input_packet+0x6a>
/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
  while(i-- > 0) {
    5952:	18 16       	cp	r1, r24
    5954:	19 06       	cpc	r1, r25
    5956:	8c f3       	brlt	.-30     	; 0x593a <input_packet+0x6a>
    5958:	0f c0       	rjmp	.+30     	; 0x5978 <input_packet+0xa8>
        /* Not broadcast or for our PAN */
        PRINTF("6MAC: for another pan %u\n", frame.dest_pid);
        return;
      }
      if(!is_broadcast_addr(frame.fcf.dest_addr_mode, frame.dest_addr)) {
        packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, (rimeaddr_t *)&frame.dest_addr);
    595a:	89 e1       	ldi	r24, 0x19	; 25
    595c:	be 01       	movw	r22, r28
    595e:	64 5f       	subi	r22, 0xF4	; 244
    5960:	7f 4f       	sbci	r23, 0xFF	; 255
    5962:	0e 94 45 33 	call	0x668a	; 0x668a <packetbuf_set_addr>
        if(!rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    5966:	89 e1       	ldi	r24, 0x19	; 25
    5968:	0e 94 4f 33 	call	0x669e	; 0x669e <packetbuf_addr>
    596c:	6b ed       	ldi	r22, 0xDB	; 219
    596e:	76 e2       	ldi	r23, 0x26	; 38
    5970:	0e 94 12 26 	call	0x4c24	; 0x4c24 <rimeaddr_cmp>
    5974:	00 97       	sbiw	r24, 0x00	; 0
    5976:	59 f0       	breq	.+22     	; 0x598e <input_packet+0xbe>
          PRINTF("6MAC: not for us\n");
          return;
        }
      }
    }
    packetbuf_set_addr(PACKETBUF_ADDR_SENDER, (rimeaddr_t *)&frame.src_addr);
    5978:	88 e1       	ldi	r24, 0x18	; 24
    597a:	be 01       	movw	r22, r28
    597c:	6a 5e       	subi	r22, 0xEA	; 234
    597e:	7f 4f       	sbci	r23, 0xFF	; 255
    5980:	0e 94 45 33 	call	0x668a	; 0x668a <packetbuf_set_addr>

    PRINTF("6MAC-IN: %2X", frame.fcf.frame_type);
    PRINTADDR(packetbuf_addr(PACKETBUF_ADDR_SENDER));
    PRINTADDR(packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    PRINTF("%u\n", packetbuf_datalen());
    NETSTACK_MAC.input();
    5984:	e0 91 71 0e 	lds	r30, 0x0E71
    5988:	f0 91 72 0e 	lds	r31, 0x0E72
    598c:	09 95       	icall
  } else {
    PRINTF("6MAC: failed to parse hdr\n");
  }
}
    598e:	e0 96       	adiw	r28, 0x30	; 48
    5990:	0f b6       	in	r0, 0x3f	; 63
    5992:	f8 94       	cli
    5994:	de bf       	out	0x3e, r29	; 62
    5996:	0f be       	out	0x3f, r0	; 63
    5998:	cd bf       	out	0x3d, r28	; 61
    599a:	cf 91       	pop	r28
    599c:	df 91       	pop	r29
    599e:	1f 91       	pop	r17
    59a0:	0f 91       	pop	r16
    59a2:	08 95       	ret

000059a4 <send_packet>:
  return 1;
}
/*---------------------------------------------------------------------------*/
static void
send_packet(mac_callback_t sent, void *ptr)
{
    59a4:	af 92       	push	r10
    59a6:	bf 92       	push	r11
    59a8:	cf 92       	push	r12
    59aa:	df 92       	push	r13
    59ac:	ef 92       	push	r14
    59ae:	ff 92       	push	r15
    59b0:	0f 93       	push	r16
    59b2:	1f 93       	push	r17
    59b4:	df 93       	push	r29
    59b6:	cf 93       	push	r28
    59b8:	cd b7       	in	r28, 0x3d	; 61
    59ba:	de b7       	in	r29, 0x3e	; 62
    59bc:	e0 97       	sbiw	r28, 0x30	; 48
    59be:	0f b6       	in	r0, 0x3f	; 63
    59c0:	f8 94       	cli
    59c2:	de bf       	out	0x3e, r29	; 62
    59c4:	0f be       	out	0x3f, r0	; 63
    59c6:	cd bf       	out	0x3d, r28	; 61
    59c8:	6c 01       	movw	r12, r24
    59ca:	8b 01       	movw	r16, r22
  frame802154_t params;
  uint8_t len;

  /* init to zeros */
  memset(&params, 0, sizeof(params));
    59cc:	fe 01       	movw	r30, r28
    59ce:	31 96       	adiw	r30, 0x01	; 1
    59d0:	80 e3       	ldi	r24, 0x30	; 48
    59d2:	df 01       	movw	r26, r30
    59d4:	1d 92       	st	X+, r1
    59d6:	8a 95       	dec	r24
    59d8:	e9 f7       	brne	.-6      	; 0x59d4 <send_packet+0x30>

  /* Build the FCF. */
  params.fcf.frame_type = FRAME802154_DATAFRAME;
    59da:	81 e0       	ldi	r24, 0x01	; 1
    59dc:	89 83       	std	Y+1, r24	; 0x01
  params.fcf.security_enabled = 0;
  params.fcf.frame_pending = 0;
  params.fcf.ack_required = packetbuf_attr(PACKETBUF_ATTR_RELIABLE);
    59de:	8c e0       	ldi	r24, 0x0C	; 12
    59e0:	0e 94 3c 33 	call	0x6678	; 0x6678 <packetbuf_attr>
    59e4:	8c 83       	std	Y+4, r24	; 0x04
  params.fcf.panid_compression = 0;
    59e6:	1d 82       	std	Y+5, r1	; 0x05

  /* Insert IEEE 802.15.4 (2003) version bit. */
  params.fcf.frame_version = FRAME802154_IEEE802154_2003;
    59e8:	1f 82       	std	Y+7, r1	; 0x07

  /* Increment and set the data sequence number. */
  params.seq = mac_dsn++;
    59ea:	80 91 e0 1d 	lds	r24, 0x1DE0
    59ee:	89 87       	std	Y+9, r24	; 0x09
    59f0:	8f 5f       	subi	r24, 0xFF	; 255
    59f2:	80 93 e0 1d 	sts	0x1DE0, r24
  /* Complete the addressing fields. */
  /**
     \todo For phase 1 the addresses are all long. We'll need a mechanism
     in the rime attributes to tell the mac to use long or short for phase 2.
  */
  params.fcf.src_addr_mode = FRAME802154_LONGADDRMODE;
    59f6:	83 e0       	ldi	r24, 0x03	; 3
    59f8:	e8 2e       	mov	r14, r24
    59fa:	e8 86       	std	Y+8, r14	; 0x08
  params.dest_pid = mac_dst_pan_id;
    59fc:	8d ec       	ldi	r24, 0xCD	; 205
    59fe:	9b ea       	ldi	r25, 0xAB	; 171
    5a00:	9b 87       	std	Y+11, r25	; 0x0b
    5a02:	8a 87       	std	Y+10, r24	; 0x0a

  /*
   *  If the output address is NULL in the Rime buf, then it is broadcast
   *  on the 802.15.4 network.
   */
  if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER), &rimeaddr_null)) {
    5a04:	89 e1       	ldi	r24, 0x19	; 25
    5a06:	0e 94 4f 33 	call	0x669e	; 0x669e <packetbuf_addr>
    5a0a:	69 e3       	ldi	r22, 0x39	; 57
    5a0c:	7e e0       	ldi	r23, 0x0E	; 14
    5a0e:	0e 94 12 26 	call	0x4c24	; 0x4c24 <rimeaddr_cmp>
    5a12:	00 97       	sbiw	r24, 0x00	; 0
    5a14:	31 f0       	breq	.+12     	; 0x5a22 <send_packet+0x7e>
    /* Broadcast requires short address mode. */
    params.fcf.dest_addr_mode = FRAME802154_SHORTADDRMODE;
    5a16:	82 e0       	ldi	r24, 0x02	; 2
    5a18:	8e 83       	std	Y+6, r24	; 0x06
    params.dest_addr[0] = 0xFF;
    5a1a:	8f ef       	ldi	r24, 0xFF	; 255
    5a1c:	8c 87       	std	Y+12, r24	; 0x0c
    params.dest_addr[1] = 0xFF;
    5a1e:	8d 87       	std	Y+13, r24	; 0x0d
    5a20:	09 c0       	rjmp	.+18     	; 0x5a34 <send_packet+0x90>

  } else {
    rimeaddr_copy((rimeaddr_t *)&params.dest_addr,
    5a22:	89 e1       	ldi	r24, 0x19	; 25
    5a24:	0e 94 4f 33 	call	0x669e	; 0x669e <packetbuf_addr>
    5a28:	bc 01       	movw	r22, r24
    5a2a:	ce 01       	movw	r24, r28
    5a2c:	0c 96       	adiw	r24, 0x0c	; 12
    5a2e:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
                  packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    params.fcf.dest_addr_mode = FRAME802154_LONGADDRMODE;
    5a32:	ee 82       	std	Y+6, r14	; 0x06
  }

  /* Set the source PAN ID to the global variable. */
  params.src_pid = mac_src_pan_id;
    5a34:	8d ec       	ldi	r24, 0xCD	; 205
    5a36:	9b ea       	ldi	r25, 0xAB	; 171
    5a38:	9d 8b       	std	Y+21, r25	; 0x15
    5a3a:	8c 8b       	std	Y+20, r24	; 0x14

  /*
   * Set up the source address using only the long address mode for
   * phase 1.
   */
  rimeaddr_copy((rimeaddr_t *)&params.src_addr, &rimeaddr_node_addr);
    5a3c:	ce 01       	movw	r24, r28
    5a3e:	46 96       	adiw	r24, 0x16	; 22
    5a40:	6b ed       	ldi	r22, 0xDB	; 219
    5a42:	76 e2       	ldi	r23, 0x26	; 38
    5a44:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>

  params.payload = packetbuf_dataptr();
    5a48:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_dataptr>
    5a4c:	9f a7       	std	Y+47, r25	; 0x2f
    5a4e:	8e a7       	std	Y+46, r24	; 0x2e
  params.payload_len = packetbuf_datalen();
    5a50:	0e 94 5a 32 	call	0x64b4	; 0x64b4 <packetbuf_datalen>
    5a54:	88 ab       	std	Y+48, r24	; 0x30
  len = frame802154_hdrlen(&params);
    5a56:	7e 01       	movw	r14, r28
    5a58:	08 94       	sec
    5a5a:	e1 1c       	adc	r14, r1
    5a5c:	f1 1c       	adc	r15, r1
    5a5e:	c7 01       	movw	r24, r14
    5a60:	0e 94 e7 38 	call	0x71ce	; 0x71ce <frame802154_hdrlen>
    5a64:	a8 2e       	mov	r10, r24
  if(packetbuf_hdralloc(len)) {
    5a66:	90 e0       	ldi	r25, 0x00	; 0
    5a68:	0e 94 70 32 	call	0x64e0	; 0x64e0 <packetbuf_hdralloc>
    5a6c:	00 97       	sbiw	r24, 0x00	; 0
    5a6e:	41 f1       	breq	.+80     	; 0x5ac0 <send_packet+0x11c>
    int ret;
    frame802154_create(&params, packetbuf_hdrptr(), len);
    5a70:	0e 94 10 32 	call	0x6420	; 0x6420 <packetbuf_hdrptr>
    5a74:	bc 01       	movw	r22, r24
    5a76:	c7 01       	movw	r24, r14
    5a78:	4a 2d       	mov	r20, r10
    5a7a:	0e 94 05 39 	call	0x720a	; 0x720a <frame802154_create>

    PRINTF("6MAC-UT: %2X", params.fcf.frame_type);
    PRINTADDR(params.dest_addr.u8);
    PRINTF("%u %u (%u)\n", len, packetbuf_datalen(), packetbuf_totlen());

    ret = NETSTACK_RADIO.send(packetbuf_hdrptr(), packetbuf_totlen());
    5a7e:	a0 90 1a 0e 	lds	r10, 0x0E1A
    5a82:	b0 90 1b 0e 	lds	r11, 0x0E1B
    5a86:	0e 94 10 32 	call	0x6420	; 0x6420 <packetbuf_hdrptr>
    5a8a:	7c 01       	movw	r14, r24
    5a8c:	0e 94 64 32 	call	0x64c8	; 0x64c8 <packetbuf_totlen>
    5a90:	bc 01       	movw	r22, r24
    5a92:	c7 01       	movw	r24, r14
    5a94:	f5 01       	movw	r30, r10
    5a96:	09 95       	icall
    if(sent) {
    5a98:	c1 14       	cp	r12, r1
    5a9a:	d1 04       	cpc	r13, r1
    5a9c:	89 f0       	breq	.+34     	; 0x5ac0 <send_packet+0x11c>
      switch(ret) {
    5a9e:	00 97       	sbiw	r24, 0x00	; 0
    5aa0:	21 f0       	breq	.+8      	; 0x5aaa <send_packet+0x106>
    5aa2:	81 30       	cpi	r24, 0x01	; 1
    5aa4:	91 05       	cpc	r25, r1
    5aa6:	61 f4       	brne	.+24     	; 0x5ac0 <send_packet+0x11c>
    5aa8:	04 c0       	rjmp	.+8      	; 0x5ab2 <send_packet+0x10e>
      case RADIO_TX_OK:
        sent(ptr, MAC_TX_OK, 1);
    5aaa:	c8 01       	movw	r24, r16
    5aac:	60 e0       	ldi	r22, 0x00	; 0
    5aae:	70 e0       	ldi	r23, 0x00	; 0
    5ab0:	03 c0       	rjmp	.+6      	; 0x5ab8 <send_packet+0x114>
        break;
      case RADIO_TX_ERR:
        sent(ptr, MAC_TX_ERR, 1);
    5ab2:	c8 01       	movw	r24, r16
    5ab4:	64 e0       	ldi	r22, 0x04	; 4
    5ab6:	70 e0       	ldi	r23, 0x00	; 0
    5ab8:	41 e0       	ldi	r20, 0x01	; 1
    5aba:	50 e0       	ldi	r21, 0x00	; 0
    5abc:	f6 01       	movw	r30, r12
    5abe:	09 95       	icall
      }
    }
  } else {
    PRINTF("6MAC-UT: too large header: %u\n", len);
  }
}
    5ac0:	e0 96       	adiw	r28, 0x30	; 48
    5ac2:	0f b6       	in	r0, 0x3f	; 63
    5ac4:	f8 94       	cli
    5ac6:	de bf       	out	0x3e, r29	; 62
    5ac8:	0f be       	out	0x3f, r0	; 63
    5aca:	cd bf       	out	0x3d, r28	; 61
    5acc:	cf 91       	pop	r28
    5ace:	df 91       	pop	r29
    5ad0:	1f 91       	pop	r17
    5ad2:	0f 91       	pop	r16
    5ad4:	ff 90       	pop	r15
    5ad6:	ef 90       	pop	r14
    5ad8:	df 90       	pop	r13
    5ada:	cf 90       	pop	r12
    5adc:	bf 90       	pop	r11
    5ade:	af 90       	pop	r10
    5ae0:	08 95       	ret

00005ae2 <init>:
}
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  mac_dsn = random_rand() % 256;
    5ae2:	0e 94 7c 31 	call	0x62f8	; 0x62f8 <random_rand>
    5ae6:	80 93 e0 1d 	sts	0x1DE0, r24

  NETSTACK_RADIO.on();
    5aea:	e0 91 24 0e 	lds	r30, 0x0E24
    5aee:	f0 91 25 0e 	lds	r31, 0x0E25
    5af2:	09 95       	icall
}
    5af4:	08 95       	ret

00005af6 <send_list>:
  }
}
/*---------------------------------------------------------------------------*/
void
send_list(mac_callback_t sent, void *ptr, struct rdc_buf_list *buf_list)
{
    5af6:	0f 93       	push	r16
    5af8:	1f 93       	push	r17
    5afa:	cf 93       	push	r28
    5afc:	df 93       	push	r29
    5afe:	8c 01       	movw	r16, r24
    5b00:	eb 01       	movw	r28, r22
  if(buf_list != NULL) {
    5b02:	41 15       	cp	r20, r1
    5b04:	51 05       	cpc	r21, r1
    5b06:	49 f0       	breq	.+18     	; 0x5b1a <send_list+0x24>
    queuebuf_to_packetbuf(buf_list->buf);
    5b08:	fa 01       	movw	r30, r20
    5b0a:	82 81       	ldd	r24, Z+2	; 0x02
    5b0c:	93 81       	ldd	r25, Z+3	; 0x03
    5b0e:	0e 94 e0 33 	call	0x67c0	; 0x67c0 <queuebuf_to_packetbuf>
    send_packet(sent, ptr);
    5b12:	c8 01       	movw	r24, r16
    5b14:	be 01       	movw	r22, r28
    5b16:	0e 94 d2 2c 	call	0x59a4	; 0x59a4 <send_packet>
  }
}
    5b1a:	df 91       	pop	r29
    5b1c:	cf 91       	pop	r28
    5b1e:	1f 91       	pop	r17
    5b20:	0f 91       	pop	r16
    5b22:	08 95       	ret

00005b24 <autostart_start>:
#endif

/*---------------------------------------------------------------------------*/
void
autostart_start(struct process * const processes[])
{
    5b24:	ef 92       	push	r14
    5b26:	ff 92       	push	r15
    5b28:	cf 93       	push	r28
    5b2a:	df 93       	push	r29
    5b2c:	e8 2e       	mov	r14, r24
    5b2e:	e7 01       	movw	r28, r14
    5b30:	7e 01       	movw	r14, r28
    5b32:	f9 2e       	mov	r15, r25
    5b34:	e7 01       	movw	r28, r14
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5b36:	04 c0       	rjmp	.+8      	; 0x5b40 <autostart_start+0x1c>
    process_start(processes[i], NULL);
    5b38:	60 e0       	ldi	r22, 0x00	; 0
    5b3a:	70 e0       	ldi	r23, 0x00	; 0
    5b3c:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <process_start>
void
autostart_start(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5b40:	89 91       	ld	r24, Y+
    5b42:	99 91       	ld	r25, Y+
    5b44:	00 97       	sbiw	r24, 0x00	; 0
    5b46:	c1 f7       	brne	.-16     	; 0x5b38 <autostart_start+0x14>
    process_start(processes[i], NULL);
    PRINTF("autostart_start: starting process '%s'\n", processes[i]->name);
  }
}
    5b48:	df 91       	pop	r29
    5b4a:	cf 91       	pop	r28
    5b4c:	ff 90       	pop	r15
    5b4e:	ef 90       	pop	r14
    5b50:	08 95       	ret

00005b52 <autostart_exit>:
/*---------------------------------------------------------------------------*/
void
autostart_exit(struct process * const processes[])
{
    5b52:	ef 92       	push	r14
    5b54:	ff 92       	push	r15
    5b56:	cf 93       	push	r28
    5b58:	df 93       	push	r29
    5b5a:	e8 2e       	mov	r14, r24
    5b5c:	e7 01       	movw	r28, r14
    5b5e:	7e 01       	movw	r14, r28
    5b60:	f9 2e       	mov	r15, r25
    5b62:	e7 01       	movw	r28, r14
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5b64:	02 c0       	rjmp	.+4      	; 0x5b6a <autostart_exit+0x18>
    process_exit(processes[i]);
    5b66:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <process_exit>
void
autostart_exit(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5b6a:	89 91       	ld	r24, Y+
    5b6c:	99 91       	ld	r25, Y+
    5b6e:	00 97       	sbiw	r24, 0x00	; 0
    5b70:	d1 f7       	brne	.-12     	; 0x5b66 <autostart_exit+0x14>
    process_exit(processes[i]);
    PRINTF("autostart_exit: stopping process '%s'\n", processes[i]->name);
  }
}
    5b72:	df 91       	pop	r29
    5b74:	cf 91       	pop	r28
    5b76:	ff 90       	pop	r15
    5b78:	ef 90       	pop	r14
    5b7a:	08 95       	ret

00005b7c <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    5b7c:	cf 93       	push	r28
    5b7e:	df 93       	push	r29
    5b80:	ec 01       	movw	r28, r24
  t->interval = interval;
    5b82:	7b 83       	std	Y+3, r23	; 0x03
    5b84:	6a 83       	std	Y+2, r22	; 0x02
  t->start = clock_time();
    5b86:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    5b8a:	99 83       	std	Y+1, r25	; 0x01
    5b8c:	88 83       	st	Y, r24
}
    5b8e:	df 91       	pop	r29
    5b90:	cf 91       	pop	r28
    5b92:	08 95       	ret

00005b94 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    5b94:	fc 01       	movw	r30, r24
  t->start += t->interval;
    5b96:	80 81       	ld	r24, Z
    5b98:	91 81       	ldd	r25, Z+1	; 0x01
    5b9a:	22 81       	ldd	r18, Z+2	; 0x02
    5b9c:	33 81       	ldd	r19, Z+3	; 0x03
    5b9e:	82 0f       	add	r24, r18
    5ba0:	93 1f       	adc	r25, r19
    5ba2:	91 83       	std	Z+1, r25	; 0x01
    5ba4:	80 83       	st	Z, r24
}
    5ba6:	08 95       	ret

00005ba8 <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    5ba8:	cf 93       	push	r28
    5baa:	df 93       	push	r29
    5bac:	ec 01       	movw	r28, r24
  t->start = clock_time();
    5bae:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    5bb2:	99 83       	std	Y+1, r25	; 0x01
    5bb4:	88 83       	st	Y, r24
}
    5bb6:	df 91       	pop	r29
    5bb8:	cf 91       	pop	r28
    5bba:	08 95       	ret

00005bbc <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    5bbc:	cf 93       	push	r28
    5bbe:	df 93       	push	r29
    5bc0:	ec 01       	movw	r28, r24
  /* Note: Can not return diff >= t->interval so we add 1 to diff and return
     t->interval < diff - required to avoid an internal error in mspgcc. */
  clock_time_t diff = (clock_time() - t->start) + 1;
    5bc2:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    5bc6:	28 81       	ld	r18, Y
    5bc8:	39 81       	ldd	r19, Y+1	; 0x01
    5bca:	82 1b       	sub	r24, r18
    5bcc:	93 0b       	sbc	r25, r19
    5bce:	01 96       	adiw	r24, 0x01	; 1
  return t->interval < diff;
    5bd0:	21 e0       	ldi	r18, 0x01	; 1
    5bd2:	30 e0       	ldi	r19, 0x00	; 0
    5bd4:	4a 81       	ldd	r20, Y+2	; 0x02
    5bd6:	5b 81       	ldd	r21, Y+3	; 0x03
    5bd8:	48 17       	cp	r20, r24
    5bda:	59 07       	cpc	r21, r25
    5bdc:	10 f0       	brcs	.+4      	; 0x5be2 <timer_expired+0x26>
    5bde:	20 e0       	ldi	r18, 0x00	; 0
    5be0:	30 e0       	ldi	r19, 0x00	; 0

}
    5be2:	c9 01       	movw	r24, r18
    5be4:	df 91       	pop	r29
    5be6:	cf 91       	pop	r28
    5be8:	08 95       	ret

00005bea <timer_remaining>:
 * \return The time until the timer expires
 *
 */
clock_time_t
timer_remaining(struct timer *t)
{
    5bea:	ef 92       	push	r14
    5bec:	ff 92       	push	r15
    5bee:	cf 93       	push	r28
    5bf0:	df 93       	push	r29
    5bf2:	fc 01       	movw	r30, r24
  return t->start + t->interval - clock_time();
    5bf4:	c2 81       	ldd	r28, Z+2	; 0x02
    5bf6:	d3 81       	ldd	r29, Z+3	; 0x03
    5bf8:	80 81       	ld	r24, Z
    5bfa:	91 81       	ldd	r25, Z+1	; 0x01
    5bfc:	c8 0f       	add	r28, r24
    5bfe:	d9 1f       	adc	r29, r25
    5c00:	0e 94 46 1c 	call	0x388c	; 0x388c <clock_time>
    5c04:	c8 1b       	sub	r28, r24
    5c06:	d9 0b       	sbc	r29, r25
}
    5c08:	ce 01       	movw	r24, r28
    5c0a:	df 91       	pop	r29
    5c0c:	cf 91       	pop	r28
    5c0e:	ff 90       	pop	r15
    5c10:	ef 90       	pop	r14
    5c12:	08 95       	ret

00005c14 <list_init>:
 * \param list The list to be initialized.
 */
void
list_init(list_t list)
{
  *list = NULL;
    5c14:	fc 01       	movw	r30, r24
    5c16:	11 82       	std	Z+1, r1	; 0x01
    5c18:	10 82       	st	Z, r1
}
    5c1a:	08 95       	ret

00005c1c <list_head>:
 *
 * \sa list_tail()
 */
void *
list_head(list_t list)
{
    5c1c:	fc 01       	movw	r30, r24
  return *list;
}
    5c1e:	80 81       	ld	r24, Z
    5c20:	91 81       	ldd	r25, Z+1	; 0x01
    5c22:	08 95       	ret

00005c24 <list_copy>:
 * \param src The source list.
 */
void
list_copy(list_t dest, list_t src)
{
  *dest = *src;
    5c24:	fb 01       	movw	r30, r22
    5c26:	20 81       	ld	r18, Z
    5c28:	31 81       	ldd	r19, Z+1	; 0x01
    5c2a:	fc 01       	movw	r30, r24
    5c2c:	31 83       	std	Z+1, r19	; 0x01
    5c2e:	20 83       	st	Z, r18
}
    5c30:	08 95       	ret

00005c32 <list_tail>:
void *
list_tail(list_t list)
{
  struct list *l;
  
  if(*list == NULL) {
    5c32:	fc 01       	movw	r30, r24
    5c34:	20 81       	ld	r18, Z
    5c36:	31 81       	ldd	r19, Z+1	; 0x01
    5c38:	21 15       	cp	r18, r1
    5c3a:	31 05       	cpc	r19, r1
    5c3c:	11 f4       	brne	.+4      	; 0x5c42 <list_tail+0x10>
    5c3e:	07 c0       	rjmp	.+14     	; 0x5c4e <list_tail+0x1c>
    return NULL;
  }
  
  for(l = *list; l->next != NULL; l = l->next);
    5c40:	9c 01       	movw	r18, r24
    5c42:	f9 01       	movw	r30, r18
    5c44:	80 81       	ld	r24, Z
    5c46:	91 81       	ldd	r25, Z+1	; 0x01
    5c48:	00 97       	sbiw	r24, 0x00	; 0
    5c4a:	d1 f7       	brne	.-12     	; 0x5c40 <list_tail+0xe>
    5c4c:	02 c0       	rjmp	.+4      	; 0x5c52 <list_tail+0x20>
list_tail(list_t list)
{
  struct list *l;
  
  if(*list == NULL) {
    return NULL;
    5c4e:	20 e0       	ldi	r18, 0x00	; 0
    5c50:	30 e0       	ldi	r19, 0x00	; 0
  }
  
  for(l = *list; l->next != NULL; l = l->next);
  
  return l;
}
    5c52:	c9 01       	movw	r24, r18
    5c54:	08 95       	ret

00005c56 <list_chop>:
 * \return The removed object
 *
 */
void *
list_chop(list_t list)
{
    5c56:	cf 93       	push	r28
    5c58:	df 93       	push	r29
    5c5a:	dc 01       	movw	r26, r24
  struct list *l, *r;
  
  if(*list == NULL) {
    5c5c:	2d 91       	ld	r18, X+
    5c5e:	3c 91       	ld	r19, X
    5c60:	11 97       	sbiw	r26, 0x01	; 1
    5c62:	21 15       	cp	r18, r1
    5c64:	31 05       	cpc	r19, r1
    5c66:	a9 f0       	breq	.+42     	; 0x5c92 <list_chop+0x3c>
    return NULL;
  }
  if(((struct list *)*list)->next == NULL) {
    5c68:	f9 01       	movw	r30, r18
    5c6a:	80 81       	ld	r24, Z
    5c6c:	91 81       	ldd	r25, Z+1	; 0x01
    5c6e:	00 97       	sbiw	r24, 0x00	; 0
    5c70:	29 f4       	brne	.+10     	; 0x5c7c <list_chop+0x26>
    l = *list;
    *list = NULL;
    5c72:	11 96       	adiw	r26, 0x01	; 1
    5c74:	1c 92       	st	X, r1
    5c76:	1e 92       	st	-X, r1
    return l;
    5c78:	0e c0       	rjmp	.+28     	; 0x5c96 <list_chop+0x40>
  }
  
  for(l = *list; l->next->next != NULL; l = l->next);
    5c7a:	f9 01       	movw	r30, r18
    5c7c:	20 81       	ld	r18, Z
    5c7e:	31 81       	ldd	r19, Z+1	; 0x01
    5c80:	d9 01       	movw	r26, r18
    5c82:	8d 91       	ld	r24, X+
    5c84:	9c 91       	ld	r25, X
    5c86:	11 97       	sbiw	r26, 0x01	; 1
    5c88:	00 97       	sbiw	r24, 0x00	; 0
    5c8a:	b9 f7       	brne	.-18     	; 0x5c7a <list_chop+0x24>

  r = l->next;
  l->next = NULL;
    5c8c:	11 82       	std	Z+1, r1	; 0x01
    5c8e:	10 82       	st	Z, r1
  
  return r;
    5c90:	02 c0       	rjmp	.+4      	; 0x5c96 <list_chop+0x40>
list_chop(list_t list)
{
  struct list *l, *r;
  
  if(*list == NULL) {
    return NULL;
    5c92:	20 e0       	ldi	r18, 0x00	; 0
    5c94:	30 e0       	ldi	r19, 0x00	; 0

  r = l->next;
  l->next = NULL;
  
  return r;
}
    5c96:	c9 01       	movw	r24, r18
    5c98:	df 91       	pop	r29
    5c9a:	cf 91       	pop	r28
    5c9c:	08 95       	ret

00005c9e <list_pop>:
 * \return Pointer to the removed element of list.
 */
/*---------------------------------------------------------------------------*/
void *
list_pop(list_t list)
{
    5c9e:	dc 01       	movw	r26, r24
  struct list *l;
  l = *list;
    5ca0:	ed 91       	ld	r30, X+
    5ca2:	fc 91       	ld	r31, X
    5ca4:	11 97       	sbiw	r26, 0x01	; 1
  if(*list != NULL) {
    5ca6:	30 97       	sbiw	r30, 0x00	; 0
    5ca8:	29 f0       	breq	.+10     	; 0x5cb4 <list_pop+0x16>
    *list = ((struct list *)*list)->next;
    5caa:	80 81       	ld	r24, Z
    5cac:	91 81       	ldd	r25, Z+1	; 0x01
    5cae:	11 96       	adiw	r26, 0x01	; 1
    5cb0:	9c 93       	st	X, r25
    5cb2:	8e 93       	st	-X, r24
  }

  return l;
}
    5cb4:	cf 01       	movw	r24, r30
    5cb6:	08 95       	ret

00005cb8 <list_remove>:
 *
 */
/*---------------------------------------------------------------------------*/
void
list_remove(list_t list, void *item)
{
    5cb8:	cf 93       	push	r28
    5cba:	df 93       	push	r29
    5cbc:	fc 01       	movw	r30, r24
  struct list *l, *r;
  
  if(*list == NULL) {
    5cbe:	a0 81       	ld	r26, Z
    5cc0:	b1 81       	ldd	r27, Z+1	; 0x01
    5cc2:	10 97       	sbiw	r26, 0x00	; 0
    5cc4:	d9 f0       	breq	.+54     	; 0x5cfc <list_remove+0x44>
    return;
  }
  
  r = NULL;
    5cc6:	c0 e0       	ldi	r28, 0x00	; 0
    5cc8:	d0 e0       	ldi	r29, 0x00	; 0
  for(l = *list; l != NULL; l = l->next) {
    5cca:	16 c0       	rjmp	.+44     	; 0x5cf8 <list_remove+0x40>
    if(l == item) {
    5ccc:	a6 17       	cp	r26, r22
    5cce:	b7 07       	cpc	r27, r23
    5cd0:	71 f4       	brne	.+28     	; 0x5cee <list_remove+0x36>
    5cd2:	8d 91       	ld	r24, X+
    5cd4:	9c 91       	ld	r25, X
    5cd6:	11 97       	sbiw	r26, 0x01	; 1
      if(r == NULL) {
    5cd8:	20 97       	sbiw	r28, 0x00	; 0
    5cda:	19 f4       	brne	.+6      	; 0x5ce2 <list_remove+0x2a>
	/* First on list */
	*list = l->next;
    5cdc:	91 83       	std	Z+1, r25	; 0x01
    5cde:	80 83       	st	Z, r24
    5ce0:	02 c0       	rjmp	.+4      	; 0x5ce6 <list_remove+0x2e>
      } else {
	/* Not first on list */
	r->next = l->next;
    5ce2:	99 83       	std	Y+1, r25	; 0x01
    5ce4:	88 83       	st	Y, r24
      }
      l->next = NULL;
    5ce6:	11 96       	adiw	r26, 0x01	; 1
    5ce8:	1c 92       	st	X, r1
    5cea:	1e 92       	st	-X, r1
      return;
    5cec:	07 c0       	rjmp	.+14     	; 0x5cfc <list_remove+0x44>
  if(*list == NULL) {
    return;
  }
  
  r = NULL;
  for(l = *list; l != NULL; l = l->next) {
    5cee:	ed 01       	movw	r28, r26
    5cf0:	98 81       	ld	r25, Y
    5cf2:	89 81       	ldd	r24, Y+1	; 0x01
    5cf4:	a9 2f       	mov	r26, r25
    5cf6:	b8 2f       	mov	r27, r24
    5cf8:	10 97       	sbiw	r26, 0x00	; 0
    5cfa:	41 f7       	brne	.-48     	; 0x5ccc <list_remove+0x14>
      l->next = NULL;
      return;
    }
    r = l;
  }
}
    5cfc:	df 91       	pop	r29
    5cfe:	cf 91       	pop	r28
    5d00:	08 95       	ret

00005d02 <list_push>:
/**
 * Add an item to the start of the list.
 */
void
list_push(list_t list, void *item)
{
    5d02:	0f 93       	push	r16
    5d04:	1f 93       	push	r17
    5d06:	cf 93       	push	r28
    5d08:	df 93       	push	r29
    5d0a:	8c 01       	movw	r16, r24
    5d0c:	eb 01       	movw	r28, r22
  /*  struct list *l;*/

  /* Make sure not to add the same element twice */
  list_remove(list, item);
    5d0e:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>

  ((struct list *)item)->next = *list;
    5d12:	f8 01       	movw	r30, r16
    5d14:	80 81       	ld	r24, Z
    5d16:	91 81       	ldd	r25, Z+1	; 0x01
    5d18:	99 83       	std	Y+1, r25	; 0x01
    5d1a:	88 83       	st	Y, r24
  *list = item;
    5d1c:	d1 83       	std	Z+1, r29	; 0x01
    5d1e:	c0 83       	st	Z, r28
}
    5d20:	df 91       	pop	r29
    5d22:	cf 91       	pop	r28
    5d24:	1f 91       	pop	r17
    5d26:	0f 91       	pop	r16
    5d28:	08 95       	ret

00005d2a <list_add>:
 * \sa list_push()
 *
 */
void
list_add(list_t list, void *item)
{
    5d2a:	ef 92       	push	r14
    5d2c:	ff 92       	push	r15
    5d2e:	0f 93       	push	r16
    5d30:	1f 93       	push	r17
    5d32:	cf 93       	push	r28
    5d34:	df 93       	push	r29
    5d36:	ec 01       	movw	r28, r24
    5d38:	7b 01       	movw	r14, r22
  struct list *l;

  /* Make sure not to add the same element twice */
  list_remove(list, item);
    5d3a:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <list_remove>

  ((struct list *)item)->next = NULL;
    5d3e:	f7 01       	movw	r30, r14
    5d40:	11 82       	std	Z+1, r1	; 0x01
    5d42:	10 82       	st	Z, r1
  
  l = list_tail(list);
    5d44:	ce 01       	movw	r24, r28
    5d46:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <list_tail>
    5d4a:	fc 01       	movw	r30, r24

  if(l == NULL) {
    5d4c:	00 97       	sbiw	r24, 0x00	; 0
    5d4e:	19 f4       	brne	.+6      	; 0x5d56 <list_add+0x2c>
    *list = item;
    5d50:	e8 82       	st	Y, r14
    5d52:	f9 82       	std	Y+1, r15	; 0x01
    5d54:	02 c0       	rjmp	.+4      	; 0x5d5a <list_add+0x30>
  } else {
    l->next = item;
    5d56:	f1 82       	std	Z+1, r15	; 0x01
    5d58:	e0 82       	st	Z, r14
  }
}
    5d5a:	df 91       	pop	r29
    5d5c:	cf 91       	pop	r28
    5d5e:	1f 91       	pop	r17
    5d60:	0f 91       	pop	r16
    5d62:	ff 90       	pop	r15
    5d64:	ef 90       	pop	r14
    5d66:	08 95       	ret

00005d68 <list_length>:
list_length(list_t list)
{
  struct list *l;
  int n = 0;

  for(l = *list; l != NULL; l = l->next) {
    5d68:	dc 01       	movw	r26, r24
    5d6a:	ed 91       	ld	r30, X+
    5d6c:	fc 91       	ld	r31, X
    5d6e:	11 97       	sbiw	r26, 0x01	; 1
/*---------------------------------------------------------------------------*/
int
list_length(list_t list)
{
  struct list *l;
  int n = 0;
    5d70:	20 e0       	ldi	r18, 0x00	; 0
    5d72:	30 e0       	ldi	r19, 0x00	; 0

  for(l = *list; l != NULL; l = l->next) {
    5d74:	05 c0       	rjmp	.+10     	; 0x5d80 <list_length+0x18>
    ++n;
    5d76:	2f 5f       	subi	r18, 0xFF	; 255
    5d78:	3f 4f       	sbci	r19, 0xFF	; 255
list_length(list_t list)
{
  struct list *l;
  int n = 0;

  for(l = *list; l != NULL; l = l->next) {
    5d7a:	01 90       	ld	r0, Z+
    5d7c:	f0 81       	ld	r31, Z
    5d7e:	e0 2d       	mov	r30, r0
    5d80:	30 97       	sbiw	r30, 0x00	; 0
    5d82:	c9 f7       	brne	.-14     	; 0x5d76 <list_length+0xe>
    ++n;
  }

  return n;
}
    5d84:	c9 01       	movw	r24, r18
    5d86:	08 95       	ret

00005d88 <list_insert>:
 *             start of the list.
 *
 */
void
list_insert(list_t list, void *previtem, void *newitem)
{
    5d88:	fb 01       	movw	r30, r22
  if(previtem == NULL) {
    5d8a:	30 97       	sbiw	r30, 0x00	; 0
    5d8c:	21 f4       	brne	.+8      	; 0x5d96 <list_insert+0xe>
    list_push(list, newitem);
    5d8e:	ba 01       	movw	r22, r20
    5d90:	0e 94 81 2e 	call	0x5d02	; 0x5d02 <list_push>
    5d94:	08 95       	ret
  } else {
  
    ((struct list *)newitem)->next = ((struct list *)previtem)->next;
    5d96:	da 01       	movw	r26, r20
    5d98:	80 81       	ld	r24, Z
    5d9a:	91 81       	ldd	r25, Z+1	; 0x01
    5d9c:	11 96       	adiw	r26, 0x01	; 1
    5d9e:	9c 93       	st	X, r25
    5da0:	8e 93       	st	-X, r24
    ((struct list *)previtem)->next = newitem;
    5da2:	51 83       	std	Z+1, r21	; 0x01
    5da4:	40 83       	st	Z, r20
    5da6:	08 95       	ret

00005da8 <list_item_next>:
 *             lists.
 */
void *
list_item_next(void *item)
{
  return item == NULL? NULL: ((struct list *)item)->next;
    5da8:	00 97       	sbiw	r24, 0x00	; 0
    5daa:	21 f0       	breq	.+8      	; 0x5db4 <list_item_next+0xc>
    5dac:	fc 01       	movw	r30, r24
    5dae:	20 81       	ld	r18, Z
    5db0:	31 81       	ldd	r19, Z+1	; 0x01
    5db2:	02 c0       	rjmp	.+4      	; 0x5db8 <list_item_next+0x10>
    5db4:	20 e0       	ldi	r18, 0x00	; 0
    5db6:	30 e0       	ldi	r19, 0x00	; 0
}
    5db8:	c9 01       	movw	r24, r18
    5dba:	08 95       	ret

00005dbc <energest_init>:
unsigned char energest_current_mode[ENERGEST_TYPE_MAX];

/*---------------------------------------------------------------------------*/
void
energest_init(void)
{
    5dbc:	cf 93       	push	r28
    5dbe:	df 93       	push	r29
    5dc0:	e3 e6       	ldi	r30, 0x63	; 99
    5dc2:	f7 e2       	ldi	r31, 0x27	; 39
    5dc4:	c5 e2       	ldi	r28, 0x25	; 37
    5dc6:	d7 e2       	ldi	r29, 0x27	; 39
    5dc8:	a7 e5       	ldi	r26, 0x57	; 87
    5dca:	b7 e2       	ldi	r27, 0x27	; 39
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; ++i) {
    energest_total_time[i].current = energest_current_time[i] = 0;
    5dcc:	11 92       	st	Z+, r1
    5dce:	11 92       	st	Z+, r1
    5dd0:	19 92       	st	Y+, r1
    5dd2:	19 92       	st	Y+, r1
    5dd4:	19 92       	st	Y+, r1
    5dd6:	19 92       	st	Y+, r1
    energest_current_mode[i] = 0;
    5dd8:	1d 92       	st	X+, r1
/*---------------------------------------------------------------------------*/
void
energest_init(void)
{
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; ++i) {
    5dda:	87 e2       	ldi	r24, 0x27	; 39
    5ddc:	eb 37       	cpi	r30, 0x7B	; 123
    5dde:	f8 07       	cpc	r31, r24
    5de0:	a9 f7       	brne	.-22     	; 0x5dcc <energest_init+0x10>
#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
  for(i = 0; i < ENERGEST_CONF_LEVELDEVICE_LEVELS; ++i) {
    energest_leveldevice_current_leveltime[i].current = 0;
  }
#endif
}
    5de2:	df 91       	pop	r29
    5de4:	cf 91       	pop	r28
    5de6:	08 95       	ret

00005de8 <energest_type_time>:
/*---------------------------------------------------------------------------*/
unsigned long
energest_type_time(int type)
{
    5de8:	0f 93       	push	r16
    5dea:	1f 93       	push	r17
    5dec:	cf 93       	push	r28
    5dee:	df 93       	push	r29
    5df0:	fc 01       	movw	r30, r24
  /* Note: does not support ENERGEST_CONF_LEVELDEVICE_LEVELS! */
#ifndef ENERGEST_CONF_LEVELDEVICE_LEVELS
  if(energest_current_mode[type]) {
    5df2:	dc 01       	movw	r26, r24
    5df4:	a9 5a       	subi	r26, 0xA9	; 169
    5df6:	b8 4d       	sbci	r27, 0xD8	; 216
    5df8:	8c 91       	ld	r24, X
    5dfa:	88 23       	and	r24, r24
    5dfc:	39 f1       	breq	.+78     	; 0x5e4c <energest_type_time+0x64>
    rtimer_clock_t now = RTIMER_NOW();
    5dfe:	00 91 94 00 	lds	r16, 0x0094
    5e02:	10 91 95 00 	lds	r17, 0x0095
    energest_total_time[type].current += (rtimer_clock_t)
    5e06:	ef 01       	movw	r28, r30
    5e08:	cc 0f       	add	r28, r28
    5e0a:	dd 1f       	adc	r29, r29
    5e0c:	cc 0f       	add	r28, r28
    5e0e:	dd 1f       	adc	r29, r29
    5e10:	cb 5d       	subi	r28, 0xDB	; 219
    5e12:	d8 4d       	sbci	r29, 0xD8	; 216
      (now - energest_current_time[type]);
    5e14:	df 01       	movw	r26, r30
    5e16:	aa 0f       	add	r26, r26
    5e18:	bb 1f       	adc	r27, r27
    5e1a:	ad 59       	subi	r26, 0x9D	; 157
    5e1c:	b8 4d       	sbci	r27, 0xD8	; 216
    5e1e:	8d 91       	ld	r24, X+
    5e20:	9c 91       	ld	r25, X
    5e22:	11 97       	sbiw	r26, 0x01	; 1
    5e24:	98 01       	movw	r18, r16
    5e26:	28 1b       	sub	r18, r24
    5e28:	39 0b       	sbc	r19, r25
{
  /* Note: does not support ENERGEST_CONF_LEVELDEVICE_LEVELS! */
#ifndef ENERGEST_CONF_LEVELDEVICE_LEVELS
  if(energest_current_mode[type]) {
    rtimer_clock_t now = RTIMER_NOW();
    energest_total_time[type].current += (rtimer_clock_t)
    5e2a:	40 e0       	ldi	r20, 0x00	; 0
    5e2c:	50 e0       	ldi	r21, 0x00	; 0
    5e2e:	68 81       	ld	r22, Y
    5e30:	79 81       	ldd	r23, Y+1	; 0x01
    5e32:	8a 81       	ldd	r24, Y+2	; 0x02
    5e34:	9b 81       	ldd	r25, Y+3	; 0x03
    5e36:	26 0f       	add	r18, r22
    5e38:	37 1f       	adc	r19, r23
    5e3a:	48 1f       	adc	r20, r24
    5e3c:	59 1f       	adc	r21, r25
    5e3e:	28 83       	st	Y, r18
    5e40:	39 83       	std	Y+1, r19	; 0x01
    5e42:	4a 83       	std	Y+2, r20	; 0x02
    5e44:	5b 83       	std	Y+3, r21	; 0x03
      (now - energest_current_time[type]);
    energest_current_time[type] = now;
    5e46:	11 96       	adiw	r26, 0x01	; 1
    5e48:	1c 93       	st	X, r17
    5e4a:	0e 93       	st	-X, r16
  }
#endif /* ENERGEST_CONF_LEVELDEVICE_LEVELS */
  return energest_total_time[type].current;
    5e4c:	ee 0f       	add	r30, r30
    5e4e:	ff 1f       	adc	r31, r31
    5e50:	ee 0f       	add	r30, r30
    5e52:	ff 1f       	adc	r31, r31
    5e54:	eb 5d       	subi	r30, 0xDB	; 219
    5e56:	f8 4d       	sbci	r31, 0xD8	; 216
#ifndef ENERGEST_CONF_LEVELDEVICE_LEVELS
  if(energest_current_mode[type]) {
    rtimer_clock_t now = RTIMER_NOW();
    energest_total_time[type].current += (rtimer_clock_t)
      (now - energest_current_time[type]);
    energest_current_time[type] = now;
    5e58:	60 81       	ld	r22, Z
    5e5a:	71 81       	ldd	r23, Z+1	; 0x01
  }
#endif /* ENERGEST_CONF_LEVELDEVICE_LEVELS */
  return energest_total_time[type].current;
}
    5e5c:	82 81       	ldd	r24, Z+2	; 0x02
    5e5e:	93 81       	ldd	r25, Z+3	; 0x03
    5e60:	df 91       	pop	r29
    5e62:	cf 91       	pop	r28
    5e64:	1f 91       	pop	r17
    5e66:	0f 91       	pop	r16
    5e68:	08 95       	ret

00005e6a <energest_leveldevice_leveltime>:
#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
  return energest_leveldevice_current_leveltime[powerlevel].current;
#else
  return 0;
#endif
}
    5e6a:	60 e0       	ldi	r22, 0x00	; 0
    5e6c:	70 e0       	ldi	r23, 0x00	; 0
    5e6e:	cb 01       	movw	r24, r22
    5e70:	08 95       	ret

00005e72 <energest_type_set>:
/*---------------------------------------------------------------------------*/
void
energest_type_set(int type, unsigned long val)
{
  energest_total_time[type].current = val;
    5e72:	fc 01       	movw	r30, r24
    5e74:	ee 0f       	add	r30, r30
    5e76:	ff 1f       	adc	r31, r31
    5e78:	ee 0f       	add	r30, r30
    5e7a:	ff 1f       	adc	r31, r31
    5e7c:	eb 5d       	subi	r30, 0xDB	; 219
    5e7e:	f8 4d       	sbci	r31, 0xD8	; 216
    5e80:	40 83       	st	Z, r20
    5e82:	51 83       	std	Z+1, r21	; 0x01
    5e84:	62 83       	std	Z+2, r22	; 0x02
    5e86:	73 83       	std	Z+3, r23	; 0x03
}
    5e88:	08 95       	ret

00005e8a <energest_flush>:
/*---------------------------------------------------------------------------*/
/* Note: does not support ENERGEST_CONF_LEVELDEVICE_LEVELS! */
void
energest_flush(void)
{
    5e8a:	ef 92       	push	r14
    5e8c:	ff 92       	push	r15
    5e8e:	0f 93       	push	r16
    5e90:	1f 93       	push	r17
    5e92:	cf 93       	push	r28
    5e94:	df 93       	push	r29
    5e96:	27 e5       	ldi	r18, 0x57	; 87
    5e98:	37 e2       	ldi	r19, 0x27	; 39
    5e9a:	c5 e2       	ldi	r28, 0x25	; 37
    5e9c:	d7 e2       	ldi	r29, 0x27	; 39
    5e9e:	e3 e6       	ldi	r30, 0x63	; 99
    5ea0:	f7 e2       	ldi	r31, 0x27	; 39
  rtimer_clock_t now;
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; i++) {
    if(energest_current_mode[i]) {
    5ea2:	d9 01       	movw	r26, r18
    5ea4:	8d 91       	ld	r24, X+
    5ea6:	9d 01       	movw	r18, r26
    5ea8:	88 23       	and	r24, r24
    5eaa:	c9 f0       	breq	.+50     	; 0x5ede <energest_flush+0x54>
      now = RTIMER_NOW();
    5eac:	40 91 94 00 	lds	r20, 0x0094
    5eb0:	50 91 95 00 	lds	r21, 0x0095
      energest_total_time[i].current += (rtimer_clock_t)
	(now - energest_current_time[i]);
    5eb4:	80 81       	ld	r24, Z
    5eb6:	91 81       	ldd	r25, Z+1	; 0x01
    5eb8:	7a 01       	movw	r14, r20
    5eba:	e8 1a       	sub	r14, r24
    5ebc:	f9 0a       	sbc	r15, r25
  rtimer_clock_t now;
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; i++) {
    if(energest_current_mode[i]) {
      now = RTIMER_NOW();
      energest_total_time[i].current += (rtimer_clock_t)
    5ebe:	00 e0       	ldi	r16, 0x00	; 0
    5ec0:	10 e0       	ldi	r17, 0x00	; 0
    5ec2:	88 81       	ld	r24, Y
    5ec4:	99 81       	ldd	r25, Y+1	; 0x01
    5ec6:	aa 81       	ldd	r26, Y+2	; 0x02
    5ec8:	bb 81       	ldd	r27, Y+3	; 0x03
    5eca:	8e 0d       	add	r24, r14
    5ecc:	9f 1d       	adc	r25, r15
    5ece:	a0 1f       	adc	r26, r16
    5ed0:	b1 1f       	adc	r27, r17
    5ed2:	88 83       	st	Y, r24
    5ed4:	99 83       	std	Y+1, r25	; 0x01
    5ed6:	aa 83       	std	Y+2, r26	; 0x02
    5ed8:	bb 83       	std	Y+3, r27	; 0x03
	(now - energest_current_time[i]);
      energest_current_time[i] = now;
    5eda:	51 83       	std	Z+1, r21	; 0x01
    5edc:	40 83       	st	Z, r20
    5ede:	24 96       	adiw	r28, 0x04	; 4
    5ee0:	32 96       	adiw	r30, 0x02	; 2
void
energest_flush(void)
{
  rtimer_clock_t now;
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; i++) {
    5ee2:	b7 e2       	ldi	r27, 0x27	; 39
    5ee4:	23 36       	cpi	r18, 0x63	; 99
    5ee6:	3b 07       	cpc	r19, r27
    5ee8:	e1 f6       	brne	.-72     	; 0x5ea2 <energest_flush+0x18>
      energest_total_time[i].current += (rtimer_clock_t)
	(now - energest_current_time[i]);
      energest_current_time[i] = now;
    }
  }
}
    5eea:	df 91       	pop	r29
    5eec:	cf 91       	pop	r28
    5eee:	1f 91       	pop	r17
    5ef0:	0f 91       	pop	r16
    5ef2:	ff 90       	pop	r15
    5ef4:	ef 90       	pop	r14
    5ef6:	08 95       	ret

00005ef8 <rtimer_init>:

/*---------------------------------------------------------------------------*/
void
rtimer_init(void)
{
  rtimer_arch_init();
    5ef8:	0e 94 9a 37 	call	0x6f34	; 0x6f34 <rtimer_arch_init>
}
    5efc:	08 95       	ret

00005efe <rtimer_set>:
/*---------------------------------------------------------------------------*/
int
rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
	   rtimer_clock_t duration,
	   rtimer_callback_t func, void *ptr)
{
    5efe:	0f 93       	push	r16
    5f00:	1f 93       	push	r17
    5f02:	fc 01       	movw	r30, r24
    5f04:	cb 01       	movw	r24, r22
  int first = 0;

  PRINTF("rtimer_set time %d\n", time);

  if(next_rtimer == NULL) {
    5f06:	40 91 e1 1d 	lds	r20, 0x1DE1
    5f0a:	50 91 e2 1d 	lds	r21, 0x1DE2
    first = 1;
  }

  rtimer->func = func;
    5f0e:	33 83       	std	Z+3, r19	; 0x03
    5f10:	22 83       	std	Z+2, r18	; 0x02
  rtimer->ptr = ptr;
    5f12:	15 83       	std	Z+5, r17	; 0x05
    5f14:	04 83       	std	Z+4, r16	; 0x04

  rtimer->time = time;
    5f16:	71 83       	std	Z+1, r23	; 0x01
    5f18:	60 83       	st	Z, r22
  next_rtimer = rtimer;
    5f1a:	f0 93 e2 1d 	sts	0x1DE2, r31
    5f1e:	e0 93 e1 1d 	sts	0x1DE1, r30

  if(first == 1) {
    5f22:	41 15       	cp	r20, r1
    5f24:	51 05       	cpc	r21, r1
    5f26:	11 f4       	brne	.+4      	; 0x5f2c <rtimer_set+0x2e>
    rtimer_arch_schedule(time);
    5f28:	0e 94 b4 37 	call	0x6f68	; 0x6f68 <rtimer_arch_schedule>
  }
  return RTIMER_OK;
}
    5f2c:	80 e0       	ldi	r24, 0x00	; 0
    5f2e:	90 e0       	ldi	r25, 0x00	; 0
    5f30:	1f 91       	pop	r17
    5f32:	0f 91       	pop	r16
    5f34:	08 95       	ret

00005f36 <rtimer_run_next>:
/*---------------------------------------------------------------------------*/
void
rtimer_run_next(void)
{
  struct rtimer *t;
  if(next_rtimer == NULL) {
    5f36:	80 91 e1 1d 	lds	r24, 0x1DE1
    5f3a:	90 91 e2 1d 	lds	r25, 0x1DE2
    5f3e:	00 97       	sbiw	r24, 0x00	; 0
    5f40:	c1 f0       	breq	.+48     	; 0x5f72 <rtimer_run_next+0x3c>
    return;
  }
  t = next_rtimer;
  next_rtimer = NULL;
    5f42:	10 92 e2 1d 	sts	0x1DE2, r1
    5f46:	10 92 e1 1d 	sts	0x1DE1, r1
  t->func(t, t->ptr);
    5f4a:	dc 01       	movw	r26, r24
    5f4c:	14 96       	adiw	r26, 0x04	; 4
    5f4e:	6d 91       	ld	r22, X+
    5f50:	7c 91       	ld	r23, X
    5f52:	15 97       	sbiw	r26, 0x05	; 5
    5f54:	12 96       	adiw	r26, 0x02	; 2
    5f56:	ed 91       	ld	r30, X+
    5f58:	fc 91       	ld	r31, X
    5f5a:	13 97       	sbiw	r26, 0x03	; 3
    5f5c:	09 95       	icall
  if(next_rtimer != NULL) {
    5f5e:	e0 91 e1 1d 	lds	r30, 0x1DE1
    5f62:	f0 91 e2 1d 	lds	r31, 0x1DE2
    5f66:	30 97       	sbiw	r30, 0x00	; 0
    5f68:	21 f0       	breq	.+8      	; 0x5f72 <rtimer_run_next+0x3c>
    rtimer_arch_schedule(next_rtimer->time);
    5f6a:	80 81       	ld	r24, Z
    5f6c:	91 81       	ldd	r25, Z+1	; 0x01
    5f6e:	0e 94 b4 37 	call	0x6f68	; 0x6f68 <rtimer_arch_schedule>
    5f72:	08 95       	ret

00005f74 <print_stats>:
#endif

/*---------------------------------------------------------------------------*/
void
print_stats(void)
{
    5f74:	0f 93       	push	r16
    5f76:	1f 93       	push	r17
  PRINTA("S %d.%d clock %lu tx %lu rx %lu rtx %lu rrx %lu rexmit %lu acktx %lu noacktx %lu ackrx %lu timedout %lu badackrx %lu toolong %lu tooshort %lu badsynch %lu badcrc %lu contentiondrop %lu sendingdrop %lu lltx %lu llrx %lu\n",
    5f78:	00 91 db 26 	lds	r16, 0x26DB
    5f7c:	10 91 dc 26 	lds	r17, 0x26DC
    5f80:	0e 94 53 1c 	call	0x38a6	; 0x38a6 <clock_seconds>
    5f84:	2d b7       	in	r18, 0x3d	; 61
    5f86:	3e b7       	in	r19, 0x3e	; 62
    5f88:	22 55       	subi	r18, 0x52	; 82
    5f8a:	30 40       	sbci	r19, 0x00	; 0
    5f8c:	0f b6       	in	r0, 0x3f	; 63
    5f8e:	f8 94       	cli
    5f90:	3e bf       	out	0x3e, r19	; 62
    5f92:	0f be       	out	0x3f, r0	; 63
    5f94:	2d bf       	out	0x3d, r18	; 61
    5f96:	ed b7       	in	r30, 0x3d	; 61
    5f98:	fe b7       	in	r31, 0x3e	; 62
    5f9a:	31 96       	adiw	r30, 0x01	; 1
    5f9c:	27 e8       	ldi	r18, 0x87	; 135
    5f9e:	32 e0       	ldi	r19, 0x02	; 2
    5fa0:	ad b7       	in	r26, 0x3d	; 61
    5fa2:	be b7       	in	r27, 0x3e	; 62
    5fa4:	12 96       	adiw	r26, 0x02	; 2
    5fa6:	3c 93       	st	X, r19
    5fa8:	2e 93       	st	-X, r18
    5faa:	11 97       	sbiw	r26, 0x01	; 1
    5fac:	02 83       	std	Z+2, r16	; 0x02
    5fae:	13 82       	std	Z+3, r1	; 0x03
    5fb0:	14 83       	std	Z+4, r17	; 0x04
    5fb2:	15 82       	std	Z+5, r1	; 0x05
    5fb4:	66 83       	std	Z+6, r22	; 0x06
    5fb6:	77 83       	std	Z+7, r23	; 0x07
    5fb8:	80 87       	std	Z+8, r24	; 0x08
    5fba:	91 87       	std	Z+9, r25	; 0x09
    5fbc:	80 91 dd 26 	lds	r24, 0x26DD
    5fc0:	90 91 de 26 	lds	r25, 0x26DE
    5fc4:	a0 91 df 26 	lds	r26, 0x26DF
    5fc8:	b0 91 e0 26 	lds	r27, 0x26E0
    5fcc:	82 87       	std	Z+10, r24	; 0x0a
    5fce:	93 87       	std	Z+11, r25	; 0x0b
    5fd0:	a4 87       	std	Z+12, r26	; 0x0c
    5fd2:	b5 87       	std	Z+13, r27	; 0x0d
    5fd4:	80 91 e1 26 	lds	r24, 0x26E1
    5fd8:	90 91 e2 26 	lds	r25, 0x26E2
    5fdc:	a0 91 e3 26 	lds	r26, 0x26E3
    5fe0:	b0 91 e4 26 	lds	r27, 0x26E4
    5fe4:	86 87       	std	Z+14, r24	; 0x0e
    5fe6:	97 87       	std	Z+15, r25	; 0x0f
    5fe8:	a0 8b       	std	Z+16, r26	; 0x10
    5fea:	b1 8b       	std	Z+17, r27	; 0x11
    5fec:	80 91 e5 26 	lds	r24, 0x26E5
    5ff0:	90 91 e6 26 	lds	r25, 0x26E6
    5ff4:	a0 91 e7 26 	lds	r26, 0x26E7
    5ff8:	b0 91 e8 26 	lds	r27, 0x26E8
    5ffc:	82 8b       	std	Z+18, r24	; 0x12
    5ffe:	93 8b       	std	Z+19, r25	; 0x13
    6000:	a4 8b       	std	Z+20, r26	; 0x14
    6002:	b5 8b       	std	Z+21, r27	; 0x15
    6004:	80 91 e9 26 	lds	r24, 0x26E9
    6008:	90 91 ea 26 	lds	r25, 0x26EA
    600c:	a0 91 eb 26 	lds	r26, 0x26EB
    6010:	b0 91 ec 26 	lds	r27, 0x26EC
    6014:	86 8b       	std	Z+22, r24	; 0x16
    6016:	97 8b       	std	Z+23, r25	; 0x17
    6018:	a0 8f       	std	Z+24, r26	; 0x18
    601a:	b1 8f       	std	Z+25, r27	; 0x19
    601c:	80 91 ed 26 	lds	r24, 0x26ED
    6020:	90 91 ee 26 	lds	r25, 0x26EE
    6024:	a0 91 ef 26 	lds	r26, 0x26EF
    6028:	b0 91 f0 26 	lds	r27, 0x26F0
    602c:	82 8f       	std	Z+26, r24	; 0x1a
    602e:	93 8f       	std	Z+27, r25	; 0x1b
    6030:	a4 8f       	std	Z+28, r26	; 0x1c
    6032:	b5 8f       	std	Z+29, r27	; 0x1d
    6034:	80 91 f1 26 	lds	r24, 0x26F1
    6038:	90 91 f2 26 	lds	r25, 0x26F2
    603c:	a0 91 f3 26 	lds	r26, 0x26F3
    6040:	b0 91 f4 26 	lds	r27, 0x26F4
    6044:	86 8f       	std	Z+30, r24	; 0x1e
    6046:	97 8f       	std	Z+31, r25	; 0x1f
    6048:	a0 a3       	std	Z+32, r26	; 0x20
    604a:	b1 a3       	std	Z+33, r27	; 0x21
    604c:	80 91 f5 26 	lds	r24, 0x26F5
    6050:	90 91 f6 26 	lds	r25, 0x26F6
    6054:	a0 91 f7 26 	lds	r26, 0x26F7
    6058:	b0 91 f8 26 	lds	r27, 0x26F8
    605c:	82 a3       	std	Z+34, r24	; 0x22
    605e:	93 a3       	std	Z+35, r25	; 0x23
    6060:	a4 a3       	std	Z+36, r26	; 0x24
    6062:	b5 a3       	std	Z+37, r27	; 0x25
    6064:	80 91 f9 26 	lds	r24, 0x26F9
    6068:	90 91 fa 26 	lds	r25, 0x26FA
    606c:	a0 91 fb 26 	lds	r26, 0x26FB
    6070:	b0 91 fc 26 	lds	r27, 0x26FC
    6074:	86 a3       	std	Z+38, r24	; 0x26
    6076:	97 a3       	std	Z+39, r25	; 0x27
    6078:	a0 a7       	std	Z+40, r26	; 0x28
    607a:	b1 a7       	std	Z+41, r27	; 0x29
    607c:	80 91 fd 26 	lds	r24, 0x26FD
    6080:	90 91 fe 26 	lds	r25, 0x26FE
    6084:	a0 91 ff 26 	lds	r26, 0x26FF
    6088:	b0 91 00 27 	lds	r27, 0x2700
    608c:	82 a7       	std	Z+42, r24	; 0x2a
    608e:	93 a7       	std	Z+43, r25	; 0x2b
    6090:	a4 a7       	std	Z+44, r26	; 0x2c
    6092:	b5 a7       	std	Z+45, r27	; 0x2d
    6094:	80 91 01 27 	lds	r24, 0x2701
    6098:	90 91 02 27 	lds	r25, 0x2702
    609c:	a0 91 03 27 	lds	r26, 0x2703
    60a0:	b0 91 04 27 	lds	r27, 0x2704
    60a4:	86 a7       	std	Z+46, r24	; 0x2e
    60a6:	97 a7       	std	Z+47, r25	; 0x2f
    60a8:	a0 ab       	std	Z+48, r26	; 0x30
    60aa:	b1 ab       	std	Z+49, r27	; 0x31
    60ac:	80 91 05 27 	lds	r24, 0x2705
    60b0:	90 91 06 27 	lds	r25, 0x2706
    60b4:	a0 91 07 27 	lds	r26, 0x2707
    60b8:	b0 91 08 27 	lds	r27, 0x2708
    60bc:	82 ab       	std	Z+50, r24	; 0x32
    60be:	93 ab       	std	Z+51, r25	; 0x33
    60c0:	a4 ab       	std	Z+52, r26	; 0x34
    60c2:	b5 ab       	std	Z+53, r27	; 0x35
    60c4:	80 91 09 27 	lds	r24, 0x2709
    60c8:	90 91 0a 27 	lds	r25, 0x270A
    60cc:	a0 91 0b 27 	lds	r26, 0x270B
    60d0:	b0 91 0c 27 	lds	r27, 0x270C
    60d4:	86 ab       	std	Z+54, r24	; 0x36
    60d6:	97 ab       	std	Z+55, r25	; 0x37
    60d8:	a0 af       	std	Z+56, r26	; 0x38
    60da:	b1 af       	std	Z+57, r27	; 0x39
    60dc:	80 91 0d 27 	lds	r24, 0x270D
    60e0:	90 91 0e 27 	lds	r25, 0x270E
    60e4:	a0 91 0f 27 	lds	r26, 0x270F
    60e8:	b0 91 10 27 	lds	r27, 0x2710
    60ec:	82 af       	std	Z+58, r24	; 0x3a
    60ee:	93 af       	std	Z+59, r25	; 0x3b
    60f0:	a4 af       	std	Z+60, r26	; 0x3c
    60f2:	b5 af       	std	Z+61, r27	; 0x3d
    60f4:	ed b7       	in	r30, 0x3d	; 61
    60f6:	fe b7       	in	r31, 0x3e	; 62
    60f8:	ff 96       	adiw	r30, 0x3f	; 63
    60fa:	80 91 11 27 	lds	r24, 0x2711
    60fe:	90 91 12 27 	lds	r25, 0x2712
    6102:	a0 91 13 27 	lds	r26, 0x2713
    6106:	b0 91 14 27 	lds	r27, 0x2714
    610a:	80 83       	st	Z, r24
    610c:	91 83       	std	Z+1, r25	; 0x01
    610e:	a2 83       	std	Z+2, r26	; 0x02
    6110:	b3 83       	std	Z+3, r27	; 0x03
    6112:	ed b7       	in	r30, 0x3d	; 61
    6114:	fe b7       	in	r31, 0x3e	; 62
    6116:	ed 5b       	subi	r30, 0xBD	; 189
    6118:	ff 4f       	sbci	r31, 0xFF	; 255
    611a:	80 91 15 27 	lds	r24, 0x2715
    611e:	90 91 16 27 	lds	r25, 0x2716
    6122:	a0 91 17 27 	lds	r26, 0x2717
    6126:	b0 91 18 27 	lds	r27, 0x2718
    612a:	80 83       	st	Z, r24
    612c:	91 83       	std	Z+1, r25	; 0x01
    612e:	a2 83       	std	Z+2, r26	; 0x02
    6130:	b3 83       	std	Z+3, r27	; 0x03
    6132:	ed b7       	in	r30, 0x3d	; 61
    6134:	fe b7       	in	r31, 0x3e	; 62
    6136:	e9 5b       	subi	r30, 0xB9	; 185
    6138:	ff 4f       	sbci	r31, 0xFF	; 255
    613a:	80 91 19 27 	lds	r24, 0x2719
    613e:	90 91 1a 27 	lds	r25, 0x271A
    6142:	a0 91 1b 27 	lds	r26, 0x271B
    6146:	b0 91 1c 27 	lds	r27, 0x271C
    614a:	80 83       	st	Z, r24
    614c:	91 83       	std	Z+1, r25	; 0x01
    614e:	a2 83       	std	Z+2, r26	; 0x02
    6150:	b3 83       	std	Z+3, r27	; 0x03
    6152:	ed b7       	in	r30, 0x3d	; 61
    6154:	fe b7       	in	r31, 0x3e	; 62
    6156:	e5 5b       	subi	r30, 0xB5	; 181
    6158:	ff 4f       	sbci	r31, 0xFF	; 255
    615a:	80 91 1d 27 	lds	r24, 0x271D
    615e:	90 91 1e 27 	lds	r25, 0x271E
    6162:	a0 91 1f 27 	lds	r26, 0x271F
    6166:	b0 91 20 27 	lds	r27, 0x2720
    616a:	80 83       	st	Z, r24
    616c:	91 83       	std	Z+1, r25	; 0x01
    616e:	a2 83       	std	Z+2, r26	; 0x02
    6170:	b3 83       	std	Z+3, r27	; 0x03
    6172:	ed b7       	in	r30, 0x3d	; 61
    6174:	fe b7       	in	r31, 0x3e	; 62
    6176:	e1 5b       	subi	r30, 0xB1	; 177
    6178:	ff 4f       	sbci	r31, 0xFF	; 255
    617a:	80 91 21 27 	lds	r24, 0x2721
    617e:	90 91 22 27 	lds	r25, 0x2722
    6182:	a0 91 23 27 	lds	r26, 0x2723
    6186:	b0 91 24 27 	lds	r27, 0x2724
    618a:	80 83       	st	Z, r24
    618c:	91 83       	std	Z+1, r25	; 0x01
    618e:	a2 83       	std	Z+2, r26	; 0x02
    6190:	b3 83       	std	Z+3, r27	; 0x03
    6192:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
	 rimestats.toolong, rimestats.tooshort,
	 rimestats.badsynch, rimestats.badcrc,
	 rimestats.contentiondrop, rimestats.sendingdrop,
	 rimestats.lltx, rimestats.llrx);
#if ENERGEST_CONF_ON
  PRINTA("E %d.%d clock %lu cpu %lu lpm %lu irq %lu gled %lu yled %lu rled %lu tx %lu listen %lu sensors %lu serial %lu\n",
    6196:	00 91 db 26 	lds	r16, 0x26DB
    619a:	10 91 dc 26 	lds	r17, 0x26DC
    619e:	2d b7       	in	r18, 0x3d	; 61
    61a0:	3e b7       	in	r19, 0x3e	; 62
    61a2:	2e 5a       	subi	r18, 0xAE	; 174
    61a4:	3f 4f       	sbci	r19, 0xFF	; 255
    61a6:	0f b6       	in	r0, 0x3f	; 63
    61a8:	f8 94       	cli
    61aa:	3e bf       	out	0x3e, r19	; 62
    61ac:	0f be       	out	0x3f, r0	; 63
    61ae:	2d bf       	out	0x3d, r18	; 61
    61b0:	0e 94 53 1c 	call	0x38a6	; 0x38a6 <clock_seconds>
    61b4:	ad b7       	in	r26, 0x3d	; 61
    61b6:	be b7       	in	r27, 0x3e	; 62
    61b8:	d2 97       	sbiw	r26, 0x32	; 50
    61ba:	0f b6       	in	r0, 0x3f	; 63
    61bc:	f8 94       	cli
    61be:	be bf       	out	0x3e, r27	; 62
    61c0:	0f be       	out	0x3f, r0	; 63
    61c2:	ad bf       	out	0x3d, r26	; 61
    61c4:	ed b7       	in	r30, 0x3d	; 61
    61c6:	fe b7       	in	r31, 0x3e	; 62
    61c8:	31 96       	adiw	r30, 0x01	; 1
    61ca:	28 e1       	ldi	r18, 0x18	; 24
    61cc:	32 e0       	ldi	r19, 0x02	; 2
    61ce:	12 96       	adiw	r26, 0x02	; 2
    61d0:	3c 93       	st	X, r19
    61d2:	2e 93       	st	-X, r18
    61d4:	11 97       	sbiw	r26, 0x01	; 1
    61d6:	02 83       	std	Z+2, r16	; 0x02
    61d8:	13 82       	std	Z+3, r1	; 0x03
    61da:	14 83       	std	Z+4, r17	; 0x04
    61dc:	15 82       	std	Z+5, r1	; 0x05
    61de:	66 83       	std	Z+6, r22	; 0x06
    61e0:	77 83       	std	Z+7, r23	; 0x07
    61e2:	80 87       	std	Z+8, r24	; 0x08
    61e4:	91 87       	std	Z+9, r25	; 0x09
    61e6:	80 91 25 27 	lds	r24, 0x2725
    61ea:	90 91 26 27 	lds	r25, 0x2726
    61ee:	a0 91 27 27 	lds	r26, 0x2727
    61f2:	b0 91 28 27 	lds	r27, 0x2728
    61f6:	82 87       	std	Z+10, r24	; 0x0a
    61f8:	93 87       	std	Z+11, r25	; 0x0b
    61fa:	a4 87       	std	Z+12, r26	; 0x0c
    61fc:	b5 87       	std	Z+13, r27	; 0x0d
    61fe:	80 91 29 27 	lds	r24, 0x2729
    6202:	90 91 2a 27 	lds	r25, 0x272A
    6206:	a0 91 2b 27 	lds	r26, 0x272B
    620a:	b0 91 2c 27 	lds	r27, 0x272C
    620e:	86 87       	std	Z+14, r24	; 0x0e
    6210:	97 87       	std	Z+15, r25	; 0x0f
    6212:	a0 8b       	std	Z+16, r26	; 0x10
    6214:	b1 8b       	std	Z+17, r27	; 0x11
    6216:	80 91 2d 27 	lds	r24, 0x272D
    621a:	90 91 2e 27 	lds	r25, 0x272E
    621e:	a0 91 2f 27 	lds	r26, 0x272F
    6222:	b0 91 30 27 	lds	r27, 0x2730
    6226:	82 8b       	std	Z+18, r24	; 0x12
    6228:	93 8b       	std	Z+19, r25	; 0x13
    622a:	a4 8b       	std	Z+20, r26	; 0x14
    622c:	b5 8b       	std	Z+21, r27	; 0x15
    622e:	80 91 31 27 	lds	r24, 0x2731
    6232:	90 91 32 27 	lds	r25, 0x2732
    6236:	a0 91 33 27 	lds	r26, 0x2733
    623a:	b0 91 34 27 	lds	r27, 0x2734
    623e:	86 8b       	std	Z+22, r24	; 0x16
    6240:	97 8b       	std	Z+23, r25	; 0x17
    6242:	a0 8f       	std	Z+24, r26	; 0x18
    6244:	b1 8f       	std	Z+25, r27	; 0x19
    6246:	80 91 35 27 	lds	r24, 0x2735
    624a:	90 91 36 27 	lds	r25, 0x2736
    624e:	a0 91 37 27 	lds	r26, 0x2737
    6252:	b0 91 38 27 	lds	r27, 0x2738
    6256:	82 8f       	std	Z+26, r24	; 0x1a
    6258:	93 8f       	std	Z+27, r25	; 0x1b
    625a:	a4 8f       	std	Z+28, r26	; 0x1c
    625c:	b5 8f       	std	Z+29, r27	; 0x1d
    625e:	80 91 39 27 	lds	r24, 0x2739
    6262:	90 91 3a 27 	lds	r25, 0x273A
    6266:	a0 91 3b 27 	lds	r26, 0x273B
    626a:	b0 91 3c 27 	lds	r27, 0x273C
    626e:	86 8f       	std	Z+30, r24	; 0x1e
    6270:	97 8f       	std	Z+31, r25	; 0x1f
    6272:	a0 a3       	std	Z+32, r26	; 0x20
    6274:	b1 a3       	std	Z+33, r27	; 0x21
    6276:	80 91 3d 27 	lds	r24, 0x273D
    627a:	90 91 3e 27 	lds	r25, 0x273E
    627e:	a0 91 3f 27 	lds	r26, 0x273F
    6282:	b0 91 40 27 	lds	r27, 0x2740
    6286:	82 a3       	std	Z+34, r24	; 0x22
    6288:	93 a3       	std	Z+35, r25	; 0x23
    628a:	a4 a3       	std	Z+36, r26	; 0x24
    628c:	b5 a3       	std	Z+37, r27	; 0x25
    628e:	80 91 41 27 	lds	r24, 0x2741
    6292:	90 91 42 27 	lds	r25, 0x2742
    6296:	a0 91 43 27 	lds	r26, 0x2743
    629a:	b0 91 44 27 	lds	r27, 0x2744
    629e:	86 a3       	std	Z+38, r24	; 0x26
    62a0:	97 a3       	std	Z+39, r25	; 0x27
    62a2:	a0 a7       	std	Z+40, r26	; 0x28
    62a4:	b1 a7       	std	Z+41, r27	; 0x29
    62a6:	80 91 4d 27 	lds	r24, 0x274D
    62aa:	90 91 4e 27 	lds	r25, 0x274E
    62ae:	a0 91 4f 27 	lds	r26, 0x274F
    62b2:	b0 91 50 27 	lds	r27, 0x2750
    62b6:	82 a7       	std	Z+42, r24	; 0x2a
    62b8:	93 a7       	std	Z+43, r25	; 0x2b
    62ba:	a4 a7       	std	Z+44, r26	; 0x2c
    62bc:	b5 a7       	std	Z+45, r27	; 0x2d
    62be:	80 91 51 27 	lds	r24, 0x2751
    62c2:	90 91 52 27 	lds	r25, 0x2752
    62c6:	a0 91 53 27 	lds	r26, 0x2753
    62ca:	b0 91 54 27 	lds	r27, 0x2754
    62ce:	86 a7       	std	Z+46, r24	; 0x2e
    62d0:	97 a7       	std	Z+47, r25	; 0x2f
    62d2:	a0 ab       	std	Z+48, r26	; 0x30
    62d4:	b1 ab       	std	Z+49, r27	; 0x31
    62d6:	0e 94 f2 4c 	call	0x99e4	; 0x99e4 <printf_P>
    62da:	2d b7       	in	r18, 0x3d	; 61
    62dc:	3e b7       	in	r19, 0x3e	; 62
    62de:	2e 5c       	subi	r18, 0xCE	; 206
    62e0:	3f 4f       	sbci	r19, 0xFF	; 255
    62e2:	0f b6       	in	r0, 0x3f	; 63
    62e4:	f8 94       	cli
    62e6:	3e bf       	out	0x3e, r19	; 62
    62e8:	0f be       	out	0x3f, r0	; 63
    62ea:	2d bf       	out	0x3d, r18	; 61
	 energest_total_time[ENERGEST_TYPE_TRANSMIT].current,
	 energest_total_time[ENERGEST_TYPE_LISTEN].current,
	 energest_total_time[ENERGEST_TYPE_SENSORS].current,
	 energest_total_time[ENERGEST_TYPE_SERIAL].current);
#endif /* ENERGEST_CONF_ON */
}
    62ec:	1f 91       	pop	r17
    62ee:	0f 91       	pop	r16
    62f0:	08 95       	ret

000062f2 <random_init>:

/*---------------------------------------------------------------------------*/
void
random_init(unsigned short seed)
{
  srand(seed);
    62f2:	0e 94 35 4c 	call	0x986a	; 0x986a <srand>
}
    62f6:	08 95       	ret

000062f8 <random_rand>:
random_rand(void)
{
/* In gcc int rand() uses RAND_MAX and long random() uses RANDOM_MAX=0x7FFFFFFF */
/* RAND_MAX varies depending on the architecture */

  return (unsigned short)rand();
    62f8:	0e 94 30 4c 	call	0x9860	; 0x9860 <rand>
}
    62fc:	08 95       	ret

000062fe <packetbuf_clear_hdr>:
}
/*---------------------------------------------------------------------------*/
void
packetbuf_clear_hdr(void)
{
  hdrptr = PACKETBUF_HDR_SIZE;
    62fe:	80 e3       	ldi	r24, 0x30	; 48
    6300:	80 93 e3 1d 	sts	0x1DE3, r24
}
    6304:	08 95       	ret

00006306 <packetbuf_copyto_hdr>:
  }
}
/*---------------------------------------------------------------------------*/
int
packetbuf_copyto_hdr(uint8_t *to)
{
    6306:	ef 92       	push	r14
    6308:	ff 92       	push	r15
    630a:	cf 93       	push	r28
    630c:	df 93       	push	r29
      PRINTF("0x%02x, ", packetbuf[i]);
    }
    PRINTF("\n");
  }
#endif /* DEBUG_LEVEL */
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
    630e:	20 91 e3 1d 	lds	r18, 0x1DE3
    6312:	30 e0       	ldi	r19, 0x00	; 0
    6314:	c0 e3       	ldi	r28, 0x30	; 48
    6316:	d0 e0       	ldi	r29, 0x00	; 0
    6318:	c2 1b       	sub	r28, r18
    631a:	d3 0b       	sbc	r29, r19
    631c:	28 51       	subi	r18, 0x18	; 24
    631e:	32 4e       	sbci	r19, 0xE2	; 226
    6320:	b9 01       	movw	r22, r18
    6322:	ae 01       	movw	r20, r28
    6324:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
  return PACKETBUF_HDR_SIZE - hdrptr;
}
    6328:	ce 01       	movw	r24, r28
    632a:	df 91       	pop	r29
    632c:	cf 91       	pop	r28
    632e:	ff 90       	pop	r15
    6330:	ef 90       	pop	r14
    6332:	08 95       	ret

00006334 <packetbuf_copyto>:
/*---------------------------------------------------------------------------*/
int
packetbuf_copyto(void *to)
{
    6334:	af 92       	push	r10
    6336:	bf 92       	push	r11
    6338:	cf 92       	push	r12
    633a:	df 92       	push	r13
    633c:	ef 92       	push	r14
    633e:	ff 92       	push	r15
    6340:	0f 93       	push	r16
    6342:	1f 93       	push	r17
    6344:	cf 93       	push	r28
    6346:	df 93       	push	r29
    6348:	7c 01       	movw	r14, r24
      bufferptr += sprintf(bufferptr, "0x%02x, ", packetbufptr[i]);
    }
    PRINTF("packetbuf_write: data: %s\n", buffer);
  }
#endif /* DEBUG_LEVEL */
  if(PACKETBUF_HDR_SIZE - hdrptr + buflen > PACKETBUF_SIZE) {
    634a:	c0 90 e4 1d 	lds	r12, 0x1DE4
    634e:	d0 90 e5 1d 	lds	r13, 0x1DE5
    6352:	20 91 e3 1d 	lds	r18, 0x1DE3
    6356:	30 e0       	ldi	r19, 0x00	; 0
    6358:	86 01       	movw	r16, r12
    635a:	00 5d       	subi	r16, 0xD0	; 208
    635c:	1f 4f       	sbci	r17, 0xFF	; 255
    635e:	02 1b       	sub	r16, r18
    6360:	13 0b       	sbc	r17, r19
    6362:	01 38       	cpi	r16, 0x81	; 129
    6364:	11 05       	cpc	r17, r1
    6366:	e0 f4       	brcc	.+56     	; 0x63a0 <packetbuf_copyto+0x6c>
    /* Too large packet */
    return 0;
  }
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
    6368:	c0 e3       	ldi	r28, 0x30	; 48
    636a:	d0 e0       	ldi	r29, 0x00	; 0
    636c:	c2 1b       	sub	r28, r18
    636e:	d3 0b       	sbc	r29, r19
    6370:	28 51       	subi	r18, 0x18	; 24
    6372:	32 4e       	sbci	r19, 0xE2	; 226
    6374:	b9 01       	movw	r22, r18
    6376:	ae 01       	movw	r20, r28
    6378:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
  memcpy((uint8_t *)to + PACKETBUF_HDR_SIZE - hdrptr, packetbufptr + bufptr,
    637c:	ce 0d       	add	r28, r14
    637e:	df 1d       	adc	r29, r15
    6380:	20 91 e6 1d 	lds	r18, 0x1DE6
    6384:	30 91 e7 1d 	lds	r19, 0x1DE7
    6388:	80 91 9a 1e 	lds	r24, 0x1E9A
    638c:	90 91 9b 1e 	lds	r25, 0x1E9B
    6390:	28 0f       	add	r18, r24
    6392:	39 1f       	adc	r19, r25
    6394:	ce 01       	movw	r24, r28
    6396:	b9 01       	movw	r22, r18
    6398:	a6 01       	movw	r20, r12
    639a:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
	 buflen);
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
    639e:	02 c0       	rjmp	.+4      	; 0x63a4 <packetbuf_copyto+0x70>
    PRINTF("packetbuf_write: data: %s\n", buffer);
  }
#endif /* DEBUG_LEVEL */
  if(PACKETBUF_HDR_SIZE - hdrptr + buflen > PACKETBUF_SIZE) {
    /* Too large packet */
    return 0;
    63a0:	00 e0       	ldi	r16, 0x00	; 0
    63a2:	10 e0       	ldi	r17, 0x00	; 0
  }
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
  memcpy((uint8_t *)to + PACKETBUF_HDR_SIZE - hdrptr, packetbufptr + bufptr,
	 buflen);
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
}
    63a4:	c8 01       	movw	r24, r16
    63a6:	df 91       	pop	r29
    63a8:	cf 91       	pop	r28
    63aa:	1f 91       	pop	r17
    63ac:	0f 91       	pop	r16
    63ae:	ff 90       	pop	r15
    63b0:	ef 90       	pop	r14
    63b2:	df 90       	pop	r13
    63b4:	cf 90       	pop	r12
    63b6:	bf 90       	pop	r11
    63b8:	af 90       	pop	r10
    63ba:	08 95       	ret

000063bc <packetbuf_hdr_remove>:
}
/*---------------------------------------------------------------------------*/
void
packetbuf_hdr_remove(int size)
{
  hdrptr += size;
    63bc:	90 91 e3 1d 	lds	r25, 0x1DE3
    63c0:	98 0f       	add	r25, r24
    63c2:	90 93 e3 1d 	sts	0x1DE3, r25
}
    63c6:	08 95       	ret

000063c8 <packetbuf_hdrreduce>:
/*---------------------------------------------------------------------------*/
int
packetbuf_hdrreduce(int size)
{
  if(buflen < size) {
    63c8:	40 91 e4 1d 	lds	r20, 0x1DE4
    63cc:	50 91 e5 1d 	lds	r21, 0x1DE5
    63d0:	9c 01       	movw	r18, r24
    63d2:	48 17       	cp	r20, r24
    63d4:	59 07       	cpc	r21, r25
    63d6:	98 f0       	brcs	.+38     	; 0x63fe <packetbuf_hdrreduce+0x36>
    return 0;
  }

  bufptr += size;
    63d8:	80 91 9a 1e 	lds	r24, 0x1E9A
    63dc:	90 91 9b 1e 	lds	r25, 0x1E9B
    63e0:	82 0f       	add	r24, r18
    63e2:	93 1f       	adc	r25, r19
    63e4:	90 93 9b 1e 	sts	0x1E9B, r25
    63e8:	80 93 9a 1e 	sts	0x1E9A, r24
  buflen -= size;
    63ec:	42 1b       	sub	r20, r18
    63ee:	53 0b       	sbc	r21, r19
    63f0:	50 93 e5 1d 	sts	0x1DE5, r21
    63f4:	40 93 e4 1d 	sts	0x1DE4, r20
  return 1;
    63f8:	21 e0       	ldi	r18, 0x01	; 1
    63fa:	30 e0       	ldi	r19, 0x00	; 0
    63fc:	02 c0       	rjmp	.+4      	; 0x6402 <packetbuf_hdrreduce+0x3a>
/*---------------------------------------------------------------------------*/
int
packetbuf_hdrreduce(int size)
{
  if(buflen < size) {
    return 0;
    63fe:	20 e0       	ldi	r18, 0x00	; 0
    6400:	30 e0       	ldi	r19, 0x00	; 0
  }

  bufptr += size;
  buflen -= size;
  return 1;
}
    6402:	c9 01       	movw	r24, r18
    6404:	08 95       	ret

00006406 <packetbuf_set_datalen>:
/*---------------------------------------------------------------------------*/
void
packetbuf_set_datalen(uint16_t len)
{
  PRINTF("packetbuf_set_len: len %d\n", len);
  buflen = len;
    6406:	90 93 e5 1d 	sts	0x1DE5, r25
    640a:	80 93 e4 1d 	sts	0x1DE4, r24
}
    640e:	08 95       	ret

00006410 <packetbuf_dataptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_dataptr(void)
{
  return (void *)(&packetbuf[bufptr + PACKETBUF_HDR_SIZE]);
    6410:	20 91 9a 1e 	lds	r18, 0x1E9A
    6414:	30 91 9b 1e 	lds	r19, 0x1E9B
    6418:	28 5e       	subi	r18, 0xE8	; 232
    641a:	31 4e       	sbci	r19, 0xE1	; 225
}
    641c:	c9 01       	movw	r24, r18
    641e:	08 95       	ret

00006420 <packetbuf_hdrptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_hdrptr(void)
{
  return (void *)(&packetbuf[hdrptr]);
    6420:	20 91 e3 1d 	lds	r18, 0x1DE3
    6424:	30 e0       	ldi	r19, 0x00	; 0
    6426:	28 51       	subi	r18, 0x18	; 24
    6428:	32 4e       	sbci	r19, 0xE2	; 226
}
    642a:	c9 01       	movw	r24, r18
    642c:	08 95       	ret

0000642e <packetbuf_is_reference>:
}
/*---------------------------------------------------------------------------*/
int
packetbuf_is_reference(void)
{
  return packetbufptr != &packetbuf[PACKETBUF_HDR_SIZE];
    642e:	21 e0       	ldi	r18, 0x01	; 1
    6430:	30 e0       	ldi	r19, 0x00	; 0
    6432:	80 91 e6 1d 	lds	r24, 0x1DE6
    6436:	90 91 e7 1d 	lds	r25, 0x1DE7
    643a:	4e e1       	ldi	r20, 0x1E	; 30
    643c:	88 31       	cpi	r24, 0x18	; 24
    643e:	94 07       	cpc	r25, r20
    6440:	11 f4       	brne	.+4      	; 0x6446 <packetbuf_is_reference+0x18>
    6442:	20 e0       	ldi	r18, 0x00	; 0
    6444:	30 e0       	ldi	r19, 0x00	; 0
}
    6446:	c9 01       	movw	r24, r18
    6448:	08 95       	ret

0000644a <packetbuf_compact>:
void
packetbuf_compact(void)
{
  int i, len;

  if(packetbuf_is_reference()) {
    644a:	0e 94 17 32 	call	0x642e	; 0x642e <packetbuf_is_reference>
    644e:	00 97       	sbiw	r24, 0x00	; 0
    6450:	71 f0       	breq	.+28     	; 0x646e <packetbuf_compact+0x24>
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
    6452:	28 e1       	ldi	r18, 0x18	; 24
    6454:	3e e1       	ldi	r19, 0x1E	; 30
    6456:	60 91 e6 1d 	lds	r22, 0x1DE6
    645a:	70 91 e7 1d 	lds	r23, 0x1DE7
    645e:	40 91 e4 1d 	lds	r20, 0x1DE4
    6462:	50 91 e5 1d 	lds	r21, 0x1DE5
    6466:	c9 01       	movw	r24, r18
    6468:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    646c:	08 95       	ret
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    646e:	a0 91 9a 1e 	lds	r26, 0x1E9A
    6472:	b0 91 9b 1e 	lds	r27, 0x1E9B
    6476:	10 97       	sbiw	r26, 0x00	; 0
    6478:	b9 f0       	breq	.+46     	; 0x64a8 <packetbuf_compact+0x5e>
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    647a:	20 91 e4 1d 	lds	r18, 0x1DE4
    647e:	30 91 e5 1d 	lds	r19, 0x1DE5
    6482:	20 5d       	subi	r18, 0xD0	; 208
    6484:	3f 4f       	sbci	r19, 0xFF	; 255
  buflen = l;
  return l;
}
/*---------------------------------------------------------------------------*/
void
packetbuf_compact(void)
    6486:	a8 5e       	subi	r26, 0xE8	; 232
    6488:	b1 4e       	sbci	r27, 0xE1	; 225
    648a:	e8 e1       	ldi	r30, 0x18	; 24
    648c:	fe e1       	ldi	r31, 0x1E	; 30
  if(packetbuf_is_reference()) {
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    for(i = PACKETBUF_HDR_SIZE; i < len; i++) {
    648e:	80 e3       	ldi	r24, 0x30	; 48
    6490:	90 e0       	ldi	r25, 0x00	; 0
    6492:	03 c0       	rjmp	.+6      	; 0x649a <packetbuf_compact+0x50>
      packetbuf[i] = packetbuf[bufptr + i];
    6494:	4d 91       	ld	r20, X+
    6496:	41 93       	st	Z+, r20
  if(packetbuf_is_reference()) {
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    for(i = PACKETBUF_HDR_SIZE; i < len; i++) {
    6498:	01 96       	adiw	r24, 0x01	; 1
    649a:	82 17       	cp	r24, r18
    649c:	93 07       	cpc	r25, r19
    649e:	d4 f3       	brlt	.-12     	; 0x6494 <packetbuf_compact+0x4a>
      packetbuf[i] = packetbuf[bufptr + i];
    }

    bufptr = 0;
    64a0:	10 92 9b 1e 	sts	0x1E9B, r1
    64a4:	10 92 9a 1e 	sts	0x1E9A, r1
    64a8:	08 95       	ret

000064aa <packetbuf_reference_ptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_reference_ptr(void)
{
  return packetbufptr;
}
    64aa:	80 91 e6 1d 	lds	r24, 0x1DE6
    64ae:	90 91 e7 1d 	lds	r25, 0x1DE7
    64b2:	08 95       	ret

000064b4 <packetbuf_datalen>:
/*---------------------------------------------------------------------------*/
uint16_t
packetbuf_datalen(void)
{
  return buflen;
}
    64b4:	80 91 e4 1d 	lds	r24, 0x1DE4
    64b8:	90 91 e5 1d 	lds	r25, 0x1DE5
    64bc:	08 95       	ret

000064be <packetbuf_hdrlen>:
/*---------------------------------------------------------------------------*/
uint8_t
packetbuf_hdrlen(void)
{
  return PACKETBUF_HDR_SIZE - hdrptr;
    64be:	90 91 e3 1d 	lds	r25, 0x1DE3
}
    64c2:	80 e3       	ldi	r24, 0x30	; 48
    64c4:	89 1b       	sub	r24, r25
    64c6:	08 95       	ret

000064c8 <packetbuf_totlen>:
}
/*---------------------------------------------------------------------------*/
uint8_t
packetbuf_hdrlen(void)
{
  return PACKETBUF_HDR_SIZE - hdrptr;
    64c8:	80 e3       	ldi	r24, 0x30	; 48
    64ca:	90 91 e3 1d 	lds	r25, 0x1DE3
    64ce:	89 1b       	sub	r24, r25
}
/*---------------------------------------------------------------------------*/
uint16_t
packetbuf_totlen(void)
{
  return packetbuf_hdrlen() + packetbuf_datalen();
    64d0:	20 91 e4 1d 	lds	r18, 0x1DE4
    64d4:	30 91 e5 1d 	lds	r19, 0x1DE5
    64d8:	28 0f       	add	r18, r24
    64da:	31 1d       	adc	r19, r1
}
    64dc:	c9 01       	movw	r24, r18
    64de:	08 95       	ret

000064e0 <packetbuf_hdralloc>:
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
}
/*---------------------------------------------------------------------------*/
int
packetbuf_hdralloc(int size)
{
    64e0:	1f 93       	push	r17
    64e2:	cf 93       	push	r28
    64e4:	df 93       	push	r29
    64e6:	ec 01       	movw	r28, r24
  if(hdrptr >= size && packetbuf_totlen() + size <= PACKETBUF_SIZE) {
    64e8:	10 91 e3 1d 	lds	r17, 0x1DE3
    64ec:	81 2f       	mov	r24, r17
    64ee:	90 e0       	ldi	r25, 0x00	; 0
    64f0:	8c 17       	cp	r24, r28
    64f2:	9d 07       	cpc	r25, r29
    64f4:	6c f0       	brlt	.+26     	; 0x6510 <packetbuf_hdralloc+0x30>
    64f6:	0e 94 64 32 	call	0x64c8	; 0x64c8 <packetbuf_totlen>
    64fa:	8c 0f       	add	r24, r28
    64fc:	9d 1f       	adc	r25, r29
    64fe:	81 38       	cpi	r24, 0x81	; 129
    6500:	91 05       	cpc	r25, r1
    6502:	30 f4       	brcc	.+12     	; 0x6510 <packetbuf_hdralloc+0x30>
    hdrptr -= size;
    6504:	1c 1b       	sub	r17, r28
    6506:	10 93 e3 1d 	sts	0x1DE3, r17
    return 1;
    650a:	21 e0       	ldi	r18, 0x01	; 1
    650c:	30 e0       	ldi	r19, 0x00	; 0
    650e:	02 c0       	rjmp	.+4      	; 0x6514 <packetbuf_hdralloc+0x34>
  }
  return 0;
    6510:	20 e0       	ldi	r18, 0x00	; 0
    6512:	30 e0       	ldi	r19, 0x00	; 0
}
    6514:	c9 01       	movw	r24, r18
    6516:	df 91       	pop	r29
    6518:	cf 91       	pop	r28
    651a:	1f 91       	pop	r17
    651c:	08 95       	ret

0000651e <packetbuf_attr_clear>:
  return packetbuf_hdrlen() + packetbuf_datalen();
}
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_clear(void)
{
    651e:	cf 93       	push	r28
    6520:	df 93       	push	r29
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    6522:	e3 e8       	ldi	r30, 0x83	; 131
    6524:	f7 e2       	ldi	r31, 0x27	; 39
    packetbuf_attrs[i].val = 0;
    6526:	11 92       	st	Z+, r1
    6528:	11 92       	st	Z+, r1
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_clear(void)
{
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    652a:	87 e2       	ldi	r24, 0x27	; 39
    652c:	e3 3b       	cpi	r30, 0xB3	; 179
    652e:	f8 07       	cpc	r31, r24
    6530:	d1 f7       	brne	.-12     	; 0x6526 <packetbuf_attr_clear+0x8>
    6532:	c0 e0       	ldi	r28, 0x00	; 0
    6534:	d0 e0       	ldi	r29, 0x00	; 0
    packetbuf_attrs[i].val = 0;
  }
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    rimeaddr_copy(&packetbuf_addrs[i].addr, &rimeaddr_null);
    6536:	ce 01       	movw	r24, r28
    6538:	88 0f       	add	r24, r24
    653a:	99 1f       	adc	r25, r25
    653c:	85 58       	subi	r24, 0x85	; 133
    653e:	98 4d       	sbci	r25, 0xD8	; 216
    6540:	69 e3       	ldi	r22, 0x39	; 57
    6542:	7e e0       	ldi	r23, 0x0E	; 14
    6544:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
{
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    packetbuf_attrs[i].val = 0;
  }
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    6548:	21 96       	adiw	r28, 0x01	; 1
    654a:	c4 30       	cpi	r28, 0x04	; 4
    654c:	d1 05       	cpc	r29, r1
    654e:	99 f7       	brne	.-26     	; 0x6536 <packetbuf_attr_clear+0x18>
    rimeaddr_copy(&packetbuf_addrs[i].addr, &rimeaddr_null);
  }
}
    6550:	df 91       	pop	r29
    6552:	cf 91       	pop	r28
    6554:	08 95       	ret

00006556 <packetbuf_clear>:

/*---------------------------------------------------------------------------*/
void
packetbuf_clear(void)
{
  buflen = bufptr = 0;
    6556:	10 92 9b 1e 	sts	0x1E9B, r1
    655a:	10 92 9a 1e 	sts	0x1E9A, r1
    655e:	10 92 e5 1d 	sts	0x1DE5, r1
    6562:	10 92 e4 1d 	sts	0x1DE4, r1
  hdrptr = PACKETBUF_HDR_SIZE;
    6566:	80 e3       	ldi	r24, 0x30	; 48
    6568:	80 93 e3 1d 	sts	0x1DE3, r24

  packetbufptr = &packetbuf[PACKETBUF_HDR_SIZE];
    656c:	88 e1       	ldi	r24, 0x18	; 24
    656e:	9e e1       	ldi	r25, 0x1E	; 30
    6570:	90 93 e7 1d 	sts	0x1DE7, r25
    6574:	80 93 e6 1d 	sts	0x1DE6, r24
  packetbuf_attr_clear();
    6578:	0e 94 8f 32 	call	0x651e	; 0x651e <packetbuf_attr_clear>
}
    657c:	08 95       	ret

0000657e <packetbuf_reference>:
  return (void *)(&packetbuf[hdrptr]);
}
/*---------------------------------------------------------------------------*/
void
packetbuf_reference(void *ptr, uint16_t len)
{
    657e:	0f 93       	push	r16
    6580:	1f 93       	push	r17
    6582:	cf 93       	push	r28
    6584:	df 93       	push	r29
    6586:	ec 01       	movw	r28, r24
    6588:	8b 01       	movw	r16, r22
  packetbuf_clear();
    658a:	0e 94 ab 32 	call	0x6556	; 0x6556 <packetbuf_clear>
  packetbufptr = ptr;
    658e:	d0 93 e7 1d 	sts	0x1DE7, r29
    6592:	c0 93 e6 1d 	sts	0x1DE6, r28
  buflen = len;
    6596:	10 93 e5 1d 	sts	0x1DE5, r17
    659a:	00 93 e4 1d 	sts	0x1DE4, r16
}
    659e:	df 91       	pop	r29
    65a0:	cf 91       	pop	r28
    65a2:	1f 91       	pop	r17
    65a4:	0f 91       	pop	r16
    65a6:	08 95       	ret

000065a8 <packetbuf_copyfrom>:
  hdrptr = PACKETBUF_HDR_SIZE;
}
/*---------------------------------------------------------------------------*/
int
packetbuf_copyfrom(const void *from, uint16_t len)
{
    65a8:	cf 92       	push	r12
    65aa:	df 92       	push	r13
    65ac:	ef 92       	push	r14
    65ae:	ff 92       	push	r15
    65b0:	0f 93       	push	r16
    65b2:	1f 93       	push	r17
    65b4:	df 93       	push	r29
    65b6:	cf 93       	push	r28
    65b8:	00 d0       	rcall	.+0      	; 0x65ba <packetbuf_copyfrom+0x12>
    65ba:	cd b7       	in	r28, 0x3d	; 61
    65bc:	de b7       	in	r29, 0x3e	; 62
    65be:	8c 01       	movw	r16, r24
  uint16_t l;

  packetbuf_clear();
    65c0:	69 83       	std	Y+1, r22	; 0x01
    65c2:	7a 83       	std	Y+2, r23	; 0x02
    65c4:	0e 94 ab 32 	call	0x6556	; 0x6556 <packetbuf_clear>
  l = len > PACKETBUF_SIZE? PACKETBUF_SIZE: len;
    65c8:	69 81       	ldd	r22, Y+1	; 0x01
    65ca:	7a 81       	ldd	r23, Y+2	; 0x02
    65cc:	c6 2e       	mov	r12, r22
    65ce:	d7 2e       	mov	r13, r23
    65d0:	21 e8       	ldi	r18, 0x81	; 129
    65d2:	c2 16       	cp	r12, r18
    65d4:	d1 04       	cpc	r13, r1
    65d6:	18 f0       	brcs	.+6      	; 0x65de <packetbuf_copyfrom+0x36>
    65d8:	30 e8       	ldi	r19, 0x80	; 128
    65da:	c3 2e       	mov	r12, r19
    65dc:	d1 2c       	mov	r13, r1
  memcpy(packetbufptr, from, l);
    65de:	80 91 e6 1d 	lds	r24, 0x1DE6
    65e2:	90 91 e7 1d 	lds	r25, 0x1DE7
    65e6:	b8 01       	movw	r22, r16
    65e8:	a6 01       	movw	r20, r12
    65ea:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
  buflen = l;
    65ee:	d0 92 e5 1d 	sts	0x1DE5, r13
    65f2:	c0 92 e4 1d 	sts	0x1DE4, r12
  return l;
}
    65f6:	c6 01       	movw	r24, r12
    65f8:	0f 90       	pop	r0
    65fa:	0f 90       	pop	r0
    65fc:	cf 91       	pop	r28
    65fe:	df 91       	pop	r29
    6600:	1f 91       	pop	r17
    6602:	0f 91       	pop	r16
    6604:	ff 90       	pop	r15
    6606:	ef 90       	pop	r14
    6608:	df 90       	pop	r13
    660a:	cf 90       	pop	r12
    660c:	08 95       	ret

0000660e <packetbuf_attr_copyto>:
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_copyto(struct packetbuf_attr *attrs,
		    struct packetbuf_addr *addrs)
{
  memcpy(attrs, packetbuf_attrs, sizeof(packetbuf_attrs));
    660e:	28 2f       	mov	r18, r24
    6610:	39 2f       	mov	r19, r25
    6612:	d9 01       	movw	r26, r18
    6614:	e3 e8       	ldi	r30, 0x83	; 131
    6616:	f7 e2       	ldi	r31, 0x27	; 39
    6618:	80 e3       	ldi	r24, 0x30	; 48
    661a:	01 90       	ld	r0, Z+
    661c:	0d 92       	st	X+, r0
    661e:	81 50       	subi	r24, 0x01	; 1
    6620:	e1 f7       	brne	.-8      	; 0x661a <packetbuf_attr_copyto+0xc>
  memcpy(addrs, packetbuf_addrs, sizeof(packetbuf_addrs));
    6622:	86 2f       	mov	r24, r22
    6624:	97 2f       	mov	r25, r23
    6626:	dc 01       	movw	r26, r24
    6628:	eb e7       	ldi	r30, 0x7B	; 123
    662a:	f7 e2       	ldi	r31, 0x27	; 39
    662c:	88 e0       	ldi	r24, 0x08	; 8
    662e:	01 90       	ld	r0, Z+
    6630:	0d 92       	st	X+, r0
    6632:	81 50       	subi	r24, 0x01	; 1
    6634:	e1 f7       	brne	.-8      	; 0x662e <packetbuf_attr_copyto+0x20>
}
    6636:	08 95       	ret

00006638 <packetbuf_attr_copyfrom>:
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_copyfrom(struct packetbuf_attr *attrs,
		      struct packetbuf_addr *addrs)
{
  memcpy(packetbuf_attrs, attrs, sizeof(packetbuf_attrs));
    6638:	e3 e8       	ldi	r30, 0x83	; 131
    663a:	f7 e2       	ldi	r31, 0x27	; 39
    663c:	28 2f       	mov	r18, r24
    663e:	39 2f       	mov	r19, r25
    6640:	d9 01       	movw	r26, r18
    6642:	80 e3       	ldi	r24, 0x30	; 48
    6644:	0d 90       	ld	r0, X+
    6646:	01 92       	st	Z+, r0
    6648:	81 50       	subi	r24, 0x01	; 1
    664a:	e1 f7       	brne	.-8      	; 0x6644 <packetbuf_attr_copyfrom+0xc>
  memcpy(packetbuf_addrs, addrs, sizeof(packetbuf_addrs));
    664c:	ab e7       	ldi	r26, 0x7B	; 123
    664e:	b7 e2       	ldi	r27, 0x27	; 39
    6650:	86 2f       	mov	r24, r22
    6652:	97 2f       	mov	r25, r23
    6654:	fc 01       	movw	r30, r24
    6656:	88 e0       	ldi	r24, 0x08	; 8
    6658:	01 90       	ld	r0, Z+
    665a:	0d 92       	st	X+, r0
    665c:	81 50       	subi	r24, 0x01	; 1
    665e:	e1 f7       	brne	.-8      	; 0x6658 <packetbuf_attr_copyfrom+0x20>
}
    6660:	08 95       	ret

00006662 <packetbuf_set_attr>:
#if !PACKETBUF_CONF_ATTRS_INLINE
int
packetbuf_set_attr(uint8_t type, const packetbuf_attr_t val)
{
/*   packetbuf_attrs[type].type = type; */
  packetbuf_attrs[type].val = val;
    6662:	e8 2f       	mov	r30, r24
    6664:	f0 e0       	ldi	r31, 0x00	; 0
    6666:	ee 0f       	add	r30, r30
    6668:	ff 1f       	adc	r31, r31
    666a:	ed 57       	subi	r30, 0x7D	; 125
    666c:	f8 4d       	sbci	r31, 0xD8	; 216
    666e:	71 83       	std	Z+1, r23	; 0x01
    6670:	60 83       	st	Z, r22
  return 1;
}
    6672:	81 e0       	ldi	r24, 0x01	; 1
    6674:	90 e0       	ldi	r25, 0x00	; 0
    6676:	08 95       	ret

00006678 <packetbuf_attr>:
/*---------------------------------------------------------------------------*/
packetbuf_attr_t
packetbuf_attr(uint8_t type)
{
  return packetbuf_attrs[type].val;
    6678:	e8 2f       	mov	r30, r24
    667a:	f0 e0       	ldi	r31, 0x00	; 0
    667c:	ee 0f       	add	r30, r30
    667e:	ff 1f       	adc	r31, r31
    6680:	ed 57       	subi	r30, 0x7D	; 125
    6682:	f8 4d       	sbci	r31, 0xD8	; 216
}
    6684:	80 81       	ld	r24, Z
    6686:	91 81       	ldd	r25, Z+1	; 0x01
    6688:	08 95       	ret

0000668a <packetbuf_set_addr>:
/*---------------------------------------------------------------------------*/
int
packetbuf_set_addr(uint8_t type, const rimeaddr_t *addr)
{
/*   packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].type = type; */
  rimeaddr_copy(&packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr, addr);
    668a:	90 e0       	ldi	r25, 0x00	; 0
    668c:	88 0f       	add	r24, r24
    668e:	99 1f       	adc	r25, r25
    6690:	85 5b       	subi	r24, 0xB5	; 181
    6692:	98 4d       	sbci	r25, 0xD8	; 216
    6694:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
  return 1;
}
    6698:	81 e0       	ldi	r24, 0x01	; 1
    669a:	90 e0       	ldi	r25, 0x00	; 0
    669c:	08 95       	ret

0000669e <packetbuf_addr>:
/*---------------------------------------------------------------------------*/
const rimeaddr_t *
packetbuf_addr(uint8_t type)
{
  return &packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr;
    669e:	28 2f       	mov	r18, r24
    66a0:	30 e0       	ldi	r19, 0x00	; 0
    66a2:	22 0f       	add	r18, r18
    66a4:	33 1f       	adc	r19, r19
    66a6:	25 5b       	subi	r18, 0xB5	; 181
    66a8:	38 4d       	sbci	r19, 0xD8	; 216
}
    66aa:	c9 01       	movw	r24, r18
    66ac:	08 95       	ret

000066ae <queuebuf_init>:
  for(i=0; i<NQBUF_FILES; i++) {
    qbuf_files[i].renewable = 1;
    qbuf_renew_file(i);
  }
#endif
  memb_init(&buframmem);
    66ae:	84 ea       	ldi	r24, 0xA4	; 164
    66b0:	9e e0       	ldi	r25, 0x0E	; 14
    66b2:	0e 94 b7 3a 	call	0x756e	; 0x756e <memb_init>
  memb_init(&bufmem);
    66b6:	84 e9       	ldi	r24, 0x94	; 148
    66b8:	9e e0       	ldi	r25, 0x0E	; 14
    66ba:	0e 94 b7 3a 	call	0x756e	; 0x756e <memb_init>
  memb_init(&refbufmem);
    66be:	8c e9       	ldi	r24, 0x9C	; 156
    66c0:	9e e0       	ldi	r25, 0x0E	; 14
    66c2:	0e 94 b7 3a 	call	0x756e	; 0x756e <memb_init>
#if QUEUEBUF_STATS
  queuebuf_max_len = QUEUEBUF_NUM;
#endif /* QUEUEBUF_STATS */
}
    66c6:	08 95       	ret

000066c8 <queuebuf_new_from_packetbuf>:
queuebuf_new_from_packetbuf_debug(const char *file, int line)
#else /* QUEUEBUF_DEBUG */
struct queuebuf *
queuebuf_new_from_packetbuf(void)
#endif /* QUEUEBUF_DEBUG */
{
    66c8:	ef 92       	push	r14
    66ca:	ff 92       	push	r15
    66cc:	0f 93       	push	r16
    66ce:	1f 93       	push	r17
    66d0:	cf 93       	push	r28
    66d2:	df 93       	push	r29
  struct queuebuf *buf;
  struct queuebuf_ref *rbuf;

  if(packetbuf_is_reference()) {
    66d4:	0e 94 17 32 	call	0x642e	; 0x642e <packetbuf_is_reference>
    66d8:	00 97       	sbiw	r24, 0x00	; 0
    66da:	c9 f0       	breq	.+50     	; 0x670e <queuebuf_new_from_packetbuf+0x46>
    rbuf = memb_alloc(&refbufmem);
    66dc:	8c e9       	ldi	r24, 0x9C	; 156
    66de:	9e e0       	ldi	r25, 0x0E	; 14
    66e0:	0e 94 d7 3a 	call	0x75ae	; 0x75ae <memb_alloc>
    66e4:	e8 2e       	mov	r14, r24
    66e6:	e7 01       	movw	r28, r14
    66e8:	7e 01       	movw	r14, r28
    66ea:	f9 2e       	mov	r15, r25
    66ec:	e7 01       	movw	r28, r14
    if(rbuf != NULL) {
    66ee:	20 97       	sbiw	r28, 0x00	; 0
    66f0:	91 f1       	breq	.+100    	; 0x6756 <queuebuf_new_from_packetbuf+0x8e>
#if QUEUEBUF_STATS
      ++queuebuf_ref_len;
#endif /* QUEUEBUF_STATS */
      rbuf->len = packetbuf_datalen();
    66f2:	0e 94 5a 32 	call	0x64b4	; 0x64b4 <packetbuf_datalen>
    66f6:	99 83       	std	Y+1, r25	; 0x01
    66f8:	88 83       	st	Y, r24
      rbuf->ref = packetbuf_reference_ptr();
    66fa:	0e 94 55 32 	call	0x64aa	; 0x64aa <packetbuf_reference_ptr>
    66fe:	9b 83       	std	Y+3, r25	; 0x03
    6700:	8a 83       	std	Y+2, r24	; 0x02
      rbuf->hdrlen = packetbuf_copyto_hdr(rbuf->hdr);
    6702:	c7 01       	movw	r24, r14
    6704:	04 96       	adiw	r24, 0x04	; 4
    6706:	0e 94 83 31 	call	0x6306	; 0x6306 <packetbuf_copyto_hdr>
    670a:	8c ab       	std	Y+52, r24	; 0x34
    } else {
      PRINTF("queuebuf_new_from_packetbuf: could not allocate a reference queuebuf\n");
    }
    return (struct queuebuf *)rbuf;
    670c:	24 c0       	rjmp	.+72     	; 0x6756 <queuebuf_new_from_packetbuf+0x8e>
  } else {
    struct queuebuf_data *buframptr;
    buf = memb_alloc(&bufmem);
    670e:	84 e9       	ldi	r24, 0x94	; 148
    6710:	9e e0       	ldi	r25, 0x0E	; 14
    6712:	0e 94 d7 3a 	call	0x75ae	; 0x75ae <memb_alloc>
    6716:	ec 01       	movw	r28, r24
    6718:	7e 01       	movw	r14, r28
    671a:	f9 2e       	mov	r15, r25
    671c:	e7 01       	movw	r28, r14
    if(buf != NULL) {
    671e:	20 97       	sbiw	r28, 0x00	; 0
    6720:	d1 f0       	breq	.+52     	; 0x6756 <queuebuf_new_from_packetbuf+0x8e>
      list_add(queuebuf_list, buf);
      buf->file = file;
      buf->line = line;
      buf->time = clock_time();
#endif /* QUEUEBUF_DEBUG */
      buf->ram_ptr = memb_alloc(&buframmem);
    6722:	84 ea       	ldi	r24, 0xA4	; 164
    6724:	9e e0       	ldi	r25, 0x0E	; 14
    6726:	0e 94 d7 3a 	call	0x75ae	; 0x75ae <memb_alloc>
    672a:	8c 01       	movw	r16, r24
    672c:	99 83       	std	Y+1, r25	; 0x01
    672e:	88 83       	st	Y, r24
        buf->swap_id = -1;
        tmpdata_qbuf = buf;
        buframptr = &tmpdata;
      }
#else
      if(buf->ram_ptr == NULL) {
    6730:	00 97       	sbiw	r24, 0x00	; 0
    6732:	79 f0       	breq	.+30     	; 0x6752 <queuebuf_new_from_packetbuf+0x8a>
        return NULL;
      }
      buframptr = buf->ram_ptr;
#endif

      buframptr->len = packetbuf_copyto(buframptr->data);
    6734:	02 96       	adiw	r24, 0x02	; 2
    6736:	0e 94 9a 31 	call	0x6334	; 0x6334 <packetbuf_copyto>
    673a:	f8 01       	movw	r30, r16
    673c:	91 83       	std	Z+1, r25	; 0x01
    673e:	80 83       	st	Z, r24
      packetbuf_attr_copyto(buframptr->attrs, buframptr->addrs);
    6740:	b8 01       	movw	r22, r16
    6742:	6e 54       	subi	r22, 0x4E	; 78
    6744:	7f 4f       	sbci	r23, 0xFF	; 255
    6746:	c8 01       	movw	r24, r16
    6748:	8e 57       	subi	r24, 0x7E	; 126
    674a:	9f 4f       	sbci	r25, 0xFF	; 255
    674c:	0e 94 07 33 	call	0x660e	; 0x660e <packetbuf_attr_copyto>
    6750:	02 c0       	rjmp	.+4      	; 0x6756 <queuebuf_new_from_packetbuf+0x8e>
        buframptr = &tmpdata;
      }
#else
      if(buf->ram_ptr == NULL) {
        PRINTF("queuebuf_new_from_packetbuf: could not queuebuf data\n");
        return NULL;
    6752:	c0 e0       	ldi	r28, 0x00	; 0
    6754:	d0 e0       	ldi	r29, 0x00	; 0
    } else {
      PRINTF("queuebuf_new_from_packetbuf: could not allocate a queuebuf\n");
    }
    return buf;
  }
}
    6756:	ce 01       	movw	r24, r28
    6758:	df 91       	pop	r29
    675a:	cf 91       	pop	r28
    675c:	1f 91       	pop	r17
    675e:	0f 91       	pop	r16
    6760:	ff 90       	pop	r15
    6762:	ef 90       	pop	r14
    6764:	08 95       	ret

00006766 <queuebuf_update_attr_from_packetbuf>:
#else /* WITH_SWAP */
/*---------------------------------------------------------------------------*/
static struct queuebuf_data *
queuebuf_load_to_ram(struct queuebuf *b)
{
  return b->ram_ptr;
    6766:	fc 01       	movw	r30, r24
    6768:	80 81       	ld	r24, Z
    676a:	91 81       	ldd	r25, Z+1	; 0x01
/*---------------------------------------------------------------------------*/
void
queuebuf_update_attr_from_packetbuf(struct queuebuf *buf)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(buf);
  packetbuf_attr_copyto(buframptr->attrs, buframptr->addrs);
    676c:	bc 01       	movw	r22, r24
    676e:	6e 54       	subi	r22, 0x4E	; 78
    6770:	7f 4f       	sbci	r23, 0xFF	; 255
    6772:	8e 57       	subi	r24, 0x7E	; 126
    6774:	9f 4f       	sbci	r25, 0xFF	; 255
    6776:	0e 94 07 33 	call	0x660e	; 0x660e <packetbuf_attr_copyto>
#if WITH_SWAP
  if(buf->location == IN_CFS) {
    queuebuf_flush_tmpdata();
  }
#endif
}
    677a:	08 95       	ret

0000677c <queuebuf_free>:
/*---------------------------------------------------------------------------*/
void
queuebuf_free(struct queuebuf *buf)
{
    677c:	cf 93       	push	r28
    677e:	df 93       	push	r29
    6780:	ec 01       	movw	r28, r24
  if(memb_inmemb(&bufmem, buf)) {
    6782:	84 e9       	ldi	r24, 0x94	; 148
    6784:	9e e0       	ldi	r25, 0x0E	; 14
    6786:	be 01       	movw	r22, r28
    6788:	0e 94 22 3b 	call	0x7644	; 0x7644 <memb_inmemb>
    678c:	00 97       	sbiw	r24, 0x00	; 0
    678e:	49 f0       	breq	.+18     	; 0x67a2 <queuebuf_free+0x26>
      memb_free(&buframmem, buf->ram_ptr);
    } else {
      queuebuf_remove_from_file(buf->swap_id);
    }
#else
    memb_free(&buframmem, buf->ram_ptr);
    6790:	68 81       	ld	r22, Y
    6792:	79 81       	ldd	r23, Y+1	; 0x01
    6794:	84 ea       	ldi	r24, 0xA4	; 164
    6796:	9e e0       	ldi	r25, 0x0E	; 14
    6798:	0e 94 fd 3a 	call	0x75fa	; 0x75fa <memb_free>
#endif
    memb_free(&bufmem, buf);
    679c:	84 e9       	ldi	r24, 0x94	; 148
    679e:	9e e0       	ldi	r25, 0x0E	; 14
    67a0:	09 c0       	rjmp	.+18     	; 0x67b4 <queuebuf_free+0x38>
    printf("#A q=%d\n", queuebuf_len);
#endif /* QUEUEBUF_STATS */
#if QUEUEBUF_DEBUG
    list_remove(queuebuf_list, buf);
#endif /* QUEUEBUF_DEBUG */
  } else if(memb_inmemb(&refbufmem, buf)) {
    67a2:	8c e9       	ldi	r24, 0x9C	; 156
    67a4:	9e e0       	ldi	r25, 0x0E	; 14
    67a6:	be 01       	movw	r22, r28
    67a8:	0e 94 22 3b 	call	0x7644	; 0x7644 <memb_inmemb>
    67ac:	00 97       	sbiw	r24, 0x00	; 0
    67ae:	29 f0       	breq	.+10     	; 0x67ba <queuebuf_free+0x3e>
    memb_free(&refbufmem, buf);
    67b0:	8c e9       	ldi	r24, 0x9C	; 156
    67b2:	9e e0       	ldi	r25, 0x0E	; 14
    67b4:	be 01       	movw	r22, r28
    67b6:	0e 94 fd 3a 	call	0x75fa	; 0x75fa <memb_free>
#if QUEUEBUF_STATS
    --queuebuf_ref_len;
#endif /* QUEUEBUF_STATS */
  }
}
    67ba:	df 91       	pop	r29
    67bc:	cf 91       	pop	r28
    67be:	08 95       	ret

000067c0 <queuebuf_to_packetbuf>:
/*---------------------------------------------------------------------------*/
void
queuebuf_to_packetbuf(struct queuebuf *b)
{
    67c0:	ef 92       	push	r14
    67c2:	ff 92       	push	r15
    67c4:	cf 93       	push	r28
    67c6:	df 93       	push	r29
    67c8:	ec 01       	movw	r28, r24
  struct queuebuf_ref *r;
  if(memb_inmemb(&bufmem, b)) {
    67ca:	84 e9       	ldi	r24, 0x94	; 148
    67cc:	9e e0       	ldi	r25, 0x0E	; 14
    67ce:	be 01       	movw	r22, r28
    67d0:	0e 94 22 3b 	call	0x7644	; 0x7644 <memb_inmemb>
    67d4:	00 97       	sbiw	r24, 0x00	; 0
    67d6:	91 f0       	breq	.+36     	; 0x67fc <queuebuf_to_packetbuf+0x3c>
#else /* WITH_SWAP */
/*---------------------------------------------------------------------------*/
static struct queuebuf_data *
queuebuf_load_to_ram(struct queuebuf *b)
{
  return b->ram_ptr;
    67d8:	09 90       	ld	r0, Y+
    67da:	d8 81       	ld	r29, Y
    67dc:	c0 2d       	mov	r28, r0
queuebuf_to_packetbuf(struct queuebuf *b)
{
  struct queuebuf_ref *r;
  if(memb_inmemb(&bufmem, b)) {
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    packetbuf_copyfrom(buframptr->data, buframptr->len);
    67de:	68 81       	ld	r22, Y
    67e0:	79 81       	ldd	r23, Y+1	; 0x01
    67e2:	ce 01       	movw	r24, r28
    67e4:	02 96       	adiw	r24, 0x02	; 2
    67e6:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <packetbuf_copyfrom>
    packetbuf_attr_copyfrom(buframptr->attrs, buframptr->addrs);
    67ea:	be 01       	movw	r22, r28
    67ec:	6e 54       	subi	r22, 0x4E	; 78
    67ee:	7f 4f       	sbci	r23, 0xFF	; 255
    67f0:	ce 01       	movw	r24, r28
    67f2:	8e 57       	subi	r24, 0x7E	; 126
    67f4:	9f 4f       	sbci	r25, 0xFF	; 255
    67f6:	0e 94 1c 33 	call	0x6638	; 0x6638 <packetbuf_attr_copyfrom>
    67fa:	1b c0       	rjmp	.+54     	; 0x6832 <queuebuf_to_packetbuf+0x72>
  } else if(memb_inmemb(&refbufmem, b)) {
    67fc:	8c e9       	ldi	r24, 0x9C	; 156
    67fe:	9e e0       	ldi	r25, 0x0E	; 14
    6800:	be 01       	movw	r22, r28
    6802:	0e 94 22 3b 	call	0x7644	; 0x7644 <memb_inmemb>
    6806:	00 97       	sbiw	r24, 0x00	; 0
    6808:	a1 f0       	breq	.+40     	; 0x6832 <queuebuf_to_packetbuf+0x72>
    r = (struct queuebuf_ref *)b;
    packetbuf_clear();
    680a:	0e 94 ab 32 	call	0x6556	; 0x6556 <packetbuf_clear>
    packetbuf_copyfrom(r->ref, r->len);
    680e:	68 81       	ld	r22, Y
    6810:	79 81       	ldd	r23, Y+1	; 0x01
    6812:	8a 81       	ldd	r24, Y+2	; 0x02
    6814:	9b 81       	ldd	r25, Y+3	; 0x03
    6816:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <packetbuf_copyfrom>
    packetbuf_hdralloc(r->hdrlen);
    681a:	8c a9       	ldd	r24, Y+52	; 0x34
    681c:	90 e0       	ldi	r25, 0x00	; 0
    681e:	0e 94 70 32 	call	0x64e0	; 0x64e0 <packetbuf_hdralloc>
    memcpy(packetbuf_hdrptr(), r->hdr, r->hdrlen);
    6822:	0e 94 10 32 	call	0x6420	; 0x6420 <packetbuf_hdrptr>
    6826:	4c a9       	ldd	r20, Y+52	; 0x34
    6828:	24 96       	adiw	r28, 0x04	; 4
    682a:	be 01       	movw	r22, r28
    682c:	50 e0       	ldi	r21, 0x00	; 0
    682e:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
  }
}
    6832:	df 91       	pop	r29
    6834:	cf 91       	pop	r28
    6836:	ff 90       	pop	r15
    6838:	ef 90       	pop	r14
    683a:	08 95       	ret

0000683c <queuebuf_dataptr>:
/*---------------------------------------------------------------------------*/
void *
queuebuf_dataptr(struct queuebuf *b)
{
    683c:	cf 93       	push	r28
    683e:	df 93       	push	r29
    6840:	ec 01       	movw	r28, r24
  struct queuebuf_ref *r;

  if(memb_inmemb(&bufmem, b)) {
    6842:	84 e9       	ldi	r24, 0x94	; 148
    6844:	9e e0       	ldi	r25, 0x0E	; 14
    6846:	be 01       	movw	r22, r28
    6848:	0e 94 22 3b 	call	0x7644	; 0x7644 <memb_inmemb>
    684c:	00 97       	sbiw	r24, 0x00	; 0
    684e:	29 f0       	breq	.+10     	; 0x685a <queuebuf_dataptr+0x1e>
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    return buframptr->data;
    6850:	28 81       	ld	r18, Y
    6852:	39 81       	ldd	r19, Y+1	; 0x01
    6854:	2e 5f       	subi	r18, 0xFE	; 254
    6856:	3f 4f       	sbci	r19, 0xFF	; 255
    6858:	0c c0       	rjmp	.+24     	; 0x6872 <queuebuf_dataptr+0x36>
  } else if(memb_inmemb(&refbufmem, b)) {
    685a:	8c e9       	ldi	r24, 0x9C	; 156
    685c:	9e e0       	ldi	r25, 0x0E	; 14
    685e:	be 01       	movw	r22, r28
    6860:	0e 94 22 3b 	call	0x7644	; 0x7644 <memb_inmemb>
    6864:	00 97       	sbiw	r24, 0x00	; 0
    6866:	19 f0       	breq	.+6      	; 0x686e <queuebuf_dataptr+0x32>
    r = (struct queuebuf_ref *)b;
    return r->ref;
    6868:	2a 81       	ldd	r18, Y+2	; 0x02
    686a:	3b 81       	ldd	r19, Y+3	; 0x03
    686c:	02 c0       	rjmp	.+4      	; 0x6872 <queuebuf_dataptr+0x36>
  }
  return NULL;
    686e:	20 e0       	ldi	r18, 0x00	; 0
    6870:	30 e0       	ldi	r19, 0x00	; 0
}
    6872:	c9 01       	movw	r24, r18
    6874:	df 91       	pop	r29
    6876:	cf 91       	pop	r28
    6878:	08 95       	ret

0000687a <queuebuf_datalen>:
/*---------------------------------------------------------------------------*/
int
queuebuf_datalen(struct queuebuf *b)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return buframptr->len;
    687a:	dc 01       	movw	r26, r24
    687c:	ed 91       	ld	r30, X+
    687e:	fc 91       	ld	r31, X
    6880:	11 97       	sbiw	r26, 0x01	; 1
}
    6882:	80 81       	ld	r24, Z
    6884:	91 81       	ldd	r25, Z+1	; 0x01
    6886:	08 95       	ret

00006888 <queuebuf_addr>:
/*---------------------------------------------------------------------------*/
rimeaddr_t *
queuebuf_addr(struct queuebuf *b, uint8_t type)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return &buframptr->addrs[type - PACKETBUF_ADDR_FIRST].addr;
    6888:	70 e0       	ldi	r23, 0x00	; 0
    688a:	6f 5b       	subi	r22, 0xBF	; 191
    688c:	7f 4f       	sbci	r23, 0xFF	; 255
    688e:	66 0f       	add	r22, r22
    6890:	77 1f       	adc	r23, r23
    6892:	fc 01       	movw	r30, r24
    6894:	20 81       	ld	r18, Z
    6896:	31 81       	ldd	r19, Z+1	; 0x01
    6898:	26 0f       	add	r18, r22
    689a:	37 1f       	adc	r19, r23
}
    689c:	c9 01       	movw	r24, r18
    689e:	08 95       	ret

000068a0 <queuebuf_attr>:
/*---------------------------------------------------------------------------*/
packetbuf_attr_t
queuebuf_attr(struct queuebuf *b, uint8_t type)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return buframptr->attrs[type].val;
    68a0:	dc 01       	movw	r26, r24
    68a2:	ed 91       	ld	r30, X+
    68a4:	fc 91       	ld	r31, X
    68a6:	11 97       	sbiw	r26, 0x01	; 1
    68a8:	70 e0       	ldi	r23, 0x00	; 0
    68aa:	6f 5b       	subi	r22, 0xBF	; 191
    68ac:	7f 4f       	sbci	r23, 0xFF	; 255
    68ae:	66 0f       	add	r22, r22
    68b0:	77 1f       	adc	r23, r23
    68b2:	e6 0f       	add	r30, r22
    68b4:	f7 1f       	adc	r31, r23
}
    68b6:	80 81       	ld	r24, Z
    68b8:	91 81       	ldd	r25, Z+1	; 0x01
    68ba:	08 95       	ret

000068bc <queuebuf_debug_print>:
      q = list_item_next(q)) {
    printf("%s,%d,%lu ", q->file, q->line, q->time);
  }
  printf("\n");
#endif /* QUEUEBUF_DEBUG */
}
    68bc:	08 95       	ret

000068be <start_periodic_tcp_timer>:

/*---------------------------------------------------------------------------*/
static void
start_periodic_tcp_timer(void)
{
  if(etimer_expired(&periodic)) {
    68be:	8a e0       	ldi	r24, 0x0A	; 10
    68c0:	95 e2       	ldi	r25, 0x25	; 37
    68c2:	0e 94 02 18 	call	0x3004	; 0x3004 <etimer_expired>
    68c6:	00 97       	sbiw	r24, 0x00	; 0
    68c8:	21 f0       	breq	.+8      	; 0x68d2 <start_periodic_tcp_timer+0x14>
    etimer_restart(&periodic);
    68ca:	8a e0       	ldi	r24, 0x0A	; 10
    68cc:	95 e2       	ldi	r25, 0x25	; 37
    68ce:	0e 94 ed 17 	call	0x2fda	; 0x2fda <etimer_restart>
    68d2:	08 95       	ret

000068d4 <tcpip_output>:

static uint8_t (* outputfunc)(void);
uint8_t
tcpip_output(void)
{
  if(outputfunc != NULL) {
    68d4:	e0 91 17 25 	lds	r30, 0x2517
    68d8:	f0 91 18 25 	lds	r31, 0x2518
    68dc:	30 97       	sbiw	r30, 0x00	; 0
    68de:	11 f0       	breq	.+4      	; 0x68e4 <tcpip_output+0x10>
    return outputfunc();
    68e0:	09 95       	icall
    68e2:	08 95       	ret
  }
  UIP_LOG("tcpip_output: Use tcpip_set_outputfunc() to set an output function");
  return 0;
    68e4:	80 e0       	ldi	r24, 0x00	; 0
}
    68e6:	08 95       	ret

000068e8 <process_thread_tcpip_process>:
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
{
    68e8:	ef 92       	push	r14
    68ea:	ff 92       	push	r15
    68ec:	0f 93       	push	r16
    68ee:	1f 93       	push	r17
    68f0:	cf 93       	push	r28
    68f2:	df 93       	push	r29
    68f4:	ec 01       	movw	r28, r24
    68f6:	8a 01       	movw	r16, r20
  PROCESS_BEGIN();
    68f8:	88 81       	ld	r24, Y
    68fa:	99 81       	ldd	r25, Y+1	; 0x01
    68fc:	00 97       	sbiw	r24, 0x00	; 0
    68fe:	31 f0       	breq	.+12     	; 0x690c <process_thread_tcpip_process+0x24>
    6900:	23 e0       	ldi	r18, 0x03	; 3
    6902:	80 30       	cpi	r24, 0x00	; 0
    6904:	92 07       	cpc	r25, r18
    6906:	09 f0       	breq	.+2      	; 0x690a <process_thread_tcpip_process+0x22>
    6908:	06 c1       	rjmp	.+524    	; 0x6b16 <process_thread_tcpip_process+0x22e>
    690a:	2b c0       	rjmp	.+86     	; 0x6962 <process_thread_tcpip_process+0x7a>
  
#if UIP_TCP
 {
   static unsigned char i;
   
   for(i = 0; i < UIP_LISTENPORTS; ++i) {
    690c:	80 e0       	ldi	r24, 0x00	; 0
    690e:	0b c0       	rjmp	.+22     	; 0x6926 <process_thread_tcpip_process+0x3e>
     s.listenports[i].port = 0;
    6910:	e8 2f       	mov	r30, r24
    6912:	f0 e0       	ldi	r31, 0x00	; 0
    6914:	ee 0f       	add	r30, r30
    6916:	ff 1f       	adc	r31, r31
    6918:	ee 0f       	add	r30, r30
    691a:	ff 1f       	adc	r31, r31
    691c:	e8 50       	subi	r30, 0x08	; 8
    691e:	fb 4d       	sbci	r31, 0xDB	; 219
    6920:	11 82       	std	Z+1, r1	; 0x01
    6922:	10 82       	st	Z, r1
    6924:	8f 5f       	subi	r24, 0xFF	; 255
  
#if UIP_TCP
 {
   static unsigned char i;
   
   for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6926:	84 30       	cpi	r24, 0x04	; 4
    6928:	98 f3       	brcs	.-26     	; 0x6910 <process_thread_tcpip_process+0x28>
    692a:	80 93 12 25 	sts	0x2512, r24
     s.listenports[i].port = 0;
   }
   s.p = PROCESS_CURRENT();
    692e:	80 91 64 1c 	lds	r24, 0x1C64
    6932:	90 91 65 1c 	lds	r25, 0x1C65
    6936:	90 93 09 25 	sts	0x2509, r25
    693a:	80 93 08 25 	sts	0x2508, r24
 }
#endif

  tcpip_event = process_alloc_event();
    693e:	0e 94 ed 15 	call	0x2bda	; 0x2bda <process_alloc_event>
    6942:	80 93 b3 27 	sts	0x27B3, r24
#if UIP_CONF_ICMP6
  tcpip_icmp6_event = process_alloc_event();
#endif /* UIP_CONF_ICMP6 */
  etimer_set(&periodic, CLOCK_SECOND / 2);
    6946:	8a e0       	ldi	r24, 0x0A	; 10
    6948:	95 e2       	ldi	r25, 0x25	; 37
    694a:	60 e4       	ldi	r22, 0x40	; 64
    694c:	70 e0       	ldi	r23, 0x00	; 0
    694e:	0e 94 d7 17 	call	0x2fae	; 0x2fae <etimer_set>

  uip_init();
    6952:	0e 94 07 3c 	call	0x780e	; 0x780e <uip_init>
#if UIP_CONF_IPV6_RPL
  rpl_init();
#endif /* UIP_CONF_IPV6_RPL */

  while(1) {
    PROCESS_YIELD();
    6956:	80 e0       	ldi	r24, 0x00	; 0
    6958:	93 e0       	ldi	r25, 0x03	; 3
    695a:	99 83       	std	Y+1, r25	; 0x01
    695c:	88 83       	st	Y, r24
    695e:	81 e0       	ldi	r24, 0x01	; 1
    6960:	dd c0       	rjmp	.+442    	; 0x6b1c <process_thread_tcpip_process+0x234>
  static unsigned char i;
  register struct listenport *l;
#endif /*UIP_TCP*/
  struct process *p;
   
  switch(ev) {
    6962:	62 30       	cpi	r22, 0x02	; 2
    6964:	09 f4       	brne	.+2      	; 0x6968 <process_thread_tcpip_process+0x80>
    6966:	b9 c0       	rjmp	.+370    	; 0x6ada <process_thread_tcpip_process+0x1f2>
    6968:	63 30       	cpi	r22, 0x03	; 3
    696a:	30 f4       	brcc	.+12     	; 0x6978 <process_thread_tcpip_process+0x90>
    696c:	66 23       	and	r22, r22
    696e:	09 f4       	brne	.+2      	; 0x6972 <process_thread_tcpip_process+0x8a>
    6970:	89 c0       	rjmp	.+274    	; 0x6a84 <process_thread_tcpip_process+0x19c>
    6972:	61 30       	cpi	r22, 0x01	; 1
    6974:	81 f7       	brne	.-32     	; 0x6956 <process_thread_tcpip_process+0x6e>
    6976:	9c c0       	rjmp	.+312    	; 0x6ab0 <process_thread_tcpip_process+0x1c8>
    6978:	67 38       	cpi	r22, 0x87	; 135
    697a:	19 f0       	breq	.+6      	; 0x6982 <process_thread_tcpip_process+0x9a>
    697c:	68 38       	cpi	r22, 0x88	; 136
    697e:	59 f7       	brne	.-42     	; 0x6956 <process_thread_tcpip_process+0x6e>
    6980:	41 c0       	rjmp	.+130    	; 0x6a04 <process_thread_tcpip_process+0x11c>
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6982:	10 92 13 25 	sts	0x2513, r1
         connections or listening TCP ports. If so, we'll close those
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
    6986:	48 ef       	ldi	r20, 0xF8	; 248
    6988:	e4 2e       	mov	r14, r20
    698a:	44 e2       	ldi	r20, 0x24	; 36
    698c:	f4 2e       	mov	r15, r20
    698e:	18 c0       	rjmp	.+48     	; 0x69c0 <process_thread_tcpip_process+0xd8>
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
        if(l->p == p) {
    6990:	f7 01       	movw	r30, r14
    6992:	82 81       	ldd	r24, Z+2	; 0x02
    6994:	93 81       	ldd	r25, Z+3	; 0x03
    6996:	80 17       	cp	r24, r16
    6998:	91 07       	cpc	r25, r17
    699a:	49 f4       	brne	.+18     	; 0x69ae <process_thread_tcpip_process+0xc6>
          uip_unlisten(l->port);
    699c:	80 81       	ld	r24, Z
    699e:	91 81       	ldd	r25, Z+1	; 0x01
    69a0:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <uip_unlisten>
          l->port = 0;
    69a4:	f7 01       	movw	r30, r14
    69a6:	11 82       	std	Z+1, r1	; 0x01
    69a8:	10 82       	st	Z, r1
          l->p = PROCESS_NONE;
    69aa:	13 82       	std	Z+3, r1	; 0x03
    69ac:	12 82       	std	Z+2, r1	; 0x02
        }
        ++l;
    69ae:	84 e0       	ldi	r24, 0x04	; 4
    69b0:	90 e0       	ldi	r25, 0x00	; 0
    69b2:	e8 0e       	add	r14, r24
    69b4:	f9 1e       	adc	r15, r25
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
    69b6:	80 91 13 25 	lds	r24, 0x2513
    69ba:	8f 5f       	subi	r24, 0xFF	; 255
    69bc:	80 93 13 25 	sts	0x2513, r24
    69c0:	80 91 13 25 	lds	r24, 0x2513
    69c4:	84 30       	cpi	r24, 0x04	; 4
    69c6:	20 f3       	brcs	.-56     	; 0x6990 <process_thread_tcpip_process+0xa8>
  if(ts->p != NULL) {
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
    69c8:	e3 ec       	ldi	r30, 0xC3	; 195
    69ca:	fc e2       	ldi	r31, 0x2C	; 44
	 
      {
        register struct uip_conn *cptr;
	    
        for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_CONNS]; ++cptr) {
          if(cptr->appstate.p == p) {
    69cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    69ce:	95 8d       	ldd	r25, Z+29	; 0x1d
    69d0:	80 17       	cp	r24, r16
    69d2:	91 07       	cpc	r25, r17
    69d4:	19 f4       	brne	.+6      	; 0x69dc <process_thread_tcpip_process+0xf4>
            cptr->appstate.p = PROCESS_NONE;
    69d6:	15 8e       	std	Z+29, r1	; 0x1d
    69d8:	14 8e       	std	Z+28, r1	; 0x1c
            cptr->tcpstateflags = UIP_CLOSED;
    69da:	11 8e       	std	Z+25, r1	; 0x19
      }
	 
      {
        register struct uip_conn *cptr;
	    
        for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_CONNS]; ++cptr) {
    69dc:	b0 96       	adiw	r30, 0x20	; 32
    69de:	9d e2       	ldi	r25, 0x2D	; 45
    69e0:	e3 34       	cpi	r30, 0x43	; 67
    69e2:	f9 07       	cpc	r31, r25
    69e4:	99 f7       	brne	.-26     	; 0x69cc <process_thread_tcpip_process+0xe4>
  if(ts->p != NULL) {
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
    69e6:	e9 e5       	ldi	r30, 0x59	; 89
    69e8:	fd e2       	ldi	r31, 0x2D	; 45
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
            cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
          if(cptr->appstate.p == p) {
    69ea:	81 85       	ldd	r24, Z+9	; 0x09
    69ec:	92 85       	ldd	r25, Z+10	; 0x0a
    69ee:	80 17       	cp	r24, r16
    69f0:	91 07       	cpc	r25, r17
    69f2:	11 f4       	brne	.+4      	; 0x69f8 <process_thread_tcpip_process+0x110>
            cptr->lport = 0;
    69f4:	15 82       	std	Z+5, r1	; 0x05
    69f6:	14 82       	std	Z+4, r1	; 0x04
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
            cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
    69f8:	3d 96       	adiw	r30, 0x0d	; 13
#endif /* UIP_TCP */
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
    69fa:	2d e2       	ldi	r18, 0x2D	; 45
    69fc:	eb 3d       	cpi	r30, 0xDB	; 219
    69fe:	f2 07       	cpc	r31, r18
    6a00:	a1 f7       	brne	.-24     	; 0x69ea <process_thread_tcpip_process+0x102>
    6a02:	a9 cf       	rjmp	.-174    	; 0x6956 <process_thread_tcpip_process+0x6e>
    case PROCESS_EVENT_TIMER:
      /* We get this event if one of our timers have expired. */
      {
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
    6a04:	85 e2       	ldi	r24, 0x25	; 37
    6a06:	4a 30       	cpi	r20, 0x0A	; 10
    6a08:	58 07       	cpc	r21, r24
    6a0a:	09 f0       	breq	.+2      	; 0x6a0e <process_thread_tcpip_process+0x126>
    6a0c:	a4 cf       	rjmp	.-184    	; 0x6956 <process_thread_tcpip_process+0x6e>
           etimer_expired(&periodic)) {
    6a0e:	ca 01       	movw	r24, r20
    6a10:	0e 94 02 18 	call	0x3004	; 0x3004 <etimer_expired>
    case PROCESS_EVENT_TIMER:
      /* We get this event if one of our timers have expired. */
      {
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
    6a14:	00 97       	sbiw	r24, 0x00	; 0
    6a16:	09 f4       	brne	.+2      	; 0x6a1a <process_thread_tcpip_process+0x132>
    6a18:	9e cf       	rjmp	.-196    	; 0x6956 <process_thread_tcpip_process+0x6e>
           etimer_expired(&periodic)) {
#if UIP_TCP
          for(i = 0; i < UIP_CONNS; ++i) {
    6a1a:	10 92 13 25 	sts	0x2513, r1
    6a1e:	2d c0       	rjmp	.+90     	; 0x6a7a <process_thread_tcpip_process+0x192>
            if(uip_conn_active(i)) {
    6a20:	f0 e0       	ldi	r31, 0x00	; 0
    6a22:	35 e0       	ldi	r19, 0x05	; 5
    6a24:	ee 0f       	add	r30, r30
    6a26:	ff 1f       	adc	r31, r31
    6a28:	3a 95       	dec	r19
    6a2a:	e1 f7       	brne	.-8      	; 0x6a24 <process_thread_tcpip_process+0x13c>
    6a2c:	ed 53       	subi	r30, 0x3D	; 61
    6a2e:	f3 4d       	sbci	r31, 0xD3	; 211
    6a30:	81 8d       	ldd	r24, Z+25	; 0x19
    6a32:	88 23       	and	r24, r24
    6a34:	e9 f0       	breq	.+58     	; 0x6a70 <process_thread_tcpip_process+0x188>
              /* Only restart the timer if there are active
                 connections. */
              etimer_restart(&periodic);
    6a36:	8a e0       	ldi	r24, 0x0A	; 10
    6a38:	95 e2       	ldi	r25, 0x25	; 37
    6a3a:	0e 94 ed 17 	call	0x2fda	; 0x2fda <etimer_restart>
              uip_periodic(i);
    6a3e:	80 91 13 25 	lds	r24, 0x2513
    6a42:	90 e0       	ldi	r25, 0x00	; 0
    6a44:	25 e0       	ldi	r18, 0x05	; 5
    6a46:	88 0f       	add	r24, r24
    6a48:	99 1f       	adc	r25, r25
    6a4a:	2a 95       	dec	r18
    6a4c:	e1 f7       	brne	.-8      	; 0x6a46 <process_thread_tcpip_process+0x15e>
    6a4e:	8d 53       	subi	r24, 0x3D	; 61
    6a50:	93 4d       	sbci	r25, 0xD3	; 211
    6a52:	90 93 c2 2c 	sts	0x2CC2, r25
    6a56:	80 93 c1 2c 	sts	0x2CC1, r24
    6a5a:	82 e0       	ldi	r24, 0x02	; 2
    6a5c:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <uip_process>
#if UIP_CONF_IPV6
              tcpip_ipv6_output();
#else
              if(uip_len > 0) {
    6a60:	80 91 b4 27 	lds	r24, 0x27B4
    6a64:	90 91 b5 27 	lds	r25, 0x27B5
    6a68:	00 97       	sbiw	r24, 0x00	; 0
    6a6a:	11 f0       	breq	.+4      	; 0x6a70 <process_thread_tcpip_process+0x188>
		PRINTF("tcpip_output from periodic len %d\n", uip_len);
                tcpip_output();
    6a6c:	0e 94 6a 34 	call	0x68d4	; 0x68d4 <tcpip_output>
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
           etimer_expired(&periodic)) {
#if UIP_TCP
          for(i = 0; i < UIP_CONNS; ++i) {
    6a70:	80 91 13 25 	lds	r24, 0x2513
    6a74:	8f 5f       	subi	r24, 0xFF	; 255
    6a76:	80 93 13 25 	sts	0x2513, r24
    6a7a:	e0 91 13 25 	lds	r30, 0x2513
    6a7e:	e4 30       	cpi	r30, 0x04	; 4
    6a80:	78 f2       	brcs	.-98     	; 0x6a20 <process_thread_tcpip_process+0x138>
    6a82:	69 cf       	rjmp	.-302    	; 0x6956 <process_thread_tcpip_process+0x6e>
      }
      break;
	 
#if UIP_TCP
    case TCP_POLL:
      if(data != NULL) {
    6a84:	41 15       	cp	r20, r1
    6a86:	51 05       	cpc	r21, r1
    6a88:	09 f4       	brne	.+2      	; 0x6a8c <process_thread_tcpip_process+0x1a4>
    6a8a:	65 cf       	rjmp	.-310    	; 0x6956 <process_thread_tcpip_process+0x6e>
        uip_poll_conn(data);
    6a8c:	50 93 c2 2c 	sts	0x2CC2, r21
    6a90:	40 93 c1 2c 	sts	0x2CC1, r20
    6a94:	83 e0       	ldi	r24, 0x03	; 3
    6a96:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <uip_process>
#if UIP_CONF_IPV6
        tcpip_ipv6_output();
#else /* UIP_CONF_IPV6 */
        if(uip_len > 0) {
    6a9a:	80 91 b4 27 	lds	r24, 0x27B4
    6a9e:	90 91 b5 27 	lds	r25, 0x27B5
    6aa2:	00 97       	sbiw	r24, 0x00	; 0
    6aa4:	11 f0       	breq	.+4      	; 0x6aaa <process_thread_tcpip_process+0x1c2>
	  PRINTF("tcpip_output from tcp poll len %d\n", uip_len);
          tcpip_output();
    6aa6:	0e 94 6a 34 	call	0x68d4	; 0x68d4 <tcpip_output>
        }
#endif /* UIP_CONF_IPV6 */
        /* Start the periodic polling, if it isn't already active. */
        start_periodic_tcp_timer();
    6aaa:	0e 94 5f 34 	call	0x68be	; 0x68be <start_periodic_tcp_timer>
    6aae:	53 cf       	rjmp	.-346    	; 0x6956 <process_thread_tcpip_process+0x6e>
      }
      break;
#endif /* UIP_TCP */
#if UIP_UDP
    case UDP_POLL:
      if(data != NULL) {
    6ab0:	41 15       	cp	r20, r1
    6ab2:	51 05       	cpc	r21, r1
    6ab4:	09 f4       	brne	.+2      	; 0x6ab8 <process_thread_tcpip_process+0x1d0>
    6ab6:	4f cf       	rjmp	.-354    	; 0x6956 <process_thread_tcpip_process+0x6e>
        uip_udp_periodic_conn(data);
    6ab8:	50 93 be 2c 	sts	0x2CBE, r21
    6abc:	40 93 bd 2c 	sts	0x2CBD, r20
    6ac0:	85 e0       	ldi	r24, 0x05	; 5
    6ac2:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <uip_process>
#if UIP_CONF_IPV6
        tcpip_ipv6_output();
#else
        if(uip_len > 0) {
    6ac6:	80 91 b4 27 	lds	r24, 0x27B4
    6aca:	90 91 b5 27 	lds	r25, 0x27B5
    6ace:	00 97       	sbiw	r24, 0x00	; 0
    6ad0:	09 f4       	brne	.+2      	; 0x6ad4 <process_thread_tcpip_process+0x1ec>
    6ad2:	41 cf       	rjmp	.-382    	; 0x6956 <process_thread_tcpip_process+0x6e>
          tcpip_output();
    6ad4:	0e 94 6a 34 	call	0x68d4	; 0x68d4 <tcpip_output>
    6ad8:	3e cf       	rjmp	.-388    	; 0x6956 <process_thread_tcpip_process+0x6e>
      }
    }
    tcpip_is_forwarding = 0;
  }
#else /* UIP_CONF_IP_FORWARD */
  if(uip_len > 0) {
    6ada:	80 91 b4 27 	lds	r24, 0x27B4
    6ade:	90 91 b5 27 	lds	r25, 0x27B5
    6ae2:	00 97       	sbiw	r24, 0x00	; 0
    6ae4:	09 f4       	brne	.+2      	; 0x6ae8 <process_thread_tcpip_process+0x200>
    6ae6:	37 cf       	rjmp	.-402    	; 0x6956 <process_thread_tcpip_process+0x6e>
     an incoming packet contains a SYN: since uIP does not inform the
     application if a SYN arrives, we have no other way of starting
     this timer.  This function is called for every incoming IP packet
     to check for such SYNs. */
#define TCP_SYN 0x02
  if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
    6ae8:	80 91 c5 27 	lds	r24, 0x27C5
    6aec:	86 30       	cpi	r24, 0x06	; 6
    6aee:	31 f4       	brne	.+12     	; 0x6afc <process_thread_tcpip_process+0x214>
     (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
    6af0:	80 91 dd 27 	lds	r24, 0x27DD
     an incoming packet contains a SYN: since uIP does not inform the
     application if a SYN arrives, we have no other way of starting
     this timer.  This function is called for every incoming IP packet
     to check for such SYNs. */
#define TCP_SYN 0x02
  if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
    6af4:	81 ff       	sbrs	r24, 1
    6af6:	02 c0       	rjmp	.+4      	; 0x6afc <process_thread_tcpip_process+0x214>
     (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
    start_periodic_tcp_timer();
    6af8:	0e 94 5f 34 	call	0x68be	; 0x68be <start_periodic_tcp_timer>
    tcpip_is_forwarding = 0;
  }
#else /* UIP_CONF_IP_FORWARD */
  if(uip_len > 0) {
    check_for_tcp_syn();
    uip_input();
    6afc:	81 e0       	ldi	r24, 0x01	; 1
    6afe:	0e 94 82 3d 	call	0x7b04	; 0x7b04 <uip_process>
    if(uip_len > 0) {
    6b02:	80 91 b4 27 	lds	r24, 0x27B4
    6b06:	90 91 b5 27 	lds	r25, 0x27B5
    6b0a:	00 97       	sbiw	r24, 0x00	; 0
    6b0c:	09 f4       	brne	.+2      	; 0x6b10 <process_thread_tcpip_process+0x228>
    6b0e:	23 cf       	rjmp	.-442    	; 0x6956 <process_thread_tcpip_process+0x6e>
#if UIP_CONF_TCP_SPLIT
      uip_split_output();
    6b10:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <uip_split_output>
    6b14:	20 cf       	rjmp	.-448    	; 0x6956 <process_thread_tcpip_process+0x6e>
  while(1) {
    PROCESS_YIELD();
    eventhandler(ev, data);
  }
  
  PROCESS_END();
    6b16:	19 82       	std	Y+1, r1	; 0x01
    6b18:	18 82       	st	Y, r1
    6b1a:	83 e0       	ldi	r24, 0x03	; 3
}
    6b1c:	df 91       	pop	r29
    6b1e:	cf 91       	pop	r28
    6b20:	1f 91       	pop	r17
    6b22:	0f 91       	pop	r16
    6b24:	ff 90       	pop	r15
    6b26:	ef 90       	pop	r14
    6b28:	08 95       	ret

00006b2a <tcpip_set_outputfunc>:
}

void
tcpip_set_outputfunc(uint8_t (*f)(void))
{
  outputfunc = f;
    6b2a:	90 93 18 25 	sts	0x2518, r25
    6b2e:	80 93 17 25 	sts	0x2517, r24
}
    6b32:	08 95       	ret

00006b34 <tcp_unlisten>:
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    if(l->port == port &&
       l->p == PROCESS_CURRENT()) {
    6b34:	20 91 64 1c 	lds	r18, 0x1C64
    6b38:	30 91 65 1c 	lds	r19, 0x1C65
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6b3c:	60 e0       	ldi	r22, 0x00	; 0
tcp_unlisten(uint16_t port)
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
    6b3e:	e8 ef       	ldi	r30, 0xF8	; 248
    6b40:	f4 e2       	ldi	r31, 0x24	; 36
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6b42:	13 c0       	rjmp	.+38     	; 0x6b6a <tcp_unlisten+0x36>
    if(l->port == port &&
    6b44:	40 81       	ld	r20, Z
    6b46:	51 81       	ldd	r21, Z+1	; 0x01
    6b48:	48 17       	cp	r20, r24
    6b4a:	59 07       	cpc	r21, r25
    6b4c:	61 f4       	brne	.+24     	; 0x6b66 <tcp_unlisten+0x32>
    6b4e:	42 81       	ldd	r20, Z+2	; 0x02
    6b50:	53 81       	ldd	r21, Z+3	; 0x03
    6b52:	42 17       	cp	r20, r18
    6b54:	53 07       	cpc	r21, r19
    6b56:	39 f4       	brne	.+14     	; 0x6b66 <tcp_unlisten+0x32>
    6b58:	60 93 16 25 	sts	0x2516, r22
       l->p == PROCESS_CURRENT()) {
      l->port = 0;
    6b5c:	11 82       	std	Z+1, r1	; 0x01
    6b5e:	10 82       	st	Z, r1
      uip_unlisten(port);
    6b60:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <uip_unlisten>
      break;
    6b64:	08 95       	ret
    }
    ++l;
    6b66:	34 96       	adiw	r30, 0x04	; 4
    6b68:	6f 5f       	subi	r22, 0xFF	; 255
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6b6a:	64 30       	cpi	r22, 0x04	; 4
    6b6c:	58 f3       	brcs	.-42     	; 0x6b44 <tcp_unlisten+0x10>
    6b6e:	60 93 16 25 	sts	0x2516, r22
    6b72:	08 95       	ret

00006b74 <tcp_listen>:
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6b74:	40 e0       	ldi	r20, 0x00	; 0
tcp_listen(uint16_t port)
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
    6b76:	e8 ef       	ldi	r30, 0xF8	; 248
    6b78:	f4 e2       	ldi	r31, 0x24	; 36
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6b7a:	16 c0       	rjmp	.+44     	; 0x6ba8 <tcp_listen+0x34>
    6b7c:	54 2f       	mov	r21, r20
    6b7e:	5f 5f       	subi	r21, 0xFF	; 255
    if(l->port == 0) {
    6b80:	20 81       	ld	r18, Z
    6b82:	31 81       	ldd	r19, Z+1	; 0x01
    6b84:	21 15       	cp	r18, r1
    6b86:	31 05       	cpc	r19, r1
    6b88:	69 f4       	brne	.+26     	; 0x6ba4 <tcp_listen+0x30>
    6b8a:	40 93 15 25 	sts	0x2515, r20
      l->port = port;
    6b8e:	91 83       	std	Z+1, r25	; 0x01
    6b90:	80 83       	st	Z, r24
      l->p = PROCESS_CURRENT();
    6b92:	20 91 64 1c 	lds	r18, 0x1C64
    6b96:	30 91 65 1c 	lds	r19, 0x1C65
    6b9a:	33 83       	std	Z+3, r19	; 0x03
    6b9c:	22 83       	std	Z+2, r18	; 0x02
      uip_listen(port);
    6b9e:	0e 94 68 3d 	call	0x7ad0	; 0x7ad0 <uip_listen>
      break;
    6ba2:	08 95       	ret
    }
    ++l;
    6ba4:	34 96       	adiw	r30, 0x04	; 4
    6ba6:	45 2f       	mov	r20, r21
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6ba8:	44 30       	cpi	r20, 0x04	; 4
    6baa:	40 f3       	brcs	.-48     	; 0x6b7c <tcp_listen+0x8>
    6bac:	40 93 15 25 	sts	0x2515, r20
    6bb0:	08 95       	ret

00006bb2 <tcp_attach>:
}
/*---------------------------------------------------------------------------*/
void
tcp_attach(struct uip_conn *conn,
	   void *appstate)
{
    6bb2:	fc 01       	movw	r30, r24
  register uip_tcp_appstate_t *s;

  s = &conn->appstate;
  s->p = PROCESS_CURRENT();
    6bb4:	80 91 64 1c 	lds	r24, 0x1C64
    6bb8:	90 91 65 1c 	lds	r25, 0x1C65
    6bbc:	95 8f       	std	Z+29, r25	; 0x1d
    6bbe:	84 8f       	std	Z+28, r24	; 0x1c
  s->state = appstate;
    6bc0:	77 8f       	std	Z+31, r23	; 0x1f
    6bc2:	66 8f       	std	Z+30, r22	; 0x1e
}
    6bc4:	08 95       	ret

00006bc6 <udp_attach>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP
void
udp_attach(struct uip_udp_conn *conn,
	   void *appstate)
{
    6bc6:	fc 01       	movw	r30, r24
  register uip_udp_appstate_t *s;

  s = &conn->appstate;
  s->p = PROCESS_CURRENT();
    6bc8:	80 91 64 1c 	lds	r24, 0x1C64
    6bcc:	90 91 65 1c 	lds	r25, 0x1C65
    6bd0:	92 87       	std	Z+10, r25	; 0x0a
    6bd2:	81 87       	std	Z+9, r24	; 0x09
  s->state = appstate;
    6bd4:	74 87       	std	Z+12, r23	; 0x0c
    6bd6:	63 87       	std	Z+11, r22	; 0x0b
}
    6bd8:	08 95       	ret

00006bda <udp_new>:
/*---------------------------------------------------------------------------*/
struct uip_udp_conn *
udp_new(const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)
{
    6bda:	cf 93       	push	r28
    6bdc:	df 93       	push	r29
    6bde:	ea 01       	movw	r28, r20
  struct uip_udp_conn *c;
  uip_udp_appstate_t *s;
  
  c = uip_udp_new(ripaddr, port);
    6be0:	0e 94 ca 3c 	call	0x7994	; 0x7994 <uip_udp_new>
    6be4:	fc 01       	movw	r30, r24
  if(c == NULL) {
    6be6:	00 97       	sbiw	r24, 0x00	; 0
    6be8:	41 f0       	breq	.+16     	; 0x6bfa <udp_new+0x20>
    return NULL;
  }

  s = &c->appstate;
  s->p = PROCESS_CURRENT();
    6bea:	80 91 64 1c 	lds	r24, 0x1C64
    6bee:	90 91 65 1c 	lds	r25, 0x1C65
    6bf2:	92 87       	std	Z+10, r25	; 0x0a
    6bf4:	81 87       	std	Z+9, r24	; 0x09
  s->state = appstate;
    6bf6:	d4 87       	std	Z+12, r29	; 0x0c
    6bf8:	c3 87       	std	Z+11, r28	; 0x0b

  return c;
}
    6bfa:	cf 01       	movw	r24, r30
    6bfc:	df 91       	pop	r29
    6bfe:	cf 91       	pop	r28
    6c00:	08 95       	ret

00006c02 <udp_broadcast_new>:
/*---------------------------------------------------------------------------*/
struct uip_udp_conn *
udp_broadcast_new(uint16_t port, void *appstate)
{
    6c02:	0f 93       	push	r16
    6c04:	1f 93       	push	r17
    6c06:	df 93       	push	r29
    6c08:	cf 93       	push	r28
    6c0a:	00 d0       	rcall	.+0      	; 0x6c0c <udp_broadcast_new+0xa>
    6c0c:	00 d0       	rcall	.+0      	; 0x6c0e <udp_broadcast_new+0xc>
    6c0e:	cd b7       	in	r28, 0x3d	; 61
    6c10:	de b7       	in	r29, 0x3e	; 62
    6c12:	8c 01       	movw	r16, r24
    6c14:	ab 01       	movw	r20, r22
  struct uip_udp_conn *conn;

#if UIP_CONF_IPV6
  uip_create_linklocal_allnodes_mcast(&addr);
#else
  uip_ipaddr(&addr, 255,255,255,255);
    6c16:	8f ef       	ldi	r24, 0xFF	; 255
    6c18:	89 83       	std	Y+1, r24	; 0x01
    6c1a:	8a 83       	std	Y+2, r24	; 0x02
    6c1c:	8b 83       	std	Y+3, r24	; 0x03
    6c1e:	8c 83       	std	Y+4, r24	; 0x04
#endif /* UIP_CONF_IPV6 */
  conn = udp_new(&addr, port, appstate);
    6c20:	ce 01       	movw	r24, r28
    6c22:	01 96       	adiw	r24, 0x01	; 1
    6c24:	b8 01       	movw	r22, r16
    6c26:	0e 94 ed 35 	call	0x6bda	; 0x6bda <udp_new>
    6c2a:	fc 01       	movw	r30, r24
  if(conn != NULL) {
    6c2c:	00 97       	sbiw	r24, 0x00	; 0
    6c2e:	11 f0       	breq	.+4      	; 0x6c34 <udp_broadcast_new+0x32>
    udp_bind(conn, port);
    6c30:	15 83       	std	Z+5, r17	; 0x05
    6c32:	04 83       	std	Z+4, r16	; 0x04
  }
  return conn;
}
    6c34:	cf 01       	movw	r24, r30
    6c36:	0f 90       	pop	r0
    6c38:	0f 90       	pop	r0
    6c3a:	0f 90       	pop	r0
    6c3c:	0f 90       	pop	r0
    6c3e:	cf 91       	pop	r28
    6c40:	df 91       	pop	r29
    6c42:	1f 91       	pop	r17
    6c44:	0f 91       	pop	r16
    6c46:	08 95       	ret

00006c48 <tcpip_input>:
}
/*---------------------------------------------------------------------------*/
void
tcpip_input(void)
{
  process_post_synch(&tcpip_process, PACKET_INPUT, NULL);
    6c48:	89 eb       	ldi	r24, 0xB9	; 185
    6c4a:	9e e0       	ldi	r25, 0x0E	; 14
    6c4c:	62 e0       	ldi	r22, 0x02	; 2
    6c4e:	40 e0       	ldi	r20, 0x00	; 0
    6c50:	50 e0       	ldi	r21, 0x00	; 0
    6c52:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <process_post_synch>
  uip_len = 0;
    6c56:	10 92 b5 27 	sts	0x27B5, r1
    6c5a:	10 92 b4 27 	sts	0x27B4, r1
#if UIP_CONF_IPV6
  uip_ext_len = 0;
#endif /*UIP_CONF_IPV6*/
}
    6c5e:	08 95       	ret

00006c60 <tcpip_poll_udp>:
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
void
tcpip_poll_udp(struct uip_udp_conn *conn)
{
    6c60:	ac 01       	movw	r20, r24
  process_post(&tcpip_process, UDP_POLL, conn);
    6c62:	89 eb       	ldi	r24, 0xB9	; 185
    6c64:	9e e0       	ldi	r25, 0x0E	; 14
    6c66:	61 e0       	ldi	r22, 0x01	; 1
    6c68:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <process_post>
}
    6c6c:	08 95       	ret

00006c6e <tcpip_poll_tcp>:
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
#if UIP_TCP
void
tcpip_poll_tcp(struct uip_conn *conn)
{
    6c6e:	ac 01       	movw	r20, r24
  process_post(&tcpip_process, TCP_POLL, conn);
    6c70:	89 eb       	ldi	r24, 0xB9	; 185
    6c72:	9e e0       	ldi	r25, 0x0E	; 14
    6c74:	60 e0       	ldi	r22, 0x00	; 0
    6c76:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <process_post>
}
    6c7a:	08 95       	ret

00006c7c <tcp_connect>:
/*---------------------------------------------------------------------------*/
#if UIP_TCP
#if UIP_ACTIVE_OPEN
struct uip_conn *
tcp_connect(uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)
{
    6c7c:	0f 93       	push	r16
    6c7e:	1f 93       	push	r17
    6c80:	cf 93       	push	r28
    6c82:	df 93       	push	r29
    6c84:	ea 01       	movw	r28, r20
  struct uip_conn *c;
  
  c = uip_connect(ripaddr, port);
    6c86:	0e 94 40 3c 	call	0x7880	; 0x7880 <uip_connect>
    6c8a:	8c 01       	movw	r16, r24
  if(c == NULL) {
    6c8c:	00 97       	sbiw	r24, 0x00	; 0
    6c8e:	61 f0       	breq	.+24     	; 0x6ca8 <tcp_connect+0x2c>
    return NULL;
  }

  c->appstate.p = PROCESS_CURRENT();
    6c90:	80 91 64 1c 	lds	r24, 0x1C64
    6c94:	90 91 65 1c 	lds	r25, 0x1C65
    6c98:	f8 01       	movw	r30, r16
    6c9a:	95 8f       	std	Z+29, r25	; 0x1d
    6c9c:	84 8f       	std	Z+28, r24	; 0x1c
  c->appstate.state = appstate;
    6c9e:	d7 8f       	std	Z+31, r29	; 0x1f
    6ca0:	c6 8f       	std	Z+30, r28	; 0x1e
  
  tcpip_poll_tcp(c);
    6ca2:	c8 01       	movw	r24, r16
    6ca4:	0e 94 37 36 	call	0x6c6e	; 0x6c6e <tcpip_poll_tcp>
  
  return c;
}
    6ca8:	c8 01       	movw	r24, r16
    6caa:	df 91       	pop	r29
    6cac:	cf 91       	pop	r28
    6cae:	1f 91       	pop	r17
    6cb0:	0f 91       	pop	r16
    6cb2:	08 95       	ret

00006cb4 <tcpip_uipcall>:
}
#endif /* UIP_TCP */
/*---------------------------------------------------------------------------*/
void
tcpip_uipcall(void)
{
    6cb4:	cf 93       	push	r28
    6cb6:	df 93       	push	r29
  register uip_udp_appstate_t *ts;
  
#if UIP_UDP
  if(uip_conn != NULL) {
    6cb8:	a0 91 c1 2c 	lds	r26, 0x2CC1
    6cbc:	b0 91 c2 2c 	lds	r27, 0x2CC2
    6cc0:	10 97       	sbiw	r26, 0x00	; 0
    6cc2:	19 f0       	breq	.+6      	; 0x6cca <tcpip_uipcall+0x16>
    ts = &uip_conn->appstate;
    6cc4:	ed 01       	movw	r28, r26
    6cc6:	6c 96       	adiw	r28, 0x1c	; 28
    6cc8:	05 c0       	rjmp	.+10     	; 0x6cd4 <tcpip_uipcall+0x20>
  } else {
    ts = &uip_udp_conn->appstate;
    6cca:	c0 91 bd 2c 	lds	r28, 0x2CBD
    6cce:	d0 91 be 2c 	lds	r29, 0x2CBE
    6cd2:	29 96       	adiw	r28, 0x09	; 9
   static unsigned char i;
   register struct listenport *l;
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
    6cd4:	80 91 bc 2c 	lds	r24, 0x2CBC
    6cd8:	86 ff       	sbrs	r24, 6
    6cda:	22 c0       	rjmp	.+68     	; 0x6d20 <tcpip_uipcall+0x6c>
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6cdc:	10 92 14 25 	sts	0x2514, r1
    6ce0:	40 e0       	ldi	r20, 0x00	; 0
   register struct listenport *l;
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
    6ce2:	e8 ef       	ldi	r30, 0xF8	; 248
    6ce4:	f4 e2       	ldi	r31, 0x24	; 36
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6ce6:	16 c0       	rjmp	.+44     	; 0x6d14 <tcpip_uipcall+0x60>
       if(l->port == uip_conn->lport &&
    6ce8:	20 81       	ld	r18, Z
    6cea:	31 81       	ldd	r19, Z+1	; 0x01
    6cec:	14 96       	adiw	r26, 0x04	; 4
    6cee:	8d 91       	ld	r24, X+
    6cf0:	9c 91       	ld	r25, X
    6cf2:	15 97       	sbiw	r26, 0x05	; 5
    6cf4:	28 17       	cp	r18, r24
    6cf6:	39 07       	cpc	r19, r25
    6cf8:	59 f4       	brne	.+22     	; 0x6d10 <tcpip_uipcall+0x5c>
	  l->p != PROCESS_NONE) {
    6cfa:	82 81       	ldd	r24, Z+2	; 0x02
    6cfc:	93 81       	ldd	r25, Z+3	; 0x03
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
       if(l->port == uip_conn->lport &&
    6cfe:	00 97       	sbiw	r24, 0x00	; 0
    6d00:	39 f0       	breq	.+14     	; 0x6d10 <tcpip_uipcall+0x5c>
    6d02:	40 93 14 25 	sts	0x2514, r20
	  l->p != PROCESS_NONE) {
	 ts->p = l->p;
    6d06:	99 83       	std	Y+1, r25	; 0x01
    6d08:	88 83       	st	Y, r24
	 ts->state = NULL;
    6d0a:	1b 82       	std	Y+3, r1	; 0x03
    6d0c:	1a 82       	std	Y+2, r1	; 0x02
	 break;
    6d0e:	06 c0       	rjmp	.+12     	; 0x6d1c <tcpip_uipcall+0x68>
       }
       ++l;
    6d10:	34 96       	adiw	r30, 0x04	; 4
    6d12:	4f 5f       	subi	r20, 0xFF	; 255
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6d14:	44 30       	cpi	r20, 0x04	; 4
    6d16:	40 f3       	brcs	.-48     	; 0x6ce8 <tcpip_uipcall+0x34>
    6d18:	40 93 14 25 	sts	0x2514, r20
       }
       ++l;
     }
     
     /* Start the periodic polling, if it isn't already active. */
     start_periodic_tcp_timer();
    6d1c:	0e 94 5f 34 	call	0x68be	; 0x68be <start_periodic_tcp_timer>
   }
 }
#endif /* UIP_TCP */
  
  if(ts->p != NULL) {
    6d20:	88 81       	ld	r24, Y
    6d22:	99 81       	ldd	r25, Y+1	; 0x01
    6d24:	00 97       	sbiw	r24, 0x00	; 0
    6d26:	31 f0       	breq	.+12     	; 0x6d34 <tcpip_uipcall+0x80>
    process_post_synch(ts->p, tcpip_event, ts->state);
    6d28:	4a 81       	ldd	r20, Y+2	; 0x02
    6d2a:	5b 81       	ldd	r21, Y+3	; 0x03
    6d2c:	60 91 b3 27 	lds	r22, 0x27B3
    6d30:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <process_post_synch>
  }
}
    6d34:	df 91       	pop	r29
    6d36:	cf 91       	pop	r28
    6d38:	08 95       	ret

00006d3a <uip_split_output>:
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])

/*-----------------------------------------------------------------------------*/
void
uip_split_output(void)
{
    6d3a:	0f 93       	push	r16
    6d3c:	1f 93       	push	r17
    6d3e:	cf 93       	push	r28
    6d40:	df 93       	push	r29
#if UIP_TCP
  uint16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP &&
    6d42:	80 91 c5 27 	lds	r24, 0x27C5
    6d46:	86 30       	cpi	r24, 0x06	; 6
    6d48:	09 f0       	breq	.+2      	; 0x6d4c <uip_split_output+0x12>
    6d4a:	74 c0       	rjmp	.+232    	; 0x6e34 <uip_split_output+0xfa>
    6d4c:	80 91 b4 27 	lds	r24, 0x27B4
    6d50:	90 91 b5 27 	lds	r25, 0x27B5
    6d54:	25 e0       	ldi	r18, 0x05	; 5
    6d56:	80 30       	cpi	r24, 0x00	; 0
    6d58:	92 07       	cpc	r25, r18
    6d5a:	09 f0       	breq	.+2      	; 0x6d5e <uip_split_output+0x24>
    6d5c:	6b c0       	rjmp	.+214    	; 0x6e34 <uip_split_output+0xfa>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN;
    6d5e:	c4 e9       	ldi	r28, 0x94	; 148
    6d60:	d2 e0       	ldi	r29, 0x02	; 2
    6d62:	d0 93 b5 27 	sts	0x27B5, r29
    6d66:	c0 93 b4 27 	sts	0x27B4, r28
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = uip_len >> 8;
    6d6a:	02 e0       	ldi	r16, 0x02	; 2
    6d6c:	00 93 be 27 	sts	0x27BE, r16
    BUF->len[1] = uip_len & 0xff;
    6d70:	14 e9       	ldi	r17, 0x94	; 148
    6d72:	10 93 bf 27 	sts	0x27BF, r17
#endif /* UIP_CONF_IPV6 */
    
    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    6d76:	10 92 e1 27 	sts	0x27E1, r1
    6d7a:	10 92 e0 27 	sts	0x27E0, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    6d7e:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <uip_tcpchksum>
    6d82:	80 95       	com	r24
    6d84:	90 95       	com	r25
    6d86:	90 93 e1 27 	sts	0x27E1, r25
    6d8a:	80 93 e0 27 	sts	0x27E0, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    6d8e:	10 92 c7 27 	sts	0x27C7, r1
    6d92:	10 92 c6 27 	sts	0x27C6, r1
    BUF->ipchksum = ~(uip_ipchksum());
    6d96:	0e 94 ee 3b 	call	0x77dc	; 0x77dc <uip_ipchksum>
    6d9a:	80 95       	com	r24
    6d9c:	90 95       	com	r25
    6d9e:	90 93 c7 27 	sts	0x27C7, r25
    6da2:	80 93 c6 27 	sts	0x27C6, r24
    /* Transmit the first packet. */
    /*    uip_fw_output();*/
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
    tcpip_output();
    6da6:	0e 94 6a 34 	call	0x68d4	; 0x68d4 <tcpip_output>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is detemined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN;
    6daa:	d0 93 b5 27 	sts	0x27B5, r29
    6dae:	c0 93 b4 27 	sts	0x27B4, r28
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = uip_len >> 8;
    6db2:	00 93 be 27 	sts	0x27BE, r16
    BUF->len[1] = uip_len & 0xff;
    6db6:	10 93 bf 27 	sts	0x27BF, r17
#endif /* UIP_CONF_IPV6 */
    
    /*    uip_appdata += len1;*/
    memcpy(uip_appdata, (uint8_t *)uip_appdata + len1, len2);
    6dba:	90 91 bf 2c 	lds	r25, 0x2CBF
    6dbe:	80 91 c0 2c 	lds	r24, 0x2CC0
    6dc2:	e9 2f       	mov	r30, r25
    6dc4:	f8 2f       	mov	r31, r24
    6dc6:	df 01       	movw	r26, r30
    6dc8:	a4 59       	subi	r26, 0x94	; 148
    6dca:	bd 4f       	sbci	r27, 0xFD	; 253
    6dcc:	8c e6       	ldi	r24, 0x6C	; 108
    6dce:	92 e0       	ldi	r25, 0x02	; 2
    6dd0:	0d 90       	ld	r0, X+
    6dd2:	01 92       	st	Z+, r0
    6dd4:	01 97       	sbiw	r24, 0x01	; 1
    6dd6:	e1 f7       	brne	.-8      	; 0x6dd0 <uip_split_output+0x96>

    uip_add32(BUF->seqno, len1);
    6dd8:	84 ed       	ldi	r24, 0xD4	; 212
    6dda:	97 e2       	ldi	r25, 0x27	; 39
    6ddc:	6c e6       	ldi	r22, 0x6C	; 108
    6dde:	72 e0       	ldi	r23, 0x02	; 2
    6de0:	0e 94 92 3b 	call	0x7724	; 0x7724 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    6de4:	80 91 b8 27 	lds	r24, 0x27B8
    6de8:	80 93 d4 27 	sts	0x27D4, r24
    BUF->seqno[1] = uip_acc32[1];
    6dec:	80 91 b9 27 	lds	r24, 0x27B9
    6df0:	80 93 d5 27 	sts	0x27D5, r24
    BUF->seqno[2] = uip_acc32[2];
    6df4:	80 91 ba 27 	lds	r24, 0x27BA
    6df8:	80 93 d6 27 	sts	0x27D6, r24
    BUF->seqno[3] = uip_acc32[3];
    6dfc:	80 91 bb 27 	lds	r24, 0x27BB
    6e00:	80 93 d7 27 	sts	0x27D7, r24
    
    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    6e04:	10 92 e1 27 	sts	0x27E1, r1
    6e08:	10 92 e0 27 	sts	0x27E0, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    6e0c:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <uip_tcpchksum>
    6e10:	80 95       	com	r24
    6e12:	90 95       	com	r25
    6e14:	90 93 e1 27 	sts	0x27E1, r25
    6e18:	80 93 e0 27 	sts	0x27E0, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    6e1c:	10 92 c7 27 	sts	0x27C7, r1
    6e20:	10 92 c6 27 	sts	0x27C6, r1
    BUF->ipchksum = ~(uip_ipchksum());
    6e24:	0e 94 ee 3b 	call	0x77dc	; 0x77dc <uip_ipchksum>
    6e28:	80 95       	com	r24
    6e2a:	90 95       	com	r25
    6e2c:	90 93 c7 27 	sts	0x27C7, r25
    6e30:	80 93 c6 27 	sts	0x27C6, r24

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
     tcpip_ipv6_output();
#else
     tcpip_output();
    6e34:	0e 94 6a 34 	call	0x68d4	; 0x68d4 <tcpip_output>
#endif /* UIP_CONF_IPV6 */
}
    6e38:	df 91       	pop	r29
    6e3a:	cf 91       	pop	r28
    6e3c:	1f 91       	pop	r17
    6e3e:	0f 91       	pop	r16
    6e40:	08 95       	ret

00006e42 <__vector_32>:
#define DEBUGFLOW(c)
#endif

/*---------------------------------------------------------------------------*/
#if defined(TCNT3) && RTIMER_ARCH_PRESCALER
ISR (TIMER3_COMPA_vect) {
    6e42:	1f 92       	push	r1
    6e44:	0f 92       	push	r0
    6e46:	0f b6       	in	r0, 0x3f	; 63
    6e48:	0f 92       	push	r0
    6e4a:	0b b6       	in	r0, 0x3b	; 59
    6e4c:	0f 92       	push	r0
    6e4e:	11 24       	eor	r1, r1
    6e50:	2f 93       	push	r18
    6e52:	3f 93       	push	r19
    6e54:	4f 93       	push	r20
    6e56:	5f 93       	push	r21
    6e58:	6f 93       	push	r22
    6e5a:	7f 93       	push	r23
    6e5c:	8f 93       	push	r24
    6e5e:	9f 93       	push	r25
    6e60:	af 93       	push	r26
    6e62:	bf 93       	push	r27
    6e64:	ef 93       	push	r30
    6e66:	ff 93       	push	r31
  DEBUGFLOW('/');
  ENERGEST_ON(ENERGEST_TYPE_IRQ);
    6e68:	80 91 94 00 	lds	r24, 0x0094
    6e6c:	90 91 95 00 	lds	r25, 0x0095
    6e70:	90 93 68 27 	sts	0x2768, r25
    6e74:	80 93 67 27 	sts	0x2767, r24
    6e78:	81 e0       	ldi	r24, 0x01	; 1
    6e7a:	80 93 59 27 	sts	0x2759, r24

  /* Disable rtimer interrupts */
  ETIMSK &= ~((1 << OCIE3A) | (1 << OCIE3B) | (1 << TOIE3) |
    6e7e:	80 91 71 00 	lds	r24, 0x0071
    6e82:	80 7d       	andi	r24, 0xD0	; 208
    6e84:	80 93 71 00 	sts	0x0071, r24
  /* All interrupts are enabled including recursive rtimer, so use with caution */
  sei();
#endif

  /* Call rtimer callback */
  rtimer_run_next();
    6e88:	0e 94 9b 2f 	call	0x5f36	; 0x5f36 <rtimer_run_next>

  ENERGEST_OFF(ENERGEST_TYPE_IRQ);
    6e8c:	80 91 59 27 	lds	r24, 0x2759
    6e90:	88 23       	and	r24, r24
    6e92:	e9 f1       	breq	.+122    	; 0x6f0e <__vector_32+0xcc>
    6e94:	80 91 94 00 	lds	r24, 0x0094
    6e98:	90 91 95 00 	lds	r25, 0x0095
    6e9c:	20 91 67 27 	lds	r18, 0x2767
    6ea0:	30 91 68 27 	lds	r19, 0x2768
    6ea4:	82 17       	cp	r24, r18
    6ea6:	93 07       	cpc	r25, r19
    6ea8:	a0 f4       	brcc	.+40     	; 0x6ed2 <__vector_32+0x90>
    6eaa:	80 91 2d 27 	lds	r24, 0x272D
    6eae:	90 91 2e 27 	lds	r25, 0x272E
    6eb2:	a0 91 2f 27 	lds	r26, 0x272F
    6eb6:	b0 91 30 27 	lds	r27, 0x2730
    6eba:	8c 57       	subi	r24, 0x7C	; 124
    6ebc:	91 4e       	sbci	r25, 0xE1	; 225
    6ebe:	af 4f       	sbci	r26, 0xFF	; 255
    6ec0:	bf 4f       	sbci	r27, 0xFF	; 255
    6ec2:	80 93 2d 27 	sts	0x272D, r24
    6ec6:	90 93 2e 27 	sts	0x272E, r25
    6eca:	a0 93 2f 27 	sts	0x272F, r26
    6ece:	b0 93 30 27 	sts	0x2730, r27
    6ed2:	80 91 94 00 	lds	r24, 0x0094
    6ed6:	90 91 95 00 	lds	r25, 0x0095
    6eda:	82 1b       	sub	r24, r18
    6edc:	93 0b       	sbc	r25, r19
    6ede:	a0 e0       	ldi	r26, 0x00	; 0
    6ee0:	b0 e0       	ldi	r27, 0x00	; 0
    6ee2:	20 91 2d 27 	lds	r18, 0x272D
    6ee6:	30 91 2e 27 	lds	r19, 0x272E
    6eea:	40 91 2f 27 	lds	r20, 0x272F
    6eee:	50 91 30 27 	lds	r21, 0x2730
    6ef2:	82 0f       	add	r24, r18
    6ef4:	93 1f       	adc	r25, r19
    6ef6:	a4 1f       	adc	r26, r20
    6ef8:	b5 1f       	adc	r27, r21
    6efa:	80 93 2d 27 	sts	0x272D, r24
    6efe:	90 93 2e 27 	sts	0x272E, r25
    6f02:	a0 93 2f 27 	sts	0x272F, r26
    6f06:	b0 93 30 27 	sts	0x2730, r27
    6f0a:	10 92 59 27 	sts	0x2759, r1
  DEBUGFLOW('\\');
}
    6f0e:	ff 91       	pop	r31
    6f10:	ef 91       	pop	r30
    6f12:	bf 91       	pop	r27
    6f14:	af 91       	pop	r26
    6f16:	9f 91       	pop	r25
    6f18:	8f 91       	pop	r24
    6f1a:	7f 91       	pop	r23
    6f1c:	6f 91       	pop	r22
    6f1e:	5f 91       	pop	r21
    6f20:	4f 91       	pop	r20
    6f22:	3f 91       	pop	r19
    6f24:	2f 91       	pop	r18
    6f26:	0f 90       	pop	r0
    6f28:	0b be       	out	0x3b, r0	; 59
    6f2a:	0f 90       	pop	r0
    6f2c:	0f be       	out	0x3f, r0	; 63
    6f2e:	0f 90       	pop	r0
    6f30:	1f 90       	pop	r1
    6f32:	18 95       	reti

00006f34 <rtimer_arch_init>:
rtimer_arch_init(void)
{
#if RTIMER_ARCH_PRESCALER
  /* Disable interrupts (store old state) */
  uint8_t sreg;
  sreg = SREG;
    6f34:	9f b7       	in	r25, 0x3f	; 63
  cli ();
    6f36:	f8 94       	cli

#ifdef TCNT3
  /* Disable all timer functions */
  ETIMSK &= ~((1 << OCIE3A) | (1 << OCIE3B) | (1 << TOIE3) |
    6f38:	e1 e7       	ldi	r30, 0x71	; 113
    6f3a:	f0 e0       	ldi	r31, 0x00	; 0
    6f3c:	80 81       	ld	r24, Z
    6f3e:	80 7d       	andi	r24, 0xD0	; 208
    6f40:	80 83       	st	Z, r24
      (1 << TICIE3) | (1 << OCIE3C));
  /* Write 1s to clear existing timer function flags */
  ETIFR |= (1 << ICF3) | (1 << OCF3A) | (1 << OCF3B) | (1 << TOV3) |
    6f42:	88 b3       	in	r24, 0x18	; 24
    6f44:	8f 62       	ori	r24, 0x2F	; 47
    6f46:	88 bb       	out	0x18, r24	; 24
  (1 << OCF3C); 

  /* Default timer behaviour */
  TCCR3A = 0;
    6f48:	10 92 90 00 	sts	0x0090, r1
  TCCR3B = 0;
    6f4c:	e1 e9       	ldi	r30, 0x91	; 145
    6f4e:	f0 e0       	ldi	r31, 0x00	; 0
    6f50:	10 82       	st	Z, r1
  TCCR3C = 0;
    6f52:	10 92 92 00 	sts	0x0092, r1

  /* Reset counter */
  TCNT3 = 0;
    6f56:	10 92 95 00 	sts	0x0095, r1
    6f5a:	10 92 94 00 	sts	0x0094, r1

#if RTIMER_ARCH_PRESCALER==1024
  TCCR3B |= 5;
    6f5e:	80 81       	ld	r24, Z
    6f60:	85 60       	ori	r24, 0x05	; 5
    6f62:	80 83       	st	Z, r24
#endif

#endif /* TCNT3 */

  /* Restore interrupt state */
  SREG = sreg;
    6f64:	9f bf       	out	0x3f, r25	; 63
#endif /* RTIMER_ARCH_PRESCALER */
}
    6f66:	08 95       	ret

00006f68 <rtimer_arch_schedule>:
rtimer_arch_schedule(rtimer_clock_t t)
{
#if RTIMER_ARCH_PRESCALER
  /* Disable interrupts (store old state) */
  uint8_t sreg;
  sreg = SREG;
    6f68:	2f b7       	in	r18, 0x3f	; 63
  cli ();
    6f6a:	f8 94       	cli
  DEBUGFLOW(':');
#ifdef TCNT3
  /* Set compare register */
  OCR3A = t;
    6f6c:	90 93 99 00 	sts	0x0099, r25
    6f70:	80 93 98 00 	sts	0x0098, r24
  /* Write 1s to clear all timer function flags */
  ETIFR |= (1 << ICF3) | (1 << OCF3A) | (1 << OCF3B) | (1 << TOV3) |
    6f74:	88 b3       	in	r24, 0x18	; 24
    6f76:	8f 62       	ori	r24, 0x2F	; 47
    6f78:	88 bb       	out	0x18, r24	; 24
  (1 << OCF3C);
  /* Enable interrupt on OCR3A match */
  ETIMSK |= (1 << OCIE3A);
    6f7a:	e1 e7       	ldi	r30, 0x71	; 113
    6f7c:	f0 e0       	ldi	r31, 0x00	; 0
    6f7e:	80 81       	ld	r24, Z
    6f80:	82 60       	ori	r24, 0x02	; 2
    6f82:	80 83       	st	Z, r24
  TIMSK |= (1 << OCIE1A);

#endif

  /* Restore interrupt state */
  SREG = sreg;
    6f84:	2f bf       	out	0x3f, r18	; 63
#endif /* RTIMER_ARCH_PRESCALER */
}
    6f86:	08 95       	ret

00006f88 <rtimer_arch_sleep>:

#if RDC_CONF_MCU_SLEEP
/*---------------------------------------------------------------------------*/
void
rtimer_arch_sleep(rtimer_clock_t howlong)
{
    6f88:	ef 92       	push	r14
    6f8a:	ff 92       	push	r15
    6f8c:	0f 93       	push	r16
    6f8e:	1f 93       	push	r17
    6f90:	cf 93       	push	r28
    6f92:	df 93       	push	r29
    6f94:	ec 01       	movw	r28, r24
uint32_t longhowlong;
#if AVR_CONF_USE32KCRYSTAL
/* Save TIMER2 configuration if clock.c is using it */
    uint8_t savedTCNT2=TCNT2, savedTCCR2A=TCCR2A, savedTCCR2B = TCCR2B, savedOCR2A = OCR2A;
#endif
    cli();
    6f96:	f8 94       	cli
	watchdog_stop();
    6f98:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <watchdog_stop>
	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
    6f9c:	83 b7       	in	r24, 0x33	; 51
    6f9e:	81 7f       	andi	r24, 0xF1	; 241
    6fa0:	86 60       	ori	r24, 0x06	; 6
    6fa2:	83 bf       	out	0x33, r24	; 51

/* Set TIMER2 clock asynchronus from external source, CTC mode */
    ASSR |= (1 << AS2);
    6fa4:	80 91 b6 00 	lds	r24, 0x00B6
    6fa8:	80 62       	ori	r24, 0x20	; 32
    6faa:	80 93 b6 00 	sts	0x00B6, r24
    TCCR2A =(1<<WGM21);
    6fae:	82 e0       	ldi	r24, 0x02	; 2
    6fb0:	80 93 b0 00 	sts	0x00B0, r24
	longhowlong=howlong*256UL;
#elif 0  // Prescale by  64 -  512 ticks/sec, 500 msec max sleep
	TCCR2B =((1<<CS22)|(0<<CS21)|(0<<CS20));
	longhowlong=howlong*512UL;
#elif 1  // Prescale by  32 - 1024 ticks/sec, 250 msec max sleep
	TCCR2B =((0<<CS22)|(1<<CS21)|(1<<CS20));
    6fb4:	83 e0       	ldi	r24, 0x03	; 3
    6fb6:	80 93 b1 00 	sts	0x00B1, r24
	longhowlong=howlong*1024UL;
    6fba:	7e 01       	movw	r14, r28
    6fbc:	00 e0       	ldi	r16, 0x00	; 0
    6fbe:	10 e0       	ldi	r17, 0x00	; 0
    6fc0:	c8 01       	movw	r24, r16
    6fc2:	b7 01       	movw	r22, r14
    6fc4:	3a e0       	ldi	r19, 0x0A	; 10
    6fc6:	66 0f       	add	r22, r22
    6fc8:	77 1f       	adc	r23, r23
    6fca:	88 1f       	adc	r24, r24
    6fcc:	99 1f       	adc	r25, r25
    6fce:	3a 95       	dec	r19
    6fd0:	d1 f7       	brne	.-12     	; 0x6fc6 <rtimer_arch_sleep+0x3e>
	longhowlong=howlong*4096UL;
#else    // No Prescale -    32768 ticks/sec, 7.8 msec max sleep
	TCCR2B =((0<<CS22)|(0<<CS21)|(1<<CS20));
	longhowlong=howlong*32768UL;
#endif
	OCR2A = longhowlong/RTIMER_ARCH_SECOND;
    6fd2:	24 e8       	ldi	r18, 0x84	; 132
    6fd4:	3e e1       	ldi	r19, 0x1E	; 30
    6fd6:	40 e0       	ldi	r20, 0x00	; 0
    6fd8:	50 e0       	ldi	r21, 0x00	; 0
    6fda:	0e 94 89 4b 	call	0x9712	; 0x9712 <__udivmodsi4>
    6fde:	20 93 b3 00 	sts	0x00B3, r18

/* Reset timer count, wait for the write (which assures TCCR2x and OCR2A are finished) */
    TCNT2 = 0; 
    6fe2:	10 92 b2 00 	sts	0x00B2, r1
    while(ASSR & (1 << TCN2UB));
    6fe6:	80 91 b6 00 	lds	r24, 0x00B6
    6fea:	84 fd       	sbrc	r24, 4
    6fec:	fc cf       	rjmp	.-8      	; 0x6fe6 <rtimer_arch_sleep+0x5e>

/* Enable TIMER2 output compare interrupt, sleep mode and sleep */
    TIMSK2 |= (1 << OCIE2A);
    6fee:	80 91 70 00 	lds	r24, 0x0070
    6ff2:	82 60       	ori	r24, 0x02	; 2
    6ff4:	80 93 70 00 	sts	0x0070, r24
    SMCR |= (1 <<  SE);
    6ff8:	83 b7       	in	r24, 0x33	; 51
    6ffa:	81 60       	ori	r24, 0x01	; 1
    6ffc:	83 bf       	out	0x33, r24	; 51
	sei();
    6ffe:	78 94       	sei
	ENERGEST_OFF(ENERGEST_TYPE_CPU);
    7000:	80 91 57 27 	lds	r24, 0x2757
    7004:	88 23       	and	r24, r24
    7006:	e9 f1       	breq	.+122    	; 0x7082 <rtimer_arch_sleep+0xfa>
    7008:	80 91 94 00 	lds	r24, 0x0094
    700c:	90 91 95 00 	lds	r25, 0x0095
    7010:	20 91 63 27 	lds	r18, 0x2763
    7014:	30 91 64 27 	lds	r19, 0x2764
    7018:	82 17       	cp	r24, r18
    701a:	93 07       	cpc	r25, r19
    701c:	a0 f4       	brcc	.+40     	; 0x7046 <rtimer_arch_sleep+0xbe>
    701e:	80 91 25 27 	lds	r24, 0x2725
    7022:	90 91 26 27 	lds	r25, 0x2726
    7026:	a0 91 27 27 	lds	r26, 0x2727
    702a:	b0 91 28 27 	lds	r27, 0x2728
    702e:	8c 57       	subi	r24, 0x7C	; 124
    7030:	91 4e       	sbci	r25, 0xE1	; 225
    7032:	af 4f       	sbci	r26, 0xFF	; 255
    7034:	bf 4f       	sbci	r27, 0xFF	; 255
    7036:	80 93 25 27 	sts	0x2725, r24
    703a:	90 93 26 27 	sts	0x2726, r25
    703e:	a0 93 27 27 	sts	0x2727, r26
    7042:	b0 93 28 27 	sts	0x2728, r27
    7046:	80 91 94 00 	lds	r24, 0x0094
    704a:	90 91 95 00 	lds	r25, 0x0095
    704e:	82 1b       	sub	r24, r18
    7050:	93 0b       	sbc	r25, r19
    7052:	a0 e0       	ldi	r26, 0x00	; 0
    7054:	b0 e0       	ldi	r27, 0x00	; 0
    7056:	20 91 25 27 	lds	r18, 0x2725
    705a:	30 91 26 27 	lds	r19, 0x2726
    705e:	40 91 27 27 	lds	r20, 0x2727
    7062:	50 91 28 27 	lds	r21, 0x2728
    7066:	82 0f       	add	r24, r18
    7068:	93 1f       	adc	r25, r19
    706a:	a4 1f       	adc	r26, r20
    706c:	b5 1f       	adc	r27, r21
    706e:	80 93 25 27 	sts	0x2725, r24
    7072:	90 93 26 27 	sts	0x2726, r25
    7076:	a0 93 27 27 	sts	0x2727, r26
    707a:	b0 93 28 27 	sts	0x2728, r27
    707e:	10 92 57 27 	sts	0x2757, r1
	if (OCR2A) sleep_mode();
    7082:	80 91 b3 00 	lds	r24, 0x00B3
    7086:	88 23       	and	r24, r24
    7088:	39 f0       	breq	.+14     	; 0x7098 <rtimer_arch_sleep+0x110>
    708a:	83 b7       	in	r24, 0x33	; 51
    708c:	81 60       	ori	r24, 0x01	; 1
    708e:	83 bf       	out	0x33, r24	; 51
    7090:	88 95       	sleep
    7092:	83 b7       	in	r24, 0x33	; 51
    7094:	8e 7f       	andi	r24, 0xFE	; 254
    7096:	83 bf       	out	0x33, r24	; 51
	  //...zzZZZzz...Ding!//

/* Disable sleep mode after wakeup, so random code cant trigger sleep */
    SMCR  &= ~(1 << SE);
    7098:	83 b7       	in	r24, 0x33	; 51
    709a:	8e 7f       	andi	r24, 0xFE	; 254
    709c:	83 bf       	out	0x33, r24	; 51

/* Adjust rtimer ticks if rtimer is enabled. TIMER3 is preferred, else TIMER1 */
#if RTIMER_ARCH_PRESCALER
#ifdef TCNT3
    TCNT3 += howlong;
    709e:	80 91 94 00 	lds	r24, 0x0094
    70a2:	90 91 95 00 	lds	r25, 0x0095
    70a6:	8c 0f       	add	r24, r28
    70a8:	9d 1f       	adc	r25, r29
    70aa:	90 93 95 00 	sts	0x0095, r25
    70ae:	80 93 94 00 	sts	0x0094, r24
#else
    TCNT1 += howlong;
#endif
#endif
	ENERGEST_ON(ENERGEST_TYPE_CPU);
    70b2:	80 91 94 00 	lds	r24, 0x0094
    70b6:	90 91 95 00 	lds	r25, 0x0095
    70ba:	90 93 64 27 	sts	0x2764, r25
    70be:	80 93 63 27 	sts	0x2763, r24
    70c2:	81 e0       	ldi	r24, 0x01	; 1
    70c4:	80 93 57 27 	sts	0x2757, r24
    OCR2A  = savedOCR2A;
    TCNT2  = savedTCNT2;
    sei();
#else
/* Disable TIMER2 interrupt */
    TIMSK2 &= ~(1 << OCIE2A);
    70c8:	80 91 70 00 	lds	r24, 0x0070
    70cc:	8d 7f       	andi	r24, 0xFD	; 253
    70ce:	80 93 70 00 	sts	0x0070, r24
#endif
    watchdog_start();
    70d2:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <watchdog_start>

/* Adjust clock.c for the time spent sleeping */
	longhowlong=CLOCK_CONF_SECOND;
	longhowlong*=howlong;
    70d6:	c8 01       	movw	r24, r16
    70d8:	b7 01       	movw	r22, r14
    70da:	27 e0       	ldi	r18, 0x07	; 7
    70dc:	66 0f       	add	r22, r22
    70de:	77 1f       	adc	r23, r23
    70e0:	88 1f       	adc	r24, r24
    70e2:	99 1f       	adc	r25, r25
    70e4:	2a 95       	dec	r18
    70e6:	d1 f7       	brne	.-12     	; 0x70dc <rtimer_arch_sleep+0x154>
    clock_adjust_ticks(longhowlong/RTIMER_ARCH_SECOND);
    70e8:	24 e8       	ldi	r18, 0x84	; 132
    70ea:	3e e1       	ldi	r19, 0x1E	; 30
    70ec:	40 e0       	ldi	r20, 0x00	; 0
    70ee:	50 e0       	ldi	r21, 0x00	; 0
    70f0:	0e 94 89 4b 	call	0x9712	; 0x9712 <__udivmodsi4>
    70f4:	c9 01       	movw	r24, r18
    70f6:	0e 94 a1 1c 	call	0x3942	; 0x3942 <clock_adjust_ticks>

}
    70fa:	df 91       	pop	r29
    70fc:	cf 91       	pop	r28
    70fe:	1f 91       	pop	r17
    7100:	0f 91       	pop	r16
    7102:	ff 90       	pop	r15
    7104:	ef 90       	pop	r14
    7106:	08 95       	ret

00007108 <__vector_13>:
#if !AVR_CONF_USE32KCRYSTAL
/*---------------------------------------------------------------------------*/
/* TIMER2 Interrupt service */

ISR(TIMER2_COMPA_vect)
{
    7108:	1f 92       	push	r1
    710a:	0f 92       	push	r0
    710c:	0f b6       	in	r0, 0x3f	; 63
    710e:	0f 92       	push	r0
    7110:	11 24       	eor	r1, r1
//    TIMSK2 &= ~(1 << OCIE2A);       //Just one interrupt needed for waking
}
    7112:	0f 90       	pop	r0
    7114:	0f be       	out	0x3f, r0	; 63
    7116:	0f 90       	pop	r0
    7118:	1f 90       	pop	r1
    711a:	18 95       	reti

0000711c <field_len>:
  }
}
/*----------------------------------------------------------------------------*/
static void
field_len(frame802154_t *p, field_length_t *flen)
{
    711c:	ef 92       	push	r14
    711e:	ff 92       	push	r15
    7120:	cf 93       	push	r28
    7122:	df 93       	push	r29
    7124:	fc 01       	movw	r30, r24
    7126:	db 01       	movw	r26, r22
  /* init flen to zeros */
  memset(flen, 0, sizeof(field_length_t));
    7128:	85 e0       	ldi	r24, 0x05	; 5
    712a:	eb 01       	movw	r28, r22
    712c:	19 92       	st	Y+, r1
    712e:	8a 95       	dec	r24
    7130:	e9 f7       	brne	.-6      	; 0x712c <field_len+0x10>

  /* Determine lengths of each field based on fcf and other args */
  if(p->fcf.dest_addr_mode & 3) {
    7132:	85 81       	ldd	r24, Z+5	; 0x05
    7134:	90 e0       	ldi	r25, 0x00	; 0
    7136:	83 70       	andi	r24, 0x03	; 3
    7138:	90 70       	andi	r25, 0x00	; 0
    713a:	00 97       	sbiw	r24, 0x00	; 0
    713c:	11 f0       	breq	.+4      	; 0x7142 <field_len+0x26>
    flen->dest_pid_len = 2;
    713e:	82 e0       	ldi	r24, 0x02	; 2
    7140:	8c 93       	st	X, r24
  }
  if(p->fcf.src_addr_mode & 3) {
    7142:	87 81       	ldd	r24, Z+7	; 0x07
    7144:	90 e0       	ldi	r25, 0x00	; 0
    7146:	83 70       	andi	r24, 0x03	; 3
    7148:	90 70       	andi	r25, 0x00	; 0
    714a:	00 97       	sbiw	r24, 0x00	; 0
    714c:	21 f0       	breq	.+8      	; 0x7156 <field_len+0x3a>
    flen->src_pid_len = 2;
    714e:	82 e0       	ldi	r24, 0x02	; 2
    7150:	12 96       	adiw	r26, 0x02	; 2
    7152:	8c 93       	st	X, r24
    7154:	12 97       	sbiw	r26, 0x02	; 2
  }

  /* Set PAN ID compression bit if src pan id matches dest pan id. */
  if(p->fcf.dest_addr_mode & 3 && p->fcf.src_addr_mode & 3 &&
    7156:	85 81       	ldd	r24, Z+5	; 0x05
    7158:	90 e0       	ldi	r25, 0x00	; 0
    715a:	83 70       	andi	r24, 0x03	; 3
    715c:	90 70       	andi	r25, 0x00	; 0
    715e:	00 97       	sbiw	r24, 0x00	; 0
    7160:	99 f0       	breq	.+38     	; 0x7188 <field_len+0x6c>
    7162:	87 81       	ldd	r24, Z+7	; 0x07
    7164:	90 e0       	ldi	r25, 0x00	; 0
    7166:	83 70       	andi	r24, 0x03	; 3
    7168:	90 70       	andi	r25, 0x00	; 0
    716a:	00 97       	sbiw	r24, 0x00	; 0
    716c:	69 f0       	breq	.+26     	; 0x7188 <field_len+0x6c>
    716e:	23 89       	ldd	r18, Z+19	; 0x13
    7170:	34 89       	ldd	r19, Z+20	; 0x14
    7172:	81 85       	ldd	r24, Z+9	; 0x09
    7174:	92 85       	ldd	r25, Z+10	; 0x0a
    7176:	28 17       	cp	r18, r24
    7178:	39 07       	cpc	r19, r25
    717a:	31 f4       	brne	.+12     	; 0x7188 <field_len+0x6c>
     p->src_pid == p->dest_pid) {
    p->fcf.panid_compression = 1;
    717c:	81 e0       	ldi	r24, 0x01	; 1
    717e:	84 83       	std	Z+4, r24	; 0x04

    /* compressed header, only do dest pid */
    flen->src_pid_len = 0;
    7180:	12 96       	adiw	r26, 0x02	; 2
    7182:	1c 92       	st	X, r1
    7184:	12 97       	sbiw	r26, 0x02	; 2
    7186:	01 c0       	rjmp	.+2      	; 0x718a <field_len+0x6e>
  } else {
    p->fcf.panid_compression = 0;
    7188:	14 82       	std	Z+4, r1	; 0x04
  }

  /* determine address lengths */
  flen->dest_addr_len = addr_len(p->fcf.dest_addr_mode & 3);
    718a:	85 81       	ldd	r24, Z+5	; 0x05
    718c:	83 70       	andi	r24, 0x03	; 3
    718e:	82 50       	subi	r24, 0x02	; 2
    7190:	82 30       	cpi	r24, 0x02	; 2
    7192:	30 f4       	brcc	.+12     	; 0x71a0 <field_len+0x84>
    7194:	c8 2f       	mov	r28, r24
    7196:	d0 e0       	ldi	r29, 0x00	; 0
    7198:	cd 53       	subi	r28, 0x3D	; 61
    719a:	d1 4f       	sbci	r29, 0xF1	; 241
    719c:	88 81       	ld	r24, Y
    719e:	01 c0       	rjmp	.+2      	; 0x71a2 <field_len+0x86>
    71a0:	80 e0       	ldi	r24, 0x00	; 0
    71a2:	11 96       	adiw	r26, 0x01	; 1
    71a4:	8c 93       	st	X, r24
    71a6:	11 97       	sbiw	r26, 0x01	; 1
  flen->src_addr_len = addr_len(p->fcf.src_addr_mode & 3);
    71a8:	e7 81       	ldd	r30, Z+7	; 0x07
    71aa:	e3 70       	andi	r30, 0x03	; 3
    71ac:	e2 50       	subi	r30, 0x02	; 2
    71ae:	e2 30       	cpi	r30, 0x02	; 2
    71b0:	28 f4       	brcc	.+10     	; 0x71bc <field_len+0xa0>
    71b2:	f0 e0       	ldi	r31, 0x00	; 0
    71b4:	ed 53       	subi	r30, 0x3D	; 61
    71b6:	f1 4f       	sbci	r31, 0xF1	; 241
    71b8:	80 81       	ld	r24, Z
    71ba:	01 c0       	rjmp	.+2      	; 0x71be <field_len+0xa2>
    71bc:	80 e0       	ldi	r24, 0x00	; 0
    71be:	13 96       	adiw	r26, 0x03	; 3
    71c0:	8c 93       	st	X, r24
    71c2:	13 97       	sbiw	r26, 0x03	; 3
    default:
      break;
    }
#endif
  }
}
    71c4:	df 91       	pop	r29
    71c6:	cf 91       	pop	r28
    71c8:	ff 90       	pop	r15
    71ca:	ef 90       	pop	r14
    71cc:	08 95       	ret

000071ce <frame802154_hdrlen>:
 *
 *   \return The length of the frame header.
*/
uint8_t
frame802154_hdrlen(frame802154_t *p)
{
    71ce:	df 93       	push	r29
    71d0:	cf 93       	push	r28
    71d2:	00 d0       	rcall	.+0      	; 0x71d4 <frame802154_hdrlen+0x6>
    71d4:	00 d0       	rcall	.+0      	; 0x71d6 <frame802154_hdrlen+0x8>
    71d6:	0f 92       	push	r0
    71d8:	cd b7       	in	r28, 0x3d	; 61
    71da:	de b7       	in	r29, 0x3e	; 62
  field_length_t flen;
  field_len(p, &flen);
    71dc:	be 01       	movw	r22, r28
    71de:	6f 5f       	subi	r22, 0xFF	; 255
    71e0:	7f 4f       	sbci	r23, 0xFF	; 255
    71e2:	0e 94 8e 38 	call	0x711c	; 0x711c <field_len>
  return 3 + flen.dest_pid_len + flen.dest_addr_len +
    71e6:	89 81       	ldd	r24, Y+1	; 0x01
    71e8:	9a 81       	ldd	r25, Y+2	; 0x02
    71ea:	89 0f       	add	r24, r25
    71ec:	8d 5f       	subi	r24, 0xFD	; 253
    71ee:	9b 81       	ldd	r25, Y+3	; 0x03
    71f0:	89 0f       	add	r24, r25
    71f2:	9c 81       	ldd	r25, Y+4	; 0x04
    71f4:	89 0f       	add	r24, r25
    71f6:	9d 81       	ldd	r25, Y+5	; 0x05
    flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len;
}
    71f8:	89 0f       	add	r24, r25
    71fa:	0f 90       	pop	r0
    71fc:	0f 90       	pop	r0
    71fe:	0f 90       	pop	r0
    7200:	0f 90       	pop	r0
    7202:	0f 90       	pop	r0
    7204:	cf 91       	pop	r28
    7206:	df 91       	pop	r29
    7208:	08 95       	ret

0000720a <frame802154_create>:
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
{
    720a:	af 92       	push	r10
    720c:	bf 92       	push	r11
    720e:	cf 92       	push	r12
    7210:	df 92       	push	r13
    7212:	ef 92       	push	r14
    7214:	ff 92       	push	r15
    7216:	0f 93       	push	r16
    7218:	1f 93       	push	r17
    721a:	df 93       	push	r29
    721c:	cf 93       	push	r28
    721e:	00 d0       	rcall	.+0      	; 0x7220 <frame802154_create+0x16>
    7220:	00 d0       	rcall	.+0      	; 0x7222 <frame802154_create+0x18>
    7222:	00 d0       	rcall	.+0      	; 0x7224 <frame802154_create+0x1a>
    7224:	cd b7       	in	r28, 0x3d	; 61
    7226:	de b7       	in	r29, 0x3e	; 62
    7228:	8c 01       	movw	r16, r24
    722a:	7b 01       	movw	r14, r22
  int c;
  field_length_t flen;
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);
    722c:	be 01       	movw	r22, r28
    722e:	6f 5f       	subi	r22, 0xFF	; 255
    7230:	7f 4f       	sbci	r23, 0xFF	; 255
    7232:	4e 83       	std	Y+6, r20	; 0x06
    7234:	0e 94 8e 38 	call	0x711c	; 0x711c <field_len>

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    7238:	c9 80       	ldd	r12, Y+1	; 0x01
    723a:	9a 81       	ldd	r25, Y+2	; 0x02
    723c:	a9 2e       	mov	r10, r25
    723e:	bb 24       	eor	r11, r11
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    7240:	db 80       	ldd	r13, Y+3	; 0x03
    7242:	8c 81       	ldd	r24, Y+4	; 0x04
    7244:	68 2f       	mov	r22, r24
    7246:	70 e0       	ldi	r23, 0x00	; 0
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    7248:	95 01       	movw	r18, r10
    724a:	2c 0d       	add	r18, r12
    724c:	31 1d       	adc	r19, r1
    724e:	2d 5f       	subi	r18, 0xFD	; 253
    7250:	3f 4f       	sbci	r19, 0xFF	; 255
    7252:	2d 0d       	add	r18, r13
    7254:	31 1d       	adc	r19, r1
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    7256:	26 0f       	add	r18, r22
    7258:	37 1f       	adc	r19, r23
    725a:	5d 81       	ldd	r21, Y+5	; 0x05
    725c:	25 0f       	add	r18, r21
    725e:	31 1d       	adc	r19, r1
    7260:	4e 81       	ldd	r20, Y+6	; 0x06
    7262:	50 e0       	ldi	r21, 0x00	; 0
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    7264:	42 17       	cp	r20, r18
    7266:	53 07       	cpc	r21, r19
    7268:	0c f4       	brge	.+2      	; 0x726c <frame802154_create+0x62>
    726a:	a8 c0       	rjmp	.+336    	; 0x73bc <frame802154_create+0x1b2>

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    726c:	d8 01       	movw	r26, r16
    726e:	11 96       	adiw	r26, 0x01	; 1
    7270:	4c 91       	ld	r20, X
    7272:	11 97       	sbiw	r26, 0x01	; 1
    7274:	50 e0       	ldi	r21, 0x00	; 0
    7276:	41 70       	andi	r20, 0x01	; 1
    7278:	50 70       	andi	r21, 0x00	; 0
    727a:	e3 e0       	ldi	r30, 0x03	; 3
    727c:	44 0f       	add	r20, r20
    727e:	55 1f       	adc	r21, r21
    7280:	ea 95       	dec	r30
    7282:	e1 f7       	brne	.-8      	; 0x727c <frame802154_create+0x72>
    ((p->fcf.frame_pending & 1) << 4) |
    7284:	12 96       	adiw	r26, 0x02	; 2
    7286:	2c 91       	ld	r18, X
    7288:	12 97       	sbiw	r26, 0x02	; 2
    728a:	30 e0       	ldi	r19, 0x00	; 0
    728c:	21 70       	andi	r18, 0x01	; 1
    728e:	30 70       	andi	r19, 0x00	; 0
    7290:	54 e0       	ldi	r21, 0x04	; 4
    7292:	22 0f       	add	r18, r18
    7294:	33 1f       	adc	r19, r19
    7296:	5a 95       	dec	r21
    7298:	e1 f7       	brne	.-8      	; 0x7292 <frame802154_create+0x88>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    729a:	24 2b       	or	r18, r20
    729c:	3c 91       	ld	r19, X
    729e:	37 70       	andi	r19, 0x07	; 7
    72a0:	23 2b       	or	r18, r19
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    72a2:	13 96       	adiw	r26, 0x03	; 3
    72a4:	3c 91       	ld	r19, X
    72a6:	13 97       	sbiw	r26, 0x03	; 3
    72a8:	e3 2f       	mov	r30, r19
    72aa:	f0 e0       	ldi	r31, 0x00	; 0
    72ac:	e1 70       	andi	r30, 0x01	; 1
    72ae:	f0 70       	andi	r31, 0x00	; 0
    72b0:	45 e0       	ldi	r20, 0x05	; 5
    72b2:	ee 0f       	add	r30, r30
    72b4:	ff 1f       	adc	r31, r31
    72b6:	4a 95       	dec	r20
    72b8:	e1 f7       	brne	.-8      	; 0x72b2 <frame802154_create+0xa8>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    72ba:	2e 2b       	or	r18, r30
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
    72bc:	14 96       	adiw	r26, 0x04	; 4
    72be:	3c 91       	ld	r19, X
    72c0:	14 97       	sbiw	r26, 0x04	; 4
    72c2:	e3 2f       	mov	r30, r19
    72c4:	f0 e0       	ldi	r31, 0x00	; 0
    72c6:	e1 70       	andi	r30, 0x01	; 1
    72c8:	f0 70       	andi	r31, 0x00	; 0
    72ca:	36 e0       	ldi	r19, 0x06	; 6
    72cc:	ee 0f       	add	r30, r30
    72ce:	ff 1f       	adc	r31, r31
    72d0:	3a 95       	dec	r19
    72d2:	e1 f7       	brne	.-8      	; 0x72cc <frame802154_create+0xc2>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    72d4:	2e 2b       	or	r18, r30
    72d6:	f7 01       	movw	r30, r14
    72d8:	20 83       	st	Z, r18
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    72da:	15 96       	adiw	r26, 0x05	; 5
    72dc:	4c 91       	ld	r20, X
    72de:	15 97       	sbiw	r26, 0x05	; 5
    72e0:	50 e0       	ldi	r21, 0x00	; 0
    72e2:	43 70       	andi	r20, 0x03	; 3
    72e4:	50 70       	andi	r21, 0x00	; 0
    72e6:	44 0f       	add	r20, r20
    72e8:	55 1f       	adc	r21, r21
    72ea:	44 0f       	add	r20, r20
    72ec:	55 1f       	adc	r21, r21
    ((p->fcf.frame_version & 3) << 4) |
    72ee:	16 96       	adiw	r26, 0x06	; 6
    72f0:	2c 91       	ld	r18, X
    72f2:	16 97       	sbiw	r26, 0x06	; 6
    72f4:	30 e0       	ldi	r19, 0x00	; 0
    72f6:	23 70       	andi	r18, 0x03	; 3
    72f8:	30 70       	andi	r19, 0x00	; 0
    72fa:	54 e0       	ldi	r21, 0x04	; 4
    72fc:	22 0f       	add	r18, r18
    72fe:	33 1f       	adc	r19, r19
    7300:	5a 95       	dec	r21
    7302:	e1 f7       	brne	.-8      	; 0x72fc <frame802154_create+0xf2>
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    7304:	24 2b       	or	r18, r20
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);
    7306:	17 96       	adiw	r26, 0x07	; 7
    7308:	3c 91       	ld	r19, X
    730a:	17 97       	sbiw	r26, 0x07	; 7
    730c:	32 95       	swap	r19
    730e:	33 0f       	add	r19, r19
    7310:	33 0f       	add	r19, r19
    7312:	30 7c       	andi	r19, 0xC0	; 192
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    7314:	32 2b       	or	r19, r18
    7316:	31 83       	std	Z+1, r19	; 0x01
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);

  /* sequence number */
  tx_frame_buffer[2] = p->seq;
    7318:	18 96       	adiw	r26, 0x08	; 8
    731a:	2c 91       	ld	r18, X
    731c:	18 97       	sbiw	r26, 0x08	; 8
    731e:	22 83       	std	Z+2, r18	; 0x02
  pos = 3;

  /* Destination PAN ID */
  if(flen.dest_pid_len == 2) {
    7320:	fc 2d       	mov	r31, r12
    7322:	f2 30       	cpi	r31, 0x02	; 2
    7324:	69 f4       	brne	.+26     	; 0x7340 <frame802154_create+0x136>
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    7326:	19 96       	adiw	r26, 0x09	; 9
    7328:	2c 91       	ld	r18, X
    732a:	d7 01       	movw	r26, r14
    732c:	13 96       	adiw	r26, 0x03	; 3
    732e:	2c 93       	st	X, r18
    7330:	13 97       	sbiw	r26, 0x03	; 3
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
    7332:	f8 01       	movw	r30, r16
    7334:	22 85       	ldd	r18, Z+10	; 0x0a
    7336:	14 96       	adiw	r26, 0x04	; 4
    7338:	2c 93       	st	X, r18
    733a:	14 97       	sbiw	r26, 0x04	; 4
    733c:	45 e0       	ldi	r20, 0x05	; 5
    733e:	01 c0       	rjmp	.+2      	; 0x7342 <frame802154_create+0x138>
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);

  /* sequence number */
  tx_frame_buffer[2] = p->seq;
  pos = 3;
    7340:	43 e0       	ldi	r20, 0x03	; 3
 *
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
    7342:	e9 2f       	mov	r30, r25
    7344:	f0 e0       	ldi	r31, 0x00	; 0
    7346:	3b 96       	adiw	r30, 0x0b	; 11
    7348:	e0 0f       	add	r30, r16
    734a:	f1 1f       	adc	r31, r17
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
  }

  /* Destination address */
  for(c = flen.dest_addr_len; c > 0; c--) {
    734c:	54 2f       	mov	r21, r20
    734e:	0a c0       	rjmp	.+20     	; 0x7364 <frame802154_create+0x15a>
    tx_frame_buffer[pos++] = p->dest_addr[c - 1];
    7350:	97 01       	movw	r18, r14
    7352:	25 0f       	add	r18, r21
    7354:	31 1d       	adc	r19, r1
    7356:	c2 90       	ld	r12, -Z
    7358:	d9 01       	movw	r26, r18
    735a:	cc 92       	st	X, r12
    735c:	5f 5f       	subi	r21, 0xFF	; 255
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
  }

  /* Destination address */
  for(c = flen.dest_addr_len; c > 0; c--) {
    735e:	08 94       	sec
    7360:	a1 08       	sbc	r10, r1
    7362:	b1 08       	sbc	r11, r1
    7364:	a1 14       	cp	r10, r1
    7366:	b1 04       	cpc	r11, r1
    7368:	99 f7       	brne	.-26     	; 0x7350 <frame802154_create+0x146>
    736a:	94 0f       	add	r25, r20
    tx_frame_buffer[pos++] = p->dest_addr[c - 1];
  }

  /* Source PAN ID */
  if(flen.src_pid_len == 2) {
    736c:	bd 2d       	mov	r27, r13
    736e:	b2 30       	cpi	r27, 0x02	; 2
    7370:	89 f4       	brne	.+34     	; 0x7394 <frame802154_create+0x18a>
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    7372:	f7 01       	movw	r30, r14
    7374:	e9 0f       	add	r30, r25
    7376:	f1 1d       	adc	r31, r1
    7378:	d8 01       	movw	r26, r16
    737a:	53 96       	adiw	r26, 0x13	; 19
    737c:	2c 91       	ld	r18, X
    737e:	53 97       	sbiw	r26, 0x13	; 19
    7380:	20 83       	st	Z, r18
    7382:	9f 5f       	subi	r25, 0xFF	; 255
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
    7384:	f7 01       	movw	r30, r14
    7386:	e9 0f       	add	r30, r25
    7388:	f1 1d       	adc	r31, r1
    738a:	54 96       	adiw	r26, 0x14	; 20
    738c:	2c 91       	ld	r18, X
    738e:	54 97       	sbiw	r26, 0x14	; 20
    7390:	20 83       	st	Z, r18
    7392:	9f 5f       	subi	r25, 0xFF	; 255
 *
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
    7394:	e8 2f       	mov	r30, r24
    7396:	f0 e0       	ldi	r31, 0x00	; 0
    7398:	75 96       	adiw	r30, 0x15	; 21
    739a:	e0 0f       	add	r30, r16
    739c:	f1 1f       	adc	r31, r17
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
  }

  /* Source address */
  for(c = flen.src_addr_len; c > 0; c--) {
    739e:	29 2f       	mov	r18, r25
    73a0:	08 c0       	rjmp	.+16     	; 0x73b2 <frame802154_create+0x1a8>
    tx_frame_buffer[pos++] = p->src_addr[c - 1];
    73a2:	d7 01       	movw	r26, r14
    73a4:	a2 0f       	add	r26, r18
    73a6:	b1 1d       	adc	r27, r1
    73a8:	32 91       	ld	r19, -Z
    73aa:	3c 93       	st	X, r19
    73ac:	2f 5f       	subi	r18, 0xFF	; 255
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
  }

  /* Source address */
  for(c = flen.src_addr_len; c > 0; c--) {
    73ae:	61 50       	subi	r22, 0x01	; 1
    73b0:	70 40       	sbci	r23, 0x00	; 0
    73b2:	61 15       	cp	r22, r1
    73b4:	71 05       	cpc	r23, r1
    73b6:	a9 f7       	brne	.-22     	; 0x73a2 <frame802154_create+0x198>
    73b8:	89 0f       	add	r24, r25
    73ba:	01 c0       	rjmp	.+2      	; 0x73be <frame802154_create+0x1b4>
  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    /* Too little space for headers. */
    return 0;
    73bc:	80 e0       	ldi	r24, 0x00	; 0
    /* TODO Aux security header not yet implemented */
/*     pos += flen.aux_sec_len; */
  }

  return pos;
}
    73be:	26 96       	adiw	r28, 0x06	; 6
    73c0:	0f b6       	in	r0, 0x3f	; 63
    73c2:	f8 94       	cli
    73c4:	de bf       	out	0x3e, r29	; 62
    73c6:	0f be       	out	0x3f, r0	; 63
    73c8:	cd bf       	out	0x3d, r28	; 61
    73ca:	cf 91       	pop	r28
    73cc:	df 91       	pop	r29
    73ce:	1f 91       	pop	r17
    73d0:	0f 91       	pop	r16
    73d2:	ff 90       	pop	r15
    73d4:	ef 90       	pop	r14
    73d6:	df 90       	pop	r13
    73d8:	cf 90       	pop	r12
    73da:	bf 90       	pop	r11
    73dc:	af 90       	pop	r10
    73de:	08 95       	ret

000073e0 <frame802154_parse>:
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
{
    73e0:	bf 92       	push	r11
    73e2:	cf 92       	push	r12
    73e4:	df 92       	push	r13
    73e6:	ef 92       	push	r14
    73e8:	ff 92       	push	r15
    73ea:	0f 93       	push	r16
    73ec:	1f 93       	push	r17
    73ee:	cf 93       	push	r28
    73f0:	df 93       	push	r29
    73f2:	7c 01       	movw	r14, r24
    73f4:	d6 2e       	mov	r13, r22
    73f6:	ea 01       	movw	r28, r20
  uint8_t *p;
  frame802154_fcf_t fcf;
  uint8_t c;

  if(len < 3) {
    73f8:	63 30       	cpi	r22, 0x03	; 3
    73fa:	08 f4       	brcc	.+2      	; 0x73fe <frame802154_parse+0x1e>
    73fc:	ad c0       	rjmp	.+346    	; 0x7558 <frame802154_parse+0x178>
  }

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
    73fe:	fc 01       	movw	r30, r24
    7400:	80 81       	ld	r24, Z
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;
    7402:	b8 2e       	mov	r11, r24
    7404:	b2 94       	swap	r11
    7406:	b6 94       	lsr	r11
    7408:	b6 94       	lsr	r11
    740a:	b3 e0       	ldi	r27, 0x03	; 3
    740c:	bb 22       	and	r11, r27
    740e:	f1 e0       	ldi	r31, 0x01	; 1
    7410:	bf 22       	and	r11, r31

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
    7412:	f7 01       	movw	r30, r14
    7414:	91 81       	ldd	r25, Z+1	; 0x01
    7416:	29 2f       	mov	r18, r25
    7418:	26 95       	lsr	r18
    741a:	26 95       	lsr	r18
    741c:	23 70       	andi	r18, 0x03	; 3
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    741e:	c9 2e       	mov	r12, r25
    7420:	c2 94       	swap	r12
    7422:	c6 94       	lsr	r12
    7424:	c6 94       	lsr	r12
    7426:	a3 e0       	ldi	r26, 0x03	; 3
    7428:	ca 22       	and	r12, r26
  }

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
    742a:	38 2f       	mov	r19, r24
    742c:	37 70       	andi	r19, 0x07	; 7
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    742e:	38 83       	st	Y, r19

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
    7430:	38 2f       	mov	r19, r24
    7432:	36 95       	lsr	r19
    7434:	36 95       	lsr	r19
    7436:	36 95       	lsr	r19
    7438:	31 70       	andi	r19, 0x01	; 1
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    743a:	39 83       	std	Y+1, r19	; 0x01
  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
    743c:	38 2f       	mov	r19, r24
    743e:	32 95       	swap	r19
    7440:	31 70       	andi	r19, 0x01	; 1
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    7442:	3a 83       	std	Y+2, r19	; 0x02

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
    7444:	82 95       	swap	r24
    7446:	86 95       	lsr	r24
    7448:	81 70       	andi	r24, 0x01	; 1
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    744a:	8b 83       	std	Y+3, r24	; 0x03
    744c:	bc 82       	std	Y+4, r11	; 0x04
    744e:	2d 83       	std	Y+5, r18	; 0x05
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
    7450:	89 2f       	mov	r24, r25
    7452:	82 95       	swap	r24
    7454:	83 70       	andi	r24, 0x03	; 3
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    7456:	8e 83       	std	Y+6, r24	; 0x06
    7458:	cf 82       	std	Y+7, r12	; 0x07

  /* copy fcf and seqNum */
  memcpy(&pf->fcf, &fcf, sizeof(frame802154_fcf_t));
  pf->seq = p[2];
    745a:	82 81       	ldd	r24, Z+2	; 0x02
    745c:	88 87       	std	Y+8, r24	; 0x08
  p += 3;                             /* Skip first three bytes */
    745e:	87 01       	movw	r16, r14
    7460:	0d 5f       	subi	r16, 0xFD	; 253
    7462:	1f 4f       	sbci	r17, 0xFF	; 255

  /* Destination address, if any */
  if(fcf.dest_addr_mode) {
    7464:	22 23       	and	r18, r18
    7466:	61 f1       	breq	.+88     	; 0x74c0 <frame802154_parse+0xe0>
    /* Destination PAN */
    pf->dest_pid = p[0] + (p[1] << 8);
    7468:	f8 01       	movw	r30, r16
    746a:	91 81       	ldd	r25, Z+1	; 0x01
    746c:	80 e0       	ldi	r24, 0x00	; 0
    746e:	f7 01       	movw	r30, r14
    7470:	33 81       	ldd	r19, Z+3	; 0x03
    7472:	83 0f       	add	r24, r19
    7474:	91 1d       	adc	r25, r1
    7476:	9a 87       	std	Y+10, r25	; 0x0a
    7478:	89 87       	std	Y+9, r24	; 0x09
    p += 2;
    747a:	87 01       	movw	r16, r14
    747c:	0b 5f       	subi	r16, 0xFB	; 251
    747e:	1f 4f       	sbci	r17, 0xFF	; 255
/*     l = addr_len(fcf.dest_addr_mode); */
/*     for(c = 0; c < l; c++) { */
/*       pf->dest_addr.u8[c] = p[l - c - 1]; */
/*     } */
/*     p += l; */
    if(fcf.dest_addr_mode == FRAME802154_SHORTADDRMODE) {
    7480:	22 30       	cpi	r18, 0x02	; 2
    7482:	81 f4       	brne	.+32     	; 0x74a4 <frame802154_parse+0xc4>
      rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
    7484:	ca 01       	movw	r24, r20
    7486:	0b 96       	adiw	r24, 0x0b	; 11
    7488:	69 e3       	ldi	r22, 0x39	; 57
    748a:	7e e0       	ldi	r23, 0x0E	; 14
    748c:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
      pf->dest_addr[0] = p[1];
    7490:	f8 01       	movw	r30, r16
    7492:	81 81       	ldd	r24, Z+1	; 0x01
    7494:	8b 87       	std	Y+11, r24	; 0x0b
      pf->dest_addr[1] = p[0];
    7496:	f7 01       	movw	r30, r14
    7498:	85 81       	ldd	r24, Z+5	; 0x05
    749a:	8c 87       	std	Y+12, r24	; 0x0c
      p += 2;
    749c:	87 01       	movw	r16, r14
    749e:	09 5f       	subi	r16, 0xF9	; 249
    74a0:	1f 4f       	sbci	r17, 0xFF	; 255
    74a2:	16 c0       	rjmp	.+44     	; 0x74d0 <frame802154_parse+0xf0>
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
    74a4:	23 30       	cpi	r18, 0x03	; 3
    74a6:	a1 f4       	brne	.+40     	; 0x74d0 <frame802154_parse+0xf0>
 *   \param data The input data from the radio chip.
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
    74a8:	f7 01       	movw	r30, r14
    74aa:	3d 96       	adiw	r30, 0x0d	; 13
    74ac:	da 01       	movw	r26, r20
    74ae:	1b 96       	adiw	r26, 0x0b	; 11
      pf->dest_addr[0] = p[1];
      pf->dest_addr[1] = p[0];
      p += 2;
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
        pf->dest_addr[c] = p[7 - c];
    74b0:	82 91       	ld	r24, -Z
    74b2:	8d 93       	st	X+, r24
      rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
      pf->dest_addr[0] = p[1];
      pf->dest_addr[1] = p[0];
      p += 2;
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
    74b4:	e0 17       	cp	r30, r16
    74b6:	f1 07       	cpc	r31, r17
    74b8:	d9 f7       	brne	.-10     	; 0x74b0 <frame802154_parse+0xd0>
        pf->dest_addr[c] = p[7 - c];
      }
      p += 8;
    74ba:	08 5f       	subi	r16, 0xF8	; 248
    74bc:	1f 4f       	sbci	r17, 0xFF	; 255
    74be:	08 c0       	rjmp	.+16     	; 0x74d0 <frame802154_parse+0xf0>
    }
  } else {
    rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
    74c0:	ca 01       	movw	r24, r20
    74c2:	0b 96       	adiw	r24, 0x0b	; 11
    74c4:	69 e3       	ldi	r22, 0x39	; 57
    74c6:	7e e0       	ldi	r23, 0x0E	; 14
    74c8:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
    pf->dest_pid = 0;
    74cc:	1a 86       	std	Y+10, r1	; 0x0a
    74ce:	19 86       	std	Y+9, r1	; 0x09
  }

  /* Source address, if any */
  if(fcf.src_addr_mode) {
    74d0:	cc 20       	and	r12, r12
    74d2:	89 f1       	breq	.+98     	; 0x7536 <frame802154_parse+0x156>
    /* Source PAN */
    if(!fcf.panid_compression) {
    74d4:	bb 20       	and	r11, r11
    74d6:	59 f4       	brne	.+22     	; 0x74ee <frame802154_parse+0x10e>
      pf->src_pid = p[0] + (p[1] << 8);
    74d8:	f8 01       	movw	r30, r16
    74da:	91 81       	ldd	r25, Z+1	; 0x01
    74dc:	80 e0       	ldi	r24, 0x00	; 0
    74de:	20 81       	ld	r18, Z
    74e0:	82 0f       	add	r24, r18
    74e2:	91 1d       	adc	r25, r1
    74e4:	9c 8b       	std	Y+20, r25	; 0x14
    74e6:	8b 8b       	std	Y+19, r24	; 0x13
      p += 2;
    74e8:	0e 5f       	subi	r16, 0xFE	; 254
    74ea:	1f 4f       	sbci	r17, 0xFF	; 255
    74ec:	04 c0       	rjmp	.+8      	; 0x74f6 <frame802154_parse+0x116>
    } else {
      pf->src_pid = pf->dest_pid;
    74ee:	89 85       	ldd	r24, Y+9	; 0x09
    74f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    74f2:	9c 8b       	std	Y+20, r25	; 0x14
    74f4:	8b 8b       	std	Y+19, r24	; 0x13
/*     l = addr_len(fcf.src_addr_mode); */
/*     for(c = 0; c < l; c++) { */
/*       pf->src_addr.u8[c] = p[l - c - 1]; */
/*     } */
/*     p += l; */
    if(fcf.src_addr_mode == FRAME802154_SHORTADDRMODE) {
    74f6:	fc 2d       	mov	r31, r12
    74f8:	f2 30       	cpi	r31, 0x02	; 2
    74fa:	71 f4       	brne	.+28     	; 0x7518 <frame802154_parse+0x138>
      rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
    74fc:	ce 01       	movw	r24, r28
    74fe:	45 96       	adiw	r24, 0x15	; 21
    7500:	69 e3       	ldi	r22, 0x39	; 57
    7502:	7e e0       	ldi	r23, 0x0E	; 14
    7504:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
      pf->src_addr[0] = p[1];
    7508:	f8 01       	movw	r30, r16
    750a:	81 81       	ldd	r24, Z+1	; 0x01
    750c:	8d 8b       	std	Y+21, r24	; 0x15
      pf->src_addr[1] = p[0];
    750e:	80 81       	ld	r24, Z
    7510:	8e 8b       	std	Y+22, r24	; 0x16
      p += 2;
    7512:	0e 5f       	subi	r16, 0xFE	; 254
    7514:	1f 4f       	sbci	r17, 0xFF	; 255
    7516:	17 c0       	rjmp	.+46     	; 0x7546 <frame802154_parse+0x166>
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
    7518:	fc 2d       	mov	r31, r12
    751a:	f3 30       	cpi	r31, 0x03	; 3
    751c:	a1 f4       	brne	.+40     	; 0x7546 <frame802154_parse+0x166>
 *   \param data The input data from the radio chip.
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
    751e:	08 5f       	subi	r16, 0xF8	; 248
    7520:	1f 4f       	sbci	r17, 0xFF	; 255
    7522:	d8 01       	movw	r26, r16
    7524:	fe 01       	movw	r30, r28
    7526:	75 96       	adiw	r30, 0x15	; 21
    7528:	80 e0       	ldi	r24, 0x00	; 0
      pf->src_addr[0] = p[1];
      pf->src_addr[1] = p[0];
      p += 2;
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
        pf->src_addr[c] = p[7 - c];
    752a:	9e 91       	ld	r25, -X
    752c:	91 93       	st	Z+, r25
      rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
      pf->src_addr[0] = p[1];
      pf->src_addr[1] = p[0];
      p += 2;
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
    752e:	8f 5f       	subi	r24, 0xFF	; 255
    7530:	88 30       	cpi	r24, 0x08	; 8
    7532:	d9 f7       	brne	.-10     	; 0x752a <frame802154_parse+0x14a>
    7534:	08 c0       	rjmp	.+16     	; 0x7546 <frame802154_parse+0x166>
        pf->src_addr[c] = p[7 - c];
      }
      p += 8;
    }
  } else {
    rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
    7536:	ce 01       	movw	r24, r28
    7538:	45 96       	adiw	r24, 0x15	; 21
    753a:	69 e3       	ldi	r22, 0x39	; 57
    753c:	7e e0       	ldi	r23, 0x0E	; 14
    753e:	0e 94 09 26 	call	0x4c12	; 0x4c12 <rimeaddr_copy>
    pf->src_pid = 0;
    7542:	1c 8a       	std	Y+20, r1	; 0x14
    7544:	1b 8a       	std	Y+19, r1	; 0x13
    /* TODO aux security header, not yet implemented */
/*     return 0; */
  }

  /* header length */
  c = p - data;
    7546:	80 2f       	mov	r24, r16
    7548:	8e 19       	sub	r24, r14
  /* payload length */
  pf->payload_len = len - c;
    754a:	9d 2d       	mov	r25, r13
    754c:	98 1b       	sub	r25, r24
    754e:	9f a7       	std	Y+47, r25	; 0x2f
  /* payload */
  pf->payload = p;
    7550:	1e a7       	std	Y+46, r17	; 0x2e
    7552:	0d a7       	std	Y+45, r16	; 0x2d

  /* return header length if successful */
  return c > len ? 0 : c;
    7554:	d8 16       	cp	r13, r24
    7556:	08 f4       	brcc	.+2      	; 0x755a <frame802154_parse+0x17a>
  uint8_t *p;
  frame802154_fcf_t fcf;
  uint8_t c;

  if(len < 3) {
    return 0;
    7558:	80 e0       	ldi	r24, 0x00	; 0
  /* payload */
  pf->payload = p;

  /* return header length if successful */
  return c > len ? 0 : c;
}
    755a:	df 91       	pop	r29
    755c:	cf 91       	pop	r28
    755e:	1f 91       	pop	r17
    7560:	0f 91       	pop	r16
    7562:	ff 90       	pop	r15
    7564:	ef 90       	pop	r14
    7566:	df 90       	pop	r13
    7568:	cf 90       	pop	r12
    756a:	bf 90       	pop	r11
    756c:	08 95       	ret

0000756e <memb_init>:
#include "lib/memb.h"

/*---------------------------------------------------------------------------*/
void
memb_init(struct memb *m)
{
    756e:	cf 93       	push	r28
    7570:	df 93       	push	r29
    7572:	ec 01       	movw	r28, r24
  memset(m->count, 0, m->num);
    7574:	4a 81       	ldd	r20, Y+2	; 0x02
    7576:	5b 81       	ldd	r21, Y+3	; 0x03
    7578:	8c 81       	ldd	r24, Y+4	; 0x04
    757a:	9d 81       	ldd	r25, Y+5	; 0x05
    757c:	60 e0       	ldi	r22, 0x00	; 0
    757e:	70 e0       	ldi	r23, 0x00	; 0
    7580:	0e 94 56 4c 	call	0x98ac	; 0x98ac <memset>
  memset(m->mem, 0, m->size * m->num);
    7584:	4a 81       	ldd	r20, Y+2	; 0x02
    7586:	5b 81       	ldd	r21, Y+3	; 0x03
    7588:	88 81       	ld	r24, Y
    758a:	99 81       	ldd	r25, Y+1	; 0x01
    758c:	48 9f       	mul	r20, r24
    758e:	90 01       	movw	r18, r0
    7590:	49 9f       	mul	r20, r25
    7592:	30 0d       	add	r19, r0
    7594:	58 9f       	mul	r21, r24
    7596:	30 0d       	add	r19, r0
    7598:	11 24       	eor	r1, r1
    759a:	8e 81       	ldd	r24, Y+6	; 0x06
    759c:	9f 81       	ldd	r25, Y+7	; 0x07
    759e:	60 e0       	ldi	r22, 0x00	; 0
    75a0:	70 e0       	ldi	r23, 0x00	; 0
    75a2:	a9 01       	movw	r20, r18
    75a4:	0e 94 56 4c 	call	0x98ac	; 0x98ac <memset>
}
    75a8:	df 91       	pop	r29
    75aa:	cf 91       	pop	r28
    75ac:	08 95       	ret

000075ae <memb_alloc>:
/*---------------------------------------------------------------------------*/
void *
memb_alloc(struct memb *m)
{
    75ae:	fc 01       	movw	r30, r24
  int i;

  for(i = 0; i < m->num; ++i) {
    75b0:	82 81       	ldd	r24, Z+2	; 0x02
    75b2:	93 81       	ldd	r25, Z+3	; 0x03
    75b4:	20 e0       	ldi	r18, 0x00	; 0
    75b6:	30 e0       	ldi	r19, 0x00	; 0
    75b8:	19 c0       	rjmp	.+50     	; 0x75ec <memb_alloc+0x3e>
    if(m->count[i] == 0) {
    75ba:	a4 81       	ldd	r26, Z+4	; 0x04
    75bc:	b5 81       	ldd	r27, Z+5	; 0x05
    75be:	a2 0f       	add	r26, r18
    75c0:	b3 1f       	adc	r27, r19
    75c2:	4c 91       	ld	r20, X
    75c4:	44 23       	and	r20, r20
    75c6:	81 f4       	brne	.+32     	; 0x75e8 <memb_alloc+0x3a>
      /* If this block was unused, we increase the reference count to
	 indicate that it now is used and return a pointer to the
	 memory block. */
      ++(m->count[i]);
    75c8:	81 e0       	ldi	r24, 0x01	; 1
    75ca:	8c 93       	st	X, r24
      return (void *)((char *)m->mem + (i * m->size));
    75cc:	40 81       	ld	r20, Z
    75ce:	51 81       	ldd	r21, Z+1	; 0x01
    75d0:	24 9f       	mul	r18, r20
    75d2:	c0 01       	movw	r24, r0
    75d4:	25 9f       	mul	r18, r21
    75d6:	90 0d       	add	r25, r0
    75d8:	34 9f       	mul	r19, r20
    75da:	90 0d       	add	r25, r0
    75dc:	11 24       	eor	r1, r1
    75de:	26 81       	ldd	r18, Z+6	; 0x06
    75e0:	37 81       	ldd	r19, Z+7	; 0x07
    75e2:	28 0f       	add	r18, r24
    75e4:	39 1f       	adc	r19, r25
    75e6:	07 c0       	rjmp	.+14     	; 0x75f6 <memb_alloc+0x48>
void *
memb_alloc(struct memb *m)
{
  int i;

  for(i = 0; i < m->num; ++i) {
    75e8:	2f 5f       	subi	r18, 0xFF	; 255
    75ea:	3f 4f       	sbci	r19, 0xFF	; 255
    75ec:	28 17       	cp	r18, r24
    75ee:	39 07       	cpc	r19, r25
    75f0:	20 f3       	brcs	.-56     	; 0x75ba <memb_alloc+0xc>
    }
  }

  /* No free block was found, so we return NULL to indicate failure to
     allocate block. */
  return NULL;
    75f2:	20 e0       	ldi	r18, 0x00	; 0
    75f4:	30 e0       	ldi	r19, 0x00	; 0
}
    75f6:	c9 01       	movw	r24, r18
    75f8:	08 95       	ret

000075fa <memb_free>:
/*---------------------------------------------------------------------------*/
char
memb_free(struct memb *m, void *ptr)
{
    75fa:	fc 01       	movw	r30, r24
  int i;
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
    75fc:	26 81       	ldd	r18, Z+6	; 0x06
    75fe:	37 81       	ldd	r19, Z+7	; 0x07
  for(i = 0; i < m->num; ++i) {
    7600:	42 81       	ldd	r20, Z+2	; 0x02
    7602:	53 81       	ldd	r21, Z+3	; 0x03
    7604:	80 e0       	ldi	r24, 0x00	; 0
    7606:	90 e0       	ldi	r25, 0x00	; 0
    7608:	18 c0       	rjmp	.+48     	; 0x763a <memb_free+0x40>
    
    if(ptr2 == (char *)ptr) {
    760a:	26 17       	cp	r18, r22
    760c:	37 07       	cpc	r19, r23
    760e:	81 f4       	brne	.+32     	; 0x7630 <memb_free+0x36>
      /* We've found to block to which "ptr" points so we decrease the
	 reference count and return the new value of it. */
      if(m->count[i] > 0) {
    7610:	a4 81       	ldd	r26, Z+4	; 0x04
    7612:	b5 81       	ldd	r27, Z+5	; 0x05
    7614:	a8 0f       	add	r26, r24
    7616:	b9 1f       	adc	r27, r25
    7618:	2c 91       	ld	r18, X
    761a:	12 16       	cp	r1, r18
    761c:	14 f4       	brge	.+4      	; 0x7622 <memb_free+0x28>
	/* Make sure that we don't deallocate free memory. */
	--(m->count[i]);
    761e:	21 50       	subi	r18, 0x01	; 1
    7620:	2c 93       	st	X, r18
      }
      return m->count[i];
    7622:	04 80       	ldd	r0, Z+4	; 0x04
    7624:	f5 81       	ldd	r31, Z+5	; 0x05
    7626:	e0 2d       	mov	r30, r0
    7628:	e8 0f       	add	r30, r24
    762a:	f9 1f       	adc	r31, r25
    762c:	80 81       	ld	r24, Z
    762e:	08 95       	ret
    }
    ptr2 += m->size;
    7630:	a0 81       	ld	r26, Z
    7632:	b1 81       	ldd	r27, Z+1	; 0x01
    7634:	2a 0f       	add	r18, r26
    7636:	3b 1f       	adc	r19, r27
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
  for(i = 0; i < m->num; ++i) {
    7638:	01 96       	adiw	r24, 0x01	; 1
    763a:	84 17       	cp	r24, r20
    763c:	95 07       	cpc	r25, r21
    763e:	28 f3       	brcs	.-54     	; 0x760a <memb_free+0x10>
      }
      return m->count[i];
    }
    ptr2 += m->size;
  }
  return -1;
    7640:	8f ef       	ldi	r24, 0xFF	; 255
}
    7642:	08 95       	ret

00007644 <memb_inmemb>:
/*---------------------------------------------------------------------------*/
int
memb_inmemb(struct memb *m, void *ptr)
{
    7644:	fc 01       	movw	r30, r24
  return (char *)ptr >= (char *)m->mem &&
    7646:	cb 01       	movw	r24, r22
    7648:	26 81       	ldd	r18, Z+6	; 0x06
    764a:	37 81       	ldd	r19, Z+7	; 0x07
    764c:	62 17       	cp	r22, r18
    764e:	73 07       	cpc	r23, r19
    7650:	90 f0       	brcs	.+36     	; 0x7676 <memb_inmemb+0x32>
    (char *)ptr < (char *)m->mem + (m->num * m->size);
    7652:	a0 81       	ld	r26, Z
    7654:	b1 81       	ldd	r27, Z+1	; 0x01
    7656:	62 81       	ldd	r22, Z+2	; 0x02
    7658:	73 81       	ldd	r23, Z+3	; 0x03
    765a:	a6 9f       	mul	r26, r22
    765c:	a0 01       	movw	r20, r0
    765e:	a7 9f       	mul	r26, r23
    7660:	50 0d       	add	r21, r0
    7662:	b6 9f       	mul	r27, r22
    7664:	50 0d       	add	r21, r0
    7666:	11 24       	eor	r1, r1
    7668:	42 0f       	add	r20, r18
    766a:	53 1f       	adc	r21, r19
  }
  return -1;
}
/*---------------------------------------------------------------------------*/
int
memb_inmemb(struct memb *m, void *ptr)
    766c:	21 e0       	ldi	r18, 0x01	; 1
    766e:	30 e0       	ldi	r19, 0x00	; 0
    7670:	84 17       	cp	r24, r20
    7672:	95 07       	cpc	r25, r21
    7674:	10 f0       	brcs	.+4      	; 0x767a <memb_inmemb+0x36>
{
  return (char *)ptr >= (char *)m->mem &&
    7676:	20 e0       	ldi	r18, 0x00	; 0
    7678:	30 e0       	ldi	r19, 0x00	; 0
    (char *)ptr < (char *)m->mem + (m->num * m->size);
}
    767a:	c9 01       	movw	r24, r18
    767c:	08 95       	ret

0000767e <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static uint16_t
chksum(uint16_t sum, const uint8_t *data, uint16_t len)
{
    767e:	9c 01       	movw	r18, r24
  uint16_t t;
  const uint8_t *dataptr;
  const uint8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    7680:	41 50       	subi	r20, 0x01	; 1
    7682:	50 40       	sbci	r21, 0x00	; 0
    7684:	46 0f       	add	r20, r22
    7686:	57 1f       	adc	r21, r23
{
  uint16_t t;
  const uint8_t *dataptr;
  const uint8_t *last_byte;

  dataptr = data;
    7688:	db 01       	movw	r26, r22
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    768a:	10 c0       	rjmp	.+32     	; 0x76ac <chksum+0x2e>
    t = (dataptr[0] << 8) + dataptr[1];
    768c:	fc 91       	ld	r31, X
    768e:	e0 e0       	ldi	r30, 0x00	; 0
    7690:	11 96       	adiw	r26, 0x01	; 1
    7692:	8c 91       	ld	r24, X
    7694:	11 97       	sbiw	r26, 0x01	; 1
    7696:	bf 01       	movw	r22, r30
    7698:	68 0f       	add	r22, r24
    769a:	71 1d       	adc	r23, r1
    sum += t;
    769c:	26 0f       	add	r18, r22
    769e:	37 1f       	adc	r19, r23
    if(sum < t) {
    76a0:	26 17       	cp	r18, r22
    76a2:	37 07       	cpc	r19, r23
    76a4:	10 f4       	brcc	.+4      	; 0x76aa <chksum+0x2c>
      sum++;		/* carry */
    76a6:	2f 5f       	subi	r18, 0xFF	; 255
    76a8:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    76aa:	12 96       	adiw	r26, 0x02	; 2
  const uint8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    76ac:	a4 17       	cp	r26, r20
    76ae:	b5 07       	cpc	r27, r21
    76b0:	68 f3       	brcs	.-38     	; 0x768c <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    76b2:	a4 17       	cp	r26, r20
    76b4:	b5 07       	cpc	r27, r21
    76b6:	49 f4       	brne	.+18     	; 0x76ca <chksum+0x4c>
    t = (dataptr[0] << 8) + 0;
    76b8:	9c 91       	ld	r25, X
    76ba:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    76bc:	28 0f       	add	r18, r24
    76be:	39 1f       	adc	r19, r25
    if(sum < t) {
    76c0:	28 17       	cp	r18, r24
    76c2:	39 07       	cpc	r19, r25
    76c4:	10 f4       	brcc	.+4      	; 0x76ca <chksum+0x4c>
      sum++;		/* carry */
    76c6:	2f 5f       	subi	r18, 0xFF	; 255
    76c8:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    76ca:	c9 01       	movw	r24, r18
    76cc:	08 95       	ret

000076ce <upper_layer_chksum>:
}
#endif
/*---------------------------------------------------------------------------*/
static uint16_t
upper_layer_chksum(uint8_t proto)
{
    76ce:	cf 93       	push	r28
    76d0:	df 93       	push	r29
  uint16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    76d2:	90 91 bf 27 	lds	r25, 0x27BF
    76d6:	c9 2f       	mov	r28, r25
    76d8:	d0 e0       	ldi	r29, 0x00	; 0
    76da:	64 97       	sbiw	r28, 0x14	; 20
    76dc:	30 91 be 27 	lds	r19, 0x27BE
    76e0:	20 e0       	ldi	r18, 0x00	; 0
    76e2:	c2 0f       	add	r28, r18
    76e4:	d3 1f       	adc	r29, r19
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (uint8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    76e6:	9e 01       	movw	r18, r28
    76e8:	28 0f       	add	r18, r24
    76ea:	31 1d       	adc	r19, r1
    76ec:	c9 01       	movw	r24, r18
    76ee:	68 ec       	ldi	r22, 0xC8	; 200
    76f0:	77 e2       	ldi	r23, 0x27	; 39
    76f2:	48 e0       	ldi	r20, 0x08	; 8
    76f4:	50 e0       	ldi	r21, 0x00	; 0
    76f6:	0e 94 3f 3b 	call	0x767e	; 0x767e <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    76fa:	60 ed       	ldi	r22, 0xD0	; 208
    76fc:	77 e2       	ldi	r23, 0x27	; 39
    76fe:	ae 01       	movw	r20, r28
    7700:	0e 94 3f 3b 	call	0x767e	; 0x767e <chksum>
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : uip_htons(sum);
    7704:	00 97       	sbiw	r24, 0x00	; 0
    7706:	19 f0       	breq	.+6      	; 0x770e <upper_layer_chksum+0x40>
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    7708:	38 2f       	mov	r19, r24
    770a:	29 2f       	mov	r18, r25
    770c:	02 c0       	rjmp	.+4      	; 0x7712 <upper_layer_chksum+0x44>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : uip_htons(sum);
    770e:	2f ef       	ldi	r18, 0xFF	; 255
    7710:	3f ef       	ldi	r19, 0xFF	; 255
}
    7712:	c9 01       	movw	r24, r18
    7714:	df 91       	pop	r29
    7716:	cf 91       	pop	r28
    7718:	08 95       	ret

0000771a <uip_setipid>:

static uint16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(uint16_t id) { ipid = id; }
    771a:	90 93 28 25 	sts	0x2528, r25
    771e:	80 93 27 25 	sts	0x2527, r24
    7722:	08 95       	ret

00007724 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(uint8_t *op32, uint16_t op16)
{
    7724:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    7726:	43 81       	ldd	r20, Z+3	; 0x03
    7728:	46 0f       	add	r20, r22
    772a:	40 93 bb 27 	sts	0x27BB, r20
  uip_acc32[2] = op32[2] + (op16 >> 8);
    772e:	87 2f       	mov	r24, r23
    7730:	99 27       	eor	r25, r25
    7732:	22 81       	ldd	r18, Z+2	; 0x02
    7734:	28 0f       	add	r18, r24
    7736:	20 93 ba 27 	sts	0x27BA, r18
  uip_acc32[1] = op32[1];
    773a:	a1 81       	ldd	r26, Z+1	; 0x01
    773c:	a0 93 b9 27 	sts	0x27B9, r26
  uip_acc32[0] = op32[0];
    7740:	50 81       	ld	r21, Z
    7742:	50 93 b8 27 	sts	0x27B8, r21
  
  if(uip_acc32[2] < (op16 >> 8)) {
    7746:	30 e0       	ldi	r19, 0x00	; 0
    7748:	28 17       	cp	r18, r24
    774a:	39 07       	cpc	r19, r25
    774c:	48 f4       	brcc	.+18     	; 0x7760 <uip_add32+0x3c>
    ++uip_acc32[1];
    774e:	8a 2f       	mov	r24, r26
    7750:	8f 5f       	subi	r24, 0xFF	; 255
    7752:	80 93 b9 27 	sts	0x27B9, r24
    if(uip_acc32[1] == 0) {
    7756:	88 23       	and	r24, r24
    7758:	19 f4       	brne	.+6      	; 0x7760 <uip_add32+0x3c>
      ++uip_acc32[0];
    775a:	5f 5f       	subi	r21, 0xFF	; 255
    775c:	50 93 b8 27 	sts	0x27B8, r21
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
    7760:	84 2f       	mov	r24, r20
    7762:	90 e0       	ldi	r25, 0x00	; 0
    7764:	70 70       	andi	r23, 0x00	; 0
    7766:	86 17       	cp	r24, r22
    7768:	97 07       	cpc	r25, r23
    776a:	98 f4       	brcc	.+38     	; 0x7792 <uip_add32+0x6e>
    ++uip_acc32[2];
    776c:	80 91 ba 27 	lds	r24, 0x27BA
    7770:	8f 5f       	subi	r24, 0xFF	; 255
    7772:	80 93 ba 27 	sts	0x27BA, r24
    if(uip_acc32[2] == 0) {
    7776:	88 23       	and	r24, r24
    7778:	61 f4       	brne	.+24     	; 0x7792 <uip_add32+0x6e>
      ++uip_acc32[1];
    777a:	80 91 b9 27 	lds	r24, 0x27B9
    777e:	8f 5f       	subi	r24, 0xFF	; 255
    7780:	80 93 b9 27 	sts	0x27B9, r24
      if(uip_acc32[1] == 0) {
    7784:	88 23       	and	r24, r24
    7786:	29 f4       	brne	.+10     	; 0x7792 <uip_add32+0x6e>
	++uip_acc32[0];
    7788:	80 91 b8 27 	lds	r24, 0x27B8
    778c:	8f 5f       	subi	r24, 0xFF	; 255
    778e:	80 93 b8 27 	sts	0x27B8, r24
    7792:	08 95       	ret

00007794 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(uint16_t n)
{
    7794:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    7796:	80 91 c1 2c 	lds	r24, 0x2CC1
    779a:	90 91 c2 2c 	lds	r25, 0x2CC2
    779e:	08 96       	adiw	r24, 0x08	; 8
    77a0:	0e 94 92 3b 	call	0x7724	; 0x7724 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    77a4:	e0 91 c1 2c 	lds	r30, 0x2CC1
    77a8:	f0 91 c2 2c 	lds	r31, 0x2CC2
    77ac:	80 91 b8 27 	lds	r24, 0x27B8
    77b0:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    77b2:	80 91 b9 27 	lds	r24, 0x27B9
    77b6:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    77b8:	80 91 ba 27 	lds	r24, 0x27BA
    77bc:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    77be:	80 91 bb 27 	lds	r24, 0x27BB
    77c2:	83 87       	std	Z+11, r24	; 0x0b
}
    77c4:	08 95       	ret

000077c6 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_chksum(uint16_t *data, uint16_t len)
{
    77c6:	9c 01       	movw	r18, r24
    77c8:	ab 01       	movw	r20, r22
  return uip_htons(chksum(0, (uint8_t *)data, len));
    77ca:	80 e0       	ldi	r24, 0x00	; 0
    77cc:	90 e0       	ldi	r25, 0x00	; 0
    77ce:	b9 01       	movw	r22, r18
    77d0:	0e 94 3f 3b 	call	0x767e	; 0x767e <chksum>
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    77d4:	38 2f       	mov	r19, r24
    77d6:	29 2f       	mov	r18, r25
/*---------------------------------------------------------------------------*/
uint16_t
uip_chksum(uint16_t *data, uint16_t len)
{
  return uip_htons(chksum(0, (uint8_t *)data, len));
}
    77d8:	c9 01       	movw	r24, r18
    77da:	08 95       	ret

000077dc <uip_ipchksum>:
uint16_t
uip_ipchksum(void)
{
  uint16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    77dc:	80 e0       	ldi	r24, 0x00	; 0
    77de:	90 e0       	ldi	r25, 0x00	; 0
    77e0:	6c eb       	ldi	r22, 0xBC	; 188
    77e2:	77 e2       	ldi	r23, 0x27	; 39
    77e4:	44 e1       	ldi	r20, 0x14	; 20
    77e6:	50 e0       	ldi	r21, 0x00	; 0
    77e8:	0e 94 3f 3b 	call	0x767e	; 0x767e <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : uip_htons(sum);
    77ec:	00 97       	sbiw	r24, 0x00	; 0
    77ee:	19 f0       	breq	.+6      	; 0x77f6 <uip_ipchksum+0x1a>
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    77f0:	38 2f       	mov	r19, r24
    77f2:	29 2f       	mov	r18, r25
    77f4:	02 c0       	rjmp	.+4      	; 0x77fa <uip_ipchksum+0x1e>
{
  uint16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : uip_htons(sum);
    77f6:	2f ef       	ldi	r18, 0xFF	; 255
    77f8:	3f ef       	ldi	r19, 0xFF	; 255
}
    77fa:	c9 01       	movw	r24, r18
    77fc:	08 95       	ret

000077fe <uip_tcpchksum>:
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
uint16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
    77fe:	86 e0       	ldi	r24, 0x06	; 6
    7800:	0e 94 67 3b 	call	0x76ce	; 0x76ce <upper_layer_chksum>
}
    7804:	08 95       	ret

00007806 <uip_udpchksum>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
uint16_t
uip_udpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_UDP);
    7806:	81 e1       	ldi	r24, 0x11	; 17
    7808:	0e 94 67 3b 	call	0x76ce	; 0x76ce <upper_layer_chksum>
}
    780c:	08 95       	ret

0000780e <uip_init>:
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    780e:	80 e0       	ldi	r24, 0x00	; 0
    7810:	09 c0       	rjmp	.+18     	; 0x7824 <uip_init+0x16>
    uip_listenports[c] = 0;
    7812:	e8 2f       	mov	r30, r24
    7814:	f0 e0       	ldi	r31, 0x00	; 0
    7816:	ee 0f       	add	r30, r30
    7818:	ff 1f       	adc	r31, r31
    781a:	ed 5b       	subi	r30, 0xBD	; 189
    781c:	f2 4d       	sbci	r31, 0xD2	; 210
    781e:	11 82       	std	Z+1, r1	; 0x01
    7820:	10 82       	st	Z, r1
    7822:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7824:	84 30       	cpi	r24, 0x04	; 4
    7826:	a8 f3       	brcs	.-22     	; 0x7812 <uip_init+0x4>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    7828:	80 e0       	ldi	r24, 0x00	; 0
    782a:	0b c0       	rjmp	.+22     	; 0x7842 <uip_init+0x34>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    782c:	e8 2f       	mov	r30, r24
    782e:	f0 e0       	ldi	r31, 0x00	; 0
    7830:	95 e0       	ldi	r25, 0x05	; 5
    7832:	ee 0f       	add	r30, r30
    7834:	ff 1f       	adc	r31, r31
    7836:	9a 95       	dec	r25
    7838:	e1 f7       	brne	.-8      	; 0x7832 <uip_init+0x24>
    783a:	ed 53       	subi	r30, 0x3D	; 61
    783c:	f3 4d       	sbci	r31, 0xD3	; 211
    783e:	11 8e       	std	Z+25, r1	; 0x19
    7840:	8f 5f       	subi	r24, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    7842:	84 30       	cpi	r24, 0x04	; 4
    7844:	98 f3       	brcs	.-26     	; 0x782c <uip_init+0x1e>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
    7846:	80 e0       	ldi	r24, 0x00	; 0
    7848:	94 e0       	ldi	r25, 0x04	; 4
    784a:	90 93 2a 25 	sts	0x252A, r25
    784e:	80 93 29 25 	sts	0x2529, r24
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    7852:	40 e0       	ldi	r20, 0x00	; 0
    uip_udp_conns[c].lport = 0;
    7854:	8d e0       	ldi	r24, 0x0D	; 13
    7856:	90 e0       	ldi	r25, 0x00	; 0
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    7858:	0e c0       	rjmp	.+28     	; 0x7876 <uip_init+0x68>
    uip_udp_conns[c].lport = 0;
    785a:	24 2f       	mov	r18, r20
    785c:	30 e0       	ldi	r19, 0x00	; 0
    785e:	28 9f       	mul	r18, r24
    7860:	f0 01       	movw	r30, r0
    7862:	29 9f       	mul	r18, r25
    7864:	f0 0d       	add	r31, r0
    7866:	38 9f       	mul	r19, r24
    7868:	f0 0d       	add	r31, r0
    786a:	11 24       	eor	r1, r1
    786c:	e7 5a       	subi	r30, 0xA7	; 167
    786e:	f2 4d       	sbci	r31, 0xD2	; 210
    7870:	15 82       	std	Z+5, r1	; 0x05
    7872:	14 82       	std	Z+4, r1	; 0x04
    7874:	4f 5f       	subi	r20, 0xFF	; 255
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    7876:	4a 30       	cpi	r20, 0x0A	; 10
    7878:	80 f3       	brcs	.-32     	; 0x785a <uip_init+0x4c>
    787a:	40 93 25 25 	sts	0x2525, r20
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    787e:	08 95       	ret

00007880 <uip_connect>:
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    7880:	20 91 29 25 	lds	r18, 0x2529
    7884:	30 91 2a 25 	lds	r19, 0x252A
{
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    7888:	2f 5f       	subi	r18, 0xFF	; 255
    788a:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    788c:	4d e7       	ldi	r20, 0x7D	; 125
    788e:	20 30       	cpi	r18, 0x00	; 0
    7890:	34 07       	cpc	r19, r20
    7892:	10 f0       	brcs	.+4      	; 0x7898 <uip_connect+0x18>
    lastport = 4096;
    7894:	20 e0       	ldi	r18, 0x00	; 0
    7896:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    7898:	52 2f       	mov	r21, r18
    789a:	43 2f       	mov	r20, r19
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    789c:	a0 e0       	ldi	r26, 0x00	; 0
    789e:	13 c0       	rjmp	.+38     	; 0x78c6 <uip_connect+0x46>
    conn = &uip_conns[c];
    78a0:	ea 2f       	mov	r30, r26
    78a2:	f0 e0       	ldi	r31, 0x00	; 0
    if(conn->tcpstateflags != UIP_CLOSED &&
    78a4:	b5 e0       	ldi	r27, 0x05	; 5
    78a6:	ee 0f       	add	r30, r30
    78a8:	ff 1f       	adc	r31, r31
    78aa:	ba 95       	dec	r27
    78ac:	e1 f7       	brne	.-8      	; 0x78a6 <uip_connect+0x26>
    78ae:	ed 53       	subi	r30, 0x3D	; 61
    78b0:	f3 4d       	sbci	r31, 0xD3	; 211
    78b2:	b1 8d       	ldd	r27, Z+25	; 0x19
    78b4:	bb 23       	and	r27, r27
    78b6:	31 f0       	breq	.+12     	; 0x78c4 <uip_connect+0x44>
    78b8:	04 80       	ldd	r0, Z+4	; 0x04
    78ba:	f5 81       	ldd	r31, Z+5	; 0x05
    78bc:	e0 2d       	mov	r30, r0
    78be:	e4 17       	cp	r30, r20
    78c0:	f5 07       	cpc	r31, r21
    78c2:	11 f3       	breq	.-60     	; 0x7888 <uip_connect+0x8>
    78c4:	af 5f       	subi	r26, 0xFF	; 255
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    78c6:	a4 30       	cpi	r26, 0x04	; 4
    78c8:	59 f7       	brne	.-42     	; 0x78a0 <uip_connect+0x20>
    78ca:	30 93 2a 25 	sts	0x252A, r19
    78ce:	20 93 29 25 	sts	0x2529, r18
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    78d2:	10 92 25 25 	sts	0x2525, r1
    78d6:	20 e0       	ldi	r18, 0x00	; 0
       conn->lport == uip_htons(lastport)) {
      goto again;
    }
  }

  conn = 0;
    78d8:	e0 e0       	ldi	r30, 0x00	; 0
    78da:	f0 e0       	ldi	r31, 0x00	; 0
  for(c = 0; c < UIP_CONNS; ++c) {
    78dc:	1e c0       	rjmp	.+60     	; 0x791a <uip_connect+0x9a>
    cconn = &uip_conns[c];
    78de:	a2 2f       	mov	r26, r18
    78e0:	b0 e0       	ldi	r27, 0x00	; 0
    78e2:	35 e0       	ldi	r19, 0x05	; 5
    78e4:	aa 0f       	add	r26, r26
    78e6:	bb 1f       	adc	r27, r27
    78e8:	3a 95       	dec	r19
    78ea:	e1 f7       	brne	.-8      	; 0x78e4 <uip_connect+0x64>
    78ec:	ad 53       	subi	r26, 0x3D	; 61
    78ee:	b3 4d       	sbci	r27, 0xD3	; 211
    if(cconn->tcpstateflags == UIP_CLOSED) {
    78f0:	59 96       	adiw	r26, 0x19	; 25
    78f2:	3c 91       	ld	r19, X
    78f4:	59 97       	sbiw	r26, 0x19	; 25
    78f6:	33 23       	and	r19, r19
    78f8:	21 f4       	brne	.+8      	; 0x7902 <uip_connect+0x82>
    78fa:	20 93 25 25 	sts	0x2525, r18
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    78fe:	fd 01       	movw	r30, r26
    7900:	10 c0       	rjmp	.+32     	; 0x7922 <uip_connect+0xa2>
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    7902:	37 30       	cpi	r19, 0x07	; 7
    7904:	49 f4       	brne	.+18     	; 0x7918 <uip_connect+0x98>
      if(conn == 0 ||
    7906:	30 97       	sbiw	r30, 0x00	; 0
    7908:	31 f0       	breq	.+12     	; 0x7916 <uip_connect+0x96>
    790a:	5a 96       	adiw	r26, 0x1a	; 26
    790c:	4c 91       	ld	r20, X
    790e:	5a 97       	sbiw	r26, 0x1a	; 26
    7910:	32 8d       	ldd	r19, Z+26	; 0x1a
    7912:	34 17       	cp	r19, r20
    7914:	08 f4       	brcc	.+2      	; 0x7918 <uip_connect+0x98>
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    7916:	fd 01       	movw	r30, r26
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
      if(conn == 0 ||
    7918:	2f 5f       	subi	r18, 0xFF	; 255
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    791a:	24 30       	cpi	r18, 0x04	; 4
    791c:	00 f3       	brcs	.-64     	; 0x78de <uip_connect+0x5e>
    791e:	20 93 25 25 	sts	0x2525, r18
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    7922:	30 97       	sbiw	r30, 0x00	; 0
    7924:	a9 f1       	breq	.+106    	; 0x7990 <uip_connect+0x110>
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;
    7926:	22 e0       	ldi	r18, 0x02	; 2
    7928:	21 8f       	std	Z+25, r18	; 0x19

  conn->snd_nxt[0] = iss[0];
    792a:	20 91 1f 25 	lds	r18, 0x251F
    792e:	24 87       	std	Z+12, r18	; 0x0c
  conn->snd_nxt[1] = iss[1];
    7930:	20 91 20 25 	lds	r18, 0x2520
    7934:	25 87       	std	Z+13, r18	; 0x0d
  conn->snd_nxt[2] = iss[2];
    7936:	20 91 21 25 	lds	r18, 0x2521
    793a:	26 87       	std	Z+14, r18	; 0x0e
  conn->snd_nxt[3] = iss[3];
    793c:	20 91 22 25 	lds	r18, 0x2522
    7940:	27 87       	std	Z+15, r18	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    7942:	28 ed       	ldi	r18, 0xD8	; 216
    7944:	34 e0       	ldi	r19, 0x04	; 4
    7946:	33 8b       	std	Z+19, r19	; 0x13
    7948:	22 8b       	std	Z+18, r18	; 0x12
    794a:	35 8b       	std	Z+21, r19	; 0x15
    794c:	24 8b       	std	Z+20, r18	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    794e:	21 e0       	ldi	r18, 0x01	; 1
    7950:	30 e0       	ldi	r19, 0x00	; 0
    7952:	31 8b       	std	Z+17, r19	; 0x11
    7954:	20 8b       	std	Z+16, r18	; 0x10
  conn->nrtx = 0;
    7956:	13 8e       	std	Z+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    7958:	21 e0       	ldi	r18, 0x01	; 1
    795a:	22 8f       	std	Z+26, r18	; 0x1a
  conn->rto = UIP_RTO;
    795c:	23 e0       	ldi	r18, 0x03	; 3
    795e:	20 8f       	std	Z+24, r18	; 0x18
  conn->sa = 0;
    7960:	16 8a       	std	Z+22, r1	; 0x16
  conn->sv = 16;   /* Initial value of the RTT variance. */
    7962:	20 e1       	ldi	r18, 0x10	; 16
    7964:	27 8b       	std	Z+23, r18	; 0x17
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    7966:	20 91 29 25 	lds	r18, 0x2529
    796a:	30 91 2a 25 	lds	r19, 0x252A
    796e:	32 27       	eor	r19, r18
    7970:	23 27       	eor	r18, r19
    7972:	32 27       	eor	r19, r18
  conn->nrtx = 0;
  conn->timer = 1; /* Send the SYN next time around. */
  conn->rto = UIP_RTO;
  conn->sa = 0;
  conn->sv = 16;   /* Initial value of the RTT variance. */
  conn->lport = uip_htons(lastport);
    7974:	35 83       	std	Z+5, r19	; 0x05
    7976:	24 83       	std	Z+4, r18	; 0x04
  conn->rport = rport;
    7978:	77 83       	std	Z+7, r23	; 0x07
    797a:	66 83       	std	Z+6, r22	; 0x06
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    797c:	dc 01       	movw	r26, r24
    797e:	2d 91       	ld	r18, X+
    7980:	3d 91       	ld	r19, X+
    7982:	4d 91       	ld	r20, X+
    7984:	5c 91       	ld	r21, X
    7986:	13 97       	sbiw	r26, 0x03	; 3
    7988:	20 83       	st	Z, r18
    798a:	31 83       	std	Z+1, r19	; 0x01
    798c:	42 83       	std	Z+2, r20	; 0x02
    798e:	53 83       	std	Z+3, r21	; 0x03
  
  return conn;
}
    7990:	cf 01       	movw	r24, r30
    7992:	08 95       	ret

00007994 <uip_udp_new>:
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(const uip_ipaddr_t *ripaddr, uint16_t rport)
{
    7994:	0f 93       	push	r16
    7996:	1f 93       	push	r17
    7998:	cf 93       	push	r28
    799a:	df 93       	push	r29
      break;
    }
  }

  if(conn == 0) {
    return 0;
    799c:	20 91 29 25 	lds	r18, 0x2529
    79a0:	30 91 2a 25 	lds	r19, 0x252A
  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == uip_htons(lastport)) {
    79a4:	4d e0       	ldi	r20, 0x0D	; 13
    79a6:	50 e0       	ldi	r21, 0x00	; 0
{
  register struct uip_udp_conn *conn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    79a8:	2f 5f       	subi	r18, 0xFF	; 255
    79aa:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    79ac:	ad e7       	ldi	r26, 0x7D	; 125
    79ae:	20 30       	cpi	r18, 0x00	; 0
    79b0:	3a 07       	cpc	r19, r26
    79b2:	10 f0       	brcs	.+4      	; 0x79b8 <uip_udp_new+0x24>
    lastport = 4096;
    79b4:	20 e0       	ldi	r18, 0x00	; 0
    79b6:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    79b8:	b2 2f       	mov	r27, r18
    79ba:	a3 2f       	mov	r26, r19

  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    79bc:	10 e0       	ldi	r17, 0x00	; 0
    79be:	12 c0       	rjmp	.+36     	; 0x79e4 <uip_udp_new+0x50>
    if(uip_udp_conns[c].lport == uip_htons(lastport)) {
    79c0:	c1 2f       	mov	r28, r17
    79c2:	d0 e0       	ldi	r29, 0x00	; 0
    79c4:	c4 9f       	mul	r28, r20
    79c6:	f0 01       	movw	r30, r0
    79c8:	c5 9f       	mul	r28, r21
    79ca:	f0 0d       	add	r31, r0
    79cc:	d4 9f       	mul	r29, r20
    79ce:	f0 0d       	add	r31, r0
    79d0:	11 24       	eor	r1, r1
    79d2:	e7 5a       	subi	r30, 0xA7	; 167
    79d4:	f2 4d       	sbci	r31, 0xD2	; 210
    79d6:	04 80       	ldd	r0, Z+4	; 0x04
    79d8:	f5 81       	ldd	r31, Z+5	; 0x05
    79da:	e0 2d       	mov	r30, r0
    79dc:	ea 17       	cp	r30, r26
    79de:	fb 07       	cpc	r31, r27
    79e0:	19 f3       	breq	.-58     	; 0x79a8 <uip_udp_new+0x14>
    79e2:	1f 5f       	subi	r17, 0xFF	; 255

  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    79e4:	1a 30       	cpi	r17, 0x0A	; 10
    79e6:	61 f7       	brne	.-40     	; 0x79c0 <uip_udp_new+0x2c>
    79e8:	30 93 2a 25 	sts	0x252A, r19
    79ec:	20 93 29 25 	sts	0x2529, r18
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    79f0:	10 e0       	ldi	r17, 0x00	; 0
    if(uip_udp_conns[c].lport == 0) {
    79f2:	2d e0       	ldi	r18, 0x0D	; 13
    79f4:	30 e0       	ldi	r19, 0x00	; 0
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    79f6:	1a c0       	rjmp	.+52     	; 0x7a2c <uip_udp_new+0x98>
    79f8:	01 2f       	mov	r16, r17
    79fa:	0f 5f       	subi	r16, 0xFF	; 255
    if(uip_udp_conns[c].lport == 0) {
    79fc:	c1 2f       	mov	r28, r17
    79fe:	d0 e0       	ldi	r29, 0x00	; 0
    7a00:	c2 9f       	mul	r28, r18
    7a02:	f0 01       	movw	r30, r0
    7a04:	c3 9f       	mul	r28, r19
    7a06:	f0 0d       	add	r31, r0
    7a08:	d2 9f       	mul	r29, r18
    7a0a:	f0 0d       	add	r31, r0
    7a0c:	11 24       	eor	r1, r1
    7a0e:	e7 5a       	subi	r30, 0xA7	; 167
    7a10:	f2 4d       	sbci	r31, 0xD2	; 210
    7a12:	df 01       	movw	r26, r30
    7a14:	14 96       	adiw	r26, 0x04	; 4
    7a16:	44 81       	ldd	r20, Z+4	; 0x04
    7a18:	55 81       	ldd	r21, Z+5	; 0x05
    7a1a:	41 15       	cp	r20, r1
    7a1c:	51 05       	cpc	r21, r1
    7a1e:	29 f4       	brne	.+10     	; 0x7a2a <uip_udp_new+0x96>
    7a20:	10 93 25 25 	sts	0x2525, r17
      conn = &uip_udp_conns[c];
      break;
    }
  }

  if(conn == 0) {
    7a24:	30 97       	sbiw	r30, 0x00	; 0
    7a26:	49 f4       	brne	.+18     	; 0x7a3a <uip_udp_new+0xa6>
    7a28:	33 c0       	rjmp	.+102    	; 0x7a90 <uip_udp_new+0xfc>
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    7a2a:	10 2f       	mov	r17, r16
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    7a2c:	1a 30       	cpi	r17, 0x0A	; 10
    7a2e:	20 f3       	brcs	.-56     	; 0x79f8 <uip_udp_new+0x64>
    7a30:	10 93 25 25 	sts	0x2525, r17
      break;
    }
  }

  if(conn == 0) {
    return 0;
    7a34:	e0 e0       	ldi	r30, 0x00	; 0
    7a36:	f0 e0       	ldi	r31, 0x00	; 0
    7a38:	2b c0       	rjmp	.+86     	; 0x7a90 <uip_udp_new+0xfc>
  }
  
  conn->lport = UIP_HTONS(lastport);
    7a3a:	20 91 29 25 	lds	r18, 0x2529
    7a3e:	30 91 2a 25 	lds	r19, 0x252A
    7a42:	32 27       	eor	r19, r18
    7a44:	23 27       	eor	r18, r19
    7a46:	32 27       	eor	r19, r18
    7a48:	11 96       	adiw	r26, 0x01	; 1
    7a4a:	3c 93       	st	X, r19
    7a4c:	2e 93       	st	-X, r18
  conn->rport = rport;
    7a4e:	77 83       	std	Z+7, r23	; 0x07
    7a50:	66 83       	std	Z+6, r22	; 0x06
  if(ripaddr == NULL) {
    7a52:	00 97       	sbiw	r24, 0x00	; 0
    7a54:	29 f4       	brne	.+10     	; 0x7a60 <uip_udp_new+0xcc>
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    7a56:	10 82       	st	Z, r1
    7a58:	11 82       	std	Z+1, r1	; 0x01
    7a5a:	12 82       	std	Z+2, r1	; 0x02
    7a5c:	13 82       	std	Z+3, r1	; 0x03
    7a5e:	09 c0       	rjmp	.+18     	; 0x7a72 <uip_udp_new+0xde>
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    7a60:	dc 01       	movw	r26, r24
    7a62:	2d 91       	ld	r18, X+
    7a64:	3d 91       	ld	r19, X+
    7a66:	4d 91       	ld	r20, X+
    7a68:	5c 91       	ld	r21, X
    7a6a:	20 83       	st	Z, r18
    7a6c:	31 83       	std	Z+1, r19	; 0x01
    7a6e:	42 83       	std	Z+2, r20	; 0x02
    7a70:	53 83       	std	Z+3, r21	; 0x03
  }
  conn->ttl = UIP_TTL;
    7a72:	8d e0       	ldi	r24, 0x0D	; 13
    7a74:	90 e0       	ldi	r25, 0x00	; 0
    7a76:	c8 9f       	mul	r28, r24
    7a78:	d0 01       	movw	r26, r0
    7a7a:	c9 9f       	mul	r28, r25
    7a7c:	b0 0d       	add	r27, r0
    7a7e:	d8 9f       	mul	r29, r24
    7a80:	b0 0d       	add	r27, r0
    7a82:	11 24       	eor	r1, r1
    7a84:	a7 5a       	subi	r26, 0xA7	; 167
    7a86:	b2 4d       	sbci	r27, 0xD2	; 210
    7a88:	80 e4       	ldi	r24, 0x40	; 64
    7a8a:	18 96       	adiw	r26, 0x08	; 8
    7a8c:	8c 93       	st	X, r24
    7a8e:	18 97       	sbiw	r26, 0x08	; 8
  
  return conn;
}
    7a90:	cf 01       	movw	r24, r30
    7a92:	df 91       	pop	r29
    7a94:	cf 91       	pop	r28
    7a96:	1f 91       	pop	r17
    7a98:	0f 91       	pop	r16
    7a9a:	08 95       	ret

00007a9c <uip_unlisten>:
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7a9c:	40 e0       	ldi	r20, 0x00	; 0
    7a9e:	13 c0       	rjmp	.+38     	; 0x7ac6 <uip_unlisten+0x2a>
    if(uip_listenports[c] == port) {
    7aa0:	e4 2f       	mov	r30, r20
    7aa2:	f0 e0       	ldi	r31, 0x00	; 0
    7aa4:	54 2f       	mov	r21, r20
    7aa6:	5f 5f       	subi	r21, 0xFF	; 255
    7aa8:	ee 0f       	add	r30, r30
    7aaa:	ff 1f       	adc	r31, r31
    7aac:	ed 5b       	subi	r30, 0xBD	; 189
    7aae:	f2 4d       	sbci	r31, 0xD2	; 210
    7ab0:	20 81       	ld	r18, Z
    7ab2:	31 81       	ldd	r19, Z+1	; 0x01
    7ab4:	28 17       	cp	r18, r24
    7ab6:	39 07       	cpc	r19, r25
    7ab8:	29 f4       	brne	.+10     	; 0x7ac4 <uip_unlisten+0x28>
    7aba:	40 93 25 25 	sts	0x2525, r20
      uip_listenports[c] = 0;
    7abe:	11 82       	std	Z+1, r1	; 0x01
    7ac0:	10 82       	st	Z, r1
      return;
    7ac2:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == port) {
    7ac4:	45 2f       	mov	r20, r21
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7ac6:	44 30       	cpi	r20, 0x04	; 4
    7ac8:	58 f3       	brcs	.-42     	; 0x7aa0 <uip_unlisten+0x4>
    7aca:	40 93 25 25 	sts	0x2525, r20
    7ace:	08 95       	ret

00007ad0 <uip_listen>:
}
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7ad0:	40 e0       	ldi	r20, 0x00	; 0
    7ad2:	13 c0       	rjmp	.+38     	; 0x7afa <uip_listen+0x2a>
    if(uip_listenports[c] == 0) {
    7ad4:	e4 2f       	mov	r30, r20
    7ad6:	f0 e0       	ldi	r31, 0x00	; 0
    7ad8:	54 2f       	mov	r21, r20
    7ada:	5f 5f       	subi	r21, 0xFF	; 255
    7adc:	ee 0f       	add	r30, r30
    7ade:	ff 1f       	adc	r31, r31
    7ae0:	ed 5b       	subi	r30, 0xBD	; 189
    7ae2:	f2 4d       	sbci	r31, 0xD2	; 210
    7ae4:	20 81       	ld	r18, Z
    7ae6:	31 81       	ldd	r19, Z+1	; 0x01
    7ae8:	21 15       	cp	r18, r1
    7aea:	31 05       	cpc	r19, r1
    7aec:	29 f4       	brne	.+10     	; 0x7af8 <uip_listen+0x28>
    7aee:	40 93 25 25 	sts	0x2525, r20
      uip_listenports[c] = port;
    7af2:	91 83       	std	Z+1, r25	; 0x01
    7af4:	80 83       	st	Z, r24
      return;
    7af6:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
    7af8:	45 2f       	mov	r20, r21
}
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7afa:	44 30       	cpi	r20, 0x04	; 4
    7afc:	58 f3       	brcs	.-42     	; 0x7ad4 <uip_listen+0x4>
    7afe:	40 93 25 25 	sts	0x2525, r20
    7b02:	08 95       	ret

00007b04 <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(uint8_t flag)
{
    7b04:	ef 92       	push	r14
    7b06:	ff 92       	push	r15
    7b08:	0f 93       	push	r16
    7b0a:	1f 93       	push	r17
    7b0c:	cf 93       	push	r28
    7b0e:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    7b10:	c0 91 c1 2c 	lds	r28, 0x2CC1
    7b14:	d0 91 c2 2c 	lds	r29, 0x2CC2

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    7b18:	84 30       	cpi	r24, 0x04	; 4
    7b1a:	09 f4       	brne	.+2      	; 0x7b1e <uip_process+0x1a>
    7b1c:	f7 c1       	rjmp	.+1006   	; 0x7f0c <uip_process+0x408>
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    7b1e:	04 ee       	ldi	r16, 0xE4	; 228
    7b20:	17 e2       	ldi	r17, 0x27	; 39
    7b22:	10 93 c0 2c 	sts	0x2CC0, r17
    7b26:	00 93 bf 2c 	sts	0x2CBF, r16
    7b2a:	10 93 b7 27 	sts	0x27B7, r17
    7b2e:	00 93 b6 27 	sts	0x27B6, r16

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    7b32:	83 30       	cpi	r24, 0x03	; 3
    7b34:	71 f4       	brne	.+28     	; 0x7b52 <uip_process+0x4e>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    7b36:	89 8d       	ldd	r24, Y+25	; 0x19
    7b38:	90 e0       	ldi	r25, 0x00	; 0
    7b3a:	8f 70       	andi	r24, 0x0F	; 15
    7b3c:	90 70       	andi	r25, 0x00	; 0
    7b3e:	83 30       	cpi	r24, 0x03	; 3
    7b40:	91 05       	cpc	r25, r1
    7b42:	09 f0       	breq	.+2      	; 0x7b46 <uip_process+0x42>
    7b44:	74 c0       	rjmp	.+232    	; 0x7c2e <uip_process+0x12a>
    7b46:	88 89       	ldd	r24, Y+16	; 0x10
    7b48:	99 89       	ldd	r25, Y+17	; 0x11
    7b4a:	00 97       	sbiw	r24, 0x00	; 0
    7b4c:	09 f0       	breq	.+2      	; 0x7b50 <uip_process+0x4c>
    7b4e:	2f c7       	rjmp	.+3678   	; 0x89ae <uip_process+0xeaa>
    7b50:	8d c0       	rjmp	.+282    	; 0x7c6c <uip_process+0x168>
#endif /* UIP_ACTIVE_OPEN */
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
    7b52:	82 30       	cpi	r24, 0x02	; 2
    7b54:	09 f0       	breq	.+2      	; 0x7b58 <uip_process+0x54>
    7b56:	8e c0       	rjmp	.+284    	; 0x7c74 <uip_process+0x170>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    7b58:	80 91 22 25 	lds	r24, 0x2522
    7b5c:	8f 5f       	subi	r24, 0xFF	; 255
    7b5e:	80 93 22 25 	sts	0x2522, r24
    7b62:	88 23       	and	r24, r24
    7b64:	99 f4       	brne	.+38     	; 0x7b8c <uip_process+0x88>
      if(++iss[2] == 0) {
    7b66:	80 91 21 25 	lds	r24, 0x2521
    7b6a:	8f 5f       	subi	r24, 0xFF	; 255
    7b6c:	80 93 21 25 	sts	0x2521, r24
    7b70:	88 23       	and	r24, r24
    7b72:	61 f4       	brne	.+24     	; 0x7b8c <uip_process+0x88>
	if(++iss[1] == 0) {
    7b74:	80 91 20 25 	lds	r24, 0x2520
    7b78:	8f 5f       	subi	r24, 0xFF	; 255
    7b7a:	80 93 20 25 	sts	0x2520, r24
    7b7e:	88 23       	and	r24, r24
    7b80:	29 f4       	brne	.+10     	; 0x7b8c <uip_process+0x88>
	  ++iss[0];
    7b82:	80 91 1f 25 	lds	r24, 0x251F
    7b86:	8f 5f       	subi	r24, 0xFF	; 255
    7b88:	80 93 1f 25 	sts	0x251F, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    7b8c:	10 92 b5 27 	sts	0x27B5, r1
    7b90:	10 92 b4 27 	sts	0x27B4, r1
    uip_slen = 0;
    7b94:	10 92 58 2d 	sts	0x2D58, r1
    7b98:	10 92 57 2d 	sts	0x2D57, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    7b9c:	89 8d       	ldd	r24, Y+25	; 0x19
    7b9e:	87 30       	cpi	r24, 0x07	; 7
    7ba0:	11 f0       	breq	.+4      	; 0x7ba6 <uip_process+0xa2>
    7ba2:	85 30       	cpi	r24, 0x05	; 5
    7ba4:	41 f4       	brne	.+16     	; 0x7bb6 <uip_process+0xb2>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    7ba6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7ba8:	8f 5f       	subi	r24, 0xFF	; 255
    7baa:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    7bac:	84 31       	cpi	r24, 0x14	; 20
    7bae:	09 f0       	breq	.+2      	; 0x7bb2 <uip_process+0xae>
    7bb0:	fe c6       	rjmp	.+3580   	; 0x89ae <uip_process+0xeaa>
	uip_connr->tcpstateflags = UIP_CLOSED;
    7bb2:	19 8e       	std	Y+25, r1	; 0x19
    7bb4:	fc c6       	rjmp	.+3576   	; 0x89ae <uip_process+0xeaa>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    7bb6:	88 23       	and	r24, r24
    7bb8:	09 f4       	brne	.+2      	; 0x7bbc <uip_process+0xb8>
    7bba:	f9 c6       	rjmp	.+3570   	; 0x89ae <uip_process+0xeaa>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
    7bbc:	28 89       	ldd	r18, Y+16	; 0x10
    7bbe:	39 89       	ldd	r19, Y+17	; 0x11
    7bc0:	21 15       	cp	r18, r1
    7bc2:	31 05       	cpc	r19, r1
    7bc4:	09 f4       	brne	.+2      	; 0x7bc8 <uip_process+0xc4>
    7bc6:	4e c0       	rjmp	.+156    	; 0x7c64 <uip_process+0x160>
	if(uip_connr->timer-- == 0) {
    7bc8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7bca:	29 2f       	mov	r18, r25
    7bcc:	21 50       	subi	r18, 0x01	; 1
    7bce:	2a 8f       	std	Y+26, r18	; 0x1a
    7bd0:	99 23       	and	r25, r25
    7bd2:	09 f0       	breq	.+2      	; 0x7bd6 <uip_process+0xd2>
    7bd4:	ec c6       	rjmp	.+3544   	; 0x89ae <uip_process+0xeaa>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    7bd6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7bd8:	98 30       	cpi	r25, 0x08	; 8
    7bda:	31 f0       	breq	.+12     	; 0x7be8 <uip_process+0xe4>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    7bdc:	28 2f       	mov	r18, r24
    7bde:	21 50       	subi	r18, 0x01	; 1
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    7be0:	22 30       	cpi	r18, 0x02	; 2
    7be2:	48 f4       	brcc	.+18     	; 0x7bf6 <uip_process+0xf2>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    7be4:	95 30       	cpi	r25, 0x05	; 5
    7be6:	39 f4       	brne	.+14     	; 0x7bf6 <uip_process+0xf2>
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    7be8:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    7bea:	80 e8       	ldi	r24, 0x80	; 128
    7bec:	80 93 bc 2c 	sts	0x2CBC, r24
	    UIP_APPCALL();
    7bf0:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>
    7bf4:	95 c5       	rjmp	.+2858   	; 0x8720 <uip_process+0xc1c>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    7bf6:	95 30       	cpi	r25, 0x05	; 5
    7bf8:	48 f4       	brcc	.+18     	; 0x7c0c <uip_process+0x108>
    7bfa:	23 e0       	ldi	r18, 0x03	; 3
    7bfc:	30 e0       	ldi	r19, 0x00	; 0
    7bfe:	09 2e       	mov	r0, r25
    7c00:	02 c0       	rjmp	.+4      	; 0x7c06 <uip_process+0x102>
    7c02:	22 0f       	add	r18, r18
    7c04:	33 1f       	adc	r19, r19
    7c06:	0a 94       	dec	r0
    7c08:	e2 f7       	brpl	.-8      	; 0x7c02 <uip_process+0xfe>
    7c0a:	01 c0       	rjmp	.+2      	; 0x7c0e <uip_process+0x10a>
    7c0c:	20 e3       	ldi	r18, 0x30	; 48
    7c0e:	2a 8f       	std	Y+26, r18	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    7c10:	9f 5f       	subi	r25, 0xFF	; 255
    7c12:	9b 8f       	std	Y+27, r25	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    7c14:	90 e0       	ldi	r25, 0x00	; 0
    7c16:	8f 70       	andi	r24, 0x0F	; 15
    7c18:	90 70       	andi	r25, 0x00	; 0
    7c1a:	83 30       	cpi	r24, 0x03	; 3
    7c1c:	91 05       	cpc	r25, r1
    7c1e:	e1 f0       	breq	.+56     	; 0x7c58 <uip_process+0x154>
    7c20:	84 30       	cpi	r24, 0x04	; 4
    7c22:	91 05       	cpc	r25, r1
    7c24:	4c f4       	brge	.+18     	; 0x7c38 <uip_process+0x134>
    7c26:	81 30       	cpi	r24, 0x01	; 1
    7c28:	91 05       	cpc	r25, r1
    7c2a:	09 f4       	brne	.+2      	; 0x7c2e <uip_process+0x12a>
    7c2c:	61 c3       	rjmp	.+1730   	; 0x82f0 <uip_process+0x7ec>
    7c2e:	82 30       	cpi	r24, 0x02	; 2
    7c30:	91 05       	cpc	r25, r1
    7c32:	09 f0       	breq	.+2      	; 0x7c36 <uip_process+0x132>
    7c34:	bc c6       	rjmp	.+3448   	; 0x89ae <uip_process+0xeaa>
    7c36:	0d c0       	rjmp	.+26     	; 0x7c52 <uip_process+0x14e>
    7c38:	86 30       	cpi	r24, 0x06	; 6
    7c3a:	91 05       	cpc	r25, r1
    7c3c:	09 f4       	brne	.+2      	; 0x7c40 <uip_process+0x13c>
    7c3e:	0c c5       	rjmp	.+2584   	; 0x8658 <uip_process+0xb54>
    7c40:	88 30       	cpi	r24, 0x08	; 8
    7c42:	91 05       	cpc	r25, r1
    7c44:	09 f4       	brne	.+2      	; 0x7c48 <uip_process+0x144>
    7c46:	08 c5       	rjmp	.+2576   	; 0x8658 <uip_process+0xb54>
    7c48:	84 30       	cpi	r24, 0x04	; 4
    7c4a:	91 05       	cpc	r25, r1
    7c4c:	09 f0       	breq	.+2      	; 0x7c50 <uip_process+0x14c>
    7c4e:	af c6       	rjmp	.+3422   	; 0x89ae <uip_process+0xeaa>
    7c50:	03 c5       	rjmp	.+2566   	; 0x8658 <uip_process+0xb54>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    7c52:	10 92 dd 27 	sts	0x27DD, r1
	    goto tcp_send_syn;
    7c56:	4f c3       	rjmp	.+1694   	; 0x82f6 <uip_process+0x7f2>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    7c58:	84 e0       	ldi	r24, 0x04	; 4
    7c5a:	80 93 bc 2c 	sts	0x2CBC, r24
	    UIP_APPCALL();
    7c5e:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>
	    goto apprexmit;
    7c62:	90 c5       	rjmp	.+2848   	; 0x8784 <uip_process+0xc80>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    7c64:	8f 70       	andi	r24, 0x0F	; 15
    7c66:	83 30       	cpi	r24, 0x03	; 3
    7c68:	09 f0       	breq	.+2      	; 0x7c6c <uip_process+0x168>
    7c6a:	a1 c6       	rjmp	.+3394   	; 0x89ae <uip_process+0xeaa>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
    7c6c:	88 e0       	ldi	r24, 0x08	; 8
    7c6e:	80 93 bc 2c 	sts	0x2CBC, r24
    7c72:	4b c5       	rjmp	.+2710   	; 0x870a <uip_process+0xc06>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    7c74:	85 30       	cpi	r24, 0x05	; 5
    7c76:	19 f5       	brne	.+70     	; 0x7cbe <uip_process+0x1ba>
    if(uip_udp_conn->lport != 0) {
    7c78:	e0 91 bd 2c 	lds	r30, 0x2CBD
    7c7c:	f0 91 be 2c 	lds	r31, 0x2CBE
    7c80:	84 81       	ldd	r24, Z+4	; 0x04
    7c82:	95 81       	ldd	r25, Z+5	; 0x05
    7c84:	00 97       	sbiw	r24, 0x00	; 0
    7c86:	09 f4       	brne	.+2      	; 0x7c8a <uip_process+0x186>
    7c88:	92 c6       	rjmp	.+3364   	; 0x89ae <uip_process+0xeaa>
      uip_conn = NULL;
    7c8a:	10 92 c2 2c 	sts	0x2CC2, r1
    7c8e:	10 92 c1 2c 	sts	0x2CC1, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    7c92:	0c 50       	subi	r16, 0x0C	; 12
    7c94:	10 40       	sbci	r17, 0x00	; 0
    7c96:	10 93 c0 2c 	sts	0x2CC0, r17
    7c9a:	00 93 bf 2c 	sts	0x2CBF, r16
    7c9e:	10 93 b7 27 	sts	0x27B7, r17
    7ca2:	00 93 b6 27 	sts	0x27B6, r16
      uip_len = uip_slen = 0;
    7ca6:	10 92 58 2d 	sts	0x2D58, r1
    7caa:	10 92 57 2d 	sts	0x2D57, r1
    7cae:	10 92 b5 27 	sts	0x27B5, r1
    7cb2:	10 92 b4 27 	sts	0x27B4, r1
      uip_flags = UIP_POLL;
    7cb6:	88 e0       	ldi	r24, 0x08	; 8
    7cb8:	80 93 bc 2c 	sts	0x2CBC, r24
    7cbc:	25 c1       	rjmp	.+586    	; 0x7f08 <uip_process+0x404>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    7cbe:	08 52       	subi	r16, 0x28	; 40
    7cc0:	10 40       	sbci	r17, 0x00	; 0
    7cc2:	80 91 bc 27 	lds	r24, 0x27BC
    7cc6:	85 34       	cpi	r24, 0x45	; 69
    7cc8:	09 f0       	breq	.+2      	; 0x7ccc <uip_process+0x1c8>
    7cca:	71 c6       	rjmp	.+3298   	; 0x89ae <uip_process+0xeaa>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    7ccc:	90 91 be 27 	lds	r25, 0x27BE
    7cd0:	80 e0       	ldi	r24, 0x00	; 0
    7cd2:	20 91 bf 27 	lds	r18, 0x27BF
    7cd6:	7c 01       	movw	r14, r24
    7cd8:	e2 0e       	add	r14, r18
    7cda:	f1 1c       	adc	r15, r1
    7cdc:	80 91 b4 27 	lds	r24, 0x27B4
    7ce0:	90 91 b5 27 	lds	r25, 0x27B5
    7ce4:	8e 15       	cp	r24, r14
    7ce6:	9f 05       	cpc	r25, r15
    7ce8:	08 f4       	brcc	.+2      	; 0x7cec <uip_process+0x1e8>
    7cea:	61 c6       	rjmp	.+3266   	; 0x89ae <uip_process+0xeaa>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    7cec:	f0 92 b5 27 	sts	0x27B5, r15
    7cf0:	e0 92 b4 27 	sts	0x27B4, r14
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    7cf4:	80 91 c2 27 	lds	r24, 0x27C2
    7cf8:	90 e0       	ldi	r25, 0x00	; 0
    7cfa:	8f 73       	andi	r24, 0x3F	; 63
    7cfc:	90 70       	andi	r25, 0x00	; 0
    7cfe:	00 97       	sbiw	r24, 0x00	; 0
    7d00:	09 f0       	breq	.+2      	; 0x7d04 <uip_process+0x200>
    7d02:	55 c6       	rjmp	.+3242   	; 0x89ae <uip_process+0xeaa>
    7d04:	80 91 c3 27 	lds	r24, 0x27C3
    7d08:	88 23       	and	r24, r24
    7d0a:	09 f0       	breq	.+2      	; 0x7d0e <uip_process+0x20a>
    7d0c:	50 c6       	rjmp	.+3232   	; 0x89ae <uip_process+0xeaa>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    7d0e:	80 91 53 2d 	lds	r24, 0x2D53
    7d12:	90 91 54 2d 	lds	r25, 0x2D54
    7d16:	c0 91 c9 0e 	lds	r28, 0x0EC9
    7d1a:	d0 91 ca 0e 	lds	r29, 0x0ECA
    7d1e:	8c 17       	cp	r24, r28
    7d20:	9d 07       	cpc	r25, r29
    7d22:	59 f4       	brne	.+22     	; 0x7d3a <uip_process+0x236>
    7d24:	40 91 55 2d 	lds	r20, 0x2D55
    7d28:	50 91 56 2d 	lds	r21, 0x2D56
    7d2c:	20 91 cb 0e 	lds	r18, 0x0ECB
    7d30:	30 91 cc 0e 	lds	r19, 0x0ECC
    7d34:	42 17       	cp	r20, r18
    7d36:	53 07       	cpc	r21, r19
    7d38:	a1 f0       	breq	.+40     	; 0x7d62 <uip_process+0x25e>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    7d3a:	20 91 cc 27 	lds	r18, 0x27CC
    7d3e:	30 91 cd 27 	lds	r19, 0x27CD
    7d42:	28 17       	cp	r18, r24
    7d44:	39 07       	cpc	r19, r25
    7d46:	09 f0       	breq	.+2      	; 0x7d4a <uip_process+0x246>
    7d48:	32 c6       	rjmp	.+3172   	; 0x89ae <uip_process+0xeaa>
    7d4a:	20 91 ce 27 	lds	r18, 0x27CE
    7d4e:	30 91 cf 27 	lds	r19, 0x27CF
    7d52:	80 91 55 2d 	lds	r24, 0x2D55
    7d56:	90 91 56 2d 	lds	r25, 0x2D56
    7d5a:	28 17       	cp	r18, r24
    7d5c:	39 07       	cpc	r19, r25
    7d5e:	09 f0       	breq	.+2      	; 0x7d62 <uip_process+0x25e>
    7d60:	26 c6       	rjmp	.+3148   	; 0x89ae <uip_process+0xeaa>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    7d62:	0e 94 ee 3b 	call	0x77dc	; 0x77dc <uip_ipchksum>
    7d66:	2f ef       	ldi	r18, 0xFF	; 255
    7d68:	8f 3f       	cpi	r24, 0xFF	; 255
    7d6a:	92 07       	cpc	r25, r18
    7d6c:	09 f0       	breq	.+2      	; 0x7d70 <uip_process+0x26c>
    7d6e:	1f c6       	rjmp	.+3134   	; 0x89ae <uip_process+0xeaa>
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    7d70:	80 91 c5 27 	lds	r24, 0x27C5
    7d74:	86 30       	cpi	r24, 0x06	; 6
    7d76:	09 f4       	brne	.+2      	; 0x7d7a <uip_process+0x276>
    7d78:	31 c1       	rjmp	.+610    	; 0x7fdc <uip_process+0x4d8>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    7d7a:	81 31       	cpi	r24, 0x11	; 17
    7d7c:	e9 f1       	breq	.+122    	; 0x7df8 <uip_process+0x2f4>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    7d7e:	81 30       	cpi	r24, 0x01	; 1
    7d80:	09 f0       	breq	.+2      	; 0x7d84 <uip_process+0x280>
    7d82:	15 c6       	rjmp	.+3114   	; 0x89ae <uip_process+0xeaa>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    7d84:	80 91 d0 27 	lds	r24, 0x27D0
    7d88:	88 30       	cpi	r24, 0x08	; 8
    7d8a:	09 f0       	breq	.+2      	; 0x7d8e <uip_process+0x28a>
    7d8c:	10 c6       	rjmp	.+3104   	; 0x89ae <uip_process+0xeaa>
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    7d8e:	10 92 d0 27 	sts	0x27D0, r1

  if(ICMPBUF->icmpchksum >= UIP_HTONS(0xffff - (ICMP_ECHO << 8))) {
    7d92:	80 91 d2 27 	lds	r24, 0x27D2
    7d96:	90 91 d3 27 	lds	r25, 0x27D3
    7d9a:	4f ef       	ldi	r20, 0xFF	; 255
    7d9c:	87 3f       	cpi	r24, 0xF7	; 247
    7d9e:	94 07       	cpc	r25, r20
    7da0:	10 f0       	brcs	.+4      	; 0x7da6 <uip_process+0x2a2>
    ICMPBUF->icmpchksum += UIP_HTONS(ICMP_ECHO << 8) + 1;
    7da2:	09 96       	adiw	r24, 0x09	; 9
    7da4:	01 c0       	rjmp	.+2      	; 0x7da8 <uip_process+0x2a4>
  } else {
    ICMPBUF->icmpchksum += UIP_HTONS(ICMP_ECHO << 8);
    7da6:	08 96       	adiw	r24, 0x08	; 8
    7da8:	90 93 d3 27 	sts	0x27D3, r25
    7dac:	80 93 d2 27 	sts	0x27D2, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    7db0:	80 91 c8 27 	lds	r24, 0x27C8
    7db4:	90 91 c9 27 	lds	r25, 0x27C9
    7db8:	a0 91 ca 27 	lds	r26, 0x27CA
    7dbc:	b0 91 cb 27 	lds	r27, 0x27CB
    7dc0:	80 93 cc 27 	sts	0x27CC, r24
    7dc4:	90 93 cd 27 	sts	0x27CD, r25
    7dc8:	a0 93 ce 27 	sts	0x27CE, r26
    7dcc:	b0 93 cf 27 	sts	0x27CF, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    7dd0:	80 91 53 2d 	lds	r24, 0x2D53
    7dd4:	90 91 54 2d 	lds	r25, 0x2D54
    7dd8:	a0 91 55 2d 	lds	r26, 0x2D55
    7ddc:	b0 91 56 2d 	lds	r27, 0x2D56
    7de0:	80 93 c8 27 	sts	0x27C8, r24
    7de4:	90 93 c9 27 	sts	0x27C9, r25
    7de8:	a0 93 ca 27 	sts	0x27CA, r26
    7dec:	b0 93 cb 27 	sts	0x27CB, r27

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    7df0:	80 e4       	ldi	r24, 0x40	; 64
    7df2:	f8 01       	movw	r30, r16
    7df4:	80 87       	std	Z+8, r24	; 0x08
  goto ip_send_nolen;
    7df6:	b8 c5       	rjmp	.+2928   	; 0x8968 <uip_process+0xe64>
  /* UDP processing is really just a hack. We don't do anything to the
     UDP/IP headers, but let the UDP application do all the hard
     work. If the application sets uip_slen, it has a packet to
     send. */
#if UIP_UDP_CHECKSUMS
  uip_len = uip_len - UIP_IPUDPH_LEN;
    7df8:	c7 01       	movw	r24, r14
    7dfa:	4c 97       	sbiw	r24, 0x1c	; 28
    7dfc:	90 93 b5 27 	sts	0x27B5, r25
    7e00:	80 93 b4 27 	sts	0x27B4, r24
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    7e04:	88 ed       	ldi	r24, 0xD8	; 216
    7e06:	97 e2       	ldi	r25, 0x27	; 39
    7e08:	90 93 c0 2c 	sts	0x2CC0, r25
    7e0c:	80 93 bf 2c 	sts	0x2CBF, r24
  if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
    7e10:	80 91 d6 27 	lds	r24, 0x27D6
    7e14:	90 91 d7 27 	lds	r25, 0x27D7
    7e18:	00 97       	sbiw	r24, 0x00	; 0
    7e1a:	39 f0       	breq	.+14     	; 0x7e2a <uip_process+0x326>
    7e1c:	0e 94 03 3c 	call	0x7806	; 0x7806 <uip_udpchksum>
    7e20:	ff ef       	ldi	r31, 0xFF	; 255
    7e22:	8f 3f       	cpi	r24, 0xFF	; 255
    7e24:	9f 07       	cpc	r25, r31
    7e26:	09 f0       	breq	.+2      	; 0x7e2a <uip_process+0x326>
    7e28:	c2 c5       	rjmp	.+2948   	; 0x89ae <uip_process+0xeaa>
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Make sure that the UDP destination port number is not zero. */
  if(UDPBUF->destport == 0) {
    7e2a:	20 91 d2 27 	lds	r18, 0x27D2
    7e2e:	30 91 d3 27 	lds	r19, 0x27D3
    7e32:	21 15       	cp	r18, r1
    7e34:	31 05       	cpc	r19, r1
    7e36:	09 f4       	brne	.+2      	; 0x7e3a <uip_process+0x336>
    7e38:	ba c5       	rjmp	.+2932   	; 0x89ae <uip_process+0xeaa>
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    7e3a:	89 e5       	ldi	r24, 0x59	; 89
    7e3c:	9d e2       	ldi	r25, 0x2D	; 45
    7e3e:	90 93 be 2c 	sts	0x2CBE, r25
    7e42:	80 93 bd 2c 	sts	0x2CBD, r24
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    7e46:	60 91 cb 0e 	lds	r22, 0x0ECB
    7e4a:	70 91 cc 0e 	lds	r23, 0x0ECC
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    7e4e:	40 91 c5 0e 	lds	r20, 0x0EC5
    7e52:	50 91 c6 0e 	lds	r21, 0x0EC6
    7e56:	00 91 c7 0e 	lds	r16, 0x0EC7
    7e5a:	10 91 c8 0e 	lds	r17, 0x0EC8
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    7e5e:	39 c0       	rjmp	.+114    	; 0x7ed2 <uip_process+0x3ce>
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    7e60:	84 81       	ldd	r24, Z+4	; 0x04
    7e62:	95 81       	ldd	r25, Z+5	; 0x05
    7e64:	00 97       	sbiw	r24, 0x00	; 0
    7e66:	81 f1       	breq	.+96     	; 0x7ec8 <uip_process+0x3c4>
    7e68:	28 17       	cp	r18, r24
    7e6a:	39 07       	cpc	r19, r25
    7e6c:	69 f5       	brne	.+90     	; 0x7ec8 <uip_process+0x3c4>
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
    7e6e:	86 81       	ldd	r24, Z+6	; 0x06
    7e70:	97 81       	ldd	r25, Z+7	; 0x07
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    7e72:	00 97       	sbiw	r24, 0x00	; 0
    7e74:	39 f0       	breq	.+14     	; 0x7e84 <uip_process+0x380>
       (uip_udp_conn->rport == 0 ||
    7e76:	a0 91 d0 27 	lds	r26, 0x27D0
    7e7a:	b0 91 d1 27 	lds	r27, 0x27D1
    7e7e:	a8 17       	cp	r26, r24
    7e80:	b9 07       	cpc	r27, r25
    7e82:	11 f5       	brne	.+68     	; 0x7ec8 <uip_process+0x3c4>
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    7e84:	80 81       	ld	r24, Z
    7e86:	91 81       	ldd	r25, Z+1	; 0x01
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    7e88:	8c 17       	cp	r24, r28
    7e8a:	9d 07       	cpc	r25, r29
    7e8c:	29 f4       	brne	.+10     	; 0x7e98 <uip_process+0x394>
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    7e8e:	a2 81       	ldd	r26, Z+2	; 0x02
    7e90:	b3 81       	ldd	r27, Z+3	; 0x03
    7e92:	a6 17       	cp	r26, r22
    7e94:	b7 07       	cpc	r27, r23
    7e96:	39 f1       	breq	.+78     	; 0x7ee6 <uip_process+0x3e2>
    7e98:	84 17       	cp	r24, r20
    7e9a:	95 07       	cpc	r25, r21
    7e9c:	29 f4       	brne	.+10     	; 0x7ea8 <uip_process+0x3a4>
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    7e9e:	a2 81       	ldd	r26, Z+2	; 0x02
    7ea0:	b3 81       	ldd	r27, Z+3	; 0x03
    7ea2:	a0 17       	cp	r26, r16
    7ea4:	b1 07       	cpc	r27, r17
    7ea6:	f9 f0       	breq	.+62     	; 0x7ee6 <uip_process+0x3e2>
    7ea8:	a0 91 c8 27 	lds	r26, 0x27C8
    7eac:	b0 91 c9 27 	lds	r27, 0x27C9
    7eb0:	a8 17       	cp	r26, r24
    7eb2:	b9 07       	cpc	r27, r25
    7eb4:	49 f4       	brne	.+18     	; 0x7ec8 <uip_process+0x3c4>
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    7eb6:	a0 91 ca 27 	lds	r26, 0x27CA
    7eba:	b0 91 cb 27 	lds	r27, 0x27CB
    7ebe:	82 81       	ldd	r24, Z+2	; 0x02
    7ec0:	93 81       	ldd	r25, Z+3	; 0x03
    7ec2:	a8 17       	cp	r26, r24
    7ec4:	b9 07       	cpc	r27, r25
    7ec6:	79 f0       	breq	.+30     	; 0x7ee6 <uip_process+0x3e2>
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    7ec8:	3d 96       	adiw	r30, 0x0d	; 13
    7eca:	f0 93 be 2c 	sts	0x2CBE, r31
    7ece:	e0 93 bd 2c 	sts	0x2CBD, r30
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    7ed2:	e0 91 bd 2c 	lds	r30, 0x2CBD
    7ed6:	f0 91 be 2c 	lds	r31, 0x2CBE
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    7eda:	8d e2       	ldi	r24, 0x2D	; 45
    7edc:	eb 3d       	cpi	r30, 0xDB	; 219
    7ede:	f8 07       	cpc	r31, r24
    7ee0:	08 f4       	brcc	.+2      	; 0x7ee4 <uip_process+0x3e0>
    7ee2:	be cf       	rjmp	.-132    	; 0x7e60 <uip_process+0x35c>
    7ee4:	64 c5       	rjmp	.+2760   	; 0x89ae <uip_process+0xeaa>
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */
  
 udp_found:
  uip_conn = NULL;
    7ee6:	10 92 c2 2c 	sts	0x2CC2, r1
    7eea:	10 92 c1 2c 	sts	0x2CC1, r1
  uip_flags = UIP_NEWDATA;
    7eee:	82 e0       	ldi	r24, 0x02	; 2
    7ef0:	80 93 bc 2c 	sts	0x2CBC, r24
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    7ef4:	88 ed       	ldi	r24, 0xD8	; 216
    7ef6:	97 e2       	ldi	r25, 0x27	; 39
    7ef8:	90 93 b7 27 	sts	0x27B7, r25
    7efc:	80 93 b6 27 	sts	0x27B6, r24
  uip_slen = 0;
    7f00:	10 92 58 2d 	sts	0x2D58, r1
    7f04:	10 92 57 2d 	sts	0x2D57, r1
  UIP_UDP_APPCALL();
    7f08:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>

 udp_send:
  if(uip_slen == 0) {
    7f0c:	80 91 57 2d 	lds	r24, 0x2D57
    7f10:	90 91 58 2d 	lds	r25, 0x2D58
    7f14:	00 97       	sbiw	r24, 0x00	; 0
    7f16:	09 f4       	brne	.+2      	; 0x7f1a <uip_process+0x416>
    7f18:	4a c5       	rjmp	.+2708   	; 0x89ae <uip_process+0xeaa>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    7f1a:	9c 01       	movw	r18, r24
    7f1c:	24 5e       	subi	r18, 0xE4	; 228
    7f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    7f20:	30 93 b5 27 	sts	0x27B5, r19
    7f24:	20 93 b4 27 	sts	0x27B4, r18
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    7f28:	30 93 be 27 	sts	0x27BE, r19
  BUF->len[1] = (uip_len & 0xff);
    7f2c:	20 93 bf 27 	sts	0x27BF, r18
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    7f30:	e0 91 bd 2c 	lds	r30, 0x2CBD
    7f34:	f0 91 be 2c 	lds	r31, 0x2CBE
    7f38:	20 85       	ldd	r18, Z+8	; 0x08
    7f3a:	20 93 c4 27 	sts	0x27C4, r18
  BUF->proto = UIP_PROTO_UDP;
    7f3e:	21 e1       	ldi	r18, 0x11	; 17
    7f40:	20 93 c5 27 	sts	0x27C5, r18

  UDPBUF->udplen = UIP_HTONS(uip_slen + UIP_UDPH_LEN);
    7f44:	08 96       	adiw	r24, 0x08	; 8
    7f46:	98 27       	eor	r25, r24
    7f48:	89 27       	eor	r24, r25
    7f4a:	98 27       	eor	r25, r24
    7f4c:	90 93 d5 27 	sts	0x27D5, r25
    7f50:	80 93 d4 27 	sts	0x27D4, r24
  UDPBUF->udpchksum = 0;
    7f54:	10 92 d7 27 	sts	0x27D7, r1
    7f58:	10 92 d6 27 	sts	0x27D6, r1

  BUF->srcport  = uip_udp_conn->lport;
    7f5c:	84 81       	ldd	r24, Z+4	; 0x04
    7f5e:	95 81       	ldd	r25, Z+5	; 0x05
    7f60:	90 93 d1 27 	sts	0x27D1, r25
    7f64:	80 93 d0 27 	sts	0x27D0, r24
  BUF->destport = uip_udp_conn->rport;
    7f68:	86 81       	ldd	r24, Z+6	; 0x06
    7f6a:	97 81       	ldd	r25, Z+7	; 0x07
    7f6c:	90 93 d3 27 	sts	0x27D3, r25
    7f70:	80 93 d2 27 	sts	0x27D2, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    7f74:	80 91 53 2d 	lds	r24, 0x2D53
    7f78:	90 91 54 2d 	lds	r25, 0x2D54
    7f7c:	a0 91 55 2d 	lds	r26, 0x2D55
    7f80:	b0 91 56 2d 	lds	r27, 0x2D56
    7f84:	80 93 c8 27 	sts	0x27C8, r24
    7f88:	90 93 c9 27 	sts	0x27C9, r25
    7f8c:	a0 93 ca 27 	sts	0x27CA, r26
    7f90:	b0 93 cb 27 	sts	0x27CB, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    7f94:	80 81       	ld	r24, Z
    7f96:	91 81       	ldd	r25, Z+1	; 0x01
    7f98:	a2 81       	ldd	r26, Z+2	; 0x02
    7f9a:	b3 81       	ldd	r27, Z+3	; 0x03
    7f9c:	80 93 cc 27 	sts	0x27CC, r24
    7fa0:	90 93 cd 27 	sts	0x27CD, r25
    7fa4:	a0 93 ce 27 	sts	0x27CE, r26
    7fa8:	b0 93 cf 27 	sts	0x27CF, r27
   
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    7fac:	84 ee       	ldi	r24, 0xE4	; 228
    7fae:	97 e2       	ldi	r25, 0x27	; 39
    7fb0:	90 93 c0 2c 	sts	0x2CC0, r25
    7fb4:	80 93 bf 2c 	sts	0x2CBF, r24

#if UIP_UDP_CHECKSUMS
  /* Calculate UDP checksum. */
  UDPBUF->udpchksum = ~(uip_udpchksum());
    7fb8:	0e 94 03 3c 	call	0x7806	; 0x7806 <uip_udpchksum>
    7fbc:	80 95       	com	r24
    7fbe:	90 95       	com	r25
    7fc0:	90 93 d7 27 	sts	0x27D7, r25
    7fc4:	80 93 d6 27 	sts	0x27D6, r24
  if(UDPBUF->udpchksum == 0) {
    7fc8:	00 97       	sbiw	r24, 0x00	; 0
    7fca:	09 f0       	breq	.+2      	; 0x7fce <uip_process+0x4ca>
    7fcc:	cd c4       	rjmp	.+2458   	; 0x8968 <uip_process+0xe64>
    UDPBUF->udpchksum = 0xffff;
    7fce:	8f ef       	ldi	r24, 0xFF	; 255
    7fd0:	9f ef       	ldi	r25, 0xFF	; 255
    7fd2:	90 93 d7 27 	sts	0x27D7, r25
    7fd6:	80 93 d6 27 	sts	0x27D6, r24
    7fda:	c6 c4       	rjmp	.+2444   	; 0x8968 <uip_process+0xe64>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    7fdc:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <uip_tcpchksum>
    7fe0:	ef ef       	ldi	r30, 0xFF	; 255
    7fe2:	8f 3f       	cpi	r24, 0xFF	; 255
    7fe4:	9e 07       	cpc	r25, r30
    7fe6:	09 f0       	breq	.+2      	; 0x7fea <uip_process+0x4e6>
    7fe8:	e2 c4       	rjmp	.+2500   	; 0x89ae <uip_process+0xeaa>
    UIP_LOG("tcp: bad checksum.");
    goto drop;
  }

  /* Make sure that the TCP port number is not zero. */
  if(BUF->destport == 0 || BUF->srcport == 0) {
    7fea:	80 91 d2 27 	lds	r24, 0x27D2
    7fee:	90 91 d3 27 	lds	r25, 0x27D3
    7ff2:	00 97       	sbiw	r24, 0x00	; 0
    7ff4:	09 f4       	brne	.+2      	; 0x7ff8 <uip_process+0x4f4>
    7ff6:	db c4       	rjmp	.+2486   	; 0x89ae <uip_process+0xeaa>
    7ff8:	20 91 d0 27 	lds	r18, 0x27D0
    7ffc:	30 91 d1 27 	lds	r19, 0x27D1
    8000:	21 15       	cp	r18, r1
    8002:	31 05       	cpc	r19, r1
    8004:	09 f4       	brne	.+2      	; 0x8008 <uip_process+0x504>
    8006:	d3 c4       	rjmp	.+2470   	; 0x89ae <uip_process+0xeaa>
  uip_conn->rcv_nxt[2] = uip_acc32[2];
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(uint8_t flag)
    8008:	c3 ec       	ldi	r28, 0xC3	; 195
    800a:	dc e2       	ldi	r29, 0x2C	; 44
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    800c:	49 8d       	ldd	r20, Y+25	; 0x19
    800e:	44 23       	and	r20, r20
    8010:	e9 f0       	breq	.+58     	; 0x804c <uip_process+0x548>
    8012:	6c 81       	ldd	r22, Y+4	; 0x04
    8014:	7d 81       	ldd	r23, Y+5	; 0x05
    8016:	86 17       	cp	r24, r22
    8018:	97 07       	cpc	r25, r23
    801a:	c1 f4       	brne	.+48     	; 0x804c <uip_process+0x548>
       BUF->destport == uip_connr->lport &&
    801c:	6e 81       	ldd	r22, Y+6	; 0x06
    801e:	7f 81       	ldd	r23, Y+7	; 0x07
    8020:	26 17       	cp	r18, r22
    8022:	37 07       	cpc	r19, r23
    8024:	99 f4       	brne	.+38     	; 0x804c <uip_process+0x548>
       BUF->srcport == uip_connr->rport &&
    8026:	e0 91 c8 27 	lds	r30, 0x27C8
    802a:	f0 91 c9 27 	lds	r31, 0x27C9
    802e:	68 81       	ld	r22, Y
    8030:	79 81       	ldd	r23, Y+1	; 0x01
    8032:	e6 17       	cp	r30, r22
    8034:	f7 07       	cpc	r31, r23
    8036:	51 f4       	brne	.+20     	; 0x804c <uip_process+0x548>
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    8038:	e0 91 ca 27 	lds	r30, 0x27CA
    803c:	f0 91 cb 27 	lds	r31, 0x27CB
    8040:	6a 81       	ldd	r22, Y+2	; 0x02
    8042:	7b 81       	ldd	r23, Y+3	; 0x03
    8044:	e6 17       	cp	r30, r22
    8046:	f7 07       	cpc	r31, r23
    8048:	09 f4       	brne	.+2      	; 0x804c <uip_process+0x548>
    804a:	6d c1       	rjmp	.+730    	; 0x8326 <uip_process+0x822>
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    804c:	a0 96       	adiw	r28, 0x20	; 32
    goto drop;
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    804e:	fd e2       	ldi	r31, 0x2D	; 45
    8050:	c3 34       	cpi	r28, 0x43	; 67
    8052:	df 07       	cpc	r29, r31
    8054:	d9 f6       	brne	.-74     	; 0x800c <uip_process+0x508>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    8056:	20 91 dd 27 	lds	r18, 0x27DD
    805a:	2f 73       	andi	r18, 0x3F	; 63
    805c:	22 30       	cpi	r18, 0x02	; 2
    805e:	b9 f4       	brne	.+46     	; 0x808e <uip_process+0x58a>
    goto reset;
  }
  
  tmp16 = BUF->destport;
    8060:	90 93 24 25 	sts	0x2524, r25
    8064:	80 93 23 25 	sts	0x2523, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    8068:	40 e0       	ldi	r20, 0x00	; 0
    806a:	0d c0       	rjmp	.+26     	; 0x8086 <uip_process+0x582>
    if(tmp16 == uip_listenports[c]) {
    806c:	e4 2f       	mov	r30, r20
    806e:	f0 e0       	ldi	r31, 0x00	; 0
    8070:	ee 0f       	add	r30, r30
    8072:	ff 1f       	adc	r31, r31
    8074:	ed 5b       	subi	r30, 0xBD	; 189
    8076:	f2 4d       	sbci	r31, 0xD2	; 210
    8078:	20 81       	ld	r18, Z
    807a:	31 81       	ldd	r19, Z+1	; 0x01
    807c:	4f 5f       	subi	r20, 0xFF	; 255
    807e:	82 17       	cp	r24, r18
    8080:	93 07       	cpc	r25, r19
    8082:	09 f4       	brne	.+2      	; 0x8086 <uip_process+0x582>
    8084:	6e c0       	rjmp	.+220    	; 0x8162 <uip_process+0x65e>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    8086:	44 30       	cpi	r20, 0x04	; 4
    8088:	88 f3       	brcs	.-30     	; 0x806c <uip_process+0x568>
    808a:	40 93 25 25 	sts	0x2525, r20
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    808e:	80 91 dd 27 	lds	r24, 0x27DD
    8092:	82 fd       	sbrc	r24, 2
    8094:	8c c4       	rjmp	.+2328   	; 0x89ae <uip_process+0xeaa>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
  
  BUF->flags = TCP_RST | TCP_ACK;
    8096:	84 e1       	ldi	r24, 0x14	; 20
    8098:	f8 01       	movw	r30, r16
    809a:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    809c:	88 e2       	ldi	r24, 0x28	; 40
    809e:	90 e0       	ldi	r25, 0x00	; 0
    80a0:	90 93 b5 27 	sts	0x27B5, r25
    80a4:	80 93 b4 27 	sts	0x27B4, r24
  BUF->tcpoffset = 5 << 4;
    80a8:	80 e5       	ldi	r24, 0x50	; 80
    80aa:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    80ac:	80 91 d7 27 	lds	r24, 0x27D7
  BUF->seqno[3] = BUF->ackno[3];
    80b0:	90 91 db 27 	lds	r25, 0x27DB
    80b4:	93 8f       	std	Z+27, r25	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    80b6:	30 91 d6 27 	lds	r19, 0x27D6
  BUF->seqno[2] = BUF->ackno[2];
    80ba:	90 91 da 27 	lds	r25, 0x27DA
    80be:	92 8f       	std	Z+26, r25	; 0x1a
  BUF->ackno[2] = c;
    80c0:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    80c2:	20 91 d5 27 	lds	r18, 0x27D5
  BUF->seqno[1] = BUF->ackno[1];
    80c6:	90 91 d9 27 	lds	r25, 0x27D9
    80ca:	91 8f       	std	Z+25, r25	; 0x19
  BUF->ackno[1] = c;
    80cc:	25 8f       	std	Z+29, r18	; 0x1d
  
  c = BUF->seqno[0];
    80ce:	90 91 d4 27 	lds	r25, 0x27D4
    80d2:	90 93 25 25 	sts	0x2525, r25
  BUF->seqno[0] = BUF->ackno[0];
    80d6:	40 91 d8 27 	lds	r20, 0x27D8
    80da:	40 8f       	std	Z+24, r20	; 0x18
  BUF->ackno[0] = c;
    80dc:	94 8f       	std	Z+28, r25	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    80de:	8f 5f       	subi	r24, 0xFF	; 255
    80e0:	87 8f       	std	Z+31, r24	; 0x1f
    80e2:	88 23       	and	r24, r24
    80e4:	61 f4       	brne	.+24     	; 0x80fe <uip_process+0x5fa>
    if(++BUF->ackno[2] == 0) {
    80e6:	83 2f       	mov	r24, r19
    80e8:	8f 5f       	subi	r24, 0xFF	; 255
    80ea:	86 8f       	std	Z+30, r24	; 0x1e
    80ec:	88 23       	and	r24, r24
    80ee:	39 f4       	brne	.+14     	; 0x80fe <uip_process+0x5fa>
      if(++BUF->ackno[1] == 0) {
    80f0:	82 2f       	mov	r24, r18
    80f2:	8f 5f       	subi	r24, 0xFF	; 255
    80f4:	85 8f       	std	Z+29, r24	; 0x1d
    80f6:	88 23       	and	r24, r24
    80f8:	11 f4       	brne	.+4      	; 0x80fe <uip_process+0x5fa>
	++BUF->ackno[0];
    80fa:	9f 5f       	subi	r25, 0xFF	; 255
    80fc:	94 8f       	std	Z+28, r25	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    80fe:	80 91 d0 27 	lds	r24, 0x27D0
    8102:	90 91 d1 27 	lds	r25, 0x27D1
    8106:	90 93 24 25 	sts	0x2524, r25
    810a:	80 93 23 25 	sts	0x2523, r24
  BUF->srcport = BUF->destport;
    810e:	20 91 d2 27 	lds	r18, 0x27D2
    8112:	30 91 d3 27 	lds	r19, 0x27D3
    8116:	f8 01       	movw	r30, r16
    8118:	35 8b       	std	Z+21, r19	; 0x15
    811a:	24 8b       	std	Z+20, r18	; 0x14
  BUF->destport = tmp16;
    811c:	97 8b       	std	Z+23, r25	; 0x17
    811e:	86 8b       	std	Z+22, r24	; 0x16
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    8120:	80 91 c8 27 	lds	r24, 0x27C8
    8124:	90 91 c9 27 	lds	r25, 0x27C9
    8128:	a0 91 ca 27 	lds	r26, 0x27CA
    812c:	b0 91 cb 27 	lds	r27, 0x27CB
    8130:	80 93 cc 27 	sts	0x27CC, r24
    8134:	90 93 cd 27 	sts	0x27CD, r25
    8138:	a0 93 ce 27 	sts	0x27CE, r26
    813c:	b0 93 cf 27 	sts	0x27CF, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    8140:	80 91 53 2d 	lds	r24, 0x2D53
    8144:	90 91 54 2d 	lds	r25, 0x2D54
    8148:	a0 91 55 2d 	lds	r26, 0x2D55
    814c:	b0 91 56 2d 	lds	r27, 0x2D56
    8150:	80 93 c8 27 	sts	0x27C8, r24
    8154:	90 93 c9 27 	sts	0x27C9, r25
    8158:	a0 93 ca 27 	sts	0x27CA, r26
    815c:	b0 93 cb 27 	sts	0x27CB, r27
  
  /* And send out the RST packet! */
  goto tcp_send_noconn;
    8160:	e8 c3       	rjmp	.+2000   	; 0x8932 <uip_process+0xe2e>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    8162:	10 92 25 25 	sts	0x2525, r1
    8166:	80 e0       	ldi	r24, 0x00	; 0
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
    8168:	c0 e0       	ldi	r28, 0x00	; 0
    816a:	d0 e0       	ldi	r29, 0x00	; 0
  for(c = 0; c < UIP_CONNS; ++c) {
    816c:	22 c0       	rjmp	.+68     	; 0x81b2 <uip_process+0x6ae>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    816e:	e8 2f       	mov	r30, r24
    8170:	f0 e0       	ldi	r31, 0x00	; 0
    8172:	75 e0       	ldi	r23, 0x05	; 5
    8174:	ee 0f       	add	r30, r30
    8176:	ff 1f       	adc	r31, r31
    8178:	7a 95       	dec	r23
    817a:	e1 f7       	brne	.-8      	; 0x8174 <uip_process+0x670>
    817c:	ed 53       	subi	r30, 0x3D	; 61
    817e:	f3 4d       	sbci	r31, 0xD3	; 211
    8180:	91 8d       	ldd	r25, Z+25	; 0x19
    8182:	99 23       	and	r25, r25
    8184:	21 f4       	brne	.+8      	; 0x818e <uip_process+0x68a>
    8186:	80 93 25 25 	sts	0x2525, r24
      uip_connr = &uip_conns[c];
    818a:	ef 01       	movw	r28, r30
      break;
    818c:	16 c0       	rjmp	.+44     	; 0x81ba <uip_process+0x6b6>
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    818e:	97 30       	cpi	r25, 0x07	; 7
    8190:	79 f4       	brne	.+30     	; 0x81b0 <uip_process+0x6ac>
      if(uip_connr == 0 ||
    8192:	20 97       	sbiw	r28, 0x00	; 0
    8194:	21 f0       	breq	.+8      	; 0x819e <uip_process+0x69a>
    8196:	22 8d       	ldd	r18, Z+26	; 0x1a
    8198:	9a 8d       	ldd	r25, Y+26	; 0x1a
    819a:	92 17       	cp	r25, r18
    819c:	48 f4       	brcc	.+18     	; 0x81b0 <uip_process+0x6ac>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    819e:	c8 2f       	mov	r28, r24
    81a0:	d0 e0       	ldi	r29, 0x00	; 0
    81a2:	65 e0       	ldi	r22, 0x05	; 5
    81a4:	cc 0f       	add	r28, r28
    81a6:	dd 1f       	adc	r29, r29
    81a8:	6a 95       	dec	r22
    81aa:	e1 f7       	brne	.-8      	; 0x81a4 <uip_process+0x6a0>
    81ac:	cd 53       	subi	r28, 0x3D	; 61
    81ae:	d3 4d       	sbci	r29, 0xD3	; 211
    81b0:	8f 5f       	subi	r24, 0xFF	; 255
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    81b2:	84 30       	cpi	r24, 0x04	; 4
    81b4:	e0 f2       	brcs	.-72     	; 0x816e <uip_process+0x66a>
    81b6:	80 93 25 25 	sts	0x2525, r24
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    81ba:	20 97       	sbiw	r28, 0x00	; 0
    81bc:	09 f4       	brne	.+2      	; 0x81c0 <uip_process+0x6bc>
    81be:	f7 c3       	rjmp	.+2030   	; 0x89ae <uip_process+0xeaa>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    81c0:	d0 93 c2 2c 	sts	0x2CC2, r29
    81c4:	c0 93 c1 2c 	sts	0x2CC1, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    81c8:	83 e0       	ldi	r24, 0x03	; 3
    81ca:	8a 8f       	std	Y+26, r24	; 0x1a
    81cc:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    81ce:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    81d0:	84 e0       	ldi	r24, 0x04	; 4
    81d2:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    81d4:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    81d6:	80 91 d2 27 	lds	r24, 0x27D2
    81da:	90 91 d3 27 	lds	r25, 0x27D3
    81de:	9d 83       	std	Y+5, r25	; 0x05
    81e0:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    81e2:	80 91 d0 27 	lds	r24, 0x27D0
    81e6:	90 91 d1 27 	lds	r25, 0x27D1
    81ea:	9f 83       	std	Y+7, r25	; 0x07
    81ec:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    81ee:	80 91 c8 27 	lds	r24, 0x27C8
    81f2:	90 91 c9 27 	lds	r25, 0x27C9
    81f6:	a0 91 ca 27 	lds	r26, 0x27CA
    81fa:	b0 91 cb 27 	lds	r27, 0x27CB
    81fe:	88 83       	st	Y, r24
    8200:	99 83       	std	Y+1, r25	; 0x01
    8202:	aa 83       	std	Y+2, r26	; 0x02
    8204:	bb 83       	std	Y+3, r27	; 0x03
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    8206:	81 e0       	ldi	r24, 0x01	; 1
    8208:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    820a:	80 91 1f 25 	lds	r24, 0x251F
    820e:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    8210:	80 91 20 25 	lds	r24, 0x2520
    8214:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    8216:	80 91 21 25 	lds	r24, 0x2521
    821a:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    821c:	80 91 22 25 	lds	r24, 0x2522
    8220:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    8222:	81 e0       	ldi	r24, 0x01	; 1
    8224:	90 e0       	ldi	r25, 0x00	; 0
    8226:	99 8b       	std	Y+17, r25	; 0x11
    8228:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    822a:	80 91 d7 27 	lds	r24, 0x27D7
    822e:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    8230:	80 91 d6 27 	lds	r24, 0x27D6
    8234:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    8236:	80 91 d5 27 	lds	r24, 0x27D5
    823a:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    823c:	80 91 d4 27 	lds	r24, 0x27D4
    8240:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    8242:	81 e0       	ldi	r24, 0x01	; 1
    8244:	90 e0       	ldi	r25, 0x00	; 0
    8246:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    824a:	80 91 dc 27 	lds	r24, 0x27DC
    824e:	28 2f       	mov	r18, r24
    8250:	30 e0       	ldi	r19, 0x00	; 0
    8252:	20 7f       	andi	r18, 0xF0	; 240
    8254:	30 70       	andi	r19, 0x00	; 0
    8256:	21 35       	cpi	r18, 0x51	; 81
    8258:	31 05       	cpc	r19, r1
    825a:	0c f4       	brge	.+2      	; 0x825e <uip_process+0x75a>
    825c:	49 c0       	rjmp	.+146    	; 0x82f0 <uip_process+0x7ec>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    825e:	82 95       	swap	r24
    8260:	8f 70       	andi	r24, 0x0F	; 15
    8262:	90 e0       	ldi	r25, 0x00	; 0
    8264:	05 97       	sbiw	r24, 0x05	; 5
    8266:	88 0f       	add	r24, r24
    8268:	99 1f       	adc	r25, r25
    826a:	88 0f       	add	r24, r24
    826c:	99 1f       	adc	r25, r25
    826e:	50 91 26 25 	lds	r21, 0x2526
    8272:	40 e0       	ldi	r20, 0x00	; 0
    8274:	34 c0       	rjmp	.+104    	; 0x82de <uip_process+0x7da>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    8276:	f9 01       	movw	r30, r18
    8278:	e4 54       	subi	r30, 0x44	; 68
    827a:	f8 4d       	sbci	r31, 0xD8	; 216
    827c:	50 a5       	ldd	r21, Z+40	; 0x28
      if(opt == TCP_OPT_END) {
    827e:	55 23       	and	r21, r21
    8280:	29 f4       	brne	.+10     	; 0x828c <uip_process+0x788>
    8282:	40 93 25 25 	sts	0x2525, r20
    8286:	10 92 26 25 	sts	0x2526, r1
    828a:	32 c0       	rjmp	.+100    	; 0x82f0 <uip_process+0x7ec>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    828c:	51 30       	cpi	r21, 0x01	; 1
    828e:	11 f4       	brne	.+4      	; 0x8294 <uip_process+0x790>
	++c;
    8290:	4f 5f       	subi	r20, 0xFF	; 255
    8292:	25 c0       	rjmp	.+74     	; 0x82de <uip_process+0x7da>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    8294:	52 30       	cpi	r21, 0x02	; 2
    8296:	e1 f4       	brne	.+56     	; 0x82d0 <uip_process+0x7cc>
    8298:	61 a5       	ldd	r22, Z+41	; 0x29
    829a:	64 30       	cpi	r22, 0x04	; 4
    829c:	c9 f4       	brne	.+50     	; 0x82d0 <uip_process+0x7cc>
    829e:	40 93 25 25 	sts	0x2525, r20
    82a2:	50 93 26 25 	sts	0x2526, r21
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    82a6:	32 a5       	ldd	r19, Z+42	; 0x2a
    82a8:	20 e0       	ldi	r18, 0x00	; 0
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    82aa:	83 a5       	ldd	r24, Z+43	; 0x2b
    82ac:	90 e0       	ldi	r25, 0x00	; 0
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    82ae:	82 2b       	or	r24, r18
    82b0:	93 2b       	or	r25, r19
    82b2:	90 93 24 25 	sts	0x2524, r25
    82b6:	80 93 23 25 	sts	0x2523, r24
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    82ba:	f4 e0       	ldi	r31, 0x04	; 4
    82bc:	89 3d       	cpi	r24, 0xD9	; 217
    82be:	9f 07       	cpc	r25, r31
    82c0:	10 f0       	brcs	.+4      	; 0x82c6 <uip_process+0x7c2>
    82c2:	88 ed       	ldi	r24, 0xD8	; 216
    82c4:	94 e0       	ldi	r25, 0x04	; 4
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    82c6:	9b 8b       	std	Y+19, r25	; 0x13
    82c8:	8a 8b       	std	Y+18, r24	; 0x12
    82ca:	9d 8b       	std	Y+21, r25	; 0x15
    82cc:	8c 8b       	std	Y+20, r24	; 0x14
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
	
	/* And we are done processing options. */
	break;
    82ce:	10 c0       	rjmp	.+32     	; 0x82f0 <uip_process+0x7ec>
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    82d0:	24 54       	subi	r18, 0x44	; 68
    82d2:	38 4d       	sbci	r19, 0xD8	; 216
    82d4:	f9 01       	movw	r30, r18
    82d6:	21 a5       	ldd	r18, Z+41	; 0x29
    82d8:	22 23       	and	r18, r18
    82da:	31 f0       	breq	.+12     	; 0x82e8 <uip_process+0x7e4>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    82dc:	42 0f       	add	r20, r18
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    82de:	24 2f       	mov	r18, r20
    82e0:	30 e0       	ldi	r19, 0x00	; 0
    82e2:	28 17       	cp	r18, r24
    82e4:	39 07       	cpc	r19, r25
    82e6:	3c f2       	brlt	.-114    	; 0x8276 <uip_process+0x772>
    82e8:	40 93 25 25 	sts	0x2525, r20
    82ec:	50 93 26 25 	sts	0x2526, r21
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    82f0:	80 e1       	ldi	r24, 0x10	; 16
    82f2:	80 93 dd 27 	sts	0x27DD, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    82f6:	80 91 dd 27 	lds	r24, 0x27DD
    82fa:	82 60       	ori	r24, 0x02	; 2
    82fc:	80 93 dd 27 	sts	0x27DD, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    8300:	82 e0       	ldi	r24, 0x02	; 2
    8302:	80 93 e4 27 	sts	0x27E4, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    8306:	84 e0       	ldi	r24, 0x04	; 4
    8308:	80 93 e5 27 	sts	0x27E5, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    830c:	80 93 e6 27 	sts	0x27E6, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    8310:	88 ed       	ldi	r24, 0xD8	; 216
    8312:	80 93 e7 27 	sts	0x27E7, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    8316:	8c e2       	ldi	r24, 0x2C	; 44
    8318:	90 e0       	ldi	r25, 0x00	; 0
    831a:	90 93 b5 27 	sts	0x27B5, r25
    831e:	80 93 b4 27 	sts	0x27B4, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    8322:	80 e6       	ldi	r24, 0x60	; 96
    8324:	b3 c2       	rjmp	.+1382   	; 0x888c <uip_process+0xd88>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    8326:	d0 93 c2 2c 	sts	0x2CC2, r29
    832a:	c0 93 c1 2c 	sts	0x2CC1, r28
  uip_flags = 0;
    832e:	10 92 bc 2c 	sts	0x2CBC, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    8332:	80 91 dd 27 	lds	r24, 0x27DD
    8336:	90 e0       	ldi	r25, 0x00	; 0
    8338:	82 ff       	sbrs	r24, 2
    833a:	03 c0       	rjmp	.+6      	; 0x8342 <uip_process+0x83e>
    uip_connr->tcpstateflags = UIP_CLOSED;
    833c:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    833e:	80 e2       	ldi	r24, 0x20	; 32
    8340:	4e c2       	rjmp	.+1180   	; 0x87de <uip_process+0xcda>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    8342:	20 91 dc 27 	lds	r18, 0x27DC
    8346:	22 95       	swap	r18
    8348:	2f 70       	andi	r18, 0x0F	; 15
    834a:	22 0f       	add	r18, r18
    834c:	22 0f       	add	r18, r18
    834e:	20 93 25 25 	sts	0x2525, r18
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    8352:	b7 01       	movw	r22, r14
    8354:	62 1b       	sub	r22, r18
    8356:	71 09       	sbc	r23, r1
    8358:	9b 01       	movw	r18, r22
    835a:	24 51       	subi	r18, 0x14	; 20
    835c:	30 40       	sbci	r19, 0x00	; 0
    835e:	30 93 b5 27 	sts	0x27B5, r19
    8362:	20 93 b4 27 	sts	0x27B4, r18
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    8366:	50 e0       	ldi	r21, 0x00	; 0
    8368:	4f 70       	andi	r20, 0x0F	; 15
    836a:	50 70       	andi	r21, 0x00	; 0
    836c:	42 30       	cpi	r20, 0x02	; 2
    836e:	51 05       	cpc	r21, r1
    8370:	39 f4       	brne	.+14     	; 0x8380 <uip_process+0x87c>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
    8372:	ac 01       	movw	r20, r24
    8374:	4f 73       	andi	r20, 0x3F	; 63
    8376:	50 70       	andi	r21, 0x00	; 0
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    8378:	42 31       	cpi	r20, 0x12	; 18
    837a:	51 05       	cpc	r21, r1
    837c:	51 f4       	brne	.+20     	; 0x8392 <uip_process+0x88e>
    837e:	2a c0       	rjmp	.+84     	; 0x83d4 <uip_process+0x8d0>
    8380:	41 30       	cpi	r20, 0x01	; 1
    8382:	51 05       	cpc	r21, r1
    8384:	31 f4       	brne	.+12     	; 0x8392 <uip_process+0x88e>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    8386:	ac 01       	movw	r20, r24
    8388:	4f 73       	andi	r20, 0x3F	; 63
    838a:	50 70       	andi	r21, 0x00	; 0
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
    838c:	42 30       	cpi	r20, 0x02	; 2
    838e:	51 05       	cpc	r21, r1
    8390:	09 f1       	breq	.+66     	; 0x83d4 <uip_process+0x8d0>
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    8392:	21 15       	cp	r18, r1
    8394:	31 05       	cpc	r19, r1
    8396:	31 f4       	brne	.+12     	; 0x83a4 <uip_process+0x8a0>
    8398:	9c 01       	movw	r18, r24
    839a:	23 70       	andi	r18, 0x03	; 3
    839c:	30 70       	andi	r19, 0x00	; 0
    839e:	21 15       	cp	r18, r1
    83a0:	31 05       	cpc	r19, r1
    83a2:	c1 f0       	breq	.+48     	; 0x83d4 <uip_process+0x8d0>
    83a4:	30 91 d4 27 	lds	r19, 0x27D4
    83a8:	28 85       	ldd	r18, Y+8	; 0x08
    83aa:	32 17       	cp	r19, r18
    83ac:	09 f0       	breq	.+2      	; 0x83b0 <uip_process+0x8ac>
    83ae:	64 c2       	rjmp	.+1224   	; 0x8878 <uip_process+0xd74>
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
    83b0:	30 91 d5 27 	lds	r19, 0x27D5
    83b4:	29 85       	ldd	r18, Y+9	; 0x09
    83b6:	32 17       	cp	r19, r18
    83b8:	09 f0       	breq	.+2      	; 0x83bc <uip_process+0x8b8>
    83ba:	5e c2       	rjmp	.+1212   	; 0x8878 <uip_process+0xd74>
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
    83bc:	30 91 d6 27 	lds	r19, 0x27D6
    83c0:	2a 85       	ldd	r18, Y+10	; 0x0a
    83c2:	32 17       	cp	r19, r18
    83c4:	09 f0       	breq	.+2      	; 0x83c8 <uip_process+0x8c4>
    83c6:	58 c2       	rjmp	.+1200   	; 0x8878 <uip_process+0xd74>
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
    83c8:	30 91 d7 27 	lds	r19, 0x27D7
    83cc:	2b 85       	ldd	r18, Y+11	; 0x0b
    83ce:	32 17       	cp	r19, r18
    83d0:	09 f0       	breq	.+2      	; 0x83d4 <uip_process+0x8d0>
    83d2:	52 c2       	rjmp	.+1188   	; 0x8878 <uip_process+0xd74>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    83d4:	84 ff       	sbrs	r24, 4
    83d6:	4a c0       	rjmp	.+148    	; 0x846c <uip_process+0x968>
    83d8:	68 89       	ldd	r22, Y+16	; 0x10
    83da:	79 89       	ldd	r23, Y+17	; 0x11
    83dc:	61 15       	cp	r22, r1
    83de:	71 05       	cpc	r23, r1
    83e0:	09 f4       	brne	.+2      	; 0x83e4 <uip_process+0x8e0>
    83e2:	44 c0       	rjmp	.+136    	; 0x846c <uip_process+0x968>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    83e4:	ce 01       	movw	r24, r28
    83e6:	0c 96       	adiw	r24, 0x0c	; 12
    83e8:	0e 94 92 3b 	call	0x7724	; 0x7724 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    83ec:	30 91 d8 27 	lds	r19, 0x27D8
    83f0:	80 91 b8 27 	lds	r24, 0x27B8
    83f4:	38 17       	cp	r19, r24
    83f6:	d1 f5       	brne	.+116    	; 0x846c <uip_process+0x968>
       BUF->ackno[1] == uip_acc32[1] &&
    83f8:	20 91 d9 27 	lds	r18, 0x27D9
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
    83fc:	80 91 b9 27 	lds	r24, 0x27B9
    8400:	28 17       	cp	r18, r24
    8402:	a1 f5       	brne	.+104    	; 0x846c <uip_process+0x968>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    8404:	90 91 da 27 	lds	r25, 0x27DA
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
    8408:	80 91 ba 27 	lds	r24, 0x27BA
    840c:	98 17       	cp	r25, r24
    840e:	71 f5       	brne	.+92     	; 0x846c <uip_process+0x968>
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
    8410:	80 91 db 27 	lds	r24, 0x27DB
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    8414:	40 91 bb 27 	lds	r20, 0x27BB
    8418:	84 17       	cp	r24, r20
    841a:	41 f5       	brne	.+80     	; 0x846c <uip_process+0x968>
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    841c:	3c 87       	std	Y+12, r19	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    841e:	2d 87       	std	Y+13, r18	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    8420:	9e 87       	std	Y+14, r25	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    8422:	8f 87       	std	Y+15, r24	; 0x0f
	
      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    8424:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8426:	88 23       	and	r24, r24
    8428:	d1 f4       	brne	.+52     	; 0x845e <uip_process+0x95a>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    842a:	2e 89       	ldd	r18, Y+22	; 0x16
      uip_connr->snd_nxt[3] = uip_acc32[3];
	
      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
    842c:	88 8d       	ldd	r24, Y+24	; 0x18
    842e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    8430:	89 1b       	sub	r24, r25
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    8432:	92 2f       	mov	r25, r18
    8434:	96 95       	lsr	r25
    8436:	96 95       	lsr	r25
    8438:	96 95       	lsr	r25
    843a:	89 1b       	sub	r24, r25
	uip_connr->sa += m;
    843c:	28 0f       	add	r18, r24
    843e:	2e 8b       	std	Y+22, r18	; 0x16
	if(m < 0) {
	  m = -m;
    8440:	87 fd       	sbrc	r24, 7
    8442:	81 95       	neg	r24
	}
	m = m - (uip_connr->sv >> 2);
    8444:	9f 89       	ldd	r25, Y+23	; 0x17
    8446:	39 2f       	mov	r19, r25
    8448:	36 95       	lsr	r19
    844a:	36 95       	lsr	r19
    844c:	93 1b       	sub	r25, r19
	uip_connr->sv += m;
    844e:	98 0f       	add	r25, r24
    8450:	9f 8b       	std	Y+23, r25	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    8452:	82 2f       	mov	r24, r18
    8454:	86 95       	lsr	r24
    8456:	86 95       	lsr	r24
    8458:	86 95       	lsr	r24
    845a:	89 0f       	add	r24, r25
    845c:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    845e:	81 e0       	ldi	r24, 0x01	; 1
    8460:	80 93 bc 2c 	sts	0x2CBC, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    8464:	88 8d       	ldd	r24, Y+24	; 0x18
    8466:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    8468:	19 8a       	std	Y+17, r1	; 0x11
    846a:	18 8a       	std	Y+16, r1	; 0x10
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    846c:	29 8d       	ldd	r18, Y+25	; 0x19
    846e:	30 e0       	ldi	r19, 0x00	; 0
    8470:	c9 01       	movw	r24, r18
    8472:	8f 70       	andi	r24, 0x0F	; 15
    8474:	90 70       	andi	r25, 0x00	; 0
    8476:	84 30       	cpi	r24, 0x04	; 4
    8478:	91 05       	cpc	r25, r1
    847a:	09 f4       	brne	.+2      	; 0x847e <uip_process+0x97a>
    847c:	b5 c1       	rjmp	.+874    	; 0x87e8 <uip_process+0xce4>
    847e:	85 30       	cpi	r24, 0x05	; 5
    8480:	91 05       	cpc	r25, r1
    8482:	64 f4       	brge	.+24     	; 0x849c <uip_process+0x998>
    8484:	82 30       	cpi	r24, 0x02	; 2
    8486:	91 05       	cpc	r25, r1
    8488:	c9 f1       	breq	.+114    	; 0x84fc <uip_process+0x9f8>
    848a:	83 30       	cpi	r24, 0x03	; 3
    848c:	91 05       	cpc	r25, r1
    848e:	0c f0       	brlt	.+2      	; 0x8492 <uip_process+0x98e>
    8490:	b9 c0       	rjmp	.+370    	; 0x8604 <uip_process+0xb00>
    8492:	81 30       	cpi	r24, 0x01	; 1
    8494:	91 05       	cpc	r25, r1
    8496:	09 f0       	breq	.+2      	; 0x849a <uip_process+0x996>
    8498:	8a c2       	rjmp	.+1300   	; 0x89ae <uip_process+0xeaa>
    849a:	11 c0       	rjmp	.+34     	; 0x84be <uip_process+0x9ba>
    849c:	86 30       	cpi	r24, 0x06	; 6
    849e:	91 05       	cpc	r25, r1
    84a0:	09 f4       	brne	.+2      	; 0x84a4 <uip_process+0x9a0>
    84a2:	e2 c1       	rjmp	.+964    	; 0x8868 <uip_process+0xd64>
    84a4:	86 30       	cpi	r24, 0x06	; 6
    84a6:	91 05       	cpc	r25, r1
    84a8:	0c f4       	brge	.+2      	; 0x84ac <uip_process+0x9a8>
    84aa:	be c1       	rjmp	.+892    	; 0x8828 <uip_process+0xd24>
    84ac:	87 30       	cpi	r24, 0x07	; 7
    84ae:	91 05       	cpc	r25, r1
    84b0:	09 f4       	brne	.+2      	; 0x84b4 <uip_process+0x9b0>
    84b2:	e2 c1       	rjmp	.+964    	; 0x8878 <uip_process+0xd74>
    84b4:	88 30       	cpi	r24, 0x08	; 8
    84b6:	91 05       	cpc	r25, r1
    84b8:	09 f0       	breq	.+2      	; 0x84bc <uip_process+0x9b8>
    84ba:	79 c2       	rjmp	.+1266   	; 0x89ae <uip_process+0xeaa>
    84bc:	8a c1       	rjmp	.+788    	; 0x87d2 <uip_process+0xcce>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    84be:	80 91 bc 2c 	lds	r24, 0x2CBC
    84c2:	80 ff       	sbrs	r24, 0
    84c4:	14 c0       	rjmp	.+40     	; 0x84ee <uip_process+0x9ea>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    84c6:	83 e0       	ldi	r24, 0x03	; 3
    84c8:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    84ca:	80 e4       	ldi	r24, 0x40	; 64
    84cc:	80 93 bc 2c 	sts	0x2CBC, r24
      uip_connr->len = 0;
    84d0:	19 8a       	std	Y+17, r1	; 0x11
    84d2:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    84d4:	80 91 b4 27 	lds	r24, 0x27B4
    84d8:	90 91 b5 27 	lds	r25, 0x27B5
    84dc:	00 97       	sbiw	r24, 0x00	; 0
    84de:	09 f4       	brne	.+2      	; 0x84e2 <uip_process+0x9de>
    84e0:	10 c1       	rjmp	.+544    	; 0x8702 <uip_process+0xbfe>
        uip_flags |= UIP_NEWDATA;
    84e2:	22 e4       	ldi	r18, 0x42	; 66
    84e4:	20 93 bc 2c 	sts	0x2CBC, r18
        uip_add_rcv_nxt(uip_len);
    84e8:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
    84ec:	0a c1       	rjmp	.+532    	; 0x8702 <uip_process+0xbfe>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* We need to retransmit the SYNACK */
    if((BUF->flags & TCP_CTL) == TCP_SYN) {
    84ee:	80 91 dd 27 	lds	r24, 0x27DD
    84f2:	8f 73       	andi	r24, 0x3F	; 63
    84f4:	82 30       	cpi	r24, 0x02	; 2
    84f6:	09 f0       	breq	.+2      	; 0x84fa <uip_process+0x9f6>
    84f8:	5a c2       	rjmp	.+1204   	; 0x89ae <uip_process+0xeaa>
    84fa:	fa ce       	rjmp	.-524    	; 0x82f0 <uip_process+0x7ec>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    84fc:	80 91 bc 2c 	lds	r24, 0x2CBC
    8500:	80 ff       	sbrs	r24, 0
    8502:	75 c0       	rjmp	.+234    	; 0x85ee <uip_process+0xaea>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
    8504:	80 91 dd 27 	lds	r24, 0x27DD
    8508:	8f 73       	andi	r24, 0x3F	; 63
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    850a:	82 31       	cpi	r24, 0x12	; 18
    850c:	09 f0       	breq	.+2      	; 0x8510 <uip_process+0xa0c>
    850e:	6f c0       	rjmp	.+222    	; 0x85ee <uip_process+0xaea>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    8510:	80 91 dc 27 	lds	r24, 0x27DC
    8514:	28 2f       	mov	r18, r24
    8516:	30 e0       	ldi	r19, 0x00	; 0
    8518:	20 7f       	andi	r18, 0xF0	; 240
    851a:	30 70       	andi	r19, 0x00	; 0
    851c:	21 35       	cpi	r18, 0x51	; 81
    851e:	31 05       	cpc	r19, r1
    8520:	0c f4       	brge	.+2      	; 0x8524 <uip_process+0xa20>
    8522:	49 c0       	rjmp	.+146    	; 0x85b6 <uip_process+0xab2>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    8524:	82 95       	swap	r24
    8526:	8f 70       	andi	r24, 0x0F	; 15
    8528:	90 e0       	ldi	r25, 0x00	; 0
    852a:	05 97       	sbiw	r24, 0x05	; 5
    852c:	88 0f       	add	r24, r24
    852e:	99 1f       	adc	r25, r25
    8530:	88 0f       	add	r24, r24
    8532:	99 1f       	adc	r25, r25
    8534:	50 91 26 25 	lds	r21, 0x2526
    8538:	40 e0       	ldi	r20, 0x00	; 0
    853a:	34 c0       	rjmp	.+104    	; 0x85a4 <uip_process+0xaa0>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    853c:	f9 01       	movw	r30, r18
    853e:	e4 54       	subi	r30, 0x44	; 68
    8540:	f8 4d       	sbci	r31, 0xD8	; 216
    8542:	50 a5       	ldd	r21, Z+40	; 0x28
	  if(opt == TCP_OPT_END) {
    8544:	55 23       	and	r21, r21
    8546:	29 f4       	brne	.+10     	; 0x8552 <uip_process+0xa4e>
    8548:	40 93 25 25 	sts	0x2525, r20
    854c:	10 92 26 25 	sts	0x2526, r1
    8550:	32 c0       	rjmp	.+100    	; 0x85b6 <uip_process+0xab2>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    8552:	51 30       	cpi	r21, 0x01	; 1
    8554:	11 f4       	brne	.+4      	; 0x855a <uip_process+0xa56>
	    ++c;
    8556:	4f 5f       	subi	r20, 0xFF	; 255
    8558:	25 c0       	rjmp	.+74     	; 0x85a4 <uip_process+0xaa0>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    855a:	52 30       	cpi	r21, 0x02	; 2
    855c:	e1 f4       	brne	.+56     	; 0x8596 <uip_process+0xa92>
    855e:	61 a5       	ldd	r22, Z+41	; 0x29
    8560:	64 30       	cpi	r22, 0x04	; 4
    8562:	c9 f4       	brne	.+50     	; 0x8596 <uip_process+0xa92>
    8564:	40 93 25 25 	sts	0x2525, r20
    8568:	50 93 26 25 	sts	0x2526, r21
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    856c:	32 a5       	ldd	r19, Z+42	; 0x2a
    856e:	20 e0       	ldi	r18, 0x00	; 0
    8570:	83 a5       	ldd	r24, Z+43	; 0x2b
    8572:	90 e0       	ldi	r25, 0x00	; 0
    8574:	82 2b       	or	r24, r18
    8576:	93 2b       	or	r25, r19
    8578:	90 93 24 25 	sts	0x2524, r25
    857c:	80 93 23 25 	sts	0x2523, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    8580:	74 e0       	ldi	r23, 0x04	; 4
    8582:	89 3d       	cpi	r24, 0xD9	; 217
    8584:	97 07       	cpc	r25, r23
    8586:	10 f0       	brcs	.+4      	; 0x858c <uip_process+0xa88>
    8588:	88 ed       	ldi	r24, 0xD8	; 216
    858a:	94 e0       	ldi	r25, 0x04	; 4
    858c:	9b 8b       	std	Y+19, r25	; 0x13
    858e:	8a 8b       	std	Y+18, r24	; 0x12
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    8590:	9d 8b       	std	Y+21, r25	; 0x15
    8592:	8c 8b       	std	Y+20, r24	; 0x14
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
    8594:	10 c0       	rjmp	.+32     	; 0x85b6 <uip_process+0xab2>
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    8596:	24 54       	subi	r18, 0x44	; 68
    8598:	38 4d       	sbci	r19, 0xD8	; 216
    859a:	f9 01       	movw	r30, r18
    859c:	21 a5       	ldd	r18, Z+41	; 0x29
    859e:	22 23       	and	r18, r18
    85a0:	31 f0       	breq	.+12     	; 0x85ae <uip_process+0xaaa>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    85a2:	42 0f       	add	r20, r18
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    85a4:	24 2f       	mov	r18, r20
    85a6:	30 e0       	ldi	r19, 0x00	; 0
    85a8:	28 17       	cp	r18, r24
    85aa:	39 07       	cpc	r19, r25
    85ac:	3c f2       	brlt	.-114    	; 0x853c <uip_process+0xa38>
    85ae:	40 93 25 25 	sts	0x2525, r20
    85b2:	50 93 26 25 	sts	0x2526, r21
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    85b6:	83 e0       	ldi	r24, 0x03	; 3
    85b8:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    85ba:	80 91 d4 27 	lds	r24, 0x27D4
    85be:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    85c0:	80 91 d5 27 	lds	r24, 0x27D5
    85c4:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    85c6:	80 91 d6 27 	lds	r24, 0x27D6
    85ca:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    85cc:	80 91 d7 27 	lds	r24, 0x27D7
    85d0:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    85d2:	81 e0       	ldi	r24, 0x01	; 1
    85d4:	90 e0       	ldi	r25, 0x00	; 0
    85d6:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    85da:	82 e4       	ldi	r24, 0x42	; 66
    85dc:	80 93 bc 2c 	sts	0x2CBC, r24
      uip_connr->len = 0;
    85e0:	19 8a       	std	Y+17, r1	; 0x11
    85e2:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    85e4:	10 92 b5 27 	sts	0x27B5, r1
    85e8:	10 92 b4 27 	sts	0x27B4, r1
    85ec:	8a c0       	rjmp	.+276    	; 0x8702 <uip_process+0xbfe>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    85ee:	80 e2       	ldi	r24, 0x20	; 32
    85f0:	80 93 bc 2c 	sts	0x2CBC, r24
    UIP_APPCALL();
    85f4:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    85f8:	e0 91 c1 2c 	lds	r30, 0x2CC1
    85fc:	f0 91 c2 2c 	lds	r31, 0x2CC2
    8600:	11 8e       	std	Z+25, r1	; 0x19
    goto reset;
    8602:	45 cd       	rjmp	.-1398   	; 0x808e <uip_process+0x58a>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    8604:	80 91 dd 27 	lds	r24, 0x27DD
    8608:	80 ff       	sbrs	r24, 0
    860a:	2a c0       	rjmp	.+84     	; 0x8660 <uip_process+0xb5c>
    860c:	24 fd       	sbrc	r18, 4
    860e:	28 c0       	rjmp	.+80     	; 0x8660 <uip_process+0xb5c>
      if(uip_outstanding(uip_connr)) {
    8610:	88 89       	ldd	r24, Y+16	; 0x10
    8612:	99 89       	ldd	r25, Y+17	; 0x11
    8614:	00 97       	sbiw	r24, 0x00	; 0
    8616:	09 f0       	breq	.+2      	; 0x861a <uip_process+0xb16>
    8618:	ca c1       	rjmp	.+916    	; 0x89ae <uip_process+0xeaa>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    861a:	80 91 b4 27 	lds	r24, 0x27B4
    861e:	90 91 b5 27 	lds	r25, 0x27B5
    8622:	01 96       	adiw	r24, 0x01	; 1
    8624:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    8628:	20 91 bc 2c 	lds	r18, 0x2CBC
    862c:	82 2f       	mov	r24, r18
    862e:	80 61       	ori	r24, 0x10	; 16
    8630:	80 93 bc 2c 	sts	0x2CBC, r24
      if(uip_len > 0) {
    8634:	80 91 b4 27 	lds	r24, 0x27B4
    8638:	90 91 b5 27 	lds	r25, 0x27B5
    863c:	00 97       	sbiw	r24, 0x00	; 0
    863e:	19 f0       	breq	.+6      	; 0x8646 <uip_process+0xb42>
	uip_flags |= UIP_NEWDATA;
    8640:	22 61       	ori	r18, 0x12	; 18
    8642:	20 93 bc 2c 	sts	0x2CBC, r18
      }
      UIP_APPCALL();
    8646:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>
      uip_connr->len = 1;
    864a:	81 e0       	ldi	r24, 0x01	; 1
    864c:	90 e0       	ldi	r25, 0x00	; 0
    864e:	99 8b       	std	Y+17, r25	; 0x11
    8650:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    8652:	88 e0       	ldi	r24, 0x08	; 8
    8654:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    8656:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    8658:	81 e1       	ldi	r24, 0x11	; 17
    865a:	80 93 dd 27 	sts	0x27DD, r24
      goto tcp_send_nodata;
    865e:	0f c1       	rjmp	.+542    	; 0x887e <uip_process+0xd7a>
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    8660:	85 ff       	sbrs	r24, 5
    8662:	1c c0       	rjmp	.+56     	; 0x869c <uip_process+0xb98>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    8664:	50 91 e2 27 	lds	r21, 0x27E2
    8668:	40 e0       	ldi	r20, 0x00	; 0
    866a:	80 91 e3 27 	lds	r24, 0x27E3
    866e:	90 e0       	ldi	r25, 0x00	; 0
    8670:	84 2b       	or	r24, r20
    8672:	95 2b       	or	r25, r21
    8674:	40 91 bf 2c 	lds	r20, 0x2CBF
    8678:	50 91 c0 2c 	lds	r21, 0x2CC0
    867c:	48 0f       	add	r20, r24
    867e:	59 1f       	adc	r21, r25
    8680:	50 93 c0 2c 	sts	0x2CC0, r21
    8684:	40 93 bf 2c 	sts	0x2CBF, r20
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    8688:	40 91 b4 27 	lds	r20, 0x27B4
    868c:	50 91 b5 27 	lds	r21, 0x27B5
    8690:	48 1b       	sub	r20, r24
    8692:	59 0b       	sbc	r21, r25
    8694:	50 93 b5 27 	sts	0x27B5, r21
    8698:	40 93 b4 27 	sts	0x27B4, r20
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    869c:	80 91 b4 27 	lds	r24, 0x27B4
    86a0:	90 91 b5 27 	lds	r25, 0x27B5
    86a4:	00 97       	sbiw	r24, 0x00	; 0
    86a6:	49 f0       	breq	.+18     	; 0x86ba <uip_process+0xbb6>
    86a8:	24 fd       	sbrc	r18, 4
    86aa:	07 c0       	rjmp	.+14     	; 0x86ba <uip_process+0xbb6>
      uip_flags |= UIP_NEWDATA;
    86ac:	20 91 bc 2c 	lds	r18, 0x2CBC
    86b0:	22 60       	ori	r18, 0x02	; 2
    86b2:	20 93 bc 2c 	sts	0x2CBC, r18
      uip_add_rcv_nxt(uip_len);
    86b6:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((uint16_t)BUF->wnd[0] << 8) + (uint16_t)BUF->wnd[1];
    86ba:	90 91 de 27 	lds	r25, 0x27DE
    86be:	80 e0       	ldi	r24, 0x00	; 0
    86c0:	20 91 df 27 	lds	r18, 0x27DF
    86c4:	82 0f       	add	r24, r18
    86c6:	91 1d       	adc	r25, r1
    86c8:	90 93 24 25 	sts	0x2524, r25
    86cc:	80 93 23 25 	sts	0x2523, r24
    if(tmp16 > uip_connr->initialmss ||
    86d0:	2c 89       	ldd	r18, Y+20	; 0x14
    86d2:	3d 89       	ldd	r19, Y+21	; 0x15
    86d4:	28 17       	cp	r18, r24
    86d6:	39 07       	cpc	r19, r25
    86d8:	10 f0       	brcs	.+4      	; 0x86de <uip_process+0xbda>
    86da:	00 97       	sbiw	r24, 0x00	; 0
    86dc:	21 f4       	brne	.+8      	; 0x86e6 <uip_process+0xbe2>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    86de:	30 93 24 25 	sts	0x2524, r19
    86e2:	20 93 23 25 	sts	0x2523, r18
    }
    uip_connr->mss = tmp16;
    86e6:	80 91 23 25 	lds	r24, 0x2523
    86ea:	90 91 24 25 	lds	r25, 0x2524
    86ee:	9b 8b       	std	Y+19, r25	; 0x13
    86f0:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    86f2:	80 91 bc 2c 	lds	r24, 0x2CBC
    86f6:	90 e0       	ldi	r25, 0x00	; 0
    86f8:	83 70       	andi	r24, 0x03	; 3
    86fa:	90 70       	andi	r25, 0x00	; 0
    86fc:	00 97       	sbiw	r24, 0x00	; 0
    86fe:	09 f4       	brne	.+2      	; 0x8702 <uip_process+0xbfe>
    8700:	56 c1       	rjmp	.+684    	; 0x89ae <uip_process+0xeaa>
      uip_slen = 0;
    8702:	10 92 58 2d 	sts	0x2D58, r1
    8706:	10 92 57 2d 	sts	0x2D57, r1
      UIP_APPCALL();
    870a:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    870e:	80 91 bc 2c 	lds	r24, 0x2CBC
    8712:	85 ff       	sbrs	r24, 5
    8714:	07 c0       	rjmp	.+14     	; 0x8724 <uip_process+0xc20>
	uip_slen = 0;
    8716:	10 92 58 2d 	sts	0x2D58, r1
    871a:	10 92 57 2d 	sts	0x2D57, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    871e:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    8720:	84 e1       	ldi	r24, 0x14	; 20
    8722:	9b cf       	rjmp	.-202    	; 0x865a <uip_process+0xb56>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    8724:	84 ff       	sbrs	r24, 4
    8726:	0a c0       	rjmp	.+20     	; 0x873c <uip_process+0xc38>
	uip_slen = 0;
    8728:	10 92 58 2d 	sts	0x2D58, r1
    872c:	10 92 57 2d 	sts	0x2D57, r1
	uip_connr->len = 1;
    8730:	81 e0       	ldi	r24, 0x01	; 1
    8732:	90 e0       	ldi	r25, 0x00	; 0
    8734:	99 8b       	std	Y+17, r25	; 0x11
    8736:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    8738:	84 e0       	ldi	r24, 0x04	; 4
    873a:	8c cf       	rjmp	.-232    	; 0x8654 <uip_process+0xb50>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    873c:	20 91 57 2d 	lds	r18, 0x2D57
    8740:	30 91 58 2d 	lds	r19, 0x2D58
    8744:	21 15       	cp	r18, r1
    8746:	31 05       	cpc	r19, r1
    8748:	e1 f0       	breq	.+56     	; 0x8782 <uip_process+0xc7e>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    874a:	80 ff       	sbrs	r24, 0
    874c:	02 c0       	rjmp	.+4      	; 0x8752 <uip_process+0xc4e>
	  uip_connr->len = 0;
    874e:	19 8a       	std	Y+17, r1	; 0x11
    8750:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    8752:	88 89       	ldd	r24, Y+16	; 0x10
    8754:	99 89       	ldd	r25, Y+17	; 0x11
    8756:	00 97       	sbiw	r24, 0x00	; 0
    8758:	81 f4       	brne	.+32     	; 0x877a <uip_process+0xc76>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    875a:	8a 89       	ldd	r24, Y+18	; 0x12
    875c:	9b 89       	ldd	r25, Y+19	; 0x13
    875e:	82 17       	cp	r24, r18
    8760:	93 07       	cpc	r25, r19
    8762:	20 f4       	brcc	.+8      	; 0x876c <uip_process+0xc68>
	    uip_slen = uip_connr->mss;
    8764:	90 93 58 2d 	sts	0x2D58, r25
    8768:	80 93 57 2d 	sts	0x2D57, r24
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    876c:	80 91 57 2d 	lds	r24, 0x2D57
    8770:	90 91 58 2d 	lds	r25, 0x2D58
    8774:	99 8b       	std	Y+17, r25	; 0x11
    8776:	88 8b       	std	Y+16, r24	; 0x10
    8778:	04 c0       	rjmp	.+8      	; 0x8782 <uip_process+0xc7e>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    877a:	90 93 58 2d 	sts	0x2D58, r25
    877e:	80 93 57 2d 	sts	0x2D57, r24
	}
      }
      uip_connr->nrtx = 0;
    8782:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    8784:	80 91 b6 27 	lds	r24, 0x27B6
    8788:	90 91 b7 27 	lds	r25, 0x27B7
    878c:	90 93 c0 2c 	sts	0x2CC0, r25
    8790:	80 93 bf 2c 	sts	0x2CBF, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    8794:	80 91 57 2d 	lds	r24, 0x2D57
    8798:	90 91 58 2d 	lds	r25, 0x2D58
    879c:	00 97       	sbiw	r24, 0x00	; 0
    879e:	59 f0       	breq	.+22     	; 0x87b6 <uip_process+0xcb2>
    87a0:	88 89       	ldd	r24, Y+16	; 0x10
    87a2:	99 89       	ldd	r25, Y+17	; 0x11
    87a4:	00 97       	sbiw	r24, 0x00	; 0
    87a6:	39 f0       	breq	.+14     	; 0x87b6 <uip_process+0xcb2>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    87a8:	88 96       	adiw	r24, 0x28	; 40
    87aa:	90 93 b5 27 	sts	0x27B5, r25
    87ae:	80 93 b4 27 	sts	0x27B4, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    87b2:	88 e1       	ldi	r24, 0x18	; 24
    87b4:	0b c0       	rjmp	.+22     	; 0x87cc <uip_process+0xcc8>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    87b6:	80 91 bc 2c 	lds	r24, 0x2CBC
    87ba:	81 ff       	sbrs	r24, 1
    87bc:	f8 c0       	rjmp	.+496    	; 0x89ae <uip_process+0xeaa>
	uip_len = UIP_TCPIP_HLEN;
    87be:	88 e2       	ldi	r24, 0x28	; 40
    87c0:	90 e0       	ldi	r25, 0x00	; 0
    87c2:	90 93 b5 27 	sts	0x27B5, r25
    87c6:	80 93 b4 27 	sts	0x27B4, r24
	BUF->flags = TCP_ACK;
    87ca:	80 e1       	ldi	r24, 0x10	; 16
    87cc:	80 93 dd 27 	sts	0x27DD, r24
	goto tcp_send_noopts;
    87d0:	5c c0       	rjmp	.+184    	; 0x888a <uip_process+0xd86>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    87d2:	80 91 bc 2c 	lds	r24, 0x2CBC
    87d6:	80 ff       	sbrs	r24, 0
    87d8:	ea c0       	rjmp	.+468    	; 0x89ae <uip_process+0xeaa>
      uip_connr->tcpstateflags = UIP_CLOSED;
    87da:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    87dc:	80 e1       	ldi	r24, 0x10	; 16
    87de:	80 93 bc 2c 	sts	0x2CBC, r24
      UIP_APPCALL();
    87e2:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>
    87e6:	e3 c0       	rjmp	.+454    	; 0x89ae <uip_process+0xeaa>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    87e8:	80 91 b4 27 	lds	r24, 0x27B4
    87ec:	90 91 b5 27 	lds	r25, 0x27B5
    87f0:	00 97       	sbiw	r24, 0x00	; 0
    87f2:	11 f0       	breq	.+4      	; 0x87f8 <uip_process+0xcf4>
      uip_add_rcv_nxt(uip_len);
    87f4:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    87f8:	90 91 dd 27 	lds	r25, 0x27DD
    87fc:	80 91 bc 2c 	lds	r24, 0x2CBC
    8800:	90 ff       	sbrs	r25, 0
    8802:	0b c0       	rjmp	.+22     	; 0x881a <uip_process+0xd16>
      if(uip_flags & UIP_ACKDATA) {
    8804:	80 ff       	sbrs	r24, 0
    8806:	06 c0       	rjmp	.+12     	; 0x8814 <uip_process+0xd10>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    8808:	87 e0       	ldi	r24, 0x07	; 7
    880a:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    880c:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    880e:	19 8a       	std	Y+17, r1	; 0x11
    8810:	18 8a       	std	Y+16, r1	; 0x10
    8812:	19 c0       	rjmp	.+50     	; 0x8846 <uip_process+0xd42>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    8814:	86 e0       	ldi	r24, 0x06	; 6
    8816:	89 8f       	std	Y+25, r24	; 0x19
    8818:	16 c0       	rjmp	.+44     	; 0x8846 <uip_process+0xd42>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    881a:	80 ff       	sbrs	r24, 0
    881c:	1e c0       	rjmp	.+60     	; 0x885a <uip_process+0xd56>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    881e:	85 e0       	ldi	r24, 0x05	; 5
    8820:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    8822:	19 8a       	std	Y+17, r1	; 0x11
    8824:	18 8a       	std	Y+16, r1	; 0x10
      goto drop;
    8826:	c3 c0       	rjmp	.+390    	; 0x89ae <uip_process+0xeaa>
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    8828:	80 91 b4 27 	lds	r24, 0x27B4
    882c:	90 91 b5 27 	lds	r25, 0x27B5
    8830:	00 97       	sbiw	r24, 0x00	; 0
    8832:	11 f0       	breq	.+4      	; 0x8838 <uip_process+0xd34>
      uip_add_rcv_nxt(uip_len);
    8834:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    8838:	80 91 dd 27 	lds	r24, 0x27DD
    883c:	80 ff       	sbrs	r24, 0
    883e:	0d c0       	rjmp	.+26     	; 0x885a <uip_process+0xd56>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    8840:	87 e0       	ldi	r24, 0x07	; 7
    8842:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    8844:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    8846:	81 e0       	ldi	r24, 0x01	; 1
    8848:	90 e0       	ldi	r25, 0x00	; 0
    884a:	0e 94 ca 3b 	call	0x7794	; 0x7794 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    884e:	80 e1       	ldi	r24, 0x10	; 16
    8850:	80 93 bc 2c 	sts	0x2CBC, r24
      UIP_APPCALL();
    8854:	0e 94 5a 36 	call	0x6cb4	; 0x6cb4 <tcpip_uipcall>
      goto tcp_send_ack;
    8858:	0f c0       	rjmp	.+30     	; 0x8878 <uip_process+0xd74>
    }
    if(uip_len > 0) {
    885a:	80 91 b4 27 	lds	r24, 0x27B4
    885e:	90 91 b5 27 	lds	r25, 0x27B5
    8862:	00 97       	sbiw	r24, 0x00	; 0
    8864:	49 f4       	brne	.+18     	; 0x8878 <uip_process+0xd74>
    8866:	a3 c0       	rjmp	.+326    	; 0x89ae <uip_process+0xeaa>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    8868:	80 91 bc 2c 	lds	r24, 0x2CBC
    886c:	80 ff       	sbrs	r24, 0
    886e:	9f c0       	rjmp	.+318    	; 0x89ae <uip_process+0xeaa>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    8870:	87 e0       	ldi	r24, 0x07	; 7
    8872:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    8874:	1a 8e       	std	Y+26, r1	; 0x1a
    8876:	9b c0       	rjmp	.+310    	; 0x89ae <uip_process+0xeaa>
  goto drop;
  
  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    8878:	80 e1       	ldi	r24, 0x10	; 16
    887a:	f8 01       	movw	r30, r16
    887c:	81 a3       	std	Z+33, r24	; 0x21
  
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    887e:	88 e2       	ldi	r24, 0x28	; 40
    8880:	90 e0       	ldi	r25, 0x00	; 0
    8882:	90 93 b5 27 	sts	0x27B5, r25
    8886:	80 93 b4 27 	sts	0x27B4, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    888a:	80 e5       	ldi	r24, 0x50	; 80
    888c:	80 93 dc 27 	sts	0x27DC, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    8890:	88 85       	ldd	r24, Y+8	; 0x08
    8892:	80 93 d8 27 	sts	0x27D8, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    8896:	89 85       	ldd	r24, Y+9	; 0x09
    8898:	80 93 d9 27 	sts	0x27D9, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    889c:	8a 85       	ldd	r24, Y+10	; 0x0a
    889e:	80 93 da 27 	sts	0x27DA, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    88a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    88a4:	80 93 db 27 	sts	0x27DB, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    88a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    88aa:	80 93 d4 27 	sts	0x27D4, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    88ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    88b0:	80 93 d5 27 	sts	0x27D5, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    88b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    88b6:	80 93 d6 27 	sts	0x27D6, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    88ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    88bc:	80 93 d7 27 	sts	0x27D7, r24

  BUF->proto = UIP_PROTO_TCP;
    88c0:	86 e0       	ldi	r24, 0x06	; 6
    88c2:	80 93 c5 27 	sts	0x27C5, r24
  
  BUF->srcport  = uip_connr->lport;
    88c6:	8c 81       	ldd	r24, Y+4	; 0x04
    88c8:	9d 81       	ldd	r25, Y+5	; 0x05
    88ca:	90 93 d1 27 	sts	0x27D1, r25
    88ce:	80 93 d0 27 	sts	0x27D0, r24
  BUF->destport = uip_connr->rport;
    88d2:	8e 81       	ldd	r24, Y+6	; 0x06
    88d4:	9f 81       	ldd	r25, Y+7	; 0x07
    88d6:	90 93 d3 27 	sts	0x27D3, r25
    88da:	80 93 d2 27 	sts	0x27D2, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    88de:	80 91 53 2d 	lds	r24, 0x2D53
    88e2:	90 91 54 2d 	lds	r25, 0x2D54
    88e6:	a0 91 55 2d 	lds	r26, 0x2D55
    88ea:	b0 91 56 2d 	lds	r27, 0x2D56
    88ee:	80 93 c8 27 	sts	0x27C8, r24
    88f2:	90 93 c9 27 	sts	0x27C9, r25
    88f6:	a0 93 ca 27 	sts	0x27CA, r26
    88fa:	b0 93 cb 27 	sts	0x27CB, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    88fe:	88 81       	ld	r24, Y
    8900:	99 81       	ldd	r25, Y+1	; 0x01
    8902:	aa 81       	ldd	r26, Y+2	; 0x02
    8904:	bb 81       	ldd	r27, Y+3	; 0x03
    8906:	80 93 cc 27 	sts	0x27CC, r24
    890a:	90 93 cd 27 	sts	0x27CD, r25
    890e:	a0 93 ce 27 	sts	0x27CE, r26
    8912:	b0 93 cf 27 	sts	0x27CF, r27

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    8916:	89 8d       	ldd	r24, Y+25	; 0x19
    8918:	84 ff       	sbrs	r24, 4
    891a:	05 c0       	rjmp	.+10     	; 0x8926 <uip_process+0xe22>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    891c:	10 92 df 27 	sts	0x27DF, r1
    8920:	10 92 de 27 	sts	0x27DE, r1
    8924:	06 c0       	rjmp	.+12     	; 0x8932 <uip_process+0xe2e>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    8926:	84 e0       	ldi	r24, 0x04	; 4
    8928:	80 93 de 27 	sts	0x27DE, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    892c:	88 ed       	ldi	r24, 0xD8	; 216
    892e:	80 93 df 27 	sts	0x27DF, r24
  }
  
 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    8932:	80 e4       	ldi	r24, 0x40	; 64
    8934:	80 93 c4 27 	sts	0x27C4, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    8938:	80 91 b4 27 	lds	r24, 0x27B4
    893c:	90 91 b5 27 	lds	r25, 0x27B5
    8940:	90 93 be 27 	sts	0x27BE, r25
  BUF->len[1] = (uip_len & 0xff);
    8944:	80 93 bf 27 	sts	0x27BF, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    8948:	10 92 e3 27 	sts	0x27E3, r1
    894c:	10 92 e2 27 	sts	0x27E2, r1
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    8950:	10 92 e1 27 	sts	0x27E1, r1
    8954:	10 92 e0 27 	sts	0x27E0, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    8958:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <uip_tcpchksum>
    895c:	80 95       	com	r24
    895e:	90 95       	com	r25
    8960:	90 93 e1 27 	sts	0x27E1, r25
    8964:	80 93 e0 27 	sts	0x27E0, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    8968:	85 e4       	ldi	r24, 0x45	; 69
    896a:	80 93 bc 27 	sts	0x27BC, r24
  BUF->tos = 0;
    896e:	10 92 bd 27 	sts	0x27BD, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    8972:	10 92 c3 27 	sts	0x27C3, r1
    8976:	10 92 c2 27 	sts	0x27C2, r1
  ++ipid;
    897a:	80 91 27 25 	lds	r24, 0x2527
    897e:	90 91 28 25 	lds	r25, 0x2528
    8982:	01 96       	adiw	r24, 0x01	; 1
    8984:	90 93 28 25 	sts	0x2528, r25
    8988:	80 93 27 25 	sts	0x2527, r24
  BUF->ipid[0] = ipid >> 8;
    898c:	90 93 c0 27 	sts	0x27C0, r25
  BUF->ipid[1] = ipid & 0xff;
    8990:	80 93 c1 27 	sts	0x27C1, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    8994:	10 92 c7 27 	sts	0x27C7, r1
    8998:	10 92 c6 27 	sts	0x27C6, r1
  BUF->ipchksum = ~(uip_ipchksum());
    899c:	0e 94 ee 3b 	call	0x77dc	; 0x77dc <uip_ipchksum>
    89a0:	80 95       	com	r24
    89a2:	90 95       	com	r25
    89a4:	90 93 c7 27 	sts	0x27C7, r25
    89a8:	80 93 c6 27 	sts	0x27C6, r24
    89ac:	04 c0       	rjmp	.+8      	; 0x89b6 <uip_process+0xeb2>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    89ae:	10 92 b5 27 	sts	0x27B5, r1
    89b2:	10 92 b4 27 	sts	0x27B4, r1
  uip_flags = 0;
    89b6:	10 92 bc 2c 	sts	0x2CBC, r1
  return;
}
    89ba:	df 91       	pop	r29
    89bc:	cf 91       	pop	r28
    89be:	1f 91       	pop	r17
    89c0:	0f 91       	pop	r16
    89c2:	ff 90       	pop	r15
    89c4:	ef 90       	pop	r14
    89c6:	08 95       	ret

000089c8 <uip_htons>:
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    89c8:	38 2f       	mov	r19, r24
    89ca:	29 2f       	mov	r18, r25
}
    89cc:	c9 01       	movw	r24, r18
    89ce:	08 95       	ret

000089d0 <uip_htonl>:

uint32_t
uip_htonl(uint32_t val)
{
  return UIP_HTONL(val);
    89d0:	38 2f       	mov	r19, r24
    89d2:	29 2f       	mov	r18, r25
    89d4:	40 e0       	ldi	r20, 0x00	; 0
    89d6:	50 e0       	ldi	r21, 0x00	; 0
    89d8:	76 27       	eor	r23, r22
    89da:	67 27       	eor	r22, r23
    89dc:	76 27       	eor	r23, r22
    89de:	80 e0       	ldi	r24, 0x00	; 0
    89e0:	90 e0       	ldi	r25, 0x00	; 0
    89e2:	cb 01       	movw	r24, r22
    89e4:	77 27       	eor	r23, r23
    89e6:	66 27       	eor	r22, r22
    89e8:	26 2b       	or	r18, r22
    89ea:	37 2b       	or	r19, r23
    89ec:	48 2b       	or	r20, r24
    89ee:	59 2b       	or	r21, r25
}
    89f0:	b9 01       	movw	r22, r18
    89f2:	ca 01       	movw	r24, r20
    89f4:	08 95       	ret

000089f6 <uip_send>:
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    89f6:	ac 01       	movw	r20, r24
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    89f8:	e0 91 b6 27 	lds	r30, 0x27B6
    89fc:	f0 91 b7 27 	lds	r31, 0x27B7
    8a00:	22 27       	eor	r18, r18
    8a02:	33 27       	eor	r19, r19
    8a04:	2e 1b       	sub	r18, r30
    8a06:	3f 0b       	sbc	r19, r31
    8a08:	24 54       	subi	r18, 0x44	; 68
    8a0a:	33 4d       	sbci	r19, 0xD3	; 211
    8a0c:	62 17       	cp	r22, r18
    8a0e:	73 07       	cpc	r23, r19
    8a10:	0c f4       	brge	.+2      	; 0x8a14 <uip_send+0x1e>
    8a12:	9b 01       	movw	r18, r22
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    8a14:	12 16       	cp	r1, r18
    8a16:	13 06       	cpc	r1, r19
    8a18:	64 f4       	brge	.+24     	; 0x8a32 <uip_send+0x3c>
    uip_slen = copylen;
    8a1a:	20 93 57 2d 	sts	0x2D57, r18
    8a1e:	30 93 58 2d 	sts	0x2D58, r19
    if(data != uip_sappdata) {
    8a22:	4e 17       	cp	r20, r30
    8a24:	5f 07       	cpc	r21, r31
    8a26:	29 f0       	breq	.+10     	; 0x8a32 <uip_send+0x3c>
      memcpy(uip_sappdata, (data), uip_slen);
    8a28:	cf 01       	movw	r24, r30
    8a2a:	ba 01       	movw	r22, r20
    8a2c:	a9 01       	movw	r20, r18
    8a2e:	0e 94 4d 4c 	call	0x989a	; 0x989a <memcpy>
    8a32:	08 95       	ret

00008a34 <__fixunssfsi>:
    8a34:	ef 92       	push	r14
    8a36:	ff 92       	push	r15
    8a38:	0f 93       	push	r16
    8a3a:	1f 93       	push	r17
    8a3c:	7b 01       	movw	r14, r22
    8a3e:	8c 01       	movw	r16, r24
    8a40:	20 e0       	ldi	r18, 0x00	; 0
    8a42:	30 e0       	ldi	r19, 0x00	; 0
    8a44:	40 e0       	ldi	r20, 0x00	; 0
    8a46:	5f e4       	ldi	r21, 0x4F	; 79
    8a48:	0e 94 96 48 	call	0x912c	; 0x912c <__gesf2>
    8a4c:	87 fd       	sbrc	r24, 7
    8a4e:	11 c0       	rjmp	.+34     	; 0x8a72 <__fixunssfsi+0x3e>
    8a50:	c8 01       	movw	r24, r16
    8a52:	b7 01       	movw	r22, r14
    8a54:	20 e0       	ldi	r18, 0x00	; 0
    8a56:	30 e0       	ldi	r19, 0x00	; 0
    8a58:	40 e0       	ldi	r20, 0x00	; 0
    8a5a:	5f e4       	ldi	r21, 0x4F	; 79
    8a5c:	0e 94 bd 46 	call	0x8d7a	; 0x8d7a <__subsf3>
    8a60:	0e 94 26 49 	call	0x924c	; 0x924c <__fixsfsi>
    8a64:	9b 01       	movw	r18, r22
    8a66:	ac 01       	movw	r20, r24
    8a68:	20 50       	subi	r18, 0x00	; 0
    8a6a:	30 40       	sbci	r19, 0x00	; 0
    8a6c:	40 40       	sbci	r20, 0x00	; 0
    8a6e:	50 48       	sbci	r21, 0x80	; 128
    8a70:	06 c0       	rjmp	.+12     	; 0x8a7e <__fixunssfsi+0x4a>
    8a72:	c8 01       	movw	r24, r16
    8a74:	b7 01       	movw	r22, r14
    8a76:	0e 94 26 49 	call	0x924c	; 0x924c <__fixsfsi>
    8a7a:	9b 01       	movw	r18, r22
    8a7c:	ac 01       	movw	r20, r24
    8a7e:	b9 01       	movw	r22, r18
    8a80:	ca 01       	movw	r24, r20
    8a82:	1f 91       	pop	r17
    8a84:	0f 91       	pop	r16
    8a86:	ff 90       	pop	r15
    8a88:	ef 90       	pop	r14
    8a8a:	08 95       	ret

00008a8c <_fpadd_parts>:
    8a8c:	a0 e0       	ldi	r26, 0x00	; 0
    8a8e:	b0 e0       	ldi	r27, 0x00	; 0
    8a90:	ec e4       	ldi	r30, 0x4C	; 76
    8a92:	f5 e4       	ldi	r31, 0x45	; 69
    8a94:	0c 94 af 4b 	jmp	0x975e	; 0x975e <__prologue_saves__+0x8>
    8a98:	fc 01       	movw	r30, r24
    8a9a:	ea 01       	movw	r28, r20
    8a9c:	80 81       	ld	r24, Z
    8a9e:	82 30       	cpi	r24, 0x02	; 2
    8aa0:	08 f4       	brcc	.+2      	; 0x8aa4 <_fpadd_parts+0x18>
    8aa2:	38 c1       	rjmp	.+624    	; 0x8d14 <_fpadd_parts+0x288>
    8aa4:	db 01       	movw	r26, r22
    8aa6:	9c 91       	ld	r25, X
    8aa8:	92 30       	cpi	r25, 0x02	; 2
    8aaa:	08 f4       	brcc	.+2      	; 0x8aae <_fpadd_parts+0x22>
    8aac:	30 c1       	rjmp	.+608    	; 0x8d0e <_fpadd_parts+0x282>
    8aae:	84 30       	cpi	r24, 0x04	; 4
    8ab0:	59 f4       	brne	.+22     	; 0x8ac8 <_fpadd_parts+0x3c>
    8ab2:	94 30       	cpi	r25, 0x04	; 4
    8ab4:	09 f0       	breq	.+2      	; 0x8ab8 <_fpadd_parts+0x2c>
    8ab6:	2e c1       	rjmp	.+604    	; 0x8d14 <_fpadd_parts+0x288>
    8ab8:	91 81       	ldd	r25, Z+1	; 0x01
    8aba:	11 96       	adiw	r26, 0x01	; 1
    8abc:	8c 91       	ld	r24, X
    8abe:	11 97       	sbiw	r26, 0x01	; 1
    8ac0:	98 17       	cp	r25, r24
    8ac2:	09 f0       	breq	.+2      	; 0x8ac6 <_fpadd_parts+0x3a>
    8ac4:	21 c1       	rjmp	.+578    	; 0x8d08 <_fpadd_parts+0x27c>
    8ac6:	26 c1       	rjmp	.+588    	; 0x8d14 <_fpadd_parts+0x288>
    8ac8:	94 30       	cpi	r25, 0x04	; 4
    8aca:	09 f4       	brne	.+2      	; 0x8ace <_fpadd_parts+0x42>
    8acc:	20 c1       	rjmp	.+576    	; 0x8d0e <_fpadd_parts+0x282>
    8ace:	92 30       	cpi	r25, 0x02	; 2
    8ad0:	b1 f4       	brne	.+44     	; 0x8afe <_fpadd_parts+0x72>
    8ad2:	82 30       	cpi	r24, 0x02	; 2
    8ad4:	09 f0       	breq	.+2      	; 0x8ad8 <_fpadd_parts+0x4c>
    8ad6:	1e c1       	rjmp	.+572    	; 0x8d14 <_fpadd_parts+0x288>
    8ad8:	ca 01       	movw	r24, r20
    8ada:	af 01       	movw	r20, r30
    8adc:	28 e0       	ldi	r18, 0x08	; 8
    8ade:	da 01       	movw	r26, r20
    8ae0:	0d 90       	ld	r0, X+
    8ae2:	ad 01       	movw	r20, r26
    8ae4:	dc 01       	movw	r26, r24
    8ae6:	0d 92       	st	X+, r0
    8ae8:	cd 01       	movw	r24, r26
    8aea:	21 50       	subi	r18, 0x01	; 1
    8aec:	c1 f7       	brne	.-16     	; 0x8ade <_fpadd_parts+0x52>
    8aee:	db 01       	movw	r26, r22
    8af0:	11 96       	adiw	r26, 0x01	; 1
    8af2:	8c 91       	ld	r24, X
    8af4:	11 97       	sbiw	r26, 0x01	; 1
    8af6:	91 81       	ldd	r25, Z+1	; 0x01
    8af8:	89 23       	and	r24, r25
    8afa:	89 83       	std	Y+1, r24	; 0x01
    8afc:	0a c1       	rjmp	.+532    	; 0x8d12 <_fpadd_parts+0x286>
    8afe:	82 30       	cpi	r24, 0x02	; 2
    8b00:	09 f4       	brne	.+2      	; 0x8b04 <_fpadd_parts+0x78>
    8b02:	05 c1       	rjmp	.+522    	; 0x8d0e <_fpadd_parts+0x282>
    8b04:	c2 80       	ldd	r12, Z+2	; 0x02
    8b06:	d3 80       	ldd	r13, Z+3	; 0x03
    8b08:	db 01       	movw	r26, r22
    8b0a:	12 96       	adiw	r26, 0x02	; 2
    8b0c:	6d 90       	ld	r6, X+
    8b0e:	7c 90       	ld	r7, X
    8b10:	13 97       	sbiw	r26, 0x03	; 3
    8b12:	24 81       	ldd	r18, Z+4	; 0x04
    8b14:	35 81       	ldd	r19, Z+5	; 0x05
    8b16:	46 81       	ldd	r20, Z+6	; 0x06
    8b18:	57 81       	ldd	r21, Z+7	; 0x07
    8b1a:	14 96       	adiw	r26, 0x04	; 4
    8b1c:	ed 90       	ld	r14, X+
    8b1e:	fd 90       	ld	r15, X+
    8b20:	0d 91       	ld	r16, X+
    8b22:	1c 91       	ld	r17, X
    8b24:	17 97       	sbiw	r26, 0x07	; 7
    8b26:	c6 01       	movw	r24, r12
    8b28:	86 19       	sub	r24, r6
    8b2a:	97 09       	sbc	r25, r7
    8b2c:	5c 01       	movw	r10, r24
    8b2e:	97 ff       	sbrs	r25, 7
    8b30:	04 c0       	rjmp	.+8      	; 0x8b3a <_fpadd_parts+0xae>
    8b32:	aa 24       	eor	r10, r10
    8b34:	bb 24       	eor	r11, r11
    8b36:	a8 1a       	sub	r10, r24
    8b38:	b9 0a       	sbc	r11, r25
    8b3a:	b0 e2       	ldi	r27, 0x20	; 32
    8b3c:	ab 16       	cp	r10, r27
    8b3e:	b1 04       	cpc	r11, r1
    8b40:	0c f0       	brlt	.+2      	; 0x8b44 <_fpadd_parts+0xb8>
    8b42:	61 c0       	rjmp	.+194    	; 0x8c06 <_fpadd_parts+0x17a>
    8b44:	18 16       	cp	r1, r24
    8b46:	19 06       	cpc	r1, r25
    8b48:	6c f5       	brge	.+90     	; 0x8ba4 <_fpadd_parts+0x118>
    8b4a:	37 01       	movw	r6, r14
    8b4c:	48 01       	movw	r8, r16
    8b4e:	0a 2c       	mov	r0, r10
    8b50:	04 c0       	rjmp	.+8      	; 0x8b5a <_fpadd_parts+0xce>
    8b52:	96 94       	lsr	r9
    8b54:	87 94       	ror	r8
    8b56:	77 94       	ror	r7
    8b58:	67 94       	ror	r6
    8b5a:	0a 94       	dec	r0
    8b5c:	d2 f7       	brpl	.-12     	; 0x8b52 <_fpadd_parts+0xc6>
    8b5e:	81 e0       	ldi	r24, 0x01	; 1
    8b60:	90 e0       	ldi	r25, 0x00	; 0
    8b62:	a0 e0       	ldi	r26, 0x00	; 0
    8b64:	b0 e0       	ldi	r27, 0x00	; 0
    8b66:	0a 2c       	mov	r0, r10
    8b68:	04 c0       	rjmp	.+8      	; 0x8b72 <_fpadd_parts+0xe6>
    8b6a:	88 0f       	add	r24, r24
    8b6c:	99 1f       	adc	r25, r25
    8b6e:	aa 1f       	adc	r26, r26
    8b70:	bb 1f       	adc	r27, r27
    8b72:	0a 94       	dec	r0
    8b74:	d2 f7       	brpl	.-12     	; 0x8b6a <_fpadd_parts+0xde>
    8b76:	01 97       	sbiw	r24, 0x01	; 1
    8b78:	a1 09       	sbc	r26, r1
    8b7a:	b1 09       	sbc	r27, r1
    8b7c:	8e 21       	and	r24, r14
    8b7e:	9f 21       	and	r25, r15
    8b80:	a0 23       	and	r26, r16
    8b82:	b1 23       	and	r27, r17
    8b84:	ee 24       	eor	r14, r14
    8b86:	ff 24       	eor	r15, r15
    8b88:	87 01       	movw	r16, r14
    8b8a:	e3 94       	inc	r14
    8b8c:	00 97       	sbiw	r24, 0x00	; 0
    8b8e:	a1 05       	cpc	r26, r1
    8b90:	b1 05       	cpc	r27, r1
    8b92:	19 f4       	brne	.+6      	; 0x8b9a <_fpadd_parts+0x10e>
    8b94:	ee 24       	eor	r14, r14
    8b96:	ff 24       	eor	r15, r15
    8b98:	87 01       	movw	r16, r14
    8b9a:	e6 28       	or	r14, r6
    8b9c:	f7 28       	or	r15, r7
    8b9e:	08 29       	or	r16, r8
    8ba0:	19 29       	or	r17, r9
    8ba2:	3c c0       	rjmp	.+120    	; 0x8c1c <_fpadd_parts+0x190>
    8ba4:	00 97       	sbiw	r24, 0x00	; 0
    8ba6:	d1 f1       	breq	.+116    	; 0x8c1c <_fpadd_parts+0x190>
    8ba8:	ca 0c       	add	r12, r10
    8baa:	db 1c       	adc	r13, r11
    8bac:	39 01       	movw	r6, r18
    8bae:	4a 01       	movw	r8, r20
    8bb0:	0a 2c       	mov	r0, r10
    8bb2:	04 c0       	rjmp	.+8      	; 0x8bbc <_fpadd_parts+0x130>
    8bb4:	96 94       	lsr	r9
    8bb6:	87 94       	ror	r8
    8bb8:	77 94       	ror	r7
    8bba:	67 94       	ror	r6
    8bbc:	0a 94       	dec	r0
    8bbe:	d2 f7       	brpl	.-12     	; 0x8bb4 <_fpadd_parts+0x128>
    8bc0:	81 e0       	ldi	r24, 0x01	; 1
    8bc2:	90 e0       	ldi	r25, 0x00	; 0
    8bc4:	a0 e0       	ldi	r26, 0x00	; 0
    8bc6:	b0 e0       	ldi	r27, 0x00	; 0
    8bc8:	0a 2c       	mov	r0, r10
    8bca:	04 c0       	rjmp	.+8      	; 0x8bd4 <_fpadd_parts+0x148>
    8bcc:	88 0f       	add	r24, r24
    8bce:	99 1f       	adc	r25, r25
    8bd0:	aa 1f       	adc	r26, r26
    8bd2:	bb 1f       	adc	r27, r27
    8bd4:	0a 94       	dec	r0
    8bd6:	d2 f7       	brpl	.-12     	; 0x8bcc <_fpadd_parts+0x140>
    8bd8:	01 97       	sbiw	r24, 0x01	; 1
    8bda:	a1 09       	sbc	r26, r1
    8bdc:	b1 09       	sbc	r27, r1
    8bde:	82 23       	and	r24, r18
    8be0:	93 23       	and	r25, r19
    8be2:	a4 23       	and	r26, r20
    8be4:	b5 23       	and	r27, r21
    8be6:	21 e0       	ldi	r18, 0x01	; 1
    8be8:	30 e0       	ldi	r19, 0x00	; 0
    8bea:	40 e0       	ldi	r20, 0x00	; 0
    8bec:	50 e0       	ldi	r21, 0x00	; 0
    8bee:	00 97       	sbiw	r24, 0x00	; 0
    8bf0:	a1 05       	cpc	r26, r1
    8bf2:	b1 05       	cpc	r27, r1
    8bf4:	19 f4       	brne	.+6      	; 0x8bfc <_fpadd_parts+0x170>
    8bf6:	20 e0       	ldi	r18, 0x00	; 0
    8bf8:	30 e0       	ldi	r19, 0x00	; 0
    8bfa:	a9 01       	movw	r20, r18
    8bfc:	26 29       	or	r18, r6
    8bfe:	37 29       	or	r19, r7
    8c00:	48 29       	or	r20, r8
    8c02:	59 29       	or	r21, r9
    8c04:	0b c0       	rjmp	.+22     	; 0x8c1c <_fpadd_parts+0x190>
    8c06:	6c 14       	cp	r6, r12
    8c08:	7d 04       	cpc	r7, r13
    8c0a:	24 f4       	brge	.+8      	; 0x8c14 <_fpadd_parts+0x188>
    8c0c:	ee 24       	eor	r14, r14
    8c0e:	ff 24       	eor	r15, r15
    8c10:	87 01       	movw	r16, r14
    8c12:	04 c0       	rjmp	.+8      	; 0x8c1c <_fpadd_parts+0x190>
    8c14:	63 01       	movw	r12, r6
    8c16:	20 e0       	ldi	r18, 0x00	; 0
    8c18:	30 e0       	ldi	r19, 0x00	; 0
    8c1a:	a9 01       	movw	r20, r18
    8c1c:	81 81       	ldd	r24, Z+1	; 0x01
    8c1e:	fb 01       	movw	r30, r22
    8c20:	91 81       	ldd	r25, Z+1	; 0x01
    8c22:	89 17       	cp	r24, r25
    8c24:	09 f4       	brne	.+2      	; 0x8c28 <_fpadd_parts+0x19c>
    8c26:	45 c0       	rjmp	.+138    	; 0x8cb2 <_fpadd_parts+0x226>
    8c28:	88 23       	and	r24, r24
    8c2a:	49 f0       	breq	.+18     	; 0x8c3e <_fpadd_parts+0x1b2>
    8c2c:	d8 01       	movw	r26, r16
    8c2e:	c7 01       	movw	r24, r14
    8c30:	82 1b       	sub	r24, r18
    8c32:	93 0b       	sbc	r25, r19
    8c34:	a4 0b       	sbc	r26, r20
    8c36:	b5 0b       	sbc	r27, r21
    8c38:	9c 01       	movw	r18, r24
    8c3a:	ad 01       	movw	r20, r26
    8c3c:	04 c0       	rjmp	.+8      	; 0x8c46 <_fpadd_parts+0x1ba>
    8c3e:	2e 19       	sub	r18, r14
    8c40:	3f 09       	sbc	r19, r15
    8c42:	40 0b       	sbc	r20, r16
    8c44:	51 0b       	sbc	r21, r17
    8c46:	57 fd       	sbrc	r21, 7
    8c48:	04 c0       	rjmp	.+8      	; 0x8c52 <_fpadd_parts+0x1c6>
    8c4a:	19 82       	std	Y+1, r1	; 0x01
    8c4c:	db 82       	std	Y+3, r13	; 0x03
    8c4e:	ca 82       	std	Y+2, r12	; 0x02
    8c50:	0b c0       	rjmp	.+22     	; 0x8c68 <_fpadd_parts+0x1dc>
    8c52:	81 e0       	ldi	r24, 0x01	; 1
    8c54:	89 83       	std	Y+1, r24	; 0x01
    8c56:	db 82       	std	Y+3, r13	; 0x03
    8c58:	ca 82       	std	Y+2, r12	; 0x02
    8c5a:	50 95       	com	r21
    8c5c:	40 95       	com	r20
    8c5e:	30 95       	com	r19
    8c60:	21 95       	neg	r18
    8c62:	3f 4f       	sbci	r19, 0xFF	; 255
    8c64:	4f 4f       	sbci	r20, 0xFF	; 255
    8c66:	5f 4f       	sbci	r21, 0xFF	; 255
    8c68:	2c 83       	std	Y+4, r18	; 0x04
    8c6a:	3d 83       	std	Y+5, r19	; 0x05
    8c6c:	4e 83       	std	Y+6, r20	; 0x06
    8c6e:	5f 83       	std	Y+7, r21	; 0x07
    8c70:	0d c0       	rjmp	.+26     	; 0x8c8c <_fpadd_parts+0x200>
    8c72:	88 0f       	add	r24, r24
    8c74:	99 1f       	adc	r25, r25
    8c76:	aa 1f       	adc	r26, r26
    8c78:	bb 1f       	adc	r27, r27
    8c7a:	8c 83       	std	Y+4, r24	; 0x04
    8c7c:	9d 83       	std	Y+5, r25	; 0x05
    8c7e:	ae 83       	std	Y+6, r26	; 0x06
    8c80:	bf 83       	std	Y+7, r27	; 0x07
    8c82:	8a 81       	ldd	r24, Y+2	; 0x02
    8c84:	9b 81       	ldd	r25, Y+3	; 0x03
    8c86:	01 97       	sbiw	r24, 0x01	; 1
    8c88:	9b 83       	std	Y+3, r25	; 0x03
    8c8a:	8a 83       	std	Y+2, r24	; 0x02
    8c8c:	8c 81       	ldd	r24, Y+4	; 0x04
    8c8e:	9d 81       	ldd	r25, Y+5	; 0x05
    8c90:	ae 81       	ldd	r26, Y+6	; 0x06
    8c92:	bf 81       	ldd	r27, Y+7	; 0x07
    8c94:	9c 01       	movw	r18, r24
    8c96:	ad 01       	movw	r20, r26
    8c98:	21 50       	subi	r18, 0x01	; 1
    8c9a:	30 40       	sbci	r19, 0x00	; 0
    8c9c:	40 40       	sbci	r20, 0x00	; 0
    8c9e:	50 40       	sbci	r21, 0x00	; 0
    8ca0:	2f 3f       	cpi	r18, 0xFF	; 255
    8ca2:	ef ef       	ldi	r30, 0xFF	; 255
    8ca4:	3e 07       	cpc	r19, r30
    8ca6:	ef ef       	ldi	r30, 0xFF	; 255
    8ca8:	4e 07       	cpc	r20, r30
    8caa:	ef e3       	ldi	r30, 0x3F	; 63
    8cac:	5e 07       	cpc	r21, r30
    8cae:	08 f3       	brcs	.-62     	; 0x8c72 <_fpadd_parts+0x1e6>
    8cb0:	0b c0       	rjmp	.+22     	; 0x8cc8 <_fpadd_parts+0x23c>
    8cb2:	89 83       	std	Y+1, r24	; 0x01
    8cb4:	db 82       	std	Y+3, r13	; 0x03
    8cb6:	ca 82       	std	Y+2, r12	; 0x02
    8cb8:	2e 0d       	add	r18, r14
    8cba:	3f 1d       	adc	r19, r15
    8cbc:	40 1f       	adc	r20, r16
    8cbe:	51 1f       	adc	r21, r17
    8cc0:	2c 83       	std	Y+4, r18	; 0x04
    8cc2:	3d 83       	std	Y+5, r19	; 0x05
    8cc4:	4e 83       	std	Y+6, r20	; 0x06
    8cc6:	5f 83       	std	Y+7, r21	; 0x07
    8cc8:	83 e0       	ldi	r24, 0x03	; 3
    8cca:	88 83       	st	Y, r24
    8ccc:	2c 81       	ldd	r18, Y+4	; 0x04
    8cce:	3d 81       	ldd	r19, Y+5	; 0x05
    8cd0:	4e 81       	ldd	r20, Y+6	; 0x06
    8cd2:	5f 81       	ldd	r21, Y+7	; 0x07
    8cd4:	57 ff       	sbrs	r21, 7
    8cd6:	1d c0       	rjmp	.+58     	; 0x8d12 <_fpadd_parts+0x286>
    8cd8:	da 01       	movw	r26, r20
    8cda:	c9 01       	movw	r24, r18
    8cdc:	81 70       	andi	r24, 0x01	; 1
    8cde:	90 70       	andi	r25, 0x00	; 0
    8ce0:	a0 70       	andi	r26, 0x00	; 0
    8ce2:	b0 70       	andi	r27, 0x00	; 0
    8ce4:	56 95       	lsr	r21
    8ce6:	47 95       	ror	r20
    8ce8:	37 95       	ror	r19
    8cea:	27 95       	ror	r18
    8cec:	82 2b       	or	r24, r18
    8cee:	93 2b       	or	r25, r19
    8cf0:	a4 2b       	or	r26, r20
    8cf2:	b5 2b       	or	r27, r21
    8cf4:	8c 83       	std	Y+4, r24	; 0x04
    8cf6:	9d 83       	std	Y+5, r25	; 0x05
    8cf8:	ae 83       	std	Y+6, r26	; 0x06
    8cfa:	bf 83       	std	Y+7, r27	; 0x07
    8cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    8cfe:	9b 81       	ldd	r25, Y+3	; 0x03
    8d00:	01 96       	adiw	r24, 0x01	; 1
    8d02:	9b 83       	std	Y+3, r25	; 0x03
    8d04:	8a 83       	std	Y+2, r24	; 0x02
    8d06:	05 c0       	rjmp	.+10     	; 0x8d12 <_fpadd_parts+0x286>
    8d08:	ed ec       	ldi	r30, 0xCD	; 205
    8d0a:	fe e0       	ldi	r31, 0x0E	; 14
    8d0c:	03 c0       	rjmp	.+6      	; 0x8d14 <_fpadd_parts+0x288>
    8d0e:	fb 01       	movw	r30, r22
    8d10:	01 c0       	rjmp	.+2      	; 0x8d14 <_fpadd_parts+0x288>
    8d12:	fe 01       	movw	r30, r28
    8d14:	cf 01       	movw	r24, r30
    8d16:	cd b7       	in	r28, 0x3d	; 61
    8d18:	de b7       	in	r29, 0x3e	; 62
    8d1a:	ee e0       	ldi	r30, 0x0E	; 14
    8d1c:	0c 94 cb 4b 	jmp	0x9796	; 0x9796 <__epilogue_restores__+0x8>

00008d20 <__addsf3>:
    8d20:	a0 e2       	ldi	r26, 0x20	; 32
    8d22:	b0 e0       	ldi	r27, 0x00	; 0
    8d24:	e6 e9       	ldi	r30, 0x96	; 150
    8d26:	f6 e4       	ldi	r31, 0x46	; 70
    8d28:	0c 94 b7 4b 	jmp	0x976e	; 0x976e <__prologue_saves__+0x18>
    8d2c:	69 83       	std	Y+1, r22	; 0x01
    8d2e:	7a 83       	std	Y+2, r23	; 0x02
    8d30:	8b 83       	std	Y+3, r24	; 0x03
    8d32:	9c 83       	std	Y+4, r25	; 0x04
    8d34:	2d 83       	std	Y+5, r18	; 0x05
    8d36:	3e 83       	std	Y+6, r19	; 0x06
    8d38:	4f 83       	std	Y+7, r20	; 0x07
    8d3a:	58 87       	std	Y+8, r21	; 0x08
    8d3c:	89 e0       	ldi	r24, 0x09	; 9
    8d3e:	e8 2e       	mov	r14, r24
    8d40:	f1 2c       	mov	r15, r1
    8d42:	ec 0e       	add	r14, r28
    8d44:	fd 1e       	adc	r15, r29
    8d46:	ce 01       	movw	r24, r28
    8d48:	01 96       	adiw	r24, 0x01	; 1
    8d4a:	b7 01       	movw	r22, r14
    8d4c:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8d50:	8e 01       	movw	r16, r28
    8d52:	0f 5e       	subi	r16, 0xEF	; 239
    8d54:	1f 4f       	sbci	r17, 0xFF	; 255
    8d56:	ce 01       	movw	r24, r28
    8d58:	05 96       	adiw	r24, 0x05	; 5
    8d5a:	b8 01       	movw	r22, r16
    8d5c:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8d60:	c7 01       	movw	r24, r14
    8d62:	b8 01       	movw	r22, r16
    8d64:	ae 01       	movw	r20, r28
    8d66:	47 5e       	subi	r20, 0xE7	; 231
    8d68:	5f 4f       	sbci	r21, 0xFF	; 255
    8d6a:	0e 94 46 45 	call	0x8a8c	; 0x8a8c <_fpadd_parts>
    8d6e:	0e 94 d2 49 	call	0x93a4	; 0x93a4 <__pack_f>
    8d72:	a0 96       	adiw	r28, 0x20	; 32
    8d74:	e6 e0       	ldi	r30, 0x06	; 6
    8d76:	0c 94 d3 4b 	jmp	0x97a6	; 0x97a6 <__epilogue_restores__+0x18>

00008d7a <__subsf3>:
    8d7a:	a0 e2       	ldi	r26, 0x20	; 32
    8d7c:	b0 e0       	ldi	r27, 0x00	; 0
    8d7e:	e3 ec       	ldi	r30, 0xC3	; 195
    8d80:	f6 e4       	ldi	r31, 0x46	; 70
    8d82:	0c 94 b7 4b 	jmp	0x976e	; 0x976e <__prologue_saves__+0x18>
    8d86:	69 83       	std	Y+1, r22	; 0x01
    8d88:	7a 83       	std	Y+2, r23	; 0x02
    8d8a:	8b 83       	std	Y+3, r24	; 0x03
    8d8c:	9c 83       	std	Y+4, r25	; 0x04
    8d8e:	2d 83       	std	Y+5, r18	; 0x05
    8d90:	3e 83       	std	Y+6, r19	; 0x06
    8d92:	4f 83       	std	Y+7, r20	; 0x07
    8d94:	58 87       	std	Y+8, r21	; 0x08
    8d96:	8e 01       	movw	r16, r28
    8d98:	07 5f       	subi	r16, 0xF7	; 247
    8d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    8d9c:	ce 01       	movw	r24, r28
    8d9e:	01 96       	adiw	r24, 0x01	; 1
    8da0:	b8 01       	movw	r22, r16
    8da2:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8da6:	91 e1       	ldi	r25, 0x11	; 17
    8da8:	e9 2e       	mov	r14, r25
    8daa:	f1 2c       	mov	r15, r1
    8dac:	ec 0e       	add	r14, r28
    8dae:	fd 1e       	adc	r15, r29
    8db0:	ce 01       	movw	r24, r28
    8db2:	05 96       	adiw	r24, 0x05	; 5
    8db4:	b7 01       	movw	r22, r14
    8db6:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8dba:	8a 89       	ldd	r24, Y+18	; 0x12
    8dbc:	91 e0       	ldi	r25, 0x01	; 1
    8dbe:	89 27       	eor	r24, r25
    8dc0:	8a 8b       	std	Y+18, r24	; 0x12
    8dc2:	c8 01       	movw	r24, r16
    8dc4:	b7 01       	movw	r22, r14
    8dc6:	ae 01       	movw	r20, r28
    8dc8:	47 5e       	subi	r20, 0xE7	; 231
    8dca:	5f 4f       	sbci	r21, 0xFF	; 255
    8dcc:	0e 94 46 45 	call	0x8a8c	; 0x8a8c <_fpadd_parts>
    8dd0:	0e 94 d2 49 	call	0x93a4	; 0x93a4 <__pack_f>
    8dd4:	a0 96       	adiw	r28, 0x20	; 32
    8dd6:	e6 e0       	ldi	r30, 0x06	; 6
    8dd8:	0c 94 d3 4b 	jmp	0x97a6	; 0x97a6 <__epilogue_restores__+0x18>

00008ddc <__mulsf3>:
    8ddc:	a0 e2       	ldi	r26, 0x20	; 32
    8dde:	b0 e0       	ldi	r27, 0x00	; 0
    8de0:	e4 ef       	ldi	r30, 0xF4	; 244
    8de2:	f6 e4       	ldi	r31, 0x46	; 70
    8de4:	0c 94 ab 4b 	jmp	0x9756	; 0x9756 <__prologue_saves__>
    8de8:	69 83       	std	Y+1, r22	; 0x01
    8dea:	7a 83       	std	Y+2, r23	; 0x02
    8dec:	8b 83       	std	Y+3, r24	; 0x03
    8dee:	9c 83       	std	Y+4, r25	; 0x04
    8df0:	2d 83       	std	Y+5, r18	; 0x05
    8df2:	3e 83       	std	Y+6, r19	; 0x06
    8df4:	4f 83       	std	Y+7, r20	; 0x07
    8df6:	58 87       	std	Y+8, r21	; 0x08
    8df8:	ce 01       	movw	r24, r28
    8dfa:	01 96       	adiw	r24, 0x01	; 1
    8dfc:	be 01       	movw	r22, r28
    8dfe:	67 5f       	subi	r22, 0xF7	; 247
    8e00:	7f 4f       	sbci	r23, 0xFF	; 255
    8e02:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8e06:	ce 01       	movw	r24, r28
    8e08:	05 96       	adiw	r24, 0x05	; 5
    8e0a:	be 01       	movw	r22, r28
    8e0c:	6f 5e       	subi	r22, 0xEF	; 239
    8e0e:	7f 4f       	sbci	r23, 0xFF	; 255
    8e10:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8e14:	99 85       	ldd	r25, Y+9	; 0x09
    8e16:	92 30       	cpi	r25, 0x02	; 2
    8e18:	78 f0       	brcs	.+30     	; 0x8e38 <__mulsf3+0x5c>
    8e1a:	89 89       	ldd	r24, Y+17	; 0x11
    8e1c:	82 30       	cpi	r24, 0x02	; 2
    8e1e:	c0 f0       	brcs	.+48     	; 0x8e50 <__mulsf3+0x74>
    8e20:	94 30       	cpi	r25, 0x04	; 4
    8e22:	19 f4       	brne	.+6      	; 0x8e2a <__mulsf3+0x4e>
    8e24:	82 30       	cpi	r24, 0x02	; 2
    8e26:	41 f4       	brne	.+16     	; 0x8e38 <__mulsf3+0x5c>
    8e28:	cb c0       	rjmp	.+406    	; 0x8fc0 <__mulsf3+0x1e4>
    8e2a:	84 30       	cpi	r24, 0x04	; 4
    8e2c:	19 f4       	brne	.+6      	; 0x8e34 <__mulsf3+0x58>
    8e2e:	92 30       	cpi	r25, 0x02	; 2
    8e30:	79 f4       	brne	.+30     	; 0x8e50 <__mulsf3+0x74>
    8e32:	c6 c0       	rjmp	.+396    	; 0x8fc0 <__mulsf3+0x1e4>
    8e34:	92 30       	cpi	r25, 0x02	; 2
    8e36:	51 f4       	brne	.+20     	; 0x8e4c <__mulsf3+0x70>
    8e38:	81 e0       	ldi	r24, 0x01	; 1
    8e3a:	2a 85       	ldd	r18, Y+10	; 0x0a
    8e3c:	9a 89       	ldd	r25, Y+18	; 0x12
    8e3e:	29 17       	cp	r18, r25
    8e40:	09 f4       	brne	.+2      	; 0x8e44 <__mulsf3+0x68>
    8e42:	80 e0       	ldi	r24, 0x00	; 0
    8e44:	8a 87       	std	Y+10, r24	; 0x0a
    8e46:	ce 01       	movw	r24, r28
    8e48:	09 96       	adiw	r24, 0x09	; 9
    8e4a:	bc c0       	rjmp	.+376    	; 0x8fc4 <__mulsf3+0x1e8>
    8e4c:	82 30       	cpi	r24, 0x02	; 2
    8e4e:	51 f4       	brne	.+20     	; 0x8e64 <__mulsf3+0x88>
    8e50:	81 e0       	ldi	r24, 0x01	; 1
    8e52:	2a 85       	ldd	r18, Y+10	; 0x0a
    8e54:	9a 89       	ldd	r25, Y+18	; 0x12
    8e56:	29 17       	cp	r18, r25
    8e58:	09 f4       	brne	.+2      	; 0x8e5c <__mulsf3+0x80>
    8e5a:	80 e0       	ldi	r24, 0x00	; 0
    8e5c:	8a 8b       	std	Y+18, r24	; 0x12
    8e5e:	ce 01       	movw	r24, r28
    8e60:	41 96       	adiw	r24, 0x11	; 17
    8e62:	b0 c0       	rjmp	.+352    	; 0x8fc4 <__mulsf3+0x1e8>
    8e64:	6d 84       	ldd	r6, Y+13	; 0x0d
    8e66:	7e 84       	ldd	r7, Y+14	; 0x0e
    8e68:	8f 84       	ldd	r8, Y+15	; 0x0f
    8e6a:	98 88       	ldd	r9, Y+16	; 0x10
    8e6c:	ed 88       	ldd	r14, Y+21	; 0x15
    8e6e:	fe 88       	ldd	r15, Y+22	; 0x16
    8e70:	0f 89       	ldd	r16, Y+23	; 0x17
    8e72:	18 8d       	ldd	r17, Y+24	; 0x18
    8e74:	e0 e2       	ldi	r30, 0x20	; 32
    8e76:	f0 e0       	ldi	r31, 0x00	; 0
    8e78:	80 e0       	ldi	r24, 0x00	; 0
    8e7a:	90 e0       	ldi	r25, 0x00	; 0
    8e7c:	dc 01       	movw	r26, r24
    8e7e:	aa 24       	eor	r10, r10
    8e80:	bb 24       	eor	r11, r11
    8e82:	65 01       	movw	r12, r10
    8e84:	20 e0       	ldi	r18, 0x00	; 0
    8e86:	30 e0       	ldi	r19, 0x00	; 0
    8e88:	a9 01       	movw	r20, r18
    8e8a:	b3 01       	movw	r22, r6
    8e8c:	61 70       	andi	r22, 0x01	; 1
    8e8e:	70 70       	andi	r23, 0x00	; 0
    8e90:	61 15       	cp	r22, r1
    8e92:	71 05       	cpc	r23, r1
    8e94:	d1 f0       	breq	.+52     	; 0x8eca <__mulsf3+0xee>
    8e96:	2e 0d       	add	r18, r14
    8e98:	3f 1d       	adc	r19, r15
    8e9a:	40 1f       	adc	r20, r16
    8e9c:	51 1f       	adc	r21, r17
    8e9e:	15 01       	movw	r2, r10
    8ea0:	26 01       	movw	r4, r12
    8ea2:	28 0e       	add	r2, r24
    8ea4:	39 1e       	adc	r3, r25
    8ea6:	4a 1e       	adc	r4, r26
    8ea8:	5b 1e       	adc	r5, r27
    8eaa:	81 e0       	ldi	r24, 0x01	; 1
    8eac:	90 e0       	ldi	r25, 0x00	; 0
    8eae:	a0 e0       	ldi	r26, 0x00	; 0
    8eb0:	b0 e0       	ldi	r27, 0x00	; 0
    8eb2:	2e 15       	cp	r18, r14
    8eb4:	3f 05       	cpc	r19, r15
    8eb6:	40 07       	cpc	r20, r16
    8eb8:	51 07       	cpc	r21, r17
    8eba:	18 f0       	brcs	.+6      	; 0x8ec2 <__mulsf3+0xe6>
    8ebc:	80 e0       	ldi	r24, 0x00	; 0
    8ebe:	90 e0       	ldi	r25, 0x00	; 0
    8ec0:	dc 01       	movw	r26, r24
    8ec2:	82 0d       	add	r24, r2
    8ec4:	93 1d       	adc	r25, r3
    8ec6:	a4 1d       	adc	r26, r4
    8ec8:	b5 1d       	adc	r27, r5
    8eca:	aa 0c       	add	r10, r10
    8ecc:	bb 1c       	adc	r11, r11
    8ece:	cc 1c       	adc	r12, r12
    8ed0:	dd 1c       	adc	r13, r13
    8ed2:	17 ff       	sbrs	r17, 7
    8ed4:	09 c0       	rjmp	.+18     	; 0x8ee8 <__mulsf3+0x10c>
    8ed6:	61 e0       	ldi	r22, 0x01	; 1
    8ed8:	26 2e       	mov	r2, r22
    8eda:	31 2c       	mov	r3, r1
    8edc:	41 2c       	mov	r4, r1
    8ede:	51 2c       	mov	r5, r1
    8ee0:	a2 28       	or	r10, r2
    8ee2:	b3 28       	or	r11, r3
    8ee4:	c4 28       	or	r12, r4
    8ee6:	d5 28       	or	r13, r5
    8ee8:	31 97       	sbiw	r30, 0x01	; 1
    8eea:	49 f0       	breq	.+18     	; 0x8efe <__mulsf3+0x122>
    8eec:	ee 0c       	add	r14, r14
    8eee:	ff 1c       	adc	r15, r15
    8ef0:	00 1f       	adc	r16, r16
    8ef2:	11 1f       	adc	r17, r17
    8ef4:	96 94       	lsr	r9
    8ef6:	87 94       	ror	r8
    8ef8:	77 94       	ror	r7
    8efa:	67 94       	ror	r6
    8efc:	c6 cf       	rjmp	.-116    	; 0x8e8a <__mulsf3+0xae>
    8efe:	6b 89       	ldd	r22, Y+19	; 0x13
    8f00:	7c 89       	ldd	r23, Y+20	; 0x14
    8f02:	eb 85       	ldd	r30, Y+11	; 0x0b
    8f04:	fc 85       	ldd	r31, Y+12	; 0x0c
    8f06:	6e 0f       	add	r22, r30
    8f08:	7f 1f       	adc	r23, r31
    8f0a:	6e 5f       	subi	r22, 0xFE	; 254
    8f0c:	7f 4f       	sbci	r23, 0xFF	; 255
    8f0e:	7c 8f       	std	Y+28, r23	; 0x1c
    8f10:	6b 8f       	std	Y+27, r22	; 0x1b
    8f12:	61 e0       	ldi	r22, 0x01	; 1
    8f14:	ea 85       	ldd	r30, Y+10	; 0x0a
    8f16:	7a 89       	ldd	r23, Y+18	; 0x12
    8f18:	e7 17       	cp	r30, r23
    8f1a:	09 f4       	brne	.+2      	; 0x8f1e <__mulsf3+0x142>
    8f1c:	60 e0       	ldi	r22, 0x00	; 0
    8f1e:	6a 8f       	std	Y+26, r22	; 0x1a
    8f20:	6b 8d       	ldd	r22, Y+27	; 0x1b
    8f22:	7c 8d       	ldd	r23, Y+28	; 0x1c
    8f24:	10 c0       	rjmp	.+32     	; 0x8f46 <__mulsf3+0x16a>
    8f26:	fc 01       	movw	r30, r24
    8f28:	e1 70       	andi	r30, 0x01	; 1
    8f2a:	f0 70       	andi	r31, 0x00	; 0
    8f2c:	30 97       	sbiw	r30, 0x00	; 0
    8f2e:	29 f0       	breq	.+10     	; 0x8f3a <__mulsf3+0x15e>
    8f30:	56 95       	lsr	r21
    8f32:	47 95       	ror	r20
    8f34:	37 95       	ror	r19
    8f36:	27 95       	ror	r18
    8f38:	50 68       	ori	r21, 0x80	; 128
    8f3a:	b6 95       	lsr	r27
    8f3c:	a7 95       	ror	r26
    8f3e:	97 95       	ror	r25
    8f40:	87 95       	ror	r24
    8f42:	6f 5f       	subi	r22, 0xFF	; 255
    8f44:	7f 4f       	sbci	r23, 0xFF	; 255
    8f46:	b7 fd       	sbrc	r27, 7
    8f48:	ee cf       	rjmp	.-36     	; 0x8f26 <__mulsf3+0x14a>
    8f4a:	0c c0       	rjmp	.+24     	; 0x8f64 <__mulsf3+0x188>
    8f4c:	88 0f       	add	r24, r24
    8f4e:	99 1f       	adc	r25, r25
    8f50:	aa 1f       	adc	r26, r26
    8f52:	bb 1f       	adc	r27, r27
    8f54:	57 fd       	sbrc	r21, 7
    8f56:	81 60       	ori	r24, 0x01	; 1
    8f58:	22 0f       	add	r18, r18
    8f5a:	33 1f       	adc	r19, r19
    8f5c:	44 1f       	adc	r20, r20
    8f5e:	55 1f       	adc	r21, r21
    8f60:	61 50       	subi	r22, 0x01	; 1
    8f62:	70 40       	sbci	r23, 0x00	; 0
    8f64:	80 30       	cpi	r24, 0x00	; 0
    8f66:	e0 e0       	ldi	r30, 0x00	; 0
    8f68:	9e 07       	cpc	r25, r30
    8f6a:	e0 e0       	ldi	r30, 0x00	; 0
    8f6c:	ae 07       	cpc	r26, r30
    8f6e:	e0 e4       	ldi	r30, 0x40	; 64
    8f70:	be 07       	cpc	r27, r30
    8f72:	60 f3       	brcs	.-40     	; 0x8f4c <__mulsf3+0x170>
    8f74:	6b 8f       	std	Y+27, r22	; 0x1b
    8f76:	7c 8f       	std	Y+28, r23	; 0x1c
    8f78:	6f e7       	ldi	r22, 0x7F	; 127
    8f7a:	e6 2e       	mov	r14, r22
    8f7c:	f1 2c       	mov	r15, r1
    8f7e:	01 2d       	mov	r16, r1
    8f80:	11 2d       	mov	r17, r1
    8f82:	e8 22       	and	r14, r24
    8f84:	f9 22       	and	r15, r25
    8f86:	0a 23       	and	r16, r26
    8f88:	1b 23       	and	r17, r27
    8f8a:	60 e4       	ldi	r22, 0x40	; 64
    8f8c:	e6 16       	cp	r14, r22
    8f8e:	f1 04       	cpc	r15, r1
    8f90:	01 05       	cpc	r16, r1
    8f92:	11 05       	cpc	r17, r1
    8f94:	61 f4       	brne	.+24     	; 0x8fae <__mulsf3+0x1d2>
    8f96:	87 fd       	sbrc	r24, 7
    8f98:	0a c0       	rjmp	.+20     	; 0x8fae <__mulsf3+0x1d2>
    8f9a:	21 15       	cp	r18, r1
    8f9c:	31 05       	cpc	r19, r1
    8f9e:	41 05       	cpc	r20, r1
    8fa0:	51 05       	cpc	r21, r1
    8fa2:	29 f0       	breq	.+10     	; 0x8fae <__mulsf3+0x1d2>
    8fa4:	80 5c       	subi	r24, 0xC0	; 192
    8fa6:	9f 4f       	sbci	r25, 0xFF	; 255
    8fa8:	af 4f       	sbci	r26, 0xFF	; 255
    8faa:	bf 4f       	sbci	r27, 0xFF	; 255
    8fac:	80 78       	andi	r24, 0x80	; 128
    8fae:	8d 8f       	std	Y+29, r24	; 0x1d
    8fb0:	9e 8f       	std	Y+30, r25	; 0x1e
    8fb2:	af 8f       	std	Y+31, r26	; 0x1f
    8fb4:	b8 a3       	std	Y+32, r27	; 0x20
    8fb6:	83 e0       	ldi	r24, 0x03	; 3
    8fb8:	89 8f       	std	Y+25, r24	; 0x19
    8fba:	ce 01       	movw	r24, r28
    8fbc:	49 96       	adiw	r24, 0x19	; 25
    8fbe:	02 c0       	rjmp	.+4      	; 0x8fc4 <__mulsf3+0x1e8>
    8fc0:	8d ec       	ldi	r24, 0xCD	; 205
    8fc2:	9e e0       	ldi	r25, 0x0E	; 14
    8fc4:	0e 94 d2 49 	call	0x93a4	; 0x93a4 <__pack_f>
    8fc8:	a0 96       	adiw	r28, 0x20	; 32
    8fca:	e2 e1       	ldi	r30, 0x12	; 18
    8fcc:	0c 94 c7 4b 	jmp	0x978e	; 0x978e <__epilogue_restores__>

00008fd0 <__divsf3>:
    8fd0:	a8 e1       	ldi	r26, 0x18	; 24
    8fd2:	b0 e0       	ldi	r27, 0x00	; 0
    8fd4:	ee ee       	ldi	r30, 0xEE	; 238
    8fd6:	f7 e4       	ldi	r31, 0x47	; 71
    8fd8:	0c 94 b3 4b 	jmp	0x9766	; 0x9766 <__prologue_saves__+0x10>
    8fdc:	69 83       	std	Y+1, r22	; 0x01
    8fde:	7a 83       	std	Y+2, r23	; 0x02
    8fe0:	8b 83       	std	Y+3, r24	; 0x03
    8fe2:	9c 83       	std	Y+4, r25	; 0x04
    8fe4:	2d 83       	std	Y+5, r18	; 0x05
    8fe6:	3e 83       	std	Y+6, r19	; 0x06
    8fe8:	4f 83       	std	Y+7, r20	; 0x07
    8fea:	58 87       	std	Y+8, r21	; 0x08
    8fec:	8e 01       	movw	r16, r28
    8fee:	07 5f       	subi	r16, 0xF7	; 247
    8ff0:	1f 4f       	sbci	r17, 0xFF	; 255
    8ff2:	ce 01       	movw	r24, r28
    8ff4:	01 96       	adiw	r24, 0x01	; 1
    8ff6:	b8 01       	movw	r22, r16
    8ff8:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    8ffc:	81 e1       	ldi	r24, 0x11	; 17
    8ffe:	e8 2e       	mov	r14, r24
    9000:	f1 2c       	mov	r15, r1
    9002:	ec 0e       	add	r14, r28
    9004:	fd 1e       	adc	r15, r29
    9006:	ce 01       	movw	r24, r28
    9008:	05 96       	adiw	r24, 0x05	; 5
    900a:	b7 01       	movw	r22, r14
    900c:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    9010:	99 85       	ldd	r25, Y+9	; 0x09
    9012:	92 30       	cpi	r25, 0x02	; 2
    9014:	08 f4       	brcc	.+2      	; 0x9018 <__divsf3+0x48>
    9016:	83 c0       	rjmp	.+262    	; 0x911e <__divsf3+0x14e>
    9018:	89 89       	ldd	r24, Y+17	; 0x11
    901a:	82 30       	cpi	r24, 0x02	; 2
    901c:	08 f4       	brcc	.+2      	; 0x9020 <__divsf3+0x50>
    901e:	7b c0       	rjmp	.+246    	; 0x9116 <__divsf3+0x146>
    9020:	2a 85       	ldd	r18, Y+10	; 0x0a
    9022:	3a 89       	ldd	r19, Y+18	; 0x12
    9024:	23 27       	eor	r18, r19
    9026:	2a 87       	std	Y+10, r18	; 0x0a
    9028:	94 30       	cpi	r25, 0x04	; 4
    902a:	11 f0       	breq	.+4      	; 0x9030 <__divsf3+0x60>
    902c:	92 30       	cpi	r25, 0x02	; 2
    902e:	21 f4       	brne	.+8      	; 0x9038 <__divsf3+0x68>
    9030:	98 17       	cp	r25, r24
    9032:	09 f0       	breq	.+2      	; 0x9036 <__divsf3+0x66>
    9034:	6c c0       	rjmp	.+216    	; 0x910e <__divsf3+0x13e>
    9036:	71 c0       	rjmp	.+226    	; 0x911a <__divsf3+0x14a>
    9038:	84 30       	cpi	r24, 0x04	; 4
    903a:	39 f4       	brne	.+14     	; 0x904a <__divsf3+0x7a>
    903c:	1d 86       	std	Y+13, r1	; 0x0d
    903e:	1e 86       	std	Y+14, r1	; 0x0e
    9040:	1f 86       	std	Y+15, r1	; 0x0f
    9042:	18 8a       	std	Y+16, r1	; 0x10
    9044:	1c 86       	std	Y+12, r1	; 0x0c
    9046:	1b 86       	std	Y+11, r1	; 0x0b
    9048:	6a c0       	rjmp	.+212    	; 0x911e <__divsf3+0x14e>
    904a:	82 30       	cpi	r24, 0x02	; 2
    904c:	19 f4       	brne	.+6      	; 0x9054 <__divsf3+0x84>
    904e:	84 e0       	ldi	r24, 0x04	; 4
    9050:	89 87       	std	Y+9, r24	; 0x09
    9052:	65 c0       	rjmp	.+202    	; 0x911e <__divsf3+0x14e>
    9054:	8b 85       	ldd	r24, Y+11	; 0x0b
    9056:	9c 85       	ldd	r25, Y+12	; 0x0c
    9058:	2b 89       	ldd	r18, Y+19	; 0x13
    905a:	3c 89       	ldd	r19, Y+20	; 0x14
    905c:	82 1b       	sub	r24, r18
    905e:	93 0b       	sbc	r25, r19
    9060:	9c 87       	std	Y+12, r25	; 0x0c
    9062:	8b 87       	std	Y+11, r24	; 0x0b
    9064:	2d 85       	ldd	r18, Y+13	; 0x0d
    9066:	3e 85       	ldd	r19, Y+14	; 0x0e
    9068:	4f 85       	ldd	r20, Y+15	; 0x0f
    906a:	58 89       	ldd	r21, Y+16	; 0x10
    906c:	ed 88       	ldd	r14, Y+21	; 0x15
    906e:	fe 88       	ldd	r15, Y+22	; 0x16
    9070:	0f 89       	ldd	r16, Y+23	; 0x17
    9072:	18 8d       	ldd	r17, Y+24	; 0x18
    9074:	2e 15       	cp	r18, r14
    9076:	3f 05       	cpc	r19, r15
    9078:	40 07       	cpc	r20, r16
    907a:	51 07       	cpc	r21, r17
    907c:	38 f4       	brcc	.+14     	; 0x908c <__divsf3+0xbc>
    907e:	22 0f       	add	r18, r18
    9080:	33 1f       	adc	r19, r19
    9082:	44 1f       	adc	r20, r20
    9084:	55 1f       	adc	r21, r21
    9086:	01 97       	sbiw	r24, 0x01	; 1
    9088:	9c 87       	std	Y+12, r25	; 0x0c
    908a:	8b 87       	std	Y+11, r24	; 0x0b
    908c:	6f e1       	ldi	r22, 0x1F	; 31
    908e:	70 e0       	ldi	r23, 0x00	; 0
    9090:	a1 2c       	mov	r10, r1
    9092:	b1 2c       	mov	r11, r1
    9094:	c1 2c       	mov	r12, r1
    9096:	a0 e4       	ldi	r26, 0x40	; 64
    9098:	da 2e       	mov	r13, r26
    909a:	80 e0       	ldi	r24, 0x00	; 0
    909c:	90 e0       	ldi	r25, 0x00	; 0
    909e:	dc 01       	movw	r26, r24
    90a0:	2e 15       	cp	r18, r14
    90a2:	3f 05       	cpc	r19, r15
    90a4:	40 07       	cpc	r20, r16
    90a6:	51 07       	cpc	r21, r17
    90a8:	40 f0       	brcs	.+16     	; 0x90ba <__divsf3+0xea>
    90aa:	8a 29       	or	r24, r10
    90ac:	9b 29       	or	r25, r11
    90ae:	ac 29       	or	r26, r12
    90b0:	bd 29       	or	r27, r13
    90b2:	2e 19       	sub	r18, r14
    90b4:	3f 09       	sbc	r19, r15
    90b6:	40 0b       	sbc	r20, r16
    90b8:	51 0b       	sbc	r21, r17
    90ba:	d6 94       	lsr	r13
    90bc:	c7 94       	ror	r12
    90be:	b7 94       	ror	r11
    90c0:	a7 94       	ror	r10
    90c2:	22 0f       	add	r18, r18
    90c4:	33 1f       	adc	r19, r19
    90c6:	44 1f       	adc	r20, r20
    90c8:	55 1f       	adc	r21, r21
    90ca:	61 50       	subi	r22, 0x01	; 1
    90cc:	70 40       	sbci	r23, 0x00	; 0
    90ce:	41 f7       	brne	.-48     	; 0x90a0 <__divsf3+0xd0>
    90d0:	6f e7       	ldi	r22, 0x7F	; 127
    90d2:	e6 2e       	mov	r14, r22
    90d4:	f1 2c       	mov	r15, r1
    90d6:	01 2d       	mov	r16, r1
    90d8:	11 2d       	mov	r17, r1
    90da:	e8 22       	and	r14, r24
    90dc:	f9 22       	and	r15, r25
    90de:	0a 23       	and	r16, r26
    90e0:	1b 23       	and	r17, r27
    90e2:	60 e4       	ldi	r22, 0x40	; 64
    90e4:	e6 16       	cp	r14, r22
    90e6:	f1 04       	cpc	r15, r1
    90e8:	01 05       	cpc	r16, r1
    90ea:	11 05       	cpc	r17, r1
    90ec:	61 f4       	brne	.+24     	; 0x9106 <__divsf3+0x136>
    90ee:	87 fd       	sbrc	r24, 7
    90f0:	0a c0       	rjmp	.+20     	; 0x9106 <__divsf3+0x136>
    90f2:	21 15       	cp	r18, r1
    90f4:	31 05       	cpc	r19, r1
    90f6:	41 05       	cpc	r20, r1
    90f8:	51 05       	cpc	r21, r1
    90fa:	29 f0       	breq	.+10     	; 0x9106 <__divsf3+0x136>
    90fc:	80 5c       	subi	r24, 0xC0	; 192
    90fe:	9f 4f       	sbci	r25, 0xFF	; 255
    9100:	af 4f       	sbci	r26, 0xFF	; 255
    9102:	bf 4f       	sbci	r27, 0xFF	; 255
    9104:	80 78       	andi	r24, 0x80	; 128
    9106:	8d 87       	std	Y+13, r24	; 0x0d
    9108:	9e 87       	std	Y+14, r25	; 0x0e
    910a:	af 87       	std	Y+15, r26	; 0x0f
    910c:	b8 8b       	std	Y+16, r27	; 0x10
    910e:	8e 01       	movw	r16, r28
    9110:	07 5f       	subi	r16, 0xF7	; 247
    9112:	1f 4f       	sbci	r17, 0xFF	; 255
    9114:	04 c0       	rjmp	.+8      	; 0x911e <__divsf3+0x14e>
    9116:	87 01       	movw	r16, r14
    9118:	02 c0       	rjmp	.+4      	; 0x911e <__divsf3+0x14e>
    911a:	0d ec       	ldi	r16, 0xCD	; 205
    911c:	1e e0       	ldi	r17, 0x0E	; 14
    911e:	c8 01       	movw	r24, r16
    9120:	0e 94 d2 49 	call	0x93a4	; 0x93a4 <__pack_f>
    9124:	68 96       	adiw	r28, 0x18	; 24
    9126:	ea e0       	ldi	r30, 0x0A	; 10
    9128:	0c 94 cf 4b 	jmp	0x979e	; 0x979e <__epilogue_restores__+0x10>

0000912c <__gesf2>:
    912c:	a8 e1       	ldi	r26, 0x18	; 24
    912e:	b0 e0       	ldi	r27, 0x00	; 0
    9130:	ec e9       	ldi	r30, 0x9C	; 156
    9132:	f8 e4       	ldi	r31, 0x48	; 72
    9134:	0c 94 b7 4b 	jmp	0x976e	; 0x976e <__prologue_saves__+0x18>
    9138:	69 83       	std	Y+1, r22	; 0x01
    913a:	7a 83       	std	Y+2, r23	; 0x02
    913c:	8b 83       	std	Y+3, r24	; 0x03
    913e:	9c 83       	std	Y+4, r25	; 0x04
    9140:	2d 83       	std	Y+5, r18	; 0x05
    9142:	3e 83       	std	Y+6, r19	; 0x06
    9144:	4f 83       	std	Y+7, r20	; 0x07
    9146:	58 87       	std	Y+8, r21	; 0x08
    9148:	8e 01       	movw	r16, r28
    914a:	07 5f       	subi	r16, 0xF7	; 247
    914c:	1f 4f       	sbci	r17, 0xFF	; 255
    914e:	ce 01       	movw	r24, r28
    9150:	01 96       	adiw	r24, 0x01	; 1
    9152:	b8 01       	movw	r22, r16
    9154:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    9158:	81 e1       	ldi	r24, 0x11	; 17
    915a:	e8 2e       	mov	r14, r24
    915c:	f1 2c       	mov	r15, r1
    915e:	ec 0e       	add	r14, r28
    9160:	fd 1e       	adc	r15, r29
    9162:	ce 01       	movw	r24, r28
    9164:	05 96       	adiw	r24, 0x05	; 5
    9166:	b7 01       	movw	r22, r14
    9168:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    916c:	89 85       	ldd	r24, Y+9	; 0x09
    916e:	82 30       	cpi	r24, 0x02	; 2
    9170:	40 f0       	brcs	.+16     	; 0x9182 <__gesf2+0x56>
    9172:	89 89       	ldd	r24, Y+17	; 0x11
    9174:	82 30       	cpi	r24, 0x02	; 2
    9176:	28 f0       	brcs	.+10     	; 0x9182 <__gesf2+0x56>
    9178:	c8 01       	movw	r24, r16
    917a:	b7 01       	movw	r22, r14
    917c:	0e 94 09 4b 	call	0x9612	; 0x9612 <__fpcmp_parts_f>
    9180:	01 c0       	rjmp	.+2      	; 0x9184 <__gesf2+0x58>
    9182:	8f ef       	ldi	r24, 0xFF	; 255
    9184:	68 96       	adiw	r28, 0x18	; 24
    9186:	e6 e0       	ldi	r30, 0x06	; 6
    9188:	0c 94 d3 4b 	jmp	0x97a6	; 0x97a6 <__epilogue_restores__+0x18>

0000918c <__floatsisf>:
    918c:	a8 e0       	ldi	r26, 0x08	; 8
    918e:	b0 e0       	ldi	r27, 0x00	; 0
    9190:	ec ec       	ldi	r30, 0xCC	; 204
    9192:	f8 e4       	ldi	r31, 0x48	; 72
    9194:	0c 94 b7 4b 	jmp	0x976e	; 0x976e <__prologue_saves__+0x18>
    9198:	7b 01       	movw	r14, r22
    919a:	8c 01       	movw	r16, r24
    919c:	83 e0       	ldi	r24, 0x03	; 3
    919e:	89 83       	std	Y+1, r24	; 0x01
    91a0:	d8 01       	movw	r26, r16
    91a2:	c7 01       	movw	r24, r14
    91a4:	88 27       	eor	r24, r24
    91a6:	b7 fd       	sbrc	r27, 7
    91a8:	83 95       	inc	r24
    91aa:	99 27       	eor	r25, r25
    91ac:	aa 27       	eor	r26, r26
    91ae:	bb 27       	eor	r27, r27
    91b0:	28 2f       	mov	r18, r24
    91b2:	8a 83       	std	Y+2, r24	; 0x02
    91b4:	e1 14       	cp	r14, r1
    91b6:	f1 04       	cpc	r15, r1
    91b8:	01 05       	cpc	r16, r1
    91ba:	11 05       	cpc	r17, r1
    91bc:	19 f4       	brne	.+6      	; 0x91c4 <__floatsisf+0x38>
    91be:	82 e0       	ldi	r24, 0x02	; 2
    91c0:	89 83       	std	Y+1, r24	; 0x01
    91c2:	37 c0       	rjmp	.+110    	; 0x9232 <__floatsisf+0xa6>
    91c4:	8e e1       	ldi	r24, 0x1E	; 30
    91c6:	90 e0       	ldi	r25, 0x00	; 0
    91c8:	9c 83       	std	Y+4, r25	; 0x04
    91ca:	8b 83       	std	Y+3, r24	; 0x03
    91cc:	22 23       	and	r18, r18
    91ce:	89 f0       	breq	.+34     	; 0x91f2 <__floatsisf+0x66>
    91d0:	80 e0       	ldi	r24, 0x00	; 0
    91d2:	e8 16       	cp	r14, r24
    91d4:	80 e0       	ldi	r24, 0x00	; 0
    91d6:	f8 06       	cpc	r15, r24
    91d8:	80 e0       	ldi	r24, 0x00	; 0
    91da:	08 07       	cpc	r16, r24
    91dc:	80 e8       	ldi	r24, 0x80	; 128
    91de:	18 07       	cpc	r17, r24
    91e0:	69 f1       	breq	.+90     	; 0x923c <__floatsisf+0xb0>
    91e2:	10 95       	com	r17
    91e4:	00 95       	com	r16
    91e6:	f0 94       	com	r15
    91e8:	e0 94       	com	r14
    91ea:	e1 1c       	adc	r14, r1
    91ec:	f1 1c       	adc	r15, r1
    91ee:	01 1d       	adc	r16, r1
    91f0:	11 1d       	adc	r17, r1
    91f2:	ed 82       	std	Y+5, r14	; 0x05
    91f4:	fe 82       	std	Y+6, r15	; 0x06
    91f6:	0f 83       	std	Y+7, r16	; 0x07
    91f8:	18 87       	std	Y+8, r17	; 0x08
    91fa:	c8 01       	movw	r24, r16
    91fc:	b7 01       	movw	r22, r14
    91fe:	0e 94 78 49 	call	0x92f0	; 0x92f0 <__clzsi2>
    9202:	9c 01       	movw	r18, r24
    9204:	21 50       	subi	r18, 0x01	; 1
    9206:	30 40       	sbci	r19, 0x00	; 0
    9208:	12 16       	cp	r1, r18
    920a:	13 06       	cpc	r1, r19
    920c:	94 f4       	brge	.+36     	; 0x9232 <__floatsisf+0xa6>
    920e:	02 2e       	mov	r0, r18
    9210:	04 c0       	rjmp	.+8      	; 0x921a <__floatsisf+0x8e>
    9212:	ee 0c       	add	r14, r14
    9214:	ff 1c       	adc	r15, r15
    9216:	00 1f       	adc	r16, r16
    9218:	11 1f       	adc	r17, r17
    921a:	0a 94       	dec	r0
    921c:	d2 f7       	brpl	.-12     	; 0x9212 <__floatsisf+0x86>
    921e:	ed 82       	std	Y+5, r14	; 0x05
    9220:	fe 82       	std	Y+6, r15	; 0x06
    9222:	0f 83       	std	Y+7, r16	; 0x07
    9224:	18 87       	std	Y+8, r17	; 0x08
    9226:	8e e1       	ldi	r24, 0x1E	; 30
    9228:	90 e0       	ldi	r25, 0x00	; 0
    922a:	82 1b       	sub	r24, r18
    922c:	93 0b       	sbc	r25, r19
    922e:	9c 83       	std	Y+4, r25	; 0x04
    9230:	8b 83       	std	Y+3, r24	; 0x03
    9232:	ce 01       	movw	r24, r28
    9234:	01 96       	adiw	r24, 0x01	; 1
    9236:	0e 94 d2 49 	call	0x93a4	; 0x93a4 <__pack_f>
    923a:	04 c0       	rjmp	.+8      	; 0x9244 <__floatsisf+0xb8>
    923c:	60 e0       	ldi	r22, 0x00	; 0
    923e:	70 e0       	ldi	r23, 0x00	; 0
    9240:	80 e0       	ldi	r24, 0x00	; 0
    9242:	9f ec       	ldi	r25, 0xCF	; 207
    9244:	28 96       	adiw	r28, 0x08	; 8
    9246:	e6 e0       	ldi	r30, 0x06	; 6
    9248:	0c 94 d3 4b 	jmp	0x97a6	; 0x97a6 <__epilogue_restores__+0x18>

0000924c <__fixsfsi>:
    924c:	ac e0       	ldi	r26, 0x0C	; 12
    924e:	b0 e0       	ldi	r27, 0x00	; 0
    9250:	ec e2       	ldi	r30, 0x2C	; 44
    9252:	f9 e4       	ldi	r31, 0x49	; 73
    9254:	0c 94 bb 4b 	jmp	0x9776	; 0x9776 <__prologue_saves__+0x20>
    9258:	69 83       	std	Y+1, r22	; 0x01
    925a:	7a 83       	std	Y+2, r23	; 0x02
    925c:	8b 83       	std	Y+3, r24	; 0x03
    925e:	9c 83       	std	Y+4, r25	; 0x04
    9260:	ce 01       	movw	r24, r28
    9262:	01 96       	adiw	r24, 0x01	; 1
    9264:	be 01       	movw	r22, r28
    9266:	6b 5f       	subi	r22, 0xFB	; 251
    9268:	7f 4f       	sbci	r23, 0xFF	; 255
    926a:	0e 94 a0 4a 	call	0x9540	; 0x9540 <__unpack_f>
    926e:	8d 81       	ldd	r24, Y+5	; 0x05
    9270:	82 30       	cpi	r24, 0x02	; 2
    9272:	81 f1       	breq	.+96     	; 0x92d4 <__fixsfsi+0x88>
    9274:	82 30       	cpi	r24, 0x02	; 2
    9276:	70 f1       	brcs	.+92     	; 0x92d4 <__fixsfsi+0x88>
    9278:	84 30       	cpi	r24, 0x04	; 4
    927a:	21 f4       	brne	.+8      	; 0x9284 <__fixsfsi+0x38>
    927c:	8e 81       	ldd	r24, Y+6	; 0x06
    927e:	88 23       	and	r24, r24
    9280:	69 f1       	breq	.+90     	; 0x92dc <__fixsfsi+0x90>
    9282:	0a c0       	rjmp	.+20     	; 0x9298 <__fixsfsi+0x4c>
    9284:	2f 81       	ldd	r18, Y+7	; 0x07
    9286:	38 85       	ldd	r19, Y+8	; 0x08
    9288:	37 fd       	sbrc	r19, 7
    928a:	24 c0       	rjmp	.+72     	; 0x92d4 <__fixsfsi+0x88>
    928c:	6e 81       	ldd	r22, Y+6	; 0x06
    928e:	2f 31       	cpi	r18, 0x1F	; 31
    9290:	31 05       	cpc	r19, r1
    9292:	3c f0       	brlt	.+14     	; 0x92a2 <__fixsfsi+0x56>
    9294:	66 23       	and	r22, r22
    9296:	11 f1       	breq	.+68     	; 0x92dc <__fixsfsi+0x90>
    9298:	20 e0       	ldi	r18, 0x00	; 0
    929a:	30 e0       	ldi	r19, 0x00	; 0
    929c:	40 e0       	ldi	r20, 0x00	; 0
    929e:	50 e8       	ldi	r21, 0x80	; 128
    92a0:	21 c0       	rjmp	.+66     	; 0x92e4 <__fixsfsi+0x98>
    92a2:	8e e1       	ldi	r24, 0x1E	; 30
    92a4:	90 e0       	ldi	r25, 0x00	; 0
    92a6:	82 1b       	sub	r24, r18
    92a8:	93 0b       	sbc	r25, r19
    92aa:	29 85       	ldd	r18, Y+9	; 0x09
    92ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    92ae:	4b 85       	ldd	r20, Y+11	; 0x0b
    92b0:	5c 85       	ldd	r21, Y+12	; 0x0c
    92b2:	04 c0       	rjmp	.+8      	; 0x92bc <__fixsfsi+0x70>
    92b4:	56 95       	lsr	r21
    92b6:	47 95       	ror	r20
    92b8:	37 95       	ror	r19
    92ba:	27 95       	ror	r18
    92bc:	8a 95       	dec	r24
    92be:	d2 f7       	brpl	.-12     	; 0x92b4 <__fixsfsi+0x68>
    92c0:	66 23       	and	r22, r22
    92c2:	81 f0       	breq	.+32     	; 0x92e4 <__fixsfsi+0x98>
    92c4:	50 95       	com	r21
    92c6:	40 95       	com	r20
    92c8:	30 95       	com	r19
    92ca:	21 95       	neg	r18
    92cc:	3f 4f       	sbci	r19, 0xFF	; 255
    92ce:	4f 4f       	sbci	r20, 0xFF	; 255
    92d0:	5f 4f       	sbci	r21, 0xFF	; 255
    92d2:	08 c0       	rjmp	.+16     	; 0x92e4 <__fixsfsi+0x98>
    92d4:	20 e0       	ldi	r18, 0x00	; 0
    92d6:	30 e0       	ldi	r19, 0x00	; 0
    92d8:	a9 01       	movw	r20, r18
    92da:	04 c0       	rjmp	.+8      	; 0x92e4 <__fixsfsi+0x98>
    92dc:	2f ef       	ldi	r18, 0xFF	; 255
    92de:	3f ef       	ldi	r19, 0xFF	; 255
    92e0:	4f ef       	ldi	r20, 0xFF	; 255
    92e2:	5f e7       	ldi	r21, 0x7F	; 127
    92e4:	b9 01       	movw	r22, r18
    92e6:	ca 01       	movw	r24, r20
    92e8:	2c 96       	adiw	r28, 0x0c	; 12
    92ea:	e2 e0       	ldi	r30, 0x02	; 2
    92ec:	0c 94 d7 4b 	jmp	0x97ae	; 0x97ae <__epilogue_restores__+0x20>

000092f0 <__clzsi2>:
    92f0:	af 92       	push	r10
    92f2:	bf 92       	push	r11
    92f4:	cf 92       	push	r12
    92f6:	df 92       	push	r13
    92f8:	ef 92       	push	r14
    92fa:	ff 92       	push	r15
    92fc:	0f 93       	push	r16
    92fe:	1f 93       	push	r17
    9300:	7b 01       	movw	r14, r22
    9302:	8c 01       	movw	r16, r24
    9304:	80 e0       	ldi	r24, 0x00	; 0
    9306:	e8 16       	cp	r14, r24
    9308:	80 e0       	ldi	r24, 0x00	; 0
    930a:	f8 06       	cpc	r15, r24
    930c:	81 e0       	ldi	r24, 0x01	; 1
    930e:	08 07       	cpc	r16, r24
    9310:	80 e0       	ldi	r24, 0x00	; 0
    9312:	18 07       	cpc	r17, r24
    9314:	58 f4       	brcc	.+22     	; 0x932c <__clzsi2+0x3c>
    9316:	ef ef       	ldi	r30, 0xFF	; 255
    9318:	ee 16       	cp	r14, r30
    931a:	f1 04       	cpc	r15, r1
    931c:	01 05       	cpc	r16, r1
    931e:	11 05       	cpc	r17, r1
    9320:	09 f0       	breq	.+2      	; 0x9324 <__clzsi2+0x34>
    9322:	90 f4       	brcc	.+36     	; 0x9348 <__clzsi2+0x58>
    9324:	80 e0       	ldi	r24, 0x00	; 0
    9326:	90 e0       	ldi	r25, 0x00	; 0
    9328:	dc 01       	movw	r26, r24
    932a:	17 c0       	rjmp	.+46     	; 0x935a <__clzsi2+0x6a>
    932c:	f0 e0       	ldi	r31, 0x00	; 0
    932e:	ef 16       	cp	r14, r31
    9330:	f0 e0       	ldi	r31, 0x00	; 0
    9332:	ff 06       	cpc	r15, r31
    9334:	f0 e0       	ldi	r31, 0x00	; 0
    9336:	0f 07       	cpc	r16, r31
    9338:	f1 e0       	ldi	r31, 0x01	; 1
    933a:	1f 07       	cpc	r17, r31
    933c:	50 f4       	brcc	.+20     	; 0x9352 <__clzsi2+0x62>
    933e:	80 e1       	ldi	r24, 0x10	; 16
    9340:	90 e0       	ldi	r25, 0x00	; 0
    9342:	a0 e0       	ldi	r26, 0x00	; 0
    9344:	b0 e0       	ldi	r27, 0x00	; 0
    9346:	09 c0       	rjmp	.+18     	; 0x935a <__clzsi2+0x6a>
    9348:	88 e0       	ldi	r24, 0x08	; 8
    934a:	90 e0       	ldi	r25, 0x00	; 0
    934c:	a0 e0       	ldi	r26, 0x00	; 0
    934e:	b0 e0       	ldi	r27, 0x00	; 0
    9350:	04 c0       	rjmp	.+8      	; 0x935a <__clzsi2+0x6a>
    9352:	88 e1       	ldi	r24, 0x18	; 24
    9354:	90 e0       	ldi	r25, 0x00	; 0
    9356:	a0 e0       	ldi	r26, 0x00	; 0
    9358:	b0 e0       	ldi	r27, 0x00	; 0
    935a:	20 e2       	ldi	r18, 0x20	; 32
    935c:	30 e0       	ldi	r19, 0x00	; 0
    935e:	40 e0       	ldi	r20, 0x00	; 0
    9360:	50 e0       	ldi	r21, 0x00	; 0
    9362:	28 1b       	sub	r18, r24
    9364:	39 0b       	sbc	r19, r25
    9366:	4a 0b       	sbc	r20, r26
    9368:	5b 0b       	sbc	r21, r27
    936a:	57 01       	movw	r10, r14
    936c:	68 01       	movw	r12, r16
    936e:	04 c0       	rjmp	.+8      	; 0x9378 <__clzsi2+0x88>
    9370:	d6 94       	lsr	r13
    9372:	c7 94       	ror	r12
    9374:	b7 94       	ror	r11
    9376:	a7 94       	ror	r10
    9378:	8a 95       	dec	r24
    937a:	d2 f7       	brpl	.-12     	; 0x9370 <__clzsi2+0x80>
    937c:	d6 01       	movw	r26, r12
    937e:	c5 01       	movw	r24, r10
    9380:	8b 52       	subi	r24, 0x2B	; 43
    9382:	91 4f       	sbci	r25, 0xF1	; 241
    9384:	fc 01       	movw	r30, r24
    9386:	80 81       	ld	r24, Z
    9388:	28 1b       	sub	r18, r24
    938a:	31 09       	sbc	r19, r1
    938c:	41 09       	sbc	r20, r1
    938e:	51 09       	sbc	r21, r1
    9390:	c9 01       	movw	r24, r18
    9392:	1f 91       	pop	r17
    9394:	0f 91       	pop	r16
    9396:	ff 90       	pop	r15
    9398:	ef 90       	pop	r14
    939a:	df 90       	pop	r13
    939c:	cf 90       	pop	r12
    939e:	bf 90       	pop	r11
    93a0:	af 90       	pop	r10
    93a2:	08 95       	ret

000093a4 <__pack_f>:
    93a4:	ef 92       	push	r14
    93a6:	ff 92       	push	r15
    93a8:	0f 93       	push	r16
    93aa:	1f 93       	push	r17
    93ac:	cf 93       	push	r28
    93ae:	df 93       	push	r29
    93b0:	fc 01       	movw	r30, r24
    93b2:	24 81       	ldd	r18, Z+4	; 0x04
    93b4:	35 81       	ldd	r19, Z+5	; 0x05
    93b6:	46 81       	ldd	r20, Z+6	; 0x06
    93b8:	57 81       	ldd	r21, Z+7	; 0x07
    93ba:	61 81       	ldd	r22, Z+1	; 0x01
    93bc:	80 81       	ld	r24, Z
    93be:	82 30       	cpi	r24, 0x02	; 2
    93c0:	20 f4       	brcc	.+8      	; 0x93ca <__pack_f+0x26>
    93c2:	40 61       	ori	r20, 0x10	; 16
    93c4:	ef ef       	ldi	r30, 0xFF	; 255
    93c6:	f0 e0       	ldi	r31, 0x00	; 0
    93c8:	a3 c0       	rjmp	.+326    	; 0x9510 <__pack_f+0x16c>
    93ca:	84 30       	cpi	r24, 0x04	; 4
    93cc:	09 f4       	brne	.+2      	; 0x93d0 <__pack_f+0x2c>
    93ce:	9b c0       	rjmp	.+310    	; 0x9506 <__pack_f+0x162>
    93d0:	82 30       	cpi	r24, 0x02	; 2
    93d2:	09 f4       	brne	.+2      	; 0x93d6 <__pack_f+0x32>
    93d4:	92 c0       	rjmp	.+292    	; 0x94fa <__pack_f+0x156>
    93d6:	21 15       	cp	r18, r1
    93d8:	31 05       	cpc	r19, r1
    93da:	41 05       	cpc	r20, r1
    93dc:	51 05       	cpc	r21, r1
    93de:	09 f4       	brne	.+2      	; 0x93e2 <__pack_f+0x3e>
    93e0:	8f c0       	rjmp	.+286    	; 0x9500 <__pack_f+0x15c>
    93e2:	02 80       	ldd	r0, Z+2	; 0x02
    93e4:	f3 81       	ldd	r31, Z+3	; 0x03
    93e6:	e0 2d       	mov	r30, r0
    93e8:	8f ef       	ldi	r24, 0xFF	; 255
    93ea:	e2 38       	cpi	r30, 0x82	; 130
    93ec:	f8 07       	cpc	r31, r24
    93ee:	0c f0       	brlt	.+2      	; 0x93f2 <__pack_f+0x4e>
    93f0:	5a c0       	rjmp	.+180    	; 0x94a6 <__pack_f+0x102>
    93f2:	c2 e8       	ldi	r28, 0x82	; 130
    93f4:	df ef       	ldi	r29, 0xFF	; 255
    93f6:	ce 1b       	sub	r28, r30
    93f8:	df 0b       	sbc	r29, r31
    93fa:	ca 31       	cpi	r28, 0x1A	; 26
    93fc:	d1 05       	cpc	r29, r1
    93fe:	6c f5       	brge	.+90     	; 0x945a <__pack_f+0xb6>
    9400:	79 01       	movw	r14, r18
    9402:	8a 01       	movw	r16, r20
    9404:	0c 2e       	mov	r0, r28
    9406:	04 c0       	rjmp	.+8      	; 0x9410 <__pack_f+0x6c>
    9408:	16 95       	lsr	r17
    940a:	07 95       	ror	r16
    940c:	f7 94       	ror	r15
    940e:	e7 94       	ror	r14
    9410:	0a 94       	dec	r0
    9412:	d2 f7       	brpl	.-12     	; 0x9408 <__pack_f+0x64>
    9414:	81 e0       	ldi	r24, 0x01	; 1
    9416:	90 e0       	ldi	r25, 0x00	; 0
    9418:	a0 e0       	ldi	r26, 0x00	; 0
    941a:	b0 e0       	ldi	r27, 0x00	; 0
    941c:	0c 2e       	mov	r0, r28
    941e:	04 c0       	rjmp	.+8      	; 0x9428 <__pack_f+0x84>
    9420:	88 0f       	add	r24, r24
    9422:	99 1f       	adc	r25, r25
    9424:	aa 1f       	adc	r26, r26
    9426:	bb 1f       	adc	r27, r27
    9428:	0a 94       	dec	r0
    942a:	d2 f7       	brpl	.-12     	; 0x9420 <__pack_f+0x7c>
    942c:	01 97       	sbiw	r24, 0x01	; 1
    942e:	a1 09       	sbc	r26, r1
    9430:	b1 09       	sbc	r27, r1
    9432:	82 23       	and	r24, r18
    9434:	93 23       	and	r25, r19
    9436:	a4 23       	and	r26, r20
    9438:	b5 23       	and	r27, r21
    943a:	21 e0       	ldi	r18, 0x01	; 1
    943c:	30 e0       	ldi	r19, 0x00	; 0
    943e:	40 e0       	ldi	r20, 0x00	; 0
    9440:	50 e0       	ldi	r21, 0x00	; 0
    9442:	00 97       	sbiw	r24, 0x00	; 0
    9444:	a1 05       	cpc	r26, r1
    9446:	b1 05       	cpc	r27, r1
    9448:	19 f4       	brne	.+6      	; 0x9450 <__pack_f+0xac>
    944a:	20 e0       	ldi	r18, 0x00	; 0
    944c:	30 e0       	ldi	r19, 0x00	; 0
    944e:	a9 01       	movw	r20, r18
    9450:	2e 29       	or	r18, r14
    9452:	3f 29       	or	r19, r15
    9454:	40 2b       	or	r20, r16
    9456:	51 2b       	or	r21, r17
    9458:	03 c0       	rjmp	.+6      	; 0x9460 <__pack_f+0xbc>
    945a:	20 e0       	ldi	r18, 0x00	; 0
    945c:	30 e0       	ldi	r19, 0x00	; 0
    945e:	a9 01       	movw	r20, r18
    9460:	da 01       	movw	r26, r20
    9462:	c9 01       	movw	r24, r18
    9464:	8f 77       	andi	r24, 0x7F	; 127
    9466:	90 70       	andi	r25, 0x00	; 0
    9468:	a0 70       	andi	r26, 0x00	; 0
    946a:	b0 70       	andi	r27, 0x00	; 0
    946c:	80 34       	cpi	r24, 0x40	; 64
    946e:	91 05       	cpc	r25, r1
    9470:	a1 05       	cpc	r26, r1
    9472:	b1 05       	cpc	r27, r1
    9474:	39 f4       	brne	.+14     	; 0x9484 <__pack_f+0xe0>
    9476:	27 ff       	sbrs	r18, 7
    9478:	09 c0       	rjmp	.+18     	; 0x948c <__pack_f+0xe8>
    947a:	20 5c       	subi	r18, 0xC0	; 192
    947c:	3f 4f       	sbci	r19, 0xFF	; 255
    947e:	4f 4f       	sbci	r20, 0xFF	; 255
    9480:	5f 4f       	sbci	r21, 0xFF	; 255
    9482:	04 c0       	rjmp	.+8      	; 0x948c <__pack_f+0xe8>
    9484:	21 5c       	subi	r18, 0xC1	; 193
    9486:	3f 4f       	sbci	r19, 0xFF	; 255
    9488:	4f 4f       	sbci	r20, 0xFF	; 255
    948a:	5f 4f       	sbci	r21, 0xFF	; 255
    948c:	e1 e0       	ldi	r30, 0x01	; 1
    948e:	f0 e0       	ldi	r31, 0x00	; 0
    9490:	20 30       	cpi	r18, 0x00	; 0
    9492:	80 e0       	ldi	r24, 0x00	; 0
    9494:	38 07       	cpc	r19, r24
    9496:	80 e0       	ldi	r24, 0x00	; 0
    9498:	48 07       	cpc	r20, r24
    949a:	80 e4       	ldi	r24, 0x40	; 64
    949c:	58 07       	cpc	r21, r24
    949e:	28 f5       	brcc	.+74     	; 0x94ea <__pack_f+0x146>
    94a0:	e0 e0       	ldi	r30, 0x00	; 0
    94a2:	f0 e0       	ldi	r31, 0x00	; 0
    94a4:	22 c0       	rjmp	.+68     	; 0x94ea <__pack_f+0x146>
    94a6:	e0 38       	cpi	r30, 0x80	; 128
    94a8:	f1 05       	cpc	r31, r1
    94aa:	6c f5       	brge	.+90     	; 0x9506 <__pack_f+0x162>
    94ac:	e1 58       	subi	r30, 0x81	; 129
    94ae:	ff 4f       	sbci	r31, 0xFF	; 255
    94b0:	da 01       	movw	r26, r20
    94b2:	c9 01       	movw	r24, r18
    94b4:	8f 77       	andi	r24, 0x7F	; 127
    94b6:	90 70       	andi	r25, 0x00	; 0
    94b8:	a0 70       	andi	r26, 0x00	; 0
    94ba:	b0 70       	andi	r27, 0x00	; 0
    94bc:	80 34       	cpi	r24, 0x40	; 64
    94be:	91 05       	cpc	r25, r1
    94c0:	a1 05       	cpc	r26, r1
    94c2:	b1 05       	cpc	r27, r1
    94c4:	39 f4       	brne	.+14     	; 0x94d4 <__pack_f+0x130>
    94c6:	27 ff       	sbrs	r18, 7
    94c8:	09 c0       	rjmp	.+18     	; 0x94dc <__pack_f+0x138>
    94ca:	20 5c       	subi	r18, 0xC0	; 192
    94cc:	3f 4f       	sbci	r19, 0xFF	; 255
    94ce:	4f 4f       	sbci	r20, 0xFF	; 255
    94d0:	5f 4f       	sbci	r21, 0xFF	; 255
    94d2:	04 c0       	rjmp	.+8      	; 0x94dc <__pack_f+0x138>
    94d4:	21 5c       	subi	r18, 0xC1	; 193
    94d6:	3f 4f       	sbci	r19, 0xFF	; 255
    94d8:	4f 4f       	sbci	r20, 0xFF	; 255
    94da:	5f 4f       	sbci	r21, 0xFF	; 255
    94dc:	57 ff       	sbrs	r21, 7
    94de:	05 c0       	rjmp	.+10     	; 0x94ea <__pack_f+0x146>
    94e0:	56 95       	lsr	r21
    94e2:	47 95       	ror	r20
    94e4:	37 95       	ror	r19
    94e6:	27 95       	ror	r18
    94e8:	31 96       	adiw	r30, 0x01	; 1
    94ea:	87 e0       	ldi	r24, 0x07	; 7
    94ec:	56 95       	lsr	r21
    94ee:	47 95       	ror	r20
    94f0:	37 95       	ror	r19
    94f2:	27 95       	ror	r18
    94f4:	8a 95       	dec	r24
    94f6:	d1 f7       	brne	.-12     	; 0x94ec <__pack_f+0x148>
    94f8:	0b c0       	rjmp	.+22     	; 0x9510 <__pack_f+0x16c>
    94fa:	e0 e0       	ldi	r30, 0x00	; 0
    94fc:	f0 e0       	ldi	r31, 0x00	; 0
    94fe:	05 c0       	rjmp	.+10     	; 0x950a <__pack_f+0x166>
    9500:	e0 e0       	ldi	r30, 0x00	; 0
    9502:	f0 e0       	ldi	r31, 0x00	; 0
    9504:	05 c0       	rjmp	.+10     	; 0x9510 <__pack_f+0x16c>
    9506:	ef ef       	ldi	r30, 0xFF	; 255
    9508:	f0 e0       	ldi	r31, 0x00	; 0
    950a:	20 e0       	ldi	r18, 0x00	; 0
    950c:	30 e0       	ldi	r19, 0x00	; 0
    950e:	a9 01       	movw	r20, r18
    9510:	8e 2f       	mov	r24, r30
    9512:	87 95       	ror	r24
    9514:	88 27       	eor	r24, r24
    9516:	87 95       	ror	r24
    9518:	94 2f       	mov	r25, r20
    951a:	9f 77       	andi	r25, 0x7F	; 127
    951c:	67 95       	ror	r22
    951e:	66 27       	eor	r22, r22
    9520:	67 95       	ror	r22
    9522:	e6 95       	lsr	r30
    9524:	e2 2e       	mov	r14, r18
    9526:	a9 2f       	mov	r26, r25
    9528:	a8 2b       	or	r26, r24
    952a:	fe 2f       	mov	r31, r30
    952c:	f6 2b       	or	r31, r22
    952e:	62 2f       	mov	r22, r18
    9530:	73 2f       	mov	r23, r19
    9532:	8a 2f       	mov	r24, r26
    9534:	9f 2f       	mov	r25, r31
    9536:	cd b7       	in	r28, 0x3d	; 61
    9538:	de b7       	in	r29, 0x3e	; 62
    953a:	e6 e0       	ldi	r30, 0x06	; 6
    953c:	0c 94 d3 4b 	jmp	0x97a6	; 0x97a6 <__epilogue_restores__+0x18>

00009540 <__unpack_f>:
    9540:	dc 01       	movw	r26, r24
    9542:	fb 01       	movw	r30, r22
    9544:	2c 91       	ld	r18, X
    9546:	11 96       	adiw	r26, 0x01	; 1
    9548:	3c 91       	ld	r19, X
    954a:	11 97       	sbiw	r26, 0x01	; 1
    954c:	12 96       	adiw	r26, 0x02	; 2
    954e:	8c 91       	ld	r24, X
    9550:	12 97       	sbiw	r26, 0x02	; 2
    9552:	48 2f       	mov	r20, r24
    9554:	4f 77       	andi	r20, 0x7F	; 127
    9556:	50 e0       	ldi	r21, 0x00	; 0
    9558:	98 2f       	mov	r25, r24
    955a:	99 1f       	adc	r25, r25
    955c:	99 27       	eor	r25, r25
    955e:	99 1f       	adc	r25, r25
    9560:	13 96       	adiw	r26, 0x03	; 3
    9562:	6c 91       	ld	r22, X
    9564:	13 97       	sbiw	r26, 0x03	; 3
    9566:	86 2f       	mov	r24, r22
    9568:	88 0f       	add	r24, r24
    956a:	89 2b       	or	r24, r25
    956c:	90 e0       	ldi	r25, 0x00	; 0
    956e:	66 1f       	adc	r22, r22
    9570:	66 27       	eor	r22, r22
    9572:	66 1f       	adc	r22, r22
    9574:	61 83       	std	Z+1, r22	; 0x01
    9576:	00 97       	sbiw	r24, 0x00	; 0
    9578:	39 f5       	brne	.+78     	; 0x95c8 <__unpack_f+0x88>
    957a:	21 15       	cp	r18, r1
    957c:	31 05       	cpc	r19, r1
    957e:	41 05       	cpc	r20, r1
    9580:	51 05       	cpc	r21, r1
    9582:	11 f4       	brne	.+4      	; 0x9588 <__unpack_f+0x48>
    9584:	82 e0       	ldi	r24, 0x02	; 2
    9586:	29 c0       	rjmp	.+82     	; 0x95da <__unpack_f+0x9a>
    9588:	82 e8       	ldi	r24, 0x82	; 130
    958a:	9f ef       	ldi	r25, 0xFF	; 255
    958c:	93 83       	std	Z+3, r25	; 0x03
    958e:	82 83       	std	Z+2, r24	; 0x02
    9590:	67 e0       	ldi	r22, 0x07	; 7
    9592:	22 0f       	add	r18, r18
    9594:	33 1f       	adc	r19, r19
    9596:	44 1f       	adc	r20, r20
    9598:	55 1f       	adc	r21, r21
    959a:	6a 95       	dec	r22
    959c:	d1 f7       	brne	.-12     	; 0x9592 <__unpack_f+0x52>
    959e:	83 e0       	ldi	r24, 0x03	; 3
    95a0:	80 83       	st	Z, r24
    95a2:	09 c0       	rjmp	.+18     	; 0x95b6 <__unpack_f+0x76>
    95a4:	22 0f       	add	r18, r18
    95a6:	33 1f       	adc	r19, r19
    95a8:	44 1f       	adc	r20, r20
    95aa:	55 1f       	adc	r21, r21
    95ac:	82 81       	ldd	r24, Z+2	; 0x02
    95ae:	93 81       	ldd	r25, Z+3	; 0x03
    95b0:	01 97       	sbiw	r24, 0x01	; 1
    95b2:	93 83       	std	Z+3, r25	; 0x03
    95b4:	82 83       	std	Z+2, r24	; 0x02
    95b6:	20 30       	cpi	r18, 0x00	; 0
    95b8:	80 e0       	ldi	r24, 0x00	; 0
    95ba:	38 07       	cpc	r19, r24
    95bc:	80 e0       	ldi	r24, 0x00	; 0
    95be:	48 07       	cpc	r20, r24
    95c0:	80 e4       	ldi	r24, 0x40	; 64
    95c2:	58 07       	cpc	r21, r24
    95c4:	78 f3       	brcs	.-34     	; 0x95a4 <__unpack_f+0x64>
    95c6:	20 c0       	rjmp	.+64     	; 0x9608 <__unpack_f+0xc8>
    95c8:	8f 3f       	cpi	r24, 0xFF	; 255
    95ca:	91 05       	cpc	r25, r1
    95cc:	79 f4       	brne	.+30     	; 0x95ec <__unpack_f+0xac>
    95ce:	21 15       	cp	r18, r1
    95d0:	31 05       	cpc	r19, r1
    95d2:	41 05       	cpc	r20, r1
    95d4:	51 05       	cpc	r21, r1
    95d6:	19 f4       	brne	.+6      	; 0x95de <__unpack_f+0x9e>
    95d8:	84 e0       	ldi	r24, 0x04	; 4
    95da:	80 83       	st	Z, r24
    95dc:	08 95       	ret
    95de:	44 ff       	sbrs	r20, 4
    95e0:	03 c0       	rjmp	.+6      	; 0x95e8 <__unpack_f+0xa8>
    95e2:	81 e0       	ldi	r24, 0x01	; 1
    95e4:	80 83       	st	Z, r24
    95e6:	10 c0       	rjmp	.+32     	; 0x9608 <__unpack_f+0xc8>
    95e8:	10 82       	st	Z, r1
    95ea:	0e c0       	rjmp	.+28     	; 0x9608 <__unpack_f+0xc8>
    95ec:	8f 57       	subi	r24, 0x7F	; 127
    95ee:	90 40       	sbci	r25, 0x00	; 0
    95f0:	93 83       	std	Z+3, r25	; 0x03
    95f2:	82 83       	std	Z+2, r24	; 0x02
    95f4:	83 e0       	ldi	r24, 0x03	; 3
    95f6:	80 83       	st	Z, r24
    95f8:	87 e0       	ldi	r24, 0x07	; 7
    95fa:	22 0f       	add	r18, r18
    95fc:	33 1f       	adc	r19, r19
    95fe:	44 1f       	adc	r20, r20
    9600:	55 1f       	adc	r21, r21
    9602:	8a 95       	dec	r24
    9604:	d1 f7       	brne	.-12     	; 0x95fa <__unpack_f+0xba>
    9606:	50 64       	ori	r21, 0x40	; 64
    9608:	24 83       	std	Z+4, r18	; 0x04
    960a:	35 83       	std	Z+5, r19	; 0x05
    960c:	46 83       	std	Z+6, r20	; 0x06
    960e:	57 83       	std	Z+7, r21	; 0x07
    9610:	08 95       	ret

00009612 <__fpcmp_parts_f>:
    9612:	fc 01       	movw	r30, r24
    9614:	db 01       	movw	r26, r22
    9616:	90 81       	ld	r25, Z
    9618:	92 30       	cpi	r25, 0x02	; 2
    961a:	08 f4       	brcc	.+2      	; 0x961e <__fpcmp_parts_f+0xc>
    961c:	49 c0       	rjmp	.+146    	; 0x96b0 <__fpcmp_parts_f+0x9e>
    961e:	8c 91       	ld	r24, X
    9620:	82 30       	cpi	r24, 0x02	; 2
    9622:	08 f4       	brcc	.+2      	; 0x9626 <__fpcmp_parts_f+0x14>
    9624:	45 c0       	rjmp	.+138    	; 0x96b0 <__fpcmp_parts_f+0x9e>
    9626:	94 30       	cpi	r25, 0x04	; 4
    9628:	51 f4       	brne	.+20     	; 0x963e <__fpcmp_parts_f+0x2c>
    962a:	61 81       	ldd	r22, Z+1	; 0x01
    962c:	84 30       	cpi	r24, 0x04	; 4
    962e:	b1 f5       	brne	.+108    	; 0x969c <__fpcmp_parts_f+0x8a>
    9630:	11 96       	adiw	r26, 0x01	; 1
    9632:	2c 91       	ld	r18, X
    9634:	11 97       	sbiw	r26, 0x01	; 1
    9636:	30 e0       	ldi	r19, 0x00	; 0
    9638:	26 1b       	sub	r18, r22
    963a:	31 09       	sbc	r19, r1
    963c:	41 c0       	rjmp	.+130    	; 0x96c0 <__fpcmp_parts_f+0xae>
    963e:	84 30       	cpi	r24, 0x04	; 4
    9640:	21 f0       	breq	.+8      	; 0x964a <__fpcmp_parts_f+0x38>
    9642:	92 30       	cpi	r25, 0x02	; 2
    9644:	41 f4       	brne	.+16     	; 0x9656 <__fpcmp_parts_f+0x44>
    9646:	82 30       	cpi	r24, 0x02	; 2
    9648:	b1 f1       	breq	.+108    	; 0x96b6 <__fpcmp_parts_f+0xa4>
    964a:	11 96       	adiw	r26, 0x01	; 1
    964c:	8c 91       	ld	r24, X
    964e:	11 97       	sbiw	r26, 0x01	; 1
    9650:	88 23       	and	r24, r24
    9652:	a1 f1       	breq	.+104    	; 0x96bc <__fpcmp_parts_f+0xaa>
    9654:	2d c0       	rjmp	.+90     	; 0x96b0 <__fpcmp_parts_f+0x9e>
    9656:	61 81       	ldd	r22, Z+1	; 0x01
    9658:	82 30       	cpi	r24, 0x02	; 2
    965a:	01 f1       	breq	.+64     	; 0x969c <__fpcmp_parts_f+0x8a>
    965c:	11 96       	adiw	r26, 0x01	; 1
    965e:	8c 91       	ld	r24, X
    9660:	11 97       	sbiw	r26, 0x01	; 1
    9662:	68 17       	cp	r22, r24
    9664:	d9 f4       	brne	.+54     	; 0x969c <__fpcmp_parts_f+0x8a>
    9666:	22 81       	ldd	r18, Z+2	; 0x02
    9668:	33 81       	ldd	r19, Z+3	; 0x03
    966a:	12 96       	adiw	r26, 0x02	; 2
    966c:	8d 91       	ld	r24, X+
    966e:	9c 91       	ld	r25, X
    9670:	13 97       	sbiw	r26, 0x03	; 3
    9672:	82 17       	cp	r24, r18
    9674:	93 07       	cpc	r25, r19
    9676:	94 f0       	brlt	.+36     	; 0x969c <__fpcmp_parts_f+0x8a>
    9678:	28 17       	cp	r18, r24
    967a:	39 07       	cpc	r19, r25
    967c:	bc f0       	brlt	.+46     	; 0x96ac <__fpcmp_parts_f+0x9a>
    967e:	24 81       	ldd	r18, Z+4	; 0x04
    9680:	35 81       	ldd	r19, Z+5	; 0x05
    9682:	46 81       	ldd	r20, Z+6	; 0x06
    9684:	57 81       	ldd	r21, Z+7	; 0x07
    9686:	14 96       	adiw	r26, 0x04	; 4
    9688:	8d 91       	ld	r24, X+
    968a:	9d 91       	ld	r25, X+
    968c:	0d 90       	ld	r0, X+
    968e:	bc 91       	ld	r27, X
    9690:	a0 2d       	mov	r26, r0
    9692:	82 17       	cp	r24, r18
    9694:	93 07       	cpc	r25, r19
    9696:	a4 07       	cpc	r26, r20
    9698:	b5 07       	cpc	r27, r21
    969a:	18 f4       	brcc	.+6      	; 0x96a2 <__fpcmp_parts_f+0x90>
    969c:	66 23       	and	r22, r22
    969e:	41 f0       	breq	.+16     	; 0x96b0 <__fpcmp_parts_f+0x9e>
    96a0:	0d c0       	rjmp	.+26     	; 0x96bc <__fpcmp_parts_f+0xaa>
    96a2:	28 17       	cp	r18, r24
    96a4:	39 07       	cpc	r19, r25
    96a6:	4a 07       	cpc	r20, r26
    96a8:	5b 07       	cpc	r21, r27
    96aa:	28 f4       	brcc	.+10     	; 0x96b6 <__fpcmp_parts_f+0xa4>
    96ac:	66 23       	and	r22, r22
    96ae:	31 f0       	breq	.+12     	; 0x96bc <__fpcmp_parts_f+0xaa>
    96b0:	21 e0       	ldi	r18, 0x01	; 1
    96b2:	30 e0       	ldi	r19, 0x00	; 0
    96b4:	05 c0       	rjmp	.+10     	; 0x96c0 <__fpcmp_parts_f+0xae>
    96b6:	20 e0       	ldi	r18, 0x00	; 0
    96b8:	30 e0       	ldi	r19, 0x00	; 0
    96ba:	02 c0       	rjmp	.+4      	; 0x96c0 <__fpcmp_parts_f+0xae>
    96bc:	2f ef       	ldi	r18, 0xFF	; 255
    96be:	3f ef       	ldi	r19, 0xFF	; 255
    96c0:	c9 01       	movw	r24, r18
    96c2:	08 95       	ret

000096c4 <__udivmodhi4>:
    96c4:	aa 1b       	sub	r26, r26
    96c6:	bb 1b       	sub	r27, r27
    96c8:	51 e1       	ldi	r21, 0x11	; 17
    96ca:	07 c0       	rjmp	.+14     	; 0x96da <__udivmodhi4_ep>

000096cc <__udivmodhi4_loop>:
    96cc:	aa 1f       	adc	r26, r26
    96ce:	bb 1f       	adc	r27, r27
    96d0:	a6 17       	cp	r26, r22
    96d2:	b7 07       	cpc	r27, r23
    96d4:	10 f0       	brcs	.+4      	; 0x96da <__udivmodhi4_ep>
    96d6:	a6 1b       	sub	r26, r22
    96d8:	b7 0b       	sbc	r27, r23

000096da <__udivmodhi4_ep>:
    96da:	88 1f       	adc	r24, r24
    96dc:	99 1f       	adc	r25, r25
    96de:	5a 95       	dec	r21
    96e0:	a9 f7       	brne	.-22     	; 0x96cc <__udivmodhi4_loop>
    96e2:	80 95       	com	r24
    96e4:	90 95       	com	r25
    96e6:	bc 01       	movw	r22, r24
    96e8:	cd 01       	movw	r24, r26
    96ea:	08 95       	ret

000096ec <__divmodhi4>:
    96ec:	97 fb       	bst	r25, 7
    96ee:	09 2e       	mov	r0, r25
    96f0:	07 26       	eor	r0, r23
    96f2:	0a d0       	rcall	.+20     	; 0x9708 <__divmodhi4_neg1>
    96f4:	77 fd       	sbrc	r23, 7
    96f6:	04 d0       	rcall	.+8      	; 0x9700 <__divmodhi4_neg2>
    96f8:	e5 df       	rcall	.-54     	; 0x96c4 <__udivmodhi4>
    96fa:	06 d0       	rcall	.+12     	; 0x9708 <__divmodhi4_neg1>
    96fc:	00 20       	and	r0, r0
    96fe:	1a f4       	brpl	.+6      	; 0x9706 <__divmodhi4_exit>

00009700 <__divmodhi4_neg2>:
    9700:	70 95       	com	r23
    9702:	61 95       	neg	r22
    9704:	7f 4f       	sbci	r23, 0xFF	; 255

00009706 <__divmodhi4_exit>:
    9706:	08 95       	ret

00009708 <__divmodhi4_neg1>:
    9708:	f6 f7       	brtc	.-4      	; 0x9706 <__divmodhi4_exit>
    970a:	90 95       	com	r25
    970c:	81 95       	neg	r24
    970e:	9f 4f       	sbci	r25, 0xFF	; 255
    9710:	08 95       	ret

00009712 <__udivmodsi4>:
    9712:	a1 e2       	ldi	r26, 0x21	; 33
    9714:	1a 2e       	mov	r1, r26
    9716:	aa 1b       	sub	r26, r26
    9718:	bb 1b       	sub	r27, r27
    971a:	fd 01       	movw	r30, r26
    971c:	0d c0       	rjmp	.+26     	; 0x9738 <__udivmodsi4_ep>

0000971e <__udivmodsi4_loop>:
    971e:	aa 1f       	adc	r26, r26
    9720:	bb 1f       	adc	r27, r27
    9722:	ee 1f       	adc	r30, r30
    9724:	ff 1f       	adc	r31, r31
    9726:	a2 17       	cp	r26, r18
    9728:	b3 07       	cpc	r27, r19
    972a:	e4 07       	cpc	r30, r20
    972c:	f5 07       	cpc	r31, r21
    972e:	20 f0       	brcs	.+8      	; 0x9738 <__udivmodsi4_ep>
    9730:	a2 1b       	sub	r26, r18
    9732:	b3 0b       	sbc	r27, r19
    9734:	e4 0b       	sbc	r30, r20
    9736:	f5 0b       	sbc	r31, r21

00009738 <__udivmodsi4_ep>:
    9738:	66 1f       	adc	r22, r22
    973a:	77 1f       	adc	r23, r23
    973c:	88 1f       	adc	r24, r24
    973e:	99 1f       	adc	r25, r25
    9740:	1a 94       	dec	r1
    9742:	69 f7       	brne	.-38     	; 0x971e <__udivmodsi4_loop>
    9744:	60 95       	com	r22
    9746:	70 95       	com	r23
    9748:	80 95       	com	r24
    974a:	90 95       	com	r25
    974c:	9b 01       	movw	r18, r22
    974e:	ac 01       	movw	r20, r24
    9750:	bd 01       	movw	r22, r26
    9752:	cf 01       	movw	r24, r30
    9754:	08 95       	ret

00009756 <__prologue_saves__>:
    9756:	2f 92       	push	r2
    9758:	3f 92       	push	r3
    975a:	4f 92       	push	r4
    975c:	5f 92       	push	r5
    975e:	6f 92       	push	r6
    9760:	7f 92       	push	r7
    9762:	8f 92       	push	r8
    9764:	9f 92       	push	r9
    9766:	af 92       	push	r10
    9768:	bf 92       	push	r11
    976a:	cf 92       	push	r12
    976c:	df 92       	push	r13
    976e:	ef 92       	push	r14
    9770:	ff 92       	push	r15
    9772:	0f 93       	push	r16
    9774:	1f 93       	push	r17
    9776:	cf 93       	push	r28
    9778:	df 93       	push	r29
    977a:	cd b7       	in	r28, 0x3d	; 61
    977c:	de b7       	in	r29, 0x3e	; 62
    977e:	ca 1b       	sub	r28, r26
    9780:	db 0b       	sbc	r29, r27
    9782:	0f b6       	in	r0, 0x3f	; 63
    9784:	f8 94       	cli
    9786:	de bf       	out	0x3e, r29	; 62
    9788:	0f be       	out	0x3f, r0	; 63
    978a:	cd bf       	out	0x3d, r28	; 61
    978c:	09 94       	ijmp

0000978e <__epilogue_restores__>:
    978e:	2a 88       	ldd	r2, Y+18	; 0x12
    9790:	39 88       	ldd	r3, Y+17	; 0x11
    9792:	48 88       	ldd	r4, Y+16	; 0x10
    9794:	5f 84       	ldd	r5, Y+15	; 0x0f
    9796:	6e 84       	ldd	r6, Y+14	; 0x0e
    9798:	7d 84       	ldd	r7, Y+13	; 0x0d
    979a:	8c 84       	ldd	r8, Y+12	; 0x0c
    979c:	9b 84       	ldd	r9, Y+11	; 0x0b
    979e:	aa 84       	ldd	r10, Y+10	; 0x0a
    97a0:	b9 84       	ldd	r11, Y+9	; 0x09
    97a2:	c8 84       	ldd	r12, Y+8	; 0x08
    97a4:	df 80       	ldd	r13, Y+7	; 0x07
    97a6:	ee 80       	ldd	r14, Y+6	; 0x06
    97a8:	fd 80       	ldd	r15, Y+5	; 0x05
    97aa:	0c 81       	ldd	r16, Y+4	; 0x04
    97ac:	1b 81       	ldd	r17, Y+3	; 0x03
    97ae:	aa 81       	ldd	r26, Y+2	; 0x02
    97b0:	b9 81       	ldd	r27, Y+1	; 0x01
    97b2:	ce 0f       	add	r28, r30
    97b4:	d1 1d       	adc	r29, r1
    97b6:	0f b6       	in	r0, 0x3f	; 63
    97b8:	f8 94       	cli
    97ba:	de bf       	out	0x3e, r29	; 62
    97bc:	0f be       	out	0x3f, r0	; 63
    97be:	cd bf       	out	0x3d, r28	; 61
    97c0:	ed 01       	movw	r28, r26
    97c2:	08 95       	ret

000097c4 <do_rand>:
    97c4:	af 92       	push	r10
    97c6:	bf 92       	push	r11
    97c8:	cf 92       	push	r12
    97ca:	df 92       	push	r13
    97cc:	ef 92       	push	r14
    97ce:	ff 92       	push	r15
    97d0:	0f 93       	push	r16
    97d2:	1f 93       	push	r17
    97d4:	cf 93       	push	r28
    97d6:	df 93       	push	r29
    97d8:	ec 01       	movw	r28, r24
    97da:	68 81       	ld	r22, Y
    97dc:	79 81       	ldd	r23, Y+1	; 0x01
    97de:	8a 81       	ldd	r24, Y+2	; 0x02
    97e0:	9b 81       	ldd	r25, Y+3	; 0x03
    97e2:	61 15       	cp	r22, r1
    97e4:	71 05       	cpc	r23, r1
    97e6:	81 05       	cpc	r24, r1
    97e8:	91 05       	cpc	r25, r1
    97ea:	21 f4       	brne	.+8      	; 0x97f4 <do_rand+0x30>
    97ec:	64 e2       	ldi	r22, 0x24	; 36
    97ee:	79 ed       	ldi	r23, 0xD9	; 217
    97f0:	8b e5       	ldi	r24, 0x5B	; 91
    97f2:	97 e0       	ldi	r25, 0x07	; 7
    97f4:	2d e1       	ldi	r18, 0x1D	; 29
    97f6:	33 ef       	ldi	r19, 0xF3	; 243
    97f8:	41 e0       	ldi	r20, 0x01	; 1
    97fa:	50 e0       	ldi	r21, 0x00	; 0
    97fc:	0e 94 95 50 	call	0xa12a	; 0xa12a <__divmodsi4>
    9800:	79 01       	movw	r14, r18
    9802:	8a 01       	movw	r16, r20
    9804:	27 ea       	ldi	r18, 0xA7	; 167
    9806:	31 e4       	ldi	r19, 0x41	; 65
    9808:	40 e0       	ldi	r20, 0x00	; 0
    980a:	50 e0       	ldi	r21, 0x00	; 0
    980c:	0e 94 76 50 	call	0xa0ec	; 0xa0ec <__mulsi3>
    9810:	5b 01       	movw	r10, r22
    9812:	6c 01       	movw	r12, r24
    9814:	c8 01       	movw	r24, r16
    9816:	b7 01       	movw	r22, r14
    9818:	2c ee       	ldi	r18, 0xEC	; 236
    981a:	34 ef       	ldi	r19, 0xF4	; 244
    981c:	4f ef       	ldi	r20, 0xFF	; 255
    981e:	5f ef       	ldi	r21, 0xFF	; 255
    9820:	0e 94 76 50 	call	0xa0ec	; 0xa0ec <__mulsi3>
    9824:	6a 0d       	add	r22, r10
    9826:	7b 1d       	adc	r23, r11
    9828:	8c 1d       	adc	r24, r12
    982a:	9d 1d       	adc	r25, r13
    982c:	97 ff       	sbrs	r25, 7
    982e:	04 c0       	rjmp	.+8      	; 0x9838 <do_rand+0x74>
    9830:	61 50       	subi	r22, 0x01	; 1
    9832:	70 40       	sbci	r23, 0x00	; 0
    9834:	80 40       	sbci	r24, 0x00	; 0
    9836:	90 48       	sbci	r25, 0x80	; 128
    9838:	68 83       	st	Y, r22
    983a:	79 83       	std	Y+1, r23	; 0x01
    983c:	8a 83       	std	Y+2, r24	; 0x02
    983e:	9b 83       	std	Y+3, r25	; 0x03
    9840:	7f 77       	andi	r23, 0x7F	; 127
    9842:	cb 01       	movw	r24, r22
    9844:	df 91       	pop	r29
    9846:	cf 91       	pop	r28
    9848:	1f 91       	pop	r17
    984a:	0f 91       	pop	r16
    984c:	ff 90       	pop	r15
    984e:	ef 90       	pop	r14
    9850:	df 90       	pop	r13
    9852:	cf 90       	pop	r12
    9854:	bf 90       	pop	r11
    9856:	af 90       	pop	r10
    9858:	08 95       	ret

0000985a <rand_r>:
    985a:	0e 94 e2 4b 	call	0x97c4	; 0x97c4 <do_rand>
    985e:	08 95       	ret

00009860 <rand>:
    9860:	85 ed       	ldi	r24, 0xD5	; 213
    9862:	9f e0       	ldi	r25, 0x0F	; 15
    9864:	0e 94 e2 4b 	call	0x97c4	; 0x97c4 <do_rand>
    9868:	08 95       	ret

0000986a <srand>:
    986a:	a0 e0       	ldi	r26, 0x00	; 0
    986c:	b0 e0       	ldi	r27, 0x00	; 0
    986e:	80 93 d5 0f 	sts	0x0FD5, r24
    9872:	90 93 d6 0f 	sts	0x0FD6, r25
    9876:	a0 93 d7 0f 	sts	0x0FD7, r26
    987a:	b0 93 d8 0f 	sts	0x0FD8, r27
    987e:	08 95       	ret

00009880 <memcmp>:
    9880:	fb 01       	movw	r30, r22
    9882:	dc 01       	movw	r26, r24
    9884:	04 c0       	rjmp	.+8      	; 0x988e <memcmp+0xe>
    9886:	8d 91       	ld	r24, X+
    9888:	01 90       	ld	r0, Z+
    988a:	80 19       	sub	r24, r0
    988c:	21 f4       	brne	.+8      	; 0x9896 <memcmp+0x16>
    988e:	41 50       	subi	r20, 0x01	; 1
    9890:	50 40       	sbci	r21, 0x00	; 0
    9892:	c8 f7       	brcc	.-14     	; 0x9886 <memcmp+0x6>
    9894:	88 1b       	sub	r24, r24
    9896:	99 0b       	sbc	r25, r25
    9898:	08 95       	ret

0000989a <memcpy>:
    989a:	fb 01       	movw	r30, r22
    989c:	dc 01       	movw	r26, r24
    989e:	02 c0       	rjmp	.+4      	; 0x98a4 <memcpy+0xa>
    98a0:	01 90       	ld	r0, Z+
    98a2:	0d 92       	st	X+, r0
    98a4:	41 50       	subi	r20, 0x01	; 1
    98a6:	50 40       	sbci	r21, 0x00	; 0
    98a8:	d8 f7       	brcc	.-10     	; 0x98a0 <memcpy+0x6>
    98aa:	08 95       	ret

000098ac <memset>:
    98ac:	dc 01       	movw	r26, r24
    98ae:	01 c0       	rjmp	.+2      	; 0x98b2 <memset+0x6>
    98b0:	6d 93       	st	X+, r22
    98b2:	41 50       	subi	r20, 0x01	; 1
    98b4:	50 40       	sbci	r21, 0x00	; 0
    98b6:	e0 f7       	brcc	.-8      	; 0x98b0 <memset+0x4>
    98b8:	08 95       	ret

000098ba <strncmp>:
    98ba:	fb 01       	movw	r30, r22
    98bc:	dc 01       	movw	r26, r24
    98be:	41 50       	subi	r20, 0x01	; 1
    98c0:	50 40       	sbci	r21, 0x00	; 0
    98c2:	30 f0       	brcs	.+12     	; 0x98d0 <strncmp+0x16>
    98c4:	8d 91       	ld	r24, X+
    98c6:	01 90       	ld	r0, Z+
    98c8:	80 19       	sub	r24, r0
    98ca:	19 f4       	brne	.+6      	; 0x98d2 <strncmp+0x18>
    98cc:	00 20       	and	r0, r0
    98ce:	b9 f7       	brne	.-18     	; 0x98be <strncmp+0x4>
    98d0:	88 1b       	sub	r24, r24
    98d2:	99 0b       	sbc	r25, r25
    98d4:	08 95       	ret

000098d6 <strnlen>:
    98d6:	fc 01       	movw	r30, r24
    98d8:	61 50       	subi	r22, 0x01	; 1
    98da:	70 40       	sbci	r23, 0x00	; 0
    98dc:	01 90       	ld	r0, Z+
    98de:	01 10       	cpse	r0, r1
    98e0:	d8 f7       	brcc	.-10     	; 0x98d8 <strnlen+0x2>
    98e2:	80 95       	com	r24
    98e4:	90 95       	com	r25
    98e6:	8e 0f       	add	r24, r30
    98e8:	9f 1f       	adc	r25, r31
    98ea:	08 95       	ret

000098ec <fputc>:
    98ec:	0f 93       	push	r16
    98ee:	1f 93       	push	r17
    98f0:	cf 93       	push	r28
    98f2:	df 93       	push	r29
    98f4:	8c 01       	movw	r16, r24
    98f6:	eb 01       	movw	r28, r22
    98f8:	8b 81       	ldd	r24, Y+3	; 0x03
    98fa:	81 ff       	sbrs	r24, 1
    98fc:	1b c0       	rjmp	.+54     	; 0x9934 <fputc+0x48>
    98fe:	82 ff       	sbrs	r24, 2
    9900:	0d c0       	rjmp	.+26     	; 0x991c <fputc+0x30>
    9902:	2e 81       	ldd	r18, Y+6	; 0x06
    9904:	3f 81       	ldd	r19, Y+7	; 0x07
    9906:	8c 81       	ldd	r24, Y+4	; 0x04
    9908:	9d 81       	ldd	r25, Y+5	; 0x05
    990a:	28 17       	cp	r18, r24
    990c:	39 07       	cpc	r19, r25
    990e:	64 f4       	brge	.+24     	; 0x9928 <fputc+0x3c>
    9910:	e8 81       	ld	r30, Y
    9912:	f9 81       	ldd	r31, Y+1	; 0x01
    9914:	01 93       	st	Z+, r16
    9916:	f9 83       	std	Y+1, r31	; 0x01
    9918:	e8 83       	st	Y, r30
    991a:	06 c0       	rjmp	.+12     	; 0x9928 <fputc+0x3c>
    991c:	e8 85       	ldd	r30, Y+8	; 0x08
    991e:	f9 85       	ldd	r31, Y+9	; 0x09
    9920:	80 2f       	mov	r24, r16
    9922:	09 95       	icall
    9924:	00 97       	sbiw	r24, 0x00	; 0
    9926:	31 f4       	brne	.+12     	; 0x9934 <fputc+0x48>
    9928:	8e 81       	ldd	r24, Y+6	; 0x06
    992a:	9f 81       	ldd	r25, Y+7	; 0x07
    992c:	01 96       	adiw	r24, 0x01	; 1
    992e:	9f 83       	std	Y+7, r25	; 0x07
    9930:	8e 83       	std	Y+6, r24	; 0x06
    9932:	02 c0       	rjmp	.+4      	; 0x9938 <fputc+0x4c>
    9934:	0f ef       	ldi	r16, 0xFF	; 255
    9936:	1f ef       	ldi	r17, 0xFF	; 255
    9938:	c8 01       	movw	r24, r16
    993a:	df 91       	pop	r29
    993c:	cf 91       	pop	r28
    993e:	1f 91       	pop	r17
    9940:	0f 91       	pop	r16
    9942:	08 95       	ret

00009944 <fread>:
    9944:	8f 92       	push	r8
    9946:	9f 92       	push	r9
    9948:	af 92       	push	r10
    994a:	bf 92       	push	r11
    994c:	cf 92       	push	r12
    994e:	df 92       	push	r13
    9950:	ef 92       	push	r14
    9952:	ff 92       	push	r15
    9954:	0f 93       	push	r16
    9956:	1f 93       	push	r17
    9958:	cf 93       	push	r28
    995a:	df 93       	push	r29
    995c:	4b 01       	movw	r8, r22
    995e:	5a 01       	movw	r10, r20
    9960:	79 01       	movw	r14, r18
    9962:	f9 01       	movw	r30, r18
    9964:	23 81       	ldd	r18, Z+3	; 0x03
    9966:	20 ff       	sbrs	r18, 0
    9968:	1b c0       	rjmp	.+54     	; 0x99a0 <fread+0x5c>
    996a:	c8 2e       	mov	r12, r24
    996c:	d9 2e       	mov	r13, r25
    996e:	c0 e0       	ldi	r28, 0x00	; 0
    9970:	d0 e0       	ldi	r29, 0x00	; 0
    9972:	10 c0       	rjmp	.+32     	; 0x9994 <fread+0x50>
    9974:	c7 01       	movw	r24, r14
    9976:	0e 94 d6 4f 	call	0x9fac	; 0x9fac <fgetc>
    997a:	ff ef       	ldi	r31, 0xFF	; 255
    997c:	8f 3f       	cpi	r24, 0xFF	; 255
    997e:	9f 07       	cpc	r25, r31
    9980:	89 f0       	breq	.+34     	; 0x99a4 <fread+0x60>
    9982:	f6 01       	movw	r30, r12
    9984:	81 93       	st	Z+, r24
    9986:	6f 01       	movw	r12, r30
    9988:	0f 5f       	subi	r16, 0xFF	; 255
    998a:	1f 4f       	sbci	r17, 0xFF	; 255
    998c:	08 15       	cp	r16, r8
    998e:	19 05       	cpc	r17, r9
    9990:	88 f3       	brcs	.-30     	; 0x9974 <fread+0x30>
    9992:	21 96       	adiw	r28, 0x01	; 1
    9994:	ca 15       	cp	r28, r10
    9996:	db 05       	cpc	r29, r11
    9998:	28 f4       	brcc	.+10     	; 0x99a4 <fread+0x60>
    999a:	00 e0       	ldi	r16, 0x00	; 0
    999c:	10 e0       	ldi	r17, 0x00	; 0
    999e:	f6 cf       	rjmp	.-20     	; 0x998c <fread+0x48>
    99a0:	c0 e0       	ldi	r28, 0x00	; 0
    99a2:	d0 e0       	ldi	r29, 0x00	; 0
    99a4:	ce 01       	movw	r24, r28
    99a6:	df 91       	pop	r29
    99a8:	cf 91       	pop	r28
    99aa:	1f 91       	pop	r17
    99ac:	0f 91       	pop	r16
    99ae:	ff 90       	pop	r15
    99b0:	ef 90       	pop	r14
    99b2:	df 90       	pop	r13
    99b4:	cf 90       	pop	r12
    99b6:	bf 90       	pop	r11
    99b8:	af 90       	pop	r10
    99ba:	9f 90       	pop	r9
    99bc:	8f 90       	pop	r8
    99be:	08 95       	ret

000099c0 <printf>:
    99c0:	df 93       	push	r29
    99c2:	cf 93       	push	r28
    99c4:	cd b7       	in	r28, 0x3d	; 61
    99c6:	de b7       	in	r29, 0x3e	; 62
    99c8:	fe 01       	movw	r30, r28
    99ca:	35 96       	adiw	r30, 0x05	; 5
    99cc:	61 91       	ld	r22, Z+
    99ce:	71 91       	ld	r23, Z+
    99d0:	80 91 dd 2d 	lds	r24, 0x2DDD
    99d4:	90 91 de 2d 	lds	r25, 0x2DDE
    99d8:	af 01       	movw	r20, r30
    99da:	0e 94 80 4d 	call	0x9b00	; 0x9b00 <vfprintf>
    99de:	cf 91       	pop	r28
    99e0:	df 91       	pop	r29
    99e2:	08 95       	ret

000099e4 <printf_P>:
    99e4:	df 93       	push	r29
    99e6:	cf 93       	push	r28
    99e8:	cd b7       	in	r28, 0x3d	; 61
    99ea:	de b7       	in	r29, 0x3e	; 62
    99ec:	fe 01       	movw	r30, r28
    99ee:	35 96       	adiw	r30, 0x05	; 5
    99f0:	61 91       	ld	r22, Z+
    99f2:	71 91       	ld	r23, Z+
    99f4:	80 91 dd 2d 	lds	r24, 0x2DDD
    99f8:	90 91 de 2d 	lds	r25, 0x2DDE
    99fc:	dc 01       	movw	r26, r24
    99fe:	13 96       	adiw	r26, 0x03	; 3
    9a00:	2c 91       	ld	r18, X
    9a02:	13 97       	sbiw	r26, 0x03	; 3
    9a04:	28 60       	ori	r18, 0x08	; 8
    9a06:	13 96       	adiw	r26, 0x03	; 3
    9a08:	2c 93       	st	X, r18
    9a0a:	af 01       	movw	r20, r30
    9a0c:	0e 94 80 4d 	call	0x9b00	; 0x9b00 <vfprintf>
    9a10:	e0 91 dd 2d 	lds	r30, 0x2DDD
    9a14:	f0 91 de 2d 	lds	r31, 0x2DDE
    9a18:	23 81       	ldd	r18, Z+3	; 0x03
    9a1a:	27 7f       	andi	r18, 0xF7	; 247
    9a1c:	23 83       	std	Z+3, r18	; 0x03
    9a1e:	cf 91       	pop	r28
    9a20:	df 91       	pop	r29
    9a22:	08 95       	ret

00009a24 <putchar>:
    9a24:	60 91 dd 2d 	lds	r22, 0x2DDD
    9a28:	70 91 de 2d 	lds	r23, 0x2DDE
    9a2c:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9a30:	08 95       	ret

00009a32 <puts>:
    9a32:	ef 92       	push	r14
    9a34:	ff 92       	push	r15
    9a36:	0f 93       	push	r16
    9a38:	1f 93       	push	r17
    9a3a:	cf 93       	push	r28
    9a3c:	df 93       	push	r29
    9a3e:	8c 01       	movw	r16, r24
    9a40:	e0 91 dd 2d 	lds	r30, 0x2DDD
    9a44:	f0 91 de 2d 	lds	r31, 0x2DDE
    9a48:	83 81       	ldd	r24, Z+3	; 0x03
    9a4a:	81 ff       	sbrs	r24, 1
    9a4c:	1f c0       	rjmp	.+62     	; 0x9a8c <puts+0x5a>
    9a4e:	c0 e0       	ldi	r28, 0x00	; 0
    9a50:	d0 e0       	ldi	r29, 0x00	; 0
    9a52:	0a c0       	rjmp	.+20     	; 0x9a68 <puts+0x36>
    9a54:	db 01       	movw	r26, r22
    9a56:	18 96       	adiw	r26, 0x08	; 8
    9a58:	ed 91       	ld	r30, X+
    9a5a:	fc 91       	ld	r31, X
    9a5c:	19 97       	sbiw	r26, 0x09	; 9
    9a5e:	09 95       	icall
    9a60:	00 97       	sbiw	r24, 0x00	; 0
    9a62:	11 f0       	breq	.+4      	; 0x9a68 <puts+0x36>
    9a64:	cf ef       	ldi	r28, 0xFF	; 255
    9a66:	df ef       	ldi	r29, 0xFF	; 255
    9a68:	f8 01       	movw	r30, r16
    9a6a:	81 91       	ld	r24, Z+
    9a6c:	8f 01       	movw	r16, r30
    9a6e:	60 91 dd 2d 	lds	r22, 0x2DDD
    9a72:	70 91 de 2d 	lds	r23, 0x2DDE
    9a76:	88 23       	and	r24, r24
    9a78:	69 f7       	brne	.-38     	; 0x9a54 <puts+0x22>
    9a7a:	db 01       	movw	r26, r22
    9a7c:	18 96       	adiw	r26, 0x08	; 8
    9a7e:	ed 91       	ld	r30, X+
    9a80:	fc 91       	ld	r31, X
    9a82:	19 97       	sbiw	r26, 0x09	; 9
    9a84:	8a e0       	ldi	r24, 0x0A	; 10
    9a86:	09 95       	icall
    9a88:	00 97       	sbiw	r24, 0x00	; 0
    9a8a:	11 f0       	breq	.+4      	; 0x9a90 <puts+0x5e>
    9a8c:	cf ef       	ldi	r28, 0xFF	; 255
    9a8e:	df ef       	ldi	r29, 0xFF	; 255
    9a90:	ce 01       	movw	r24, r28
    9a92:	df 91       	pop	r29
    9a94:	cf 91       	pop	r28
    9a96:	1f 91       	pop	r17
    9a98:	0f 91       	pop	r16
    9a9a:	ff 90       	pop	r15
    9a9c:	ef 90       	pop	r14
    9a9e:	08 95       	ret

00009aa0 <sprintf>:
    9aa0:	0f 93       	push	r16
    9aa2:	1f 93       	push	r17
    9aa4:	df 93       	push	r29
    9aa6:	cf 93       	push	r28
    9aa8:	cd b7       	in	r28, 0x3d	; 61
    9aaa:	de b7       	in	r29, 0x3e	; 62
    9aac:	2e 97       	sbiw	r28, 0x0e	; 14
    9aae:	0f b6       	in	r0, 0x3f	; 63
    9ab0:	f8 94       	cli
    9ab2:	de bf       	out	0x3e, r29	; 62
    9ab4:	0f be       	out	0x3f, r0	; 63
    9ab6:	cd bf       	out	0x3d, r28	; 61
    9ab8:	0d 89       	ldd	r16, Y+21	; 0x15
    9aba:	1e 89       	ldd	r17, Y+22	; 0x16
    9abc:	86 e0       	ldi	r24, 0x06	; 6
    9abe:	8c 83       	std	Y+4, r24	; 0x04
    9ac0:	1a 83       	std	Y+2, r17	; 0x02
    9ac2:	09 83       	std	Y+1, r16	; 0x01
    9ac4:	8f ef       	ldi	r24, 0xFF	; 255
    9ac6:	9f e7       	ldi	r25, 0x7F	; 127
    9ac8:	9e 83       	std	Y+6, r25	; 0x06
    9aca:	8d 83       	std	Y+5, r24	; 0x05
    9acc:	9e 01       	movw	r18, r28
    9ace:	27 5e       	subi	r18, 0xE7	; 231
    9ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    9ad2:	ce 01       	movw	r24, r28
    9ad4:	01 96       	adiw	r24, 0x01	; 1
    9ad6:	6f 89       	ldd	r22, Y+23	; 0x17
    9ad8:	78 8d       	ldd	r23, Y+24	; 0x18
    9ada:	a9 01       	movw	r20, r18
    9adc:	0e 94 80 4d 	call	0x9b00	; 0x9b00 <vfprintf>
    9ae0:	ef 81       	ldd	r30, Y+7	; 0x07
    9ae2:	f8 85       	ldd	r31, Y+8	; 0x08
    9ae4:	e0 0f       	add	r30, r16
    9ae6:	f1 1f       	adc	r31, r17
    9ae8:	10 82       	st	Z, r1
    9aea:	2e 96       	adiw	r28, 0x0e	; 14
    9aec:	0f b6       	in	r0, 0x3f	; 63
    9aee:	f8 94       	cli
    9af0:	de bf       	out	0x3e, r29	; 62
    9af2:	0f be       	out	0x3f, r0	; 63
    9af4:	cd bf       	out	0x3d, r28	; 61
    9af6:	cf 91       	pop	r28
    9af8:	df 91       	pop	r29
    9afa:	1f 91       	pop	r17
    9afc:	0f 91       	pop	r16
    9afe:	08 95       	ret

00009b00 <vfprintf>:
    9b00:	2f 92       	push	r2
    9b02:	3f 92       	push	r3
    9b04:	4f 92       	push	r4
    9b06:	5f 92       	push	r5
    9b08:	6f 92       	push	r6
    9b0a:	7f 92       	push	r7
    9b0c:	8f 92       	push	r8
    9b0e:	9f 92       	push	r9
    9b10:	af 92       	push	r10
    9b12:	bf 92       	push	r11
    9b14:	cf 92       	push	r12
    9b16:	df 92       	push	r13
    9b18:	ef 92       	push	r14
    9b1a:	ff 92       	push	r15
    9b1c:	0f 93       	push	r16
    9b1e:	1f 93       	push	r17
    9b20:	df 93       	push	r29
    9b22:	cf 93       	push	r28
    9b24:	cd b7       	in	r28, 0x3d	; 61
    9b26:	de b7       	in	r29, 0x3e	; 62
    9b28:	2c 97       	sbiw	r28, 0x0c	; 12
    9b2a:	0f b6       	in	r0, 0x3f	; 63
    9b2c:	f8 94       	cli
    9b2e:	de bf       	out	0x3e, r29	; 62
    9b30:	0f be       	out	0x3f, r0	; 63
    9b32:	cd bf       	out	0x3d, r28	; 61
    9b34:	6c 01       	movw	r12, r24
    9b36:	1b 01       	movw	r2, r22
    9b38:	8a 01       	movw	r16, r20
    9b3a:	fc 01       	movw	r30, r24
    9b3c:	17 82       	std	Z+7, r1	; 0x07
    9b3e:	16 82       	std	Z+6, r1	; 0x06
    9b40:	83 81       	ldd	r24, Z+3	; 0x03
    9b42:	81 ff       	sbrs	r24, 1
    9b44:	d1 c1       	rjmp	.+930    	; 0x9ee8 <vfprintf+0x3e8>
    9b46:	2e 01       	movw	r4, r28
    9b48:	08 94       	sec
    9b4a:	41 1c       	adc	r4, r1
    9b4c:	51 1c       	adc	r5, r1
    9b4e:	f6 01       	movw	r30, r12
    9b50:	93 81       	ldd	r25, Z+3	; 0x03
    9b52:	f1 01       	movw	r30, r2
    9b54:	93 fd       	sbrc	r25, 3
    9b56:	85 91       	lpm	r24, Z+
    9b58:	93 ff       	sbrs	r25, 3
    9b5a:	81 91       	ld	r24, Z+
    9b5c:	1f 01       	movw	r2, r30
    9b5e:	88 23       	and	r24, r24
    9b60:	09 f4       	brne	.+2      	; 0x9b64 <vfprintf+0x64>
    9b62:	be c1       	rjmp	.+892    	; 0x9ee0 <vfprintf+0x3e0>
    9b64:	85 32       	cpi	r24, 0x25	; 37
    9b66:	39 f4       	brne	.+14     	; 0x9b76 <vfprintf+0x76>
    9b68:	93 fd       	sbrc	r25, 3
    9b6a:	85 91       	lpm	r24, Z+
    9b6c:	93 ff       	sbrs	r25, 3
    9b6e:	81 91       	ld	r24, Z+
    9b70:	1f 01       	movw	r2, r30
    9b72:	85 32       	cpi	r24, 0x25	; 37
    9b74:	29 f4       	brne	.+10     	; 0x9b80 <vfprintf+0x80>
    9b76:	90 e0       	ldi	r25, 0x00	; 0
    9b78:	b6 01       	movw	r22, r12
    9b7a:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9b7e:	e7 cf       	rjmp	.-50     	; 0x9b4e <vfprintf+0x4e>
    9b80:	ee 24       	eor	r14, r14
    9b82:	ff 24       	eor	r15, r15
    9b84:	20 e0       	ldi	r18, 0x00	; 0
    9b86:	20 32       	cpi	r18, 0x20	; 32
    9b88:	b0 f4       	brcc	.+44     	; 0x9bb6 <vfprintf+0xb6>
    9b8a:	8b 32       	cpi	r24, 0x2B	; 43
    9b8c:	69 f0       	breq	.+26     	; 0x9ba8 <vfprintf+0xa8>
    9b8e:	8c 32       	cpi	r24, 0x2C	; 44
    9b90:	28 f4       	brcc	.+10     	; 0x9b9c <vfprintf+0x9c>
    9b92:	80 32       	cpi	r24, 0x20	; 32
    9b94:	51 f0       	breq	.+20     	; 0x9baa <vfprintf+0xaa>
    9b96:	83 32       	cpi	r24, 0x23	; 35
    9b98:	71 f4       	brne	.+28     	; 0x9bb6 <vfprintf+0xb6>
    9b9a:	0b c0       	rjmp	.+22     	; 0x9bb2 <vfprintf+0xb2>
    9b9c:	8d 32       	cpi	r24, 0x2D	; 45
    9b9e:	39 f0       	breq	.+14     	; 0x9bae <vfprintf+0xae>
    9ba0:	80 33       	cpi	r24, 0x30	; 48
    9ba2:	49 f4       	brne	.+18     	; 0x9bb6 <vfprintf+0xb6>
    9ba4:	21 60       	ori	r18, 0x01	; 1
    9ba6:	2c c0       	rjmp	.+88     	; 0x9c00 <vfprintf+0x100>
    9ba8:	22 60       	ori	r18, 0x02	; 2
    9baa:	24 60       	ori	r18, 0x04	; 4
    9bac:	29 c0       	rjmp	.+82     	; 0x9c00 <vfprintf+0x100>
    9bae:	28 60       	ori	r18, 0x08	; 8
    9bb0:	27 c0       	rjmp	.+78     	; 0x9c00 <vfprintf+0x100>
    9bb2:	20 61       	ori	r18, 0x10	; 16
    9bb4:	25 c0       	rjmp	.+74     	; 0x9c00 <vfprintf+0x100>
    9bb6:	27 fd       	sbrc	r18, 7
    9bb8:	2c c0       	rjmp	.+88     	; 0x9c12 <vfprintf+0x112>
    9bba:	38 2f       	mov	r19, r24
    9bbc:	30 53       	subi	r19, 0x30	; 48
    9bbe:	3a 30       	cpi	r19, 0x0A	; 10
    9bc0:	98 f4       	brcc	.+38     	; 0x9be8 <vfprintf+0xe8>
    9bc2:	26 ff       	sbrs	r18, 6
    9bc4:	08 c0       	rjmp	.+16     	; 0x9bd6 <vfprintf+0xd6>
    9bc6:	8e 2d       	mov	r24, r14
    9bc8:	88 0f       	add	r24, r24
    9bca:	e8 2e       	mov	r14, r24
    9bcc:	ee 0c       	add	r14, r14
    9bce:	ee 0c       	add	r14, r14
    9bd0:	e8 0e       	add	r14, r24
    9bd2:	e3 0e       	add	r14, r19
    9bd4:	15 c0       	rjmp	.+42     	; 0x9c00 <vfprintf+0x100>
    9bd6:	8f 2d       	mov	r24, r15
    9bd8:	88 0f       	add	r24, r24
    9bda:	f8 2e       	mov	r15, r24
    9bdc:	ff 0c       	add	r15, r15
    9bde:	ff 0c       	add	r15, r15
    9be0:	f8 0e       	add	r15, r24
    9be2:	f3 0e       	add	r15, r19
    9be4:	20 62       	ori	r18, 0x20	; 32
    9be6:	0c c0       	rjmp	.+24     	; 0x9c00 <vfprintf+0x100>
    9be8:	8e 32       	cpi	r24, 0x2E	; 46
    9bea:	21 f4       	brne	.+8      	; 0x9bf4 <vfprintf+0xf4>
    9bec:	26 fd       	sbrc	r18, 6
    9bee:	78 c1       	rjmp	.+752    	; 0x9ee0 <vfprintf+0x3e0>
    9bf0:	20 64       	ori	r18, 0x40	; 64
    9bf2:	06 c0       	rjmp	.+12     	; 0x9c00 <vfprintf+0x100>
    9bf4:	8c 36       	cpi	r24, 0x6C	; 108
    9bf6:	11 f4       	brne	.+4      	; 0x9bfc <vfprintf+0xfc>
    9bf8:	20 68       	ori	r18, 0x80	; 128
    9bfa:	02 c0       	rjmp	.+4      	; 0x9c00 <vfprintf+0x100>
    9bfc:	88 36       	cpi	r24, 0x68	; 104
    9bfe:	49 f4       	brne	.+18     	; 0x9c12 <vfprintf+0x112>
    9c00:	f1 01       	movw	r30, r2
    9c02:	93 fd       	sbrc	r25, 3
    9c04:	85 91       	lpm	r24, Z+
    9c06:	93 ff       	sbrs	r25, 3
    9c08:	81 91       	ld	r24, Z+
    9c0a:	1f 01       	movw	r2, r30
    9c0c:	88 23       	and	r24, r24
    9c0e:	09 f0       	breq	.+2      	; 0x9c12 <vfprintf+0x112>
    9c10:	ba cf       	rjmp	.-140    	; 0x9b86 <vfprintf+0x86>
    9c12:	98 2f       	mov	r25, r24
    9c14:	95 54       	subi	r25, 0x45	; 69
    9c16:	93 30       	cpi	r25, 0x03	; 3
    9c18:	18 f0       	brcs	.+6      	; 0x9c20 <vfprintf+0x120>
    9c1a:	90 52       	subi	r25, 0x20	; 32
    9c1c:	93 30       	cpi	r25, 0x03	; 3
    9c1e:	28 f4       	brcc	.+10     	; 0x9c2a <vfprintf+0x12a>
    9c20:	0c 5f       	subi	r16, 0xFC	; 252
    9c22:	1f 4f       	sbci	r17, 0xFF	; 255
    9c24:	ff e3       	ldi	r31, 0x3F	; 63
    9c26:	f9 83       	std	Y+1, r31	; 0x01
    9c28:	0d c0       	rjmp	.+26     	; 0x9c44 <vfprintf+0x144>
    9c2a:	83 36       	cpi	r24, 0x63	; 99
    9c2c:	31 f0       	breq	.+12     	; 0x9c3a <vfprintf+0x13a>
    9c2e:	83 37       	cpi	r24, 0x73	; 115
    9c30:	71 f0       	breq	.+28     	; 0x9c4e <vfprintf+0x14e>
    9c32:	83 35       	cpi	r24, 0x53	; 83
    9c34:	09 f0       	breq	.+2      	; 0x9c38 <vfprintf+0x138>
    9c36:	60 c0       	rjmp	.+192    	; 0x9cf8 <vfprintf+0x1f8>
    9c38:	22 c0       	rjmp	.+68     	; 0x9c7e <vfprintf+0x17e>
    9c3a:	f8 01       	movw	r30, r16
    9c3c:	80 81       	ld	r24, Z
    9c3e:	89 83       	std	Y+1, r24	; 0x01
    9c40:	0e 5f       	subi	r16, 0xFE	; 254
    9c42:	1f 4f       	sbci	r17, 0xFF	; 255
    9c44:	42 01       	movw	r8, r4
    9c46:	71 e0       	ldi	r23, 0x01	; 1
    9c48:	a7 2e       	mov	r10, r23
    9c4a:	b1 2c       	mov	r11, r1
    9c4c:	16 c0       	rjmp	.+44     	; 0x9c7a <vfprintf+0x17a>
    9c4e:	62 e0       	ldi	r22, 0x02	; 2
    9c50:	66 2e       	mov	r6, r22
    9c52:	71 2c       	mov	r7, r1
    9c54:	60 0e       	add	r6, r16
    9c56:	71 1e       	adc	r7, r17
    9c58:	f8 01       	movw	r30, r16
    9c5a:	80 80       	ld	r8, Z
    9c5c:	91 80       	ldd	r9, Z+1	; 0x01
    9c5e:	26 ff       	sbrs	r18, 6
    9c60:	03 c0       	rjmp	.+6      	; 0x9c68 <vfprintf+0x168>
    9c62:	6e 2d       	mov	r22, r14
    9c64:	70 e0       	ldi	r23, 0x00	; 0
    9c66:	02 c0       	rjmp	.+4      	; 0x9c6c <vfprintf+0x16c>
    9c68:	6f ef       	ldi	r22, 0xFF	; 255
    9c6a:	7f ef       	ldi	r23, 0xFF	; 255
    9c6c:	c4 01       	movw	r24, r8
    9c6e:	2c 87       	std	Y+12, r18	; 0x0c
    9c70:	0e 94 6b 4c 	call	0x98d6	; 0x98d6 <strnlen>
    9c74:	5c 01       	movw	r10, r24
    9c76:	83 01       	movw	r16, r6
    9c78:	2c 85       	ldd	r18, Y+12	; 0x0c
    9c7a:	2f 77       	andi	r18, 0x7F	; 127
    9c7c:	17 c0       	rjmp	.+46     	; 0x9cac <vfprintf+0x1ac>
    9c7e:	52 e0       	ldi	r21, 0x02	; 2
    9c80:	65 2e       	mov	r6, r21
    9c82:	71 2c       	mov	r7, r1
    9c84:	60 0e       	add	r6, r16
    9c86:	71 1e       	adc	r7, r17
    9c88:	f8 01       	movw	r30, r16
    9c8a:	80 80       	ld	r8, Z
    9c8c:	91 80       	ldd	r9, Z+1	; 0x01
    9c8e:	26 ff       	sbrs	r18, 6
    9c90:	03 c0       	rjmp	.+6      	; 0x9c98 <vfprintf+0x198>
    9c92:	6e 2d       	mov	r22, r14
    9c94:	70 e0       	ldi	r23, 0x00	; 0
    9c96:	02 c0       	rjmp	.+4      	; 0x9c9c <vfprintf+0x19c>
    9c98:	6f ef       	ldi	r22, 0xFF	; 255
    9c9a:	7f ef       	ldi	r23, 0xFF	; 255
    9c9c:	c4 01       	movw	r24, r8
    9c9e:	2c 87       	std	Y+12, r18	; 0x0c
    9ca0:	0e 94 cb 4f 	call	0x9f96	; 0x9f96 <strnlen_P>
    9ca4:	5c 01       	movw	r10, r24
    9ca6:	2c 85       	ldd	r18, Y+12	; 0x0c
    9ca8:	20 68       	ori	r18, 0x80	; 128
    9caa:	83 01       	movw	r16, r6
    9cac:	23 fd       	sbrc	r18, 3
    9cae:	20 c0       	rjmp	.+64     	; 0x9cf0 <vfprintf+0x1f0>
    9cb0:	08 c0       	rjmp	.+16     	; 0x9cc2 <vfprintf+0x1c2>
    9cb2:	80 e2       	ldi	r24, 0x20	; 32
    9cb4:	90 e0       	ldi	r25, 0x00	; 0
    9cb6:	b6 01       	movw	r22, r12
    9cb8:	2c 87       	std	Y+12, r18	; 0x0c
    9cba:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9cbe:	fa 94       	dec	r15
    9cc0:	2c 85       	ldd	r18, Y+12	; 0x0c
    9cc2:	8f 2d       	mov	r24, r15
    9cc4:	90 e0       	ldi	r25, 0x00	; 0
    9cc6:	a8 16       	cp	r10, r24
    9cc8:	b9 06       	cpc	r11, r25
    9cca:	98 f3       	brcs	.-26     	; 0x9cb2 <vfprintf+0x1b2>
    9ccc:	11 c0       	rjmp	.+34     	; 0x9cf0 <vfprintf+0x1f0>
    9cce:	f4 01       	movw	r30, r8
    9cd0:	27 fd       	sbrc	r18, 7
    9cd2:	85 91       	lpm	r24, Z+
    9cd4:	27 ff       	sbrs	r18, 7
    9cd6:	81 91       	ld	r24, Z+
    9cd8:	4f 01       	movw	r8, r30
    9cda:	90 e0       	ldi	r25, 0x00	; 0
    9cdc:	b6 01       	movw	r22, r12
    9cde:	2c 87       	std	Y+12, r18	; 0x0c
    9ce0:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9ce4:	2c 85       	ldd	r18, Y+12	; 0x0c
    9ce6:	f1 10       	cpse	r15, r1
    9ce8:	fa 94       	dec	r15
    9cea:	08 94       	sec
    9cec:	a1 08       	sbc	r10, r1
    9cee:	b1 08       	sbc	r11, r1
    9cf0:	a1 14       	cp	r10, r1
    9cf2:	b1 04       	cpc	r11, r1
    9cf4:	61 f7       	brne	.-40     	; 0x9cce <vfprintf+0x1ce>
    9cf6:	f1 c0       	rjmp	.+482    	; 0x9eda <vfprintf+0x3da>
    9cf8:	84 36       	cpi	r24, 0x64	; 100
    9cfa:	11 f0       	breq	.+4      	; 0x9d00 <vfprintf+0x200>
    9cfc:	89 36       	cpi	r24, 0x69	; 105
    9cfe:	49 f5       	brne	.+82     	; 0x9d52 <vfprintf+0x252>
    9d00:	27 ff       	sbrs	r18, 7
    9d02:	08 c0       	rjmp	.+16     	; 0x9d14 <vfprintf+0x214>
    9d04:	f8 01       	movw	r30, r16
    9d06:	60 81       	ld	r22, Z
    9d08:	71 81       	ldd	r23, Z+1	; 0x01
    9d0a:	82 81       	ldd	r24, Z+2	; 0x02
    9d0c:	93 81       	ldd	r25, Z+3	; 0x03
    9d0e:	0c 5f       	subi	r16, 0xFC	; 252
    9d10:	1f 4f       	sbci	r17, 0xFF	; 255
    9d12:	09 c0       	rjmp	.+18     	; 0x9d26 <vfprintf+0x226>
    9d14:	f8 01       	movw	r30, r16
    9d16:	60 81       	ld	r22, Z
    9d18:	71 81       	ldd	r23, Z+1	; 0x01
    9d1a:	88 27       	eor	r24, r24
    9d1c:	77 fd       	sbrc	r23, 7
    9d1e:	80 95       	com	r24
    9d20:	98 2f       	mov	r25, r24
    9d22:	0e 5f       	subi	r16, 0xFE	; 254
    9d24:	1f 4f       	sbci	r17, 0xFF	; 255
    9d26:	4f e6       	ldi	r20, 0x6F	; 111
    9d28:	b4 2e       	mov	r11, r20
    9d2a:	b2 22       	and	r11, r18
    9d2c:	97 ff       	sbrs	r25, 7
    9d2e:	09 c0       	rjmp	.+18     	; 0x9d42 <vfprintf+0x242>
    9d30:	90 95       	com	r25
    9d32:	80 95       	com	r24
    9d34:	70 95       	com	r23
    9d36:	61 95       	neg	r22
    9d38:	7f 4f       	sbci	r23, 0xFF	; 255
    9d3a:	8f 4f       	sbci	r24, 0xFF	; 255
    9d3c:	9f 4f       	sbci	r25, 0xFF	; 255
    9d3e:	f0 e8       	ldi	r31, 0x80	; 128
    9d40:	bf 2a       	or	r11, r31
    9d42:	a2 01       	movw	r20, r4
    9d44:	2a e0       	ldi	r18, 0x0A	; 10
    9d46:	30 e0       	ldi	r19, 0x00	; 0
    9d48:	0e 94 18 50 	call	0xa030	; 0xa030 <__ultoa_invert>
    9d4c:	78 2e       	mov	r7, r24
    9d4e:	74 18       	sub	r7, r4
    9d50:	45 c0       	rjmp	.+138    	; 0x9ddc <vfprintf+0x2dc>
    9d52:	85 37       	cpi	r24, 0x75	; 117
    9d54:	31 f4       	brne	.+12     	; 0x9d62 <vfprintf+0x262>
    9d56:	3f ee       	ldi	r19, 0xEF	; 239
    9d58:	b3 2e       	mov	r11, r19
    9d5a:	b2 22       	and	r11, r18
    9d5c:	2a e0       	ldi	r18, 0x0A	; 10
    9d5e:	30 e0       	ldi	r19, 0x00	; 0
    9d60:	25 c0       	rjmp	.+74     	; 0x9dac <vfprintf+0x2ac>
    9d62:	99 ef       	ldi	r25, 0xF9	; 249
    9d64:	b9 2e       	mov	r11, r25
    9d66:	b2 22       	and	r11, r18
    9d68:	8f 36       	cpi	r24, 0x6F	; 111
    9d6a:	c1 f0       	breq	.+48     	; 0x9d9c <vfprintf+0x29c>
    9d6c:	80 37       	cpi	r24, 0x70	; 112
    9d6e:	20 f4       	brcc	.+8      	; 0x9d78 <vfprintf+0x278>
    9d70:	88 35       	cpi	r24, 0x58	; 88
    9d72:	09 f0       	breq	.+2      	; 0x9d76 <vfprintf+0x276>
    9d74:	b5 c0       	rjmp	.+362    	; 0x9ee0 <vfprintf+0x3e0>
    9d76:	0d c0       	rjmp	.+26     	; 0x9d92 <vfprintf+0x292>
    9d78:	80 37       	cpi	r24, 0x70	; 112
    9d7a:	21 f0       	breq	.+8      	; 0x9d84 <vfprintf+0x284>
    9d7c:	88 37       	cpi	r24, 0x78	; 120
    9d7e:	09 f0       	breq	.+2      	; 0x9d82 <vfprintf+0x282>
    9d80:	af c0       	rjmp	.+350    	; 0x9ee0 <vfprintf+0x3e0>
    9d82:	02 c0       	rjmp	.+4      	; 0x9d88 <vfprintf+0x288>
    9d84:	20 e1       	ldi	r18, 0x10	; 16
    9d86:	b2 2a       	or	r11, r18
    9d88:	b4 fe       	sbrs	r11, 4
    9d8a:	0b c0       	rjmp	.+22     	; 0x9da2 <vfprintf+0x2a2>
    9d8c:	84 e0       	ldi	r24, 0x04	; 4
    9d8e:	b8 2a       	or	r11, r24
    9d90:	08 c0       	rjmp	.+16     	; 0x9da2 <vfprintf+0x2a2>
    9d92:	b4 fe       	sbrs	r11, 4
    9d94:	09 c0       	rjmp	.+18     	; 0x9da8 <vfprintf+0x2a8>
    9d96:	e6 e0       	ldi	r30, 0x06	; 6
    9d98:	be 2a       	or	r11, r30
    9d9a:	06 c0       	rjmp	.+12     	; 0x9da8 <vfprintf+0x2a8>
    9d9c:	28 e0       	ldi	r18, 0x08	; 8
    9d9e:	30 e0       	ldi	r19, 0x00	; 0
    9da0:	05 c0       	rjmp	.+10     	; 0x9dac <vfprintf+0x2ac>
    9da2:	20 e1       	ldi	r18, 0x10	; 16
    9da4:	30 e0       	ldi	r19, 0x00	; 0
    9da6:	02 c0       	rjmp	.+4      	; 0x9dac <vfprintf+0x2ac>
    9da8:	20 e1       	ldi	r18, 0x10	; 16
    9daa:	32 e0       	ldi	r19, 0x02	; 2
    9dac:	b7 fe       	sbrs	r11, 7
    9dae:	08 c0       	rjmp	.+16     	; 0x9dc0 <vfprintf+0x2c0>
    9db0:	f8 01       	movw	r30, r16
    9db2:	60 81       	ld	r22, Z
    9db4:	71 81       	ldd	r23, Z+1	; 0x01
    9db6:	82 81       	ldd	r24, Z+2	; 0x02
    9db8:	93 81       	ldd	r25, Z+3	; 0x03
    9dba:	0c 5f       	subi	r16, 0xFC	; 252
    9dbc:	1f 4f       	sbci	r17, 0xFF	; 255
    9dbe:	07 c0       	rjmp	.+14     	; 0x9dce <vfprintf+0x2ce>
    9dc0:	f8 01       	movw	r30, r16
    9dc2:	60 81       	ld	r22, Z
    9dc4:	71 81       	ldd	r23, Z+1	; 0x01
    9dc6:	80 e0       	ldi	r24, 0x00	; 0
    9dc8:	90 e0       	ldi	r25, 0x00	; 0
    9dca:	0e 5f       	subi	r16, 0xFE	; 254
    9dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    9dce:	a2 01       	movw	r20, r4
    9dd0:	0e 94 18 50 	call	0xa030	; 0xa030 <__ultoa_invert>
    9dd4:	78 2e       	mov	r7, r24
    9dd6:	74 18       	sub	r7, r4
    9dd8:	ff e7       	ldi	r31, 0x7F	; 127
    9dda:	bf 22       	and	r11, r31
    9ddc:	b6 fe       	sbrs	r11, 6
    9dde:	0b c0       	rjmp	.+22     	; 0x9df6 <vfprintf+0x2f6>
    9de0:	2e ef       	ldi	r18, 0xFE	; 254
    9de2:	b2 22       	and	r11, r18
    9de4:	7e 14       	cp	r7, r14
    9de6:	38 f4       	brcc	.+14     	; 0x9df6 <vfprintf+0x2f6>
    9de8:	b4 fe       	sbrs	r11, 4
    9dea:	07 c0       	rjmp	.+14     	; 0x9dfa <vfprintf+0x2fa>
    9dec:	b2 fc       	sbrc	r11, 2
    9dee:	05 c0       	rjmp	.+10     	; 0x9dfa <vfprintf+0x2fa>
    9df0:	8f ee       	ldi	r24, 0xEF	; 239
    9df2:	b8 22       	and	r11, r24
    9df4:	02 c0       	rjmp	.+4      	; 0x9dfa <vfprintf+0x2fa>
    9df6:	a7 2c       	mov	r10, r7
    9df8:	01 c0       	rjmp	.+2      	; 0x9dfc <vfprintf+0x2fc>
    9dfa:	ae 2c       	mov	r10, r14
    9dfc:	8b 2d       	mov	r24, r11
    9dfe:	90 e0       	ldi	r25, 0x00	; 0
    9e00:	b4 fe       	sbrs	r11, 4
    9e02:	0d c0       	rjmp	.+26     	; 0x9e1e <vfprintf+0x31e>
    9e04:	fe 01       	movw	r30, r28
    9e06:	e7 0d       	add	r30, r7
    9e08:	f1 1d       	adc	r31, r1
    9e0a:	20 81       	ld	r18, Z
    9e0c:	20 33       	cpi	r18, 0x30	; 48
    9e0e:	19 f4       	brne	.+6      	; 0x9e16 <vfprintf+0x316>
    9e10:	e9 ee       	ldi	r30, 0xE9	; 233
    9e12:	be 22       	and	r11, r30
    9e14:	09 c0       	rjmp	.+18     	; 0x9e28 <vfprintf+0x328>
    9e16:	a3 94       	inc	r10
    9e18:	b2 fe       	sbrs	r11, 2
    9e1a:	06 c0       	rjmp	.+12     	; 0x9e28 <vfprintf+0x328>
    9e1c:	04 c0       	rjmp	.+8      	; 0x9e26 <vfprintf+0x326>
    9e1e:	86 78       	andi	r24, 0x86	; 134
    9e20:	90 70       	andi	r25, 0x00	; 0
    9e22:	00 97       	sbiw	r24, 0x00	; 0
    9e24:	09 f0       	breq	.+2      	; 0x9e28 <vfprintf+0x328>
    9e26:	a3 94       	inc	r10
    9e28:	8b 2c       	mov	r8, r11
    9e2a:	99 24       	eor	r9, r9
    9e2c:	b3 fc       	sbrc	r11, 3
    9e2e:	14 c0       	rjmp	.+40     	; 0x9e58 <vfprintf+0x358>
    9e30:	b0 fe       	sbrs	r11, 0
    9e32:	0f c0       	rjmp	.+30     	; 0x9e52 <vfprintf+0x352>
    9e34:	af 14       	cp	r10, r15
    9e36:	28 f4       	brcc	.+10     	; 0x9e42 <vfprintf+0x342>
    9e38:	e7 2c       	mov	r14, r7
    9e3a:	ef 0c       	add	r14, r15
    9e3c:	ea 18       	sub	r14, r10
    9e3e:	af 2c       	mov	r10, r15
    9e40:	08 c0       	rjmp	.+16     	; 0x9e52 <vfprintf+0x352>
    9e42:	e7 2c       	mov	r14, r7
    9e44:	06 c0       	rjmp	.+12     	; 0x9e52 <vfprintf+0x352>
    9e46:	80 e2       	ldi	r24, 0x20	; 32
    9e48:	90 e0       	ldi	r25, 0x00	; 0
    9e4a:	b6 01       	movw	r22, r12
    9e4c:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9e50:	a3 94       	inc	r10
    9e52:	af 14       	cp	r10, r15
    9e54:	c0 f3       	brcs	.-16     	; 0x9e46 <vfprintf+0x346>
    9e56:	04 c0       	rjmp	.+8      	; 0x9e60 <vfprintf+0x360>
    9e58:	af 14       	cp	r10, r15
    9e5a:	10 f4       	brcc	.+4      	; 0x9e60 <vfprintf+0x360>
    9e5c:	fa 18       	sub	r15, r10
    9e5e:	01 c0       	rjmp	.+2      	; 0x9e62 <vfprintf+0x362>
    9e60:	ff 24       	eor	r15, r15
    9e62:	84 fe       	sbrs	r8, 4
    9e64:	0f c0       	rjmp	.+30     	; 0x9e84 <vfprintf+0x384>
    9e66:	80 e3       	ldi	r24, 0x30	; 48
    9e68:	90 e0       	ldi	r25, 0x00	; 0
    9e6a:	b6 01       	movw	r22, r12
    9e6c:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9e70:	82 fe       	sbrs	r8, 2
    9e72:	1f c0       	rjmp	.+62     	; 0x9eb2 <vfprintf+0x3b2>
    9e74:	81 fe       	sbrs	r8, 1
    9e76:	03 c0       	rjmp	.+6      	; 0x9e7e <vfprintf+0x37e>
    9e78:	88 e5       	ldi	r24, 0x58	; 88
    9e7a:	90 e0       	ldi	r25, 0x00	; 0
    9e7c:	10 c0       	rjmp	.+32     	; 0x9e9e <vfprintf+0x39e>
    9e7e:	88 e7       	ldi	r24, 0x78	; 120
    9e80:	90 e0       	ldi	r25, 0x00	; 0
    9e82:	0d c0       	rjmp	.+26     	; 0x9e9e <vfprintf+0x39e>
    9e84:	c4 01       	movw	r24, r8
    9e86:	86 78       	andi	r24, 0x86	; 134
    9e88:	90 70       	andi	r25, 0x00	; 0
    9e8a:	00 97       	sbiw	r24, 0x00	; 0
    9e8c:	91 f0       	breq	.+36     	; 0x9eb2 <vfprintf+0x3b2>
    9e8e:	81 fc       	sbrc	r8, 1
    9e90:	02 c0       	rjmp	.+4      	; 0x9e96 <vfprintf+0x396>
    9e92:	80 e2       	ldi	r24, 0x20	; 32
    9e94:	01 c0       	rjmp	.+2      	; 0x9e98 <vfprintf+0x398>
    9e96:	8b e2       	ldi	r24, 0x2B	; 43
    9e98:	b7 fc       	sbrc	r11, 7
    9e9a:	8d e2       	ldi	r24, 0x2D	; 45
    9e9c:	90 e0       	ldi	r25, 0x00	; 0
    9e9e:	b6 01       	movw	r22, r12
    9ea0:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9ea4:	06 c0       	rjmp	.+12     	; 0x9eb2 <vfprintf+0x3b2>
    9ea6:	80 e3       	ldi	r24, 0x30	; 48
    9ea8:	90 e0       	ldi	r25, 0x00	; 0
    9eaa:	b6 01       	movw	r22, r12
    9eac:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9eb0:	ea 94       	dec	r14
    9eb2:	7e 14       	cp	r7, r14
    9eb4:	c0 f3       	brcs	.-16     	; 0x9ea6 <vfprintf+0x3a6>
    9eb6:	7a 94       	dec	r7
    9eb8:	f2 01       	movw	r30, r4
    9eba:	e7 0d       	add	r30, r7
    9ebc:	f1 1d       	adc	r31, r1
    9ebe:	80 81       	ld	r24, Z
    9ec0:	90 e0       	ldi	r25, 0x00	; 0
    9ec2:	b6 01       	movw	r22, r12
    9ec4:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9ec8:	77 20       	and	r7, r7
    9eca:	a9 f7       	brne	.-22     	; 0x9eb6 <vfprintf+0x3b6>
    9ecc:	06 c0       	rjmp	.+12     	; 0x9eda <vfprintf+0x3da>
    9ece:	80 e2       	ldi	r24, 0x20	; 32
    9ed0:	90 e0       	ldi	r25, 0x00	; 0
    9ed2:	b6 01       	movw	r22, r12
    9ed4:	0e 94 76 4c 	call	0x98ec	; 0x98ec <fputc>
    9ed8:	fa 94       	dec	r15
    9eda:	ff 20       	and	r15, r15
    9edc:	c1 f7       	brne	.-16     	; 0x9ece <vfprintf+0x3ce>
    9ede:	37 ce       	rjmp	.-914    	; 0x9b4e <vfprintf+0x4e>
    9ee0:	f6 01       	movw	r30, r12
    9ee2:	26 81       	ldd	r18, Z+6	; 0x06
    9ee4:	37 81       	ldd	r19, Z+7	; 0x07
    9ee6:	02 c0       	rjmp	.+4      	; 0x9eec <vfprintf+0x3ec>
    9ee8:	2f ef       	ldi	r18, 0xFF	; 255
    9eea:	3f ef       	ldi	r19, 0xFF	; 255
    9eec:	c9 01       	movw	r24, r18
    9eee:	2c 96       	adiw	r28, 0x0c	; 12
    9ef0:	0f b6       	in	r0, 0x3f	; 63
    9ef2:	f8 94       	cli
    9ef4:	de bf       	out	0x3e, r29	; 62
    9ef6:	0f be       	out	0x3f, r0	; 63
    9ef8:	cd bf       	out	0x3d, r28	; 61
    9efa:	cf 91       	pop	r28
    9efc:	df 91       	pop	r29
    9efe:	1f 91       	pop	r17
    9f00:	0f 91       	pop	r16
    9f02:	ff 90       	pop	r15
    9f04:	ef 90       	pop	r14
    9f06:	df 90       	pop	r13
    9f08:	cf 90       	pop	r12
    9f0a:	bf 90       	pop	r11
    9f0c:	af 90       	pop	r10
    9f0e:	9f 90       	pop	r9
    9f10:	8f 90       	pop	r8
    9f12:	7f 90       	pop	r7
    9f14:	6f 90       	pop	r6
    9f16:	5f 90       	pop	r5
    9f18:	4f 90       	pop	r4
    9f1a:	3f 90       	pop	r3
    9f1c:	2f 90       	pop	r2
    9f1e:	08 95       	ret

00009f20 <__eerd_block_m128rfa1>:
    9f20:	dc 01       	movw	r26, r24
    9f22:	cb 01       	movw	r24, r22

00009f24 <__eerd_blraw_m128rfa1>:
    9f24:	fc 01       	movw	r30, r24
    9f26:	f9 99       	sbic	0x1f, 1	; 31
    9f28:	fe cf       	rjmp	.-4      	; 0x9f26 <__eerd_blraw_m128rfa1+0x2>
    9f2a:	06 c0       	rjmp	.+12     	; 0x9f38 <__eerd_blraw_m128rfa1+0x14>
    9f2c:	f2 bd       	out	0x22, r31	; 34
    9f2e:	e1 bd       	out	0x21, r30	; 33
    9f30:	f8 9a       	sbi	0x1f, 0	; 31
    9f32:	31 96       	adiw	r30, 0x01	; 1
    9f34:	00 b4       	in	r0, 0x20	; 32
    9f36:	0d 92       	st	X+, r0
    9f38:	41 50       	subi	r20, 0x01	; 1
    9f3a:	50 40       	sbci	r21, 0x00	; 0
    9f3c:	b8 f7       	brcc	.-18     	; 0x9f2c <__eerd_blraw_m128rfa1+0x8>
    9f3e:	08 95       	ret

00009f40 <__eerd_byte_m128rfa1>:
    9f40:	f9 99       	sbic	0x1f, 1	; 31
    9f42:	fe cf       	rjmp	.-4      	; 0x9f40 <__eerd_byte_m128rfa1>
    9f44:	92 bd       	out	0x22, r25	; 34
    9f46:	81 bd       	out	0x21, r24	; 33
    9f48:	f8 9a       	sbi	0x1f, 0	; 31
    9f4a:	99 27       	eor	r25, r25
    9f4c:	80 b5       	in	r24, 0x20	; 32
    9f4e:	08 95       	ret

00009f50 <__eerd_word_m128rfa1>:
    9f50:	a8 e1       	ldi	r26, 0x18	; 24
    9f52:	b0 e0       	ldi	r27, 0x00	; 0
    9f54:	42 e0       	ldi	r20, 0x02	; 2
    9f56:	50 e0       	ldi	r21, 0x00	; 0
    9f58:	0c 94 92 4f 	jmp	0x9f24	; 0x9f24 <__eerd_blraw_m128rfa1>

00009f5c <__eewr_block_m128rfa1>:
    9f5c:	dc 01       	movw	r26, r24
    9f5e:	cb 01       	movw	r24, r22
    9f60:	03 c0       	rjmp	.+6      	; 0x9f68 <__eewr_block_m128rfa1+0xc>
    9f62:	2d 91       	ld	r18, X+
    9f64:	0e 94 b9 4f 	call	0x9f72	; 0x9f72 <__eewr_r18_m128rfa1>
    9f68:	41 50       	subi	r20, 0x01	; 1
    9f6a:	50 40       	sbci	r21, 0x00	; 0
    9f6c:	d0 f7       	brcc	.-12     	; 0x9f62 <__eewr_block_m128rfa1+0x6>
    9f6e:	08 95       	ret

00009f70 <__eewr_byte_m128rfa1>:
    9f70:	26 2f       	mov	r18, r22

00009f72 <__eewr_r18_m128rfa1>:
    9f72:	f9 99       	sbic	0x1f, 1	; 31
    9f74:	fe cf       	rjmp	.-4      	; 0x9f72 <__eewr_r18_m128rfa1>
    9f76:	1f ba       	out	0x1f, r1	; 31
    9f78:	92 bd       	out	0x22, r25	; 34
    9f7a:	81 bd       	out	0x21, r24	; 33
    9f7c:	20 bd       	out	0x20, r18	; 32
    9f7e:	0f b6       	in	r0, 0x3f	; 63
    9f80:	f8 94       	cli
    9f82:	fa 9a       	sbi	0x1f, 2	; 31
    9f84:	f9 9a       	sbi	0x1f, 1	; 31
    9f86:	0f be       	out	0x3f, r0	; 63
    9f88:	01 96       	adiw	r24, 0x01	; 1
    9f8a:	08 95       	ret

00009f8c <__eewr_word_m128rfa1>:
    9f8c:	0e 94 b8 4f 	call	0x9f70	; 0x9f70 <__eewr_byte_m128rfa1>
    9f90:	27 2f       	mov	r18, r23
    9f92:	0c 94 b9 4f 	jmp	0x9f72	; 0x9f72 <__eewr_r18_m128rfa1>

00009f96 <strnlen_P>:
    9f96:	fc 01       	movw	r30, r24
    9f98:	05 90       	lpm	r0, Z+
    9f9a:	61 50       	subi	r22, 0x01	; 1
    9f9c:	70 40       	sbci	r23, 0x00	; 0
    9f9e:	01 10       	cpse	r0, r1
    9fa0:	d8 f7       	brcc	.-10     	; 0x9f98 <strnlen_P+0x2>
    9fa2:	80 95       	com	r24
    9fa4:	90 95       	com	r25
    9fa6:	8e 0f       	add	r24, r30
    9fa8:	9f 1f       	adc	r25, r31
    9faa:	08 95       	ret

00009fac <fgetc>:
    9fac:	cf 93       	push	r28
    9fae:	df 93       	push	r29
    9fb0:	ec 01       	movw	r28, r24
    9fb2:	3b 81       	ldd	r19, Y+3	; 0x03
    9fb4:	30 ff       	sbrs	r19, 0
    9fb6:	36 c0       	rjmp	.+108    	; 0xa024 <fgetc+0x78>
    9fb8:	36 ff       	sbrs	r19, 6
    9fba:	09 c0       	rjmp	.+18     	; 0x9fce <fgetc+0x22>
    9fbc:	3f 7b       	andi	r19, 0xBF	; 191
    9fbe:	3b 83       	std	Y+3, r19	; 0x03
    9fc0:	8e 81       	ldd	r24, Y+6	; 0x06
    9fc2:	9f 81       	ldd	r25, Y+7	; 0x07
    9fc4:	01 96       	adiw	r24, 0x01	; 1
    9fc6:	9f 83       	std	Y+7, r25	; 0x07
    9fc8:	8e 83       	std	Y+6, r24	; 0x06
    9fca:	2a 81       	ldd	r18, Y+2	; 0x02
    9fcc:	29 c0       	rjmp	.+82     	; 0xa020 <fgetc+0x74>
    9fce:	32 ff       	sbrs	r19, 2
    9fd0:	0f c0       	rjmp	.+30     	; 0x9ff0 <fgetc+0x44>
    9fd2:	e8 81       	ld	r30, Y
    9fd4:	f9 81       	ldd	r31, Y+1	; 0x01
    9fd6:	80 81       	ld	r24, Z
    9fd8:	99 27       	eor	r25, r25
    9fda:	87 fd       	sbrc	r24, 7
    9fdc:	90 95       	com	r25
    9fde:	00 97       	sbiw	r24, 0x00	; 0
    9fe0:	19 f4       	brne	.+6      	; 0x9fe8 <fgetc+0x3c>
    9fe2:	30 62       	ori	r19, 0x20	; 32
    9fe4:	3b 83       	std	Y+3, r19	; 0x03
    9fe6:	1e c0       	rjmp	.+60     	; 0xa024 <fgetc+0x78>
    9fe8:	31 96       	adiw	r30, 0x01	; 1
    9fea:	f9 83       	std	Y+1, r31	; 0x01
    9fec:	e8 83       	st	Y, r30
    9fee:	11 c0       	rjmp	.+34     	; 0xa012 <fgetc+0x66>
    9ff0:	ea 85       	ldd	r30, Y+10	; 0x0a
    9ff2:	fb 85       	ldd	r31, Y+11	; 0x0b
    9ff4:	ce 01       	movw	r24, r28
    9ff6:	09 95       	icall
    9ff8:	97 ff       	sbrs	r25, 7
    9ffa:	0b c0       	rjmp	.+22     	; 0xa012 <fgetc+0x66>
    9ffc:	2b 81       	ldd	r18, Y+3	; 0x03
    9ffe:	3f ef       	ldi	r19, 0xFF	; 255
    a000:	8f 3f       	cpi	r24, 0xFF	; 255
    a002:	93 07       	cpc	r25, r19
    a004:	11 f4       	brne	.+4      	; 0xa00a <fgetc+0x5e>
    a006:	80 e1       	ldi	r24, 0x10	; 16
    a008:	01 c0       	rjmp	.+2      	; 0xa00c <fgetc+0x60>
    a00a:	80 e2       	ldi	r24, 0x20	; 32
    a00c:	82 2b       	or	r24, r18
    a00e:	8b 83       	std	Y+3, r24	; 0x03
    a010:	09 c0       	rjmp	.+18     	; 0xa024 <fgetc+0x78>
    a012:	2e 81       	ldd	r18, Y+6	; 0x06
    a014:	3f 81       	ldd	r19, Y+7	; 0x07
    a016:	2f 5f       	subi	r18, 0xFF	; 255
    a018:	3f 4f       	sbci	r19, 0xFF	; 255
    a01a:	3f 83       	std	Y+7, r19	; 0x07
    a01c:	2e 83       	std	Y+6, r18	; 0x06
    a01e:	28 2f       	mov	r18, r24
    a020:	30 e0       	ldi	r19, 0x00	; 0
    a022:	02 c0       	rjmp	.+4      	; 0xa028 <fgetc+0x7c>
    a024:	2f ef       	ldi	r18, 0xFF	; 255
    a026:	3f ef       	ldi	r19, 0xFF	; 255
    a028:	c9 01       	movw	r24, r18
    a02a:	df 91       	pop	r29
    a02c:	cf 91       	pop	r28
    a02e:	08 95       	ret

0000a030 <__ultoa_invert>:
    a030:	fa 01       	movw	r30, r20
    a032:	aa 27       	eor	r26, r26
    a034:	28 30       	cpi	r18, 0x08	; 8
    a036:	51 f1       	breq	.+84     	; 0xa08c <__ultoa_invert+0x5c>
    a038:	20 31       	cpi	r18, 0x10	; 16
    a03a:	81 f1       	breq	.+96     	; 0xa09c <__ultoa_invert+0x6c>
    a03c:	e8 94       	clt
    a03e:	6f 93       	push	r22
    a040:	6e 7f       	andi	r22, 0xFE	; 254
    a042:	6e 5f       	subi	r22, 0xFE	; 254
    a044:	7f 4f       	sbci	r23, 0xFF	; 255
    a046:	8f 4f       	sbci	r24, 0xFF	; 255
    a048:	9f 4f       	sbci	r25, 0xFF	; 255
    a04a:	af 4f       	sbci	r26, 0xFF	; 255
    a04c:	b1 e0       	ldi	r27, 0x01	; 1
    a04e:	3e d0       	rcall	.+124    	; 0xa0cc <__ultoa_invert+0x9c>
    a050:	b4 e0       	ldi	r27, 0x04	; 4
    a052:	3c d0       	rcall	.+120    	; 0xa0cc <__ultoa_invert+0x9c>
    a054:	67 0f       	add	r22, r23
    a056:	78 1f       	adc	r23, r24
    a058:	89 1f       	adc	r24, r25
    a05a:	9a 1f       	adc	r25, r26
    a05c:	a1 1d       	adc	r26, r1
    a05e:	68 0f       	add	r22, r24
    a060:	79 1f       	adc	r23, r25
    a062:	8a 1f       	adc	r24, r26
    a064:	91 1d       	adc	r25, r1
    a066:	a1 1d       	adc	r26, r1
    a068:	6a 0f       	add	r22, r26
    a06a:	71 1d       	adc	r23, r1
    a06c:	81 1d       	adc	r24, r1
    a06e:	91 1d       	adc	r25, r1
    a070:	a1 1d       	adc	r26, r1
    a072:	20 d0       	rcall	.+64     	; 0xa0b4 <__ultoa_invert+0x84>
    a074:	09 f4       	brne	.+2      	; 0xa078 <__ultoa_invert+0x48>
    a076:	68 94       	set
    a078:	3f 91       	pop	r19
    a07a:	2a e0       	ldi	r18, 0x0A	; 10
    a07c:	26 9f       	mul	r18, r22
    a07e:	11 24       	eor	r1, r1
    a080:	30 19       	sub	r19, r0
    a082:	30 5d       	subi	r19, 0xD0	; 208
    a084:	31 93       	st	Z+, r19
    a086:	de f6       	brtc	.-74     	; 0xa03e <__ultoa_invert+0xe>
    a088:	cf 01       	movw	r24, r30
    a08a:	08 95       	ret
    a08c:	46 2f       	mov	r20, r22
    a08e:	47 70       	andi	r20, 0x07	; 7
    a090:	40 5d       	subi	r20, 0xD0	; 208
    a092:	41 93       	st	Z+, r20
    a094:	b3 e0       	ldi	r27, 0x03	; 3
    a096:	0f d0       	rcall	.+30     	; 0xa0b6 <__ultoa_invert+0x86>
    a098:	c9 f7       	brne	.-14     	; 0xa08c <__ultoa_invert+0x5c>
    a09a:	f6 cf       	rjmp	.-20     	; 0xa088 <__ultoa_invert+0x58>
    a09c:	46 2f       	mov	r20, r22
    a09e:	4f 70       	andi	r20, 0x0F	; 15
    a0a0:	40 5d       	subi	r20, 0xD0	; 208
    a0a2:	4a 33       	cpi	r20, 0x3A	; 58
    a0a4:	18 f0       	brcs	.+6      	; 0xa0ac <__ultoa_invert+0x7c>
    a0a6:	49 5d       	subi	r20, 0xD9	; 217
    a0a8:	31 fd       	sbrc	r19, 1
    a0aa:	40 52       	subi	r20, 0x20	; 32
    a0ac:	41 93       	st	Z+, r20
    a0ae:	02 d0       	rcall	.+4      	; 0xa0b4 <__ultoa_invert+0x84>
    a0b0:	a9 f7       	brne	.-22     	; 0xa09c <__ultoa_invert+0x6c>
    a0b2:	ea cf       	rjmp	.-44     	; 0xa088 <__ultoa_invert+0x58>
    a0b4:	b4 e0       	ldi	r27, 0x04	; 4
    a0b6:	a6 95       	lsr	r26
    a0b8:	97 95       	ror	r25
    a0ba:	87 95       	ror	r24
    a0bc:	77 95       	ror	r23
    a0be:	67 95       	ror	r22
    a0c0:	ba 95       	dec	r27
    a0c2:	c9 f7       	brne	.-14     	; 0xa0b6 <__ultoa_invert+0x86>
    a0c4:	00 97       	sbiw	r24, 0x00	; 0
    a0c6:	61 05       	cpc	r22, r1
    a0c8:	71 05       	cpc	r23, r1
    a0ca:	08 95       	ret
    a0cc:	9b 01       	movw	r18, r22
    a0ce:	ac 01       	movw	r20, r24
    a0d0:	0a 2e       	mov	r0, r26
    a0d2:	06 94       	lsr	r0
    a0d4:	57 95       	ror	r21
    a0d6:	47 95       	ror	r20
    a0d8:	37 95       	ror	r19
    a0da:	27 95       	ror	r18
    a0dc:	ba 95       	dec	r27
    a0de:	c9 f7       	brne	.-14     	; 0xa0d2 <__ultoa_invert+0xa2>
    a0e0:	62 0f       	add	r22, r18
    a0e2:	73 1f       	adc	r23, r19
    a0e4:	84 1f       	adc	r24, r20
    a0e6:	95 1f       	adc	r25, r21
    a0e8:	a0 1d       	adc	r26, r0
    a0ea:	08 95       	ret

0000a0ec <__mulsi3>:
    a0ec:	62 9f       	mul	r22, r18
    a0ee:	d0 01       	movw	r26, r0
    a0f0:	73 9f       	mul	r23, r19
    a0f2:	f0 01       	movw	r30, r0
    a0f4:	82 9f       	mul	r24, r18
    a0f6:	e0 0d       	add	r30, r0
    a0f8:	f1 1d       	adc	r31, r1
    a0fa:	64 9f       	mul	r22, r20
    a0fc:	e0 0d       	add	r30, r0
    a0fe:	f1 1d       	adc	r31, r1
    a100:	92 9f       	mul	r25, r18
    a102:	f0 0d       	add	r31, r0
    a104:	83 9f       	mul	r24, r19
    a106:	f0 0d       	add	r31, r0
    a108:	74 9f       	mul	r23, r20
    a10a:	f0 0d       	add	r31, r0
    a10c:	65 9f       	mul	r22, r21
    a10e:	f0 0d       	add	r31, r0
    a110:	99 27       	eor	r25, r25
    a112:	72 9f       	mul	r23, r18
    a114:	b0 0d       	add	r27, r0
    a116:	e1 1d       	adc	r30, r1
    a118:	f9 1f       	adc	r31, r25
    a11a:	63 9f       	mul	r22, r19
    a11c:	b0 0d       	add	r27, r0
    a11e:	e1 1d       	adc	r30, r1
    a120:	f9 1f       	adc	r31, r25
    a122:	bd 01       	movw	r22, r26
    a124:	cf 01       	movw	r24, r30
    a126:	11 24       	eor	r1, r1
    a128:	08 95       	ret

0000a12a <__divmodsi4>:
    a12a:	97 fb       	bst	r25, 7
    a12c:	09 2e       	mov	r0, r25
    a12e:	05 26       	eor	r0, r21
    a130:	0e d0       	rcall	.+28     	; 0xa14e <__divmodsi4_neg1>
    a132:	57 fd       	sbrc	r21, 7
    a134:	04 d0       	rcall	.+8      	; 0xa13e <__divmodsi4_neg2>
    a136:	ed da       	rcall	.-2598   	; 0x9712 <__udivmodsi4>
    a138:	0a d0       	rcall	.+20     	; 0xa14e <__divmodsi4_neg1>
    a13a:	00 1c       	adc	r0, r0
    a13c:	38 f4       	brcc	.+14     	; 0xa14c <__divmodsi4_exit>

0000a13e <__divmodsi4_neg2>:
    a13e:	50 95       	com	r21
    a140:	40 95       	com	r20
    a142:	30 95       	com	r19
    a144:	21 95       	neg	r18
    a146:	3f 4f       	sbci	r19, 0xFF	; 255
    a148:	4f 4f       	sbci	r20, 0xFF	; 255
    a14a:	5f 4f       	sbci	r21, 0xFF	; 255

0000a14c <__divmodsi4_exit>:
    a14c:	08 95       	ret

0000a14e <__divmodsi4_neg1>:
    a14e:	f6 f7       	brtc	.-4      	; 0xa14c <__divmodsi4_exit>
    a150:	90 95       	com	r25
    a152:	80 95       	com	r24
    a154:	70 95       	com	r23
    a156:	61 95       	neg	r22
    a158:	7f 4f       	sbci	r23, 0xFF	; 255
    a15a:	8f 4f       	sbci	r24, 0xFF	; 255
    a15c:	9f 4f       	sbci	r25, 0xFF	; 255
    a15e:	08 95       	ret

0000a160 <_exit>:
    a160:	f8 94       	cli

0000a162 <__stop_program>:
    a162:	ff cf       	rjmp	.-2      	; 0xa162 <__stop_program>
