
fibonacci.avr-atmega128rfa1:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000d86  00800200  00009f66  0000a05a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00009f66  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00002744  00800f86  00800f86  0000ade0  2**0
                  ALLOC
  3 .eeprom       00000029  00810000  00810000  0000ade0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fuse         00000003  00820000  00820000  0000ae09  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .signature    00000003  00840000  00840000  0000ae0c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .stab         000032dc  00000000  00000000  0000ae10  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .stabstr      000010e3  00000000  00000000  0000e0ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000005c0  00000000  00000000  0000f1cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000211e  00000000  00000000  0000f78f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000de28  00000000  00000000  000118ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000482d  00000000  00000000  0001f6d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000994d  00000000  00000000  00023f02  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000018c0  00000000  00000000  0002d850  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003ac9  00000000  00000000  0002f110  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00006bc6  00000000  00000000  00032bd9  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_pubtypes 00001789  00000000  00000000  0003979f  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000078  00000000  00000000  0003af28  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b2 01 	jmp	0x364	; 0x364 <__ctors_end>
       4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
       8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
       c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      10:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      14:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      18:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      1c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      20:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      24:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      28:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      2c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      30:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      34:	0c 94 85 37 	jmp	0x6f0a	; 0x6f0a <__vector_13>
      38:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      3c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      40:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      44:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      48:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      4c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      50:	0c 94 f9 24 	jmp	0x49f2	; 0x49f2 <__vector_20>
      54:	0c 94 25 1c 	jmp	0x384a	; 0x384a <__vector_21>
      58:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      5c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      60:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      64:	0c 94 9a 1c 	jmp	0x3934	; 0x3934 <__vector_25>
      68:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      6c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      70:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      74:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      78:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      7c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      80:	0c 94 22 36 	jmp	0x6c44	; 0x6c44 <__vector_32>
      84:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      88:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      8c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      90:	0c 94 c9 1c 	jmp	0x3992	; 0x3992 <__vector_36>
      94:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      98:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      9c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      a0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      a4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      a8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      ac:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      b0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      b4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      b8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      bc:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      c0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      c4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      c8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      cc:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      d0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      d4:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      d8:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      dc:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      e0:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
      e4:	0c 94 b2 24 	jmp	0x4964	; 0x4964 <__vector_57>
      e8:	0c 94 bc 24 	jmp	0x4978	; 0x4978 <__vector_58>
      ec:	0c 94 a8 24 	jmp	0x4950	; 0x4950 <__vector_59>
      f0:	0c 94 62 24 	jmp	0x48c4	; 0x48c4 <__vector_60>
      f4:	0c 94 ed 24 	jmp	0x49da	; 0x49da <__vector_61>
      f8:	0c 94 de 24 	jmp	0x49bc	; 0x49bc <__vector_62>
      fc:	0c 94 d2 24 	jmp	0x49a4	; 0x49a4 <__vector_63>
     100:	0c 94 c6 24 	jmp	0x498c	; 0x498c <__vector_64>
     104:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     108:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     10c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     110:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     114:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     118:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>
     11c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__bad_interrupt>

00000120 <__c.4609>:
     120:	25 73 25 73 0a 00                                   %s%s..

00000126 <__c.4599>:
     126:	4e 65 76 65 72 2d 75 73 65 64 20 73 74 61 63 6b     Never-used stack
     136:	20 3e 20 25 64 20 62 79 74 65 73 0a 00               > %d bytes..

00000143 <__c.4589>:
     143:	4f 6e 6c 69 6e 65 0a 00                             Online..

0000014b <__c.4587>:
     14b:	25 73 20 25 73 2c 20 63 68 61 6e 6e 65 6c 20 25     %s %s, channel %
     15b:	75 20 2c 20 63 68 65 63 6b 20 72 61 74 65 20 25     u , check rate %
     16b:	75 20 48 7a 20 74 78 20 70 6f 77 65 72 20 25 75     u Hz tx power %u
     17b:	0a 00                                               ..

0000017d <__c.4585>:
     17d:	0a 00                                               ..

0000017f <__c.4580>:
     17f:	25 78 3a 00                                         %x:.

00000183 <__c.4577>:
     183:	4d 41 43 20 61 64 64 72 65 73 73 20 00              MAC address .

00000190 <__c.4575>:
     190:	52 61 6e 64 6f 6d 20 45 55 49 36 34 20 61 64 64     Random EUI64 add
     1a0:	72 65 73 73 20 67 65 6e 65 72 61 74 65 64 0a 00     ress generated..

000001b0 <__c.4572>:
     1b0:	0a 2a 2a 2a 2a 2a 2a 2a 42 6f 6f 74 69 6e 67 20     .*******Booting 
     1c0:	25 73 2a 2a 2a 2a 2a 2a 2a 0a 00                    %s*******..

000001cb <default_mac_address>:
     1cb:	02 00 00 ff fe 00 00 01                             ........

000001d3 <default_server_name>:
     1d3:	41 54 4d 45 47 41 31 32 38 72 66 61 31 00           ATMEGA128rfa1.

000001e1 <default_domain_name>:
     1e1:	6c 6f 63 61 6c 68 6f 73 74 00                       localhost.

000001eb <__c.4334>:
     1eb:	45 45 50 52 4f 4d 20 69 73 20 63 6f 72 72 75 70     EEPROM is corrup
     1fb:	74 2c 20 72 65 77 72 69 74 69 6e 67 20 77 69 74     t, rewriting wit
     20b:	68 20 64 65 66 61 75 6c 74 73 2e 0a 00              h defaults...

00000218 <__c.3462>:
     218:	45 20 25 64 2e 25 64 20 63 6c 6f 63 6b 20 25 6c     E %d.%d clock %l
     228:	75 20 63 70 75 20 25 6c 75 20 6c 70 6d 20 25 6c     u cpu %lu lpm %l
     238:	75 20 69 72 71 20 25 6c 75 20 67 6c 65 64 20 25     u irq %lu gled %
     248:	6c 75 20 79 6c 65 64 20 25 6c 75 20 72 6c 65 64     lu yled %lu rled
     258:	20 25 6c 75 20 74 78 20 25 6c 75 20 6c 69 73 74      %lu tx %lu list
     268:	65 6e 20 25 6c 75 20 73 65 6e 73 6f 72 73 20 25     en %lu sensors %
     278:	6c 75 20 73 65 72 69 61 6c 20 25 6c 75 0a 00        lu serial %lu..

00000287 <__c.3460>:
     287:	53 20 25 64 2e 25 64 20 63 6c 6f 63 6b 20 25 6c     S %d.%d clock %l
     297:	75 20 74 78 20 25 6c 75 20 72 78 20 25 6c 75 20     u tx %lu rx %lu 
     2a7:	72 74 78 20 25 6c 75 20 72 72 78 20 25 6c 75 20     rtx %lu rrx %lu 
     2b7:	72 65 78 6d 69 74 20 25 6c 75 20 61 63 6b 74 78     rexmit %lu acktx
     2c7:	20 25 6c 75 20 6e 6f 61 63 6b 74 78 20 25 6c 75      %lu noacktx %lu
     2d7:	20 61 63 6b 72 78 20 25 6c 75 20 74 69 6d 65 64      ackrx %lu timed
     2e7:	6f 75 74 20 25 6c 75 20 62 61 64 61 63 6b 72 78     out %lu badackrx
     2f7:	20 25 6c 75 20 74 6f 6f 6c 6f 6e 67 20 25 6c 75      %lu toolong %lu
     307:	20 74 6f 6f 73 68 6f 72 74 20 25 6c 75 20 62 61      tooshort %lu ba
     317:	64 73 79 6e 63 68 20 25 6c 75 20 62 61 64 63 72     dsynch %lu badcr
     327:	63 20 25 6c 75 20 63 6f 6e 74 65 6e 74 69 6f 6e     c %lu contention
     337:	64 72 6f 70 20 25 6c 75 20 73 65 6e 64 69 6e 67     drop %lu sending
     347:	64 72 6f 70 20 25 6c 75 20 6c 6c 74 78 20 25 6c     drop %lu lltx %l
     357:	75 20 6c 6c 72 78 20 25 6c 75 0a 00 00              u llrx %lu...

00000364 <__ctors_end>:
     364:	11 24       	eor	r1, r1
     366:	1f be       	out	0x3f, r1	; 63
     368:	cf ef       	ldi	r28, 0xFF	; 255
     36a:	d1 e4       	ldi	r29, 0x41	; 65
     36c:	de bf       	out	0x3e, r29	; 62
     36e:	cd bf       	out	0x3d, r28	; 61

00000370 <__do_copy_data>:
     370:	1f e0       	ldi	r17, 0x0F	; 15
     372:	a0 e0       	ldi	r26, 0x00	; 0
     374:	b2 e0       	ldi	r27, 0x02	; 2
     376:	e6 e6       	ldi	r30, 0x66	; 102
     378:	ff e9       	ldi	r31, 0x9F	; 159
     37a:	00 e0       	ldi	r16, 0x00	; 0
     37c:	0b bf       	out	0x3b, r16	; 59
     37e:	02 c0       	rjmp	.+4      	; 0x384 <__do_copy_data+0x14>
     380:	07 90       	elpm	r0, Z+
     382:	0d 92       	st	X+, r0
     384:	a6 38       	cpi	r26, 0x86	; 134
     386:	b1 07       	cpc	r27, r17
     388:	d9 f7       	brne	.-10     	; 0x380 <__do_copy_data+0x10>

0000038a <__do_clear_bss>:
     38a:	16 e3       	ldi	r17, 0x36	; 54
     38c:	a6 e8       	ldi	r26, 0x86	; 134
     38e:	bf e0       	ldi	r27, 0x0F	; 15
     390:	01 c0       	rjmp	.+2      	; 0x394 <.do_clear_bss_start>

00000392 <.do_clear_bss_loop>:
     392:	1d 92       	st	X+, r1

00000394 <.do_clear_bss_start>:
     394:	aa 3c       	cpi	r26, 0xCA	; 202
     396:	b1 07       	cpc	r27, r17
     398:	e1 f7       	brne	.-8      	; 0x392 <.do_clear_bss_loop>
     39a:	0e 94 08 1a 	call	0x3410	; 0x3410 <main>
     39e:	0c 94 b1 4f 	jmp	0x9f62	; 0x9f62 <_exit>

000003a2 <__bad_interrupt>:
     3a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a6 <process_thread_measurement_process>:

PROCESS(measurement_process, "Measurement Process");
AUTOSTART_PROCESSES(&measurement_process, &radiotftp_process);

PROCESS_THREAD(measurement_process, ev, data)
{
     3a6:	7f 92       	push	r7
     3a8:	8f 92       	push	r8
     3aa:	9f 92       	push	r9
     3ac:	af 92       	push	r10
     3ae:	bf 92       	push	r11
     3b0:	cf 92       	push	r12
     3b2:	df 92       	push	r13
     3b4:	ef 92       	push	r14
     3b6:	ff 92       	push	r15
     3b8:	0f 93       	push	r16
     3ba:	1f 93       	push	r17
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	6c 01       	movw	r12, r24
	static uint32_t counter=0;
	static uint16_t numBytes=0;
	static uint64_t fibo[3] = {0, 1, 1};
	static struct etimer measurement_timer;
	static uint8_t fake_measurement_string[450];
	PROCESS_BEGIN();
     3c2:	dc 01       	movw	r26, r24
     3c4:	8d 91       	ld	r24, X+
     3c6:	9c 91       	ld	r25, X
     3c8:	11 97       	sbiw	r26, 0x01	; 1
     3ca:	00 97       	sbiw	r24, 0x00	; 0
     3cc:	29 f0       	breq	.+10     	; 0x3d8 <process_thread_measurement_process+0x32>
     3ce:	84 32       	cpi	r24, 0x24	; 36
     3d0:	91 05       	cpc	r25, r1
     3d2:	09 f0       	breq	.+2      	; 0x3d6 <process_thread_measurement_process+0x30>
     3d4:	5e c1       	rjmp	.+700    	; 0x692 <process_thread_measurement_process+0x2ec>
     3d6:	0d c0       	rjmp	.+26     	; 0x3f2 <process_thread_measurement_process+0x4c>

	etimer_set(&measurement_timer, CLOCK_SECOND*2);
     3d8:	88 e4       	ldi	r24, 0x48	; 72
     3da:	91 e1       	ldi	r25, 0x11	; 17
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	71 e0       	ldi	r23, 0x01	; 1
     3e0:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <etimer_set>
	while(1)
	{
		PROCESS_WAIT_EVENT();
     3e4:	84 e2       	ldi	r24, 0x24	; 36
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	f6 01       	movw	r30, r12
     3ea:	91 83       	std	Z+1, r25	; 0x01
     3ec:	80 83       	st	Z, r24
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	54 c1       	rjmp	.+680    	; 0x69a <process_thread_measurement_process+0x2f4>
		counter++;
     3f2:	80 91 52 11 	lds	r24, 0x1152
     3f6:	90 91 53 11 	lds	r25, 0x1153
     3fa:	a0 91 54 11 	lds	r26, 0x1154
     3fe:	b0 91 55 11 	lds	r27, 0x1155
     402:	01 96       	adiw	r24, 0x01	; 1
     404:	a1 1d       	adc	r26, r1
     406:	b1 1d       	adc	r27, r1
     408:	80 93 52 11 	sts	0x1152, r24
     40c:	90 93 53 11 	sts	0x1153, r25
     410:	a0 93 54 11 	sts	0x1154, r26
     414:	b0 93 55 11 	sts	0x1155, r27
		fibo[2]=fibo[1]+fibo[0];
     418:	30 91 74 02 	lds	r19, 0x0274
     41c:	e0 90 75 02 	lds	r14, 0x0275
     420:	00 91 76 02 	lds	r16, 0x0276
     424:	80 90 77 02 	lds	r8, 0x0277
     428:	90 90 78 02 	lds	r9, 0x0278
     42c:	a0 90 79 02 	lds	r10, 0x0279
     430:	b0 90 7a 02 	lds	r11, 0x027A
     434:	f0 90 7b 02 	lds	r15, 0x027B
     438:	20 91 7c 02 	lds	r18, 0x027C
     43c:	40 91 7d 02 	lds	r20, 0x027D
     440:	f0 91 7e 02 	lds	r31, 0x027E
     444:	70 90 7f 02 	lds	r7, 0x027F
     448:	70 91 80 02 	lds	r23, 0x0280
     44c:	50 91 81 02 	lds	r21, 0x0281
     450:	60 91 82 02 	lds	r22, 0x0282
     454:	10 91 83 02 	lds	r17, 0x0283
     458:	23 0f       	add	r18, r19
     45a:	e1 e0       	ldi	r30, 0x01	; 1
     45c:	23 17       	cp	r18, r19
     45e:	08 f0       	brcs	.+2      	; 0x462 <process_thread_measurement_process+0xbc>
     460:	e0 e0       	ldi	r30, 0x00	; 0
     462:	4e 0d       	add	r20, r14
     464:	31 e0       	ldi	r19, 0x01	; 1
     466:	4e 15       	cp	r20, r14
     468:	08 f0       	brcs	.+2      	; 0x46c <process_thread_measurement_process+0xc6>
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	ee 2e       	mov	r14, r30
     46e:	e4 0e       	add	r14, r20
     470:	e1 e0       	ldi	r30, 0x01	; 1
     472:	e4 16       	cp	r14, r20
     474:	08 f0       	brcs	.+2      	; 0x478 <process_thread_measurement_process+0xd2>
     476:	e0 e0       	ldi	r30, 0x00	; 0
     478:	3e 2b       	or	r19, r30
     47a:	f0 0f       	add	r31, r16
     47c:	41 e0       	ldi	r20, 0x01	; 1
     47e:	f0 17       	cp	r31, r16
     480:	08 f0       	brcs	.+2      	; 0x484 <process_thread_measurement_process+0xde>
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	03 2f       	mov	r16, r19
     486:	0f 0f       	add	r16, r31
     488:	31 e0       	ldi	r19, 0x01	; 1
     48a:	0f 17       	cp	r16, r31
     48c:	08 f0       	brcs	.+2      	; 0x490 <process_thread_measurement_process+0xea>
     48e:	30 e0       	ldi	r19, 0x00	; 0
     490:	43 2b       	or	r20, r19
     492:	e8 2d       	mov	r30, r8
     494:	e7 0d       	add	r30, r7
     496:	31 e0       	ldi	r19, 0x01	; 1
     498:	e8 15       	cp	r30, r8
     49a:	08 f0       	brcs	.+2      	; 0x49e <process_thread_measurement_process+0xf8>
     49c:	30 e0       	ldi	r19, 0x00	; 0
     49e:	f4 2f       	mov	r31, r20
     4a0:	fe 0f       	add	r31, r30
     4a2:	41 e0       	ldi	r20, 0x01	; 1
     4a4:	fe 17       	cp	r31, r30
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <process_thread_measurement_process+0x104>
     4a8:	40 e0       	ldi	r20, 0x00	; 0
     4aa:	34 2b       	or	r19, r20
     4ac:	79 0d       	add	r23, r9
     4ae:	41 e0       	ldi	r20, 0x01	; 1
     4b0:	79 15       	cp	r23, r9
     4b2:	08 f0       	brcs	.+2      	; 0x4b6 <process_thread_measurement_process+0x110>
     4b4:	40 e0       	ldi	r20, 0x00	; 0
     4b6:	e3 2f       	mov	r30, r19
     4b8:	e7 0f       	add	r30, r23
     4ba:	31 e0       	ldi	r19, 0x01	; 1
     4bc:	e7 17       	cp	r30, r23
     4be:	08 f0       	brcs	.+2      	; 0x4c2 <process_thread_measurement_process+0x11c>
     4c0:	30 e0       	ldi	r19, 0x00	; 0
     4c2:	43 2b       	or	r20, r19
     4c4:	5a 0d       	add	r21, r10
     4c6:	31 e0       	ldi	r19, 0x01	; 1
     4c8:	5a 15       	cp	r21, r10
     4ca:	08 f0       	brcs	.+2      	; 0x4ce <process_thread_measurement_process+0x128>
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	45 0f       	add	r20, r21
     4d0:	71 e0       	ldi	r23, 0x01	; 1
     4d2:	45 17       	cp	r20, r21
     4d4:	08 f0       	brcs	.+2      	; 0x4d8 <process_thread_measurement_process+0x132>
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	37 2b       	or	r19, r23
     4da:	6b 0d       	add	r22, r11
     4dc:	51 e0       	ldi	r21, 0x01	; 1
     4de:	6b 15       	cp	r22, r11
     4e0:	08 f0       	brcs	.+2      	; 0x4e4 <process_thread_measurement_process+0x13e>
     4e2:	50 e0       	ldi	r21, 0x00	; 0
     4e4:	73 2f       	mov	r23, r19
     4e6:	76 0f       	add	r23, r22
     4e8:	31 e0       	ldi	r19, 0x01	; 1
     4ea:	76 17       	cp	r23, r22
     4ec:	08 f0       	brcs	.+2      	; 0x4f0 <process_thread_measurement_process+0x14a>
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	53 2b       	or	r21, r19
     4f2:	1f 0d       	add	r17, r15
     4f4:	51 0f       	add	r21, r17
     4f6:	20 93 84 02 	sts	0x0284, r18
     4fa:	e0 92 85 02 	sts	0x0285, r14
     4fe:	00 93 86 02 	sts	0x0286, r16
     502:	f0 93 87 02 	sts	0x0287, r31
     506:	e0 93 88 02 	sts	0x0288, r30
     50a:	40 93 89 02 	sts	0x0289, r20
     50e:	70 93 8a 02 	sts	0x028A, r23
     512:	50 93 8b 02 	sts	0x028B, r21
		numBytes=sprintf(fake_measurement_string, "Some Data: fibonacci(%d)=", counter);
     516:	c6 e8       	ldi	r28, 0x86	; 134
     518:	df e0       	ldi	r29, 0x0F	; 15
     51a:	2d b7       	in	r18, 0x3d	; 61
     51c:	3e b7       	in	r19, 0x3e	; 62
     51e:	28 50       	subi	r18, 0x08	; 8
     520:	30 40       	sbci	r19, 0x00	; 0
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	3e bf       	out	0x3e, r19	; 62
     528:	0f be       	out	0x3f, r0	; 63
     52a:	2d bf       	out	0x3d, r18	; 61
     52c:	4d b7       	in	r20, 0x3d	; 61
     52e:	5e b7       	in	r21, 0x3e	; 62
     530:	4f 5f       	subi	r20, 0xFF	; 255
     532:	5f 4f       	sbci	r21, 0xFF	; 255
     534:	ed b7       	in	r30, 0x3d	; 61
     536:	fe b7       	in	r31, 0x3e	; 62
     538:	d2 83       	std	Z+2, r29	; 0x02
     53a:	c1 83       	std	Z+1, r28	; 0x01
     53c:	20 e0       	ldi	r18, 0x00	; 0
     53e:	32 e0       	ldi	r19, 0x02	; 2
     540:	fa 01       	movw	r30, r20
     542:	33 83       	std	Z+3, r19	; 0x03
     544:	22 83       	std	Z+2, r18	; 0x02
     546:	84 83       	std	Z+4, r24	; 0x04
     548:	95 83       	std	Z+5, r25	; 0x05
     54a:	a6 83       	std	Z+6, r26	; 0x06
     54c:	b7 83       	std	Z+7, r27	; 0x07
     54e:	0e 94 51 4c 	call	0x98a2	; 0x98a2 <sprintf>
     552:	7c 01       	movw	r14, r24
     554:	90 93 51 11 	sts	0x1151, r25
     558:	80 93 50 11 	sts	0x1150, r24
		numBytes+=sprintf(fake_measurement_string+numBytes, "%u [Alp Sayin, KTH Royal Institute of Technology]\n", fibo[0]);
     55c:	00 d0       	rcall	.+0      	; 0x55e <process_thread_measurement_process+0x1b8>
     55e:	00 d0       	rcall	.+0      	; 0x560 <process_thread_measurement_process+0x1ba>
     560:	ed b7       	in	r30, 0x3d	; 61
     562:	fe b7       	in	r31, 0x3e	; 62
     564:	31 96       	adiw	r30, 0x01	; 1
     566:	8c 0f       	add	r24, r28
     568:	9d 1f       	adc	r25, r29
     56a:	ad b7       	in	r26, 0x3d	; 61
     56c:	be b7       	in	r27, 0x3e	; 62
     56e:	12 96       	adiw	r26, 0x02	; 2
     570:	9c 93       	st	X, r25
     572:	8e 93       	st	-X, r24
     574:	11 97       	sbiw	r26, 0x01	; 1
     576:	8a e1       	ldi	r24, 0x1A	; 26
     578:	92 e0       	ldi	r25, 0x02	; 2
     57a:	93 83       	std	Z+3, r25	; 0x03
     57c:	82 83       	std	Z+2, r24	; 0x02
     57e:	04 e7       	ldi	r16, 0x74	; 116
     580:	12 e0       	ldi	r17, 0x02	; 2
     582:	80 91 74 02 	lds	r24, 0x0274
     586:	84 83       	std	Z+4, r24	; 0x04
     588:	80 91 75 02 	lds	r24, 0x0275
     58c:	85 83       	std	Z+5, r24	; 0x05
     58e:	80 91 76 02 	lds	r24, 0x0276
     592:	86 83       	std	Z+6, r24	; 0x06
     594:	80 91 77 02 	lds	r24, 0x0277
     598:	87 83       	std	Z+7, r24	; 0x07
     59a:	80 91 78 02 	lds	r24, 0x0278
     59e:	80 87       	std	Z+8, r24	; 0x08
     5a0:	80 91 79 02 	lds	r24, 0x0279
     5a4:	81 87       	std	Z+9, r24	; 0x09
     5a6:	80 91 7a 02 	lds	r24, 0x027A
     5aa:	82 87       	std	Z+10, r24	; 0x0a
     5ac:	80 91 7b 02 	lds	r24, 0x027B
     5b0:	83 87       	std	Z+11, r24	; 0x0b
     5b2:	0e 94 51 4c 	call	0x98a2	; 0x98a2 <sprintf>
     5b6:	e8 0e       	add	r14, r24
     5b8:	f9 1e       	adc	r15, r25
     5ba:	f0 92 51 11 	sts	0x1151, r15
     5be:	e0 92 50 11 	sts	0x1150, r14
		printf("%s", fake_measurement_string);
     5c2:	ed b7       	in	r30, 0x3d	; 61
     5c4:	fe b7       	in	r31, 0x3e	; 62
     5c6:	38 96       	adiw	r30, 0x08	; 8
     5c8:	0f b6       	in	r0, 0x3f	; 63
     5ca:	f8 94       	cli
     5cc:	fe bf       	out	0x3e, r31	; 62
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	ed bf       	out	0x3d, r30	; 61
     5d2:	8d e4       	ldi	r24, 0x4D	; 77
     5d4:	92 e0       	ldi	r25, 0x02	; 2
     5d6:	92 83       	std	Z+2, r25	; 0x02
     5d8:	81 83       	std	Z+1, r24	; 0x01
     5da:	d4 83       	std	Z+4, r29	; 0x04
     5dc:	c3 83       	std	Z+3, r28	; 0x03
     5de:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		fibo[0]=fibo[1];
     5e2:	f8 01       	movw	r30, r16
     5e4:	38 96       	adiw	r30, 0x08	; 8
     5e6:	80 91 7c 02 	lds	r24, 0x027C
     5ea:	80 93 74 02 	sts	0x0274, r24
     5ee:	80 91 7d 02 	lds	r24, 0x027D
     5f2:	d8 01       	movw	r26, r16
     5f4:	11 96       	adiw	r26, 0x01	; 1
     5f6:	8c 93       	st	X, r24
     5f8:	11 97       	sbiw	r26, 0x01	; 1
     5fa:	80 91 7e 02 	lds	r24, 0x027E
     5fe:	12 96       	adiw	r26, 0x02	; 2
     600:	8c 93       	st	X, r24
     602:	12 97       	sbiw	r26, 0x02	; 2
     604:	80 91 7f 02 	lds	r24, 0x027F
     608:	13 96       	adiw	r26, 0x03	; 3
     60a:	8c 93       	st	X, r24
     60c:	13 97       	sbiw	r26, 0x03	; 3
     60e:	80 91 80 02 	lds	r24, 0x0280
     612:	14 96       	adiw	r26, 0x04	; 4
     614:	8c 93       	st	X, r24
     616:	14 97       	sbiw	r26, 0x04	; 4
     618:	80 91 81 02 	lds	r24, 0x0281
     61c:	15 96       	adiw	r26, 0x05	; 5
     61e:	8c 93       	st	X, r24
     620:	15 97       	sbiw	r26, 0x05	; 5
     622:	80 91 82 02 	lds	r24, 0x0282
     626:	16 96       	adiw	r26, 0x06	; 6
     628:	8c 93       	st	X, r24
     62a:	16 97       	sbiw	r26, 0x06	; 6
     62c:	80 91 83 02 	lds	r24, 0x0283
     630:	17 96       	adiw	r26, 0x07	; 7
     632:	8c 93       	st	X, r24
     634:	17 97       	sbiw	r26, 0x07	; 7
		fibo[1]=fibo[2];
     636:	80 91 84 02 	lds	r24, 0x0284
     63a:	18 96       	adiw	r26, 0x08	; 8
     63c:	8c 93       	st	X, r24
     63e:	80 91 85 02 	lds	r24, 0x0285
     642:	81 83       	std	Z+1, r24	; 0x01
     644:	80 91 86 02 	lds	r24, 0x0286
     648:	82 83       	std	Z+2, r24	; 0x02
     64a:	80 91 87 02 	lds	r24, 0x0287
     64e:	83 83       	std	Z+3, r24	; 0x03
     650:	80 91 88 02 	lds	r24, 0x0288
     654:	84 83       	std	Z+4, r24	; 0x04
     656:	80 91 89 02 	lds	r24, 0x0289
     65a:	85 83       	std	Z+5, r24	; 0x05
     65c:	80 91 8a 02 	lds	r24, 0x028A
     660:	86 83       	std	Z+6, r24	; 0x06
     662:	80 91 8b 02 	lds	r24, 0x028B
     666:	87 83       	std	Z+7, r24	; 0x07
		radiotftp_setNumBytesToSend(numBytes);
     668:	0f 90       	pop	r0
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	80 91 50 11 	lds	r24, 0x1150
     674:	90 91 51 11 	lds	r25, 0x1151
     678:	0e 94 36 12 	call	0x246c	; 0x246c <radiotftp_setNumBytesToSend>
		process_post_synch(&radiotftp_process, PROCESS_EVENT_COM, (void*)fake_measurement_string);
     67c:	87 e5       	ldi	r24, 0x57	; 87
     67e:	9d e0       	ldi	r25, 0x0D	; 13
     680:	69 e8       	ldi	r22, 0x89	; 137
     682:	ae 01       	movw	r20, r28
     684:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <process_post_synch>
		etimer_set(&measurement_timer, CLOCK_SECOND*10);
     688:	88 e4       	ldi	r24, 0x48	; 72
     68a:	91 e1       	ldi	r25, 0x11	; 17
     68c:	60 e0       	ldi	r22, 0x00	; 0
     68e:	75 e0       	ldi	r23, 0x05	; 5
     690:	a7 ce       	rjmp	.-690    	; 0x3e0 <process_thread_measurement_process+0x3a>
	}
	PROCESS_END();
     692:	f6 01       	movw	r30, r12
     694:	11 82       	std	Z+1, r1	; 0x01
     696:	10 82       	st	Z, r1
     698:	83 e0       	ldi	r24, 0x03	; 3
}
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	0f 91       	pop	r16
     6a2:	ff 90       	pop	r15
     6a4:	ef 90       	pop	r14
     6a6:	df 90       	pop	r13
     6a8:	cf 90       	pop	r12
     6aa:	bf 90       	pop	r11
     6ac:	af 90       	pop	r10
     6ae:	9f 90       	pop	r9
     6b0:	8f 90       	pop	r8
     6b2:	7f 90       	pop	r7
     6b4:	08 95       	ret

000006b6 <ax25_compute_crc>:
	}
	return fcs;
}

static uint16_t ax25_compute_crc(uint8_t* buf, uint16_t len)
{
     6b6:	fc 01       	movw	r30, r24
     6b8:	2f ef       	ldi	r18, 0xFF	; 255
     6ba:	3f ef       	ldi	r19, 0xFF	; 255
     6bc:	12 c0       	rjmp	.+36     	; 0x6e2 <ax25_compute_crc+0x2c>

static uint16_t ax25_fcs(uint16_t fcs, uint8_t* cp, uint16_t len)
{
	while (len--)
	{
    	fcs = (fcs >> 8) ^ ax25_fcstab[(fcs ^ *cp++) & 0xff];
     6be:	83 2f       	mov	r24, r19
     6c0:	99 27       	eor	r25, r25
     6c2:	a1 91       	ld	r26, Z+
     6c4:	b0 e0       	ldi	r27, 0x00	; 0
     6c6:	a2 27       	eor	r26, r18
     6c8:	b3 27       	eor	r27, r19
     6ca:	b0 70       	andi	r27, 0x00	; 0
     6cc:	aa 0f       	add	r26, r26
     6ce:	bb 1f       	adc	r27, r27
     6d0:	a4 57       	subi	r26, 0x74	; 116
     6d2:	bd 4f       	sbci	r27, 0xFD	; 253
     6d4:	2d 91       	ld	r18, X+
     6d6:	3c 91       	ld	r19, X
     6d8:	11 97       	sbiw	r26, 0x01	; 1
     6da:	28 27       	eor	r18, r24
     6dc:	39 27       	eor	r19, r25
     6de:	61 50       	subi	r22, 0x01	; 1
     6e0:	70 40       	sbci	r23, 0x00	; 0
   0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

static uint16_t ax25_fcs(uint16_t fcs, uint8_t* cp, uint16_t len)
{
	while (len--)
     6e2:	61 15       	cp	r22, r1
     6e4:	71 05       	cpc	r23, r1
     6e6:	59 f7       	brne	.-42     	; 0x6be <ax25_compute_crc+0x8>

static uint16_t ax25_compute_crc(uint8_t* buf, uint16_t len)
{
	uint16_t fcs = INITFCS;
	fcs = ax25_fcs(fcs, buf, len);
	fcs ^= 0xffff;
     6e8:	20 95       	com	r18
     6ea:	30 95       	com	r19
	return fcs;
}
     6ec:	c9 01       	movw	r24, r18
     6ee:	08 95       	ret

000006f0 <ax25_initialize_network>:

void ax25_initialize_network(uint8_t* myCallsign)
{
     6f0:	28 2f       	mov	r18, r24
     6f2:	39 2f       	mov	r19, r25
     6f4:	d9 01       	movw	r26, r18
     6f6:	e3 e9       	ldi	r30, 0x93	; 147
     6f8:	f4 e0       	ldi	r31, 0x04	; 4
    uint32_t i;
    for(i=0; i<7; i++)
    	ax25_local_callsign[i] = myCallsign[i];
     6fa:	8d 91       	ld	r24, X+
     6fc:	81 93       	st	Z+, r24
}

void ax25_initialize_network(uint8_t* myCallsign)
{
    uint32_t i;
    for(i=0; i<7; i++)
     6fe:	84 e0       	ldi	r24, 0x04	; 4
     700:	ea 39       	cpi	r30, 0x9A	; 154
     702:	f8 07       	cpc	r31, r24
     704:	d1 f7       	brne	.-12     	; 0x6fa <ax25_initialize_network+0xa>
    	ax25_local_callsign[i] = myCallsign[i];
}
     706:	08 95       	ret

00000708 <ax25_get_local_callsign>:
uint8_t* ax25_get_local_callsign(uint8_t* callsign_out)
{
    uint8_t i;

    if(callsign_out!=NULL)
     708:	00 97       	sbiw	r24, 0x00	; 0
     70a:	49 f0       	breq	.+18     	; 0x71e <ax25_get_local_callsign+0x16>
     70c:	e3 e9       	ldi	r30, 0x93	; 147
     70e:	f4 e0       	ldi	r31, 0x04	; 4
     710:	dc 01       	movw	r26, r24
    {
        for(i=0; i<7; i++)
        	callsign_out[i] = ax25_local_callsign[i];
     712:	81 91       	ld	r24, Z+
     714:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(callsign_out!=NULL)
    {
        for(i=0; i<7; i++)
     716:	84 e0       	ldi	r24, 0x04	; 4
     718:	ea 39       	cpi	r30, 0x9A	; 154
     71a:	f8 07       	cpc	r31, r24
     71c:	d1 f7       	brne	.-12     	; 0x712 <ax25_get_local_callsign+0xa>
        	callsign_out[i] = ax25_local_callsign[i];
    }
    return ax25_local_callsign;
}
     71e:	83 e9       	ldi	r24, 0x93	; 147
     720:	94 e0       	ldi	r25, 0x04	; 4
     722:	08 95       	ret

00000724 <ax25_get_broadcast_callsign>:

uint8_t* ax25_get_broadcast_callsign(uint8_t* callsign_out)
{
    uint8_t i;

    if(callsign_out!=NULL)
     724:	00 97       	sbiw	r24, 0x00	; 0
     726:	49 f0       	breq	.+18     	; 0x73a <ax25_get_broadcast_callsign+0x16>
     728:	ec e8       	ldi	r30, 0x8C	; 140
     72a:	f4 e0       	ldi	r31, 0x04	; 4
     72c:	dc 01       	movw	r26, r24
    {
        for(i=0; i<7; i++)
        	callsign_out[i] = ax25_broadcast_address[i];
     72e:	81 91       	ld	r24, Z+
     730:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(callsign_out!=NULL)
    {
        for(i=0; i<7; i++)
     732:	84 e0       	ldi	r24, 0x04	; 4
     734:	e3 39       	cpi	r30, 0x93	; 147
     736:	f8 07       	cpc	r31, r24
     738:	d1 f7       	brne	.-12     	; 0x72e <ax25_get_broadcast_callsign+0xa>
        	callsign_out[i] = ax25_broadcast_address[i];
    }
    return ax25_broadcast_address;
}
     73a:	8c e8       	ldi	r24, 0x8C	; 140
     73c:	94 e0       	ldi	r25, 0x04	; 4
     73e:	08 95       	ret

00000740 <ax25_create_ui_packet>:

uint32_t ax25_create_ui_packet(uint8_t* src_in, uint8_t* dst_in, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
{
     740:	ef 92       	push	r14
     742:	ff 92       	push	r15
     744:	0f 93       	push	r16
     746:	1f 93       	push	r17
     748:	cf 93       	push	r28
     74a:	df 93       	push	r29
     74c:	79 01       	movw	r14, r18
	uint16_t crc=0;
	uint16_t len=0;
	uint16_t ax25_len=0;

    //check for input errors
    if(payload_length > AX25_MAX_PAYLOAD_LENGTH || packet_out==NULL)
     74e:	21 e2       	ldi	r18, 0x21	; 33
     750:	e2 16       	cp	r14, r18
     752:	22 e0       	ldi	r18, 0x02	; 2
     754:	f2 06       	cpc	r15, r18
     756:	90 f5       	brcc	.+100    	; 0x7bc <ax25_create_ui_packet+0x7c>
     758:	01 15       	cp	r16, r1
     75a:	11 05       	cpc	r17, r1
     75c:	79 f1       	breq	.+94     	; 0x7bc <ax25_create_ui_packet+0x7c>
        return 0;

    //destination address
    memcpy(packet_out+AX25_DESTINATION_OFFSET, dst_in, AX25_DESTINATION_LENGTH);
     75e:	d8 01       	movw	r26, r16
     760:	26 2f       	mov	r18, r22
     762:	37 2f       	mov	r19, r23
     764:	f9 01       	movw	r30, r18
     766:	27 e0       	ldi	r18, 0x07	; 7
     768:	01 90       	ld	r0, Z+
     76a:	0d 92       	st	X+, r0
     76c:	21 50       	subi	r18, 0x01	; 1
     76e:	e1 f7       	brne	.-8      	; 0x768 <ax25_create_ui_packet+0x28>
    len+=AX25_DESTINATION_LENGTH;

    //source address
    memcpy(packet_out+AX25_SOURCE_OFFSET, src_in, AX25_SOURCE_LENGTH);
     770:	d8 01       	movw	r26, r16
     772:	17 96       	adiw	r26, 0x07	; 7
     774:	fc 01       	movw	r30, r24
     776:	87 e0       	ldi	r24, 0x07	; 7
     778:	01 90       	ld	r0, Z+
     77a:	0d 92       	st	X+, r0
     77c:	81 50       	subi	r24, 0x01	; 1
     77e:	e1 f7       	brne	.-8      	; 0x778 <ax25_create_ui_packet+0x38>
    len+=AX25_SOURCE_LENGTH;

    //control field
    packet_out[AX25_CONTROL_OFFSET]=AX25_CONTROL_UI_FINAL;
     780:	83 e0       	ldi	r24, 0x03	; 3
     782:	f8 01       	movw	r30, r16
     784:	86 87       	std	Z+14, r24	; 0x0e
    len+=AX25_CONTROL_LENGTH;

    //PID
    packet_out[AX25_PID_OFFSET]=AX25_PID_NO_PROTOCOL;
     786:	80 ef       	ldi	r24, 0xF0	; 240
     788:	87 87       	std	Z+15, r24	; 0x0f
    len+=AX25_PID_LENGTH;

    //payload
    memcpy(packet_out+AX25_PAYLOAD_OFFSET, payload_in, payload_length);
     78a:	98 01       	movw	r18, r16
     78c:	20 5f       	subi	r18, 0xF0	; 240
     78e:	3f 4f       	sbci	r19, 0xFF	; 255
     790:	c9 01       	movw	r24, r18
     792:	ba 01       	movw	r22, r20
     794:	a7 01       	movw	r20, r14
     796:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    len+=payload_length;
     79a:	e7 01       	movw	r28, r14
     79c:	60 96       	adiw	r28, 0x10	; 16

    //fcs (crc16)
    crc=ax25_compute_crc(packet_out, len);
     79e:	c8 01       	movw	r24, r16
     7a0:	be 01       	movw	r22, r28
     7a2:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <ax25_compute_crc>

    packet_out[len]=crc>>8 & 0xFF;
     7a6:	c0 0f       	add	r28, r16
     7a8:	d1 1f       	adc	r29, r17
     7aa:	98 83       	st	Y, r25
    packet_out[len+1]=crc & 0xFF;
     7ac:	89 83       	std	Y+1, r24	; 0x01
    len+=AX25_FCS_LENGTH;
     7ae:	82 e1       	ldi	r24, 0x12	; 18
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	e8 0e       	add	r14, r24
     7b4:	f9 1e       	adc	r15, r25

    return len;
     7b6:	00 e0       	ldi	r16, 0x00	; 0
     7b8:	10 e0       	ldi	r17, 0x00	; 0
     7ba:	03 c0       	rjmp	.+6      	; 0x7c2 <ax25_create_ui_packet+0x82>
	uint16_t len=0;
	uint16_t ax25_len=0;

    //check for input errors
    if(payload_length > AX25_MAX_PAYLOAD_LENGTH || packet_out==NULL)
        return 0;
     7bc:	ee 24       	eor	r14, r14
     7be:	ff 24       	eor	r15, r15
     7c0:	87 01       	movw	r16, r14
    packet_out[len]=crc>>8 & 0xFF;
    packet_out[len+1]=crc & 0xFF;
    len+=AX25_FCS_LENGTH;

    return len;
}
     7c2:	b7 01       	movw	r22, r14
     7c4:	c8 01       	movw	r24, r16
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	08 95       	ret

000007d4 <ax25_check_destination>:

uint8_t ax25_check_destination(uint8_t* my_dst, uint8_t* packet_dst_out, uint8_t* packet_in)
{
     7d4:	0f 93       	push	r16
     7d6:	1f 93       	push	r17
     7d8:	cf 93       	push	r28
     7da:	df 93       	push	r29
     7dc:	eb 01       	movw	r28, r22
     7de:	8a 01       	movw	r16, r20
    uint8_t result;
    //check for address match
    result=memcmp(my_dst, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     7e0:	ba 01       	movw	r22, r20
     7e2:	47 e0       	ldi	r20, 0x07	; 7
     7e4:	50 e0       	ldi	r21, 0x00	; 0
     7e6:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
    if(result)
     7ea:	88 23       	and	r24, r24
     7ec:	39 f0       	breq	.+14     	; 0x7fc <ax25_check_destination+0x28>
    {
        result=memcmp(ax25_broadcast_address, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     7ee:	8c e8       	ldi	r24, 0x8C	; 140
     7f0:	94 e0       	ldi	r25, 0x04	; 4
     7f2:	b8 01       	movw	r22, r16
     7f4:	47 e0       	ldi	r20, 0x07	; 7
     7f6:	50 e0       	ldi	r21, 0x00	; 0
     7f8:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
    }

    //copy the destination address in the packet
    if(packet_dst_out!=NULL)
     7fc:	20 97       	sbiw	r28, 0x00	; 0
     7fe:	41 f0       	breq	.+16     	; 0x810 <ax25_check_destination+0x3c>
    	memcpy(packet_dst_out, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     800:	20 2f       	mov	r18, r16
     802:	31 2f       	mov	r19, r17
     804:	f9 01       	movw	r30, r18
     806:	97 e0       	ldi	r25, 0x07	; 7
     808:	01 90       	ld	r0, Z+
     80a:	09 92       	st	Y+, r0
     80c:	91 50       	subi	r25, 0x01	; 1
     80e:	e1 f7       	brne	.-8      	; 0x808 <ax25_check_destination+0x34>
    return result;
}
     810:	df 91       	pop	r29
     812:	cf 91       	pop	r28
     814:	1f 91       	pop	r17
     816:	0f 91       	pop	r16
     818:	08 95       	ret

0000081a <ax25_open_ui_packet>:

uint16_t ax25_open_ui_packet(uint8_t* src_out, uint8_t* dst_out, uint8_t* payload_out, uint8_t* packet_in, uint16_t packet_length)
{
     81a:	af 92       	push	r10
     81c:	bf 92       	push	r11
     81e:	cf 92       	push	r12
     820:	df 92       	push	r13
     822:	ef 92       	push	r14
     824:	ff 92       	push	r15
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	6a 01       	movw	r12, r20
     830:	e9 01       	movw	r28, r18
     832:	98 01       	movw	r18, r16
    uint8_t control=0, pid=0;
    uint16_t ax25_len=0, len=0;
    uint16_t crc=0, packet_crc=0;
    //copy destination address
    if(dst_out!=NULL)
     834:	61 15       	cp	r22, r1
     836:	71 05       	cpc	r23, r1
     838:	39 f0       	breq	.+14     	; 0x848 <ax25_open_ui_packet+0x2e>
    	memcpy(dst_out, packet_in+AX25_DESTINATION_OFFSET, AX25_DESTINATION_LENGTH);
     83a:	db 01       	movw	r26, r22
     83c:	fe 01       	movw	r30, r28
     83e:	47 e0       	ldi	r20, 0x07	; 7
     840:	01 90       	ld	r0, Z+
     842:	0d 92       	st	X+, r0
     844:	41 50       	subi	r20, 0x01	; 1
     846:	e1 f7       	brne	.-8      	; 0x840 <ax25_open_ui_packet+0x26>

    //copy source address
    if(src_out!=NULL)
     848:	00 97       	sbiw	r24, 0x00	; 0
     84a:	41 f0       	breq	.+16     	; 0x85c <ax25_open_ui_packet+0x42>
    	memcpy(src_out, packet_in+AX25_SOURCE_OFFSET, AX25_SOURCE_LENGTH);
     84c:	dc 01       	movw	r26, r24
     84e:	fe 01       	movw	r30, r28
     850:	37 96       	adiw	r30, 0x07	; 7
     852:	87 e0       	ldi	r24, 0x07	; 7
     854:	01 90       	ld	r0, Z+
     856:	0d 92       	st	X+, r0
     858:	81 50       	subi	r24, 0x01	; 1
     85a:	e1 f7       	brne	.-8      	; 0x854 <ax25_open_ui_packet+0x3a>
    //copy ax25 pid
    pid=packet_in[AX25_PID_OFFSET];

    //calculate payload length
    ax25_len=packet_length;
    len=ax25_len-AX25_DESTINATION_LENGTH-AX25_SOURCE_LENGTH-AX25_CONTROL_LENGTH-AX25_PID_LENGTH-AX25_FCS_LENGTH;
     85c:	89 01       	movw	r16, r18
     85e:	02 51       	subi	r16, 0x12	; 18
     860:	10 40       	sbci	r17, 0x00	; 0

    //copy the crc came with packet
    packet_crc=packet_in[AX25_FCS_OFFSET(len)] & 0xFF;
     862:	7e 01       	movw	r14, r28
     864:	e0 0e       	add	r14, r16
     866:	f1 1e       	adc	r15, r17
     868:	f7 01       	movw	r30, r14
     86a:	80 89       	ldd	r24, Z+16	; 0x10
    packet_crc=packet_crc<<8;
     86c:	b8 2e       	mov	r11, r24
     86e:	aa 24       	eor	r10, r10
    packet_crc|=packet_in[AX25_FCS_OFFSET(len)+1] & 0xFF;

    //calculate fcs (crc32)
    crc=ax25_compute_crc(packet_in, ax25_len-AX25_FCS_LENGTH);
     870:	b9 01       	movw	r22, r18
     872:	62 50       	subi	r22, 0x02	; 2
     874:	70 40       	sbci	r23, 0x00	; 0
     876:	ce 01       	movw	r24, r28
     878:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <ax25_compute_crc>
    len=ax25_len-AX25_DESTINATION_LENGTH-AX25_SOURCE_LENGTH-AX25_CONTROL_LENGTH-AX25_PID_LENGTH-AX25_FCS_LENGTH;

    //copy the crc came with packet
    packet_crc=packet_in[AX25_FCS_OFFSET(len)] & 0xFF;
    packet_crc=packet_crc<<8;
    packet_crc|=packet_in[AX25_FCS_OFFSET(len)+1] & 0xFF;
     87c:	f7 01       	movw	r30, r14
     87e:	21 89       	ldd	r18, Z+17	; 0x11
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	2a 29       	or	r18, r10
     884:	3b 29       	or	r19, r11

    //calculate fcs (crc32)
    crc=ax25_compute_crc(packet_in, ax25_len-AX25_FCS_LENGTH);

    //check for match
    if(packet_crc != crc)
     886:	28 17       	cp	r18, r24
     888:	39 07       	cpc	r19, r25
     88a:	71 f4       	brne	.+28     	; 0x8a8 <ax25_open_ui_packet+0x8e>
        return 0;

    if(payload_out!=NULL)
     88c:	c1 14       	cp	r12, r1
     88e:	d1 04       	cpc	r13, r1
     890:	69 f0       	breq	.+26     	; 0x8ac <ax25_open_ui_packet+0x92>
    {
        memcpy(payload_out, packet_in+AX25_PAYLOAD_OFFSET, len);
     892:	60 96       	adiw	r28, 0x10	; 16
     894:	c6 01       	movw	r24, r12
     896:	be 01       	movw	r22, r28
     898:	a8 01       	movw	r20, r16
     89a:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
        payload_out[len]=0;
     89e:	f6 01       	movw	r30, r12
     8a0:	e0 0f       	add	r30, r16
     8a2:	f1 1f       	adc	r31, r17
     8a4:	10 82       	st	Z, r1
     8a6:	02 c0       	rjmp	.+4      	; 0x8ac <ax25_open_ui_packet+0x92>
    //calculate fcs (crc32)
    crc=ax25_compute_crc(packet_in, ax25_len-AX25_FCS_LENGTH);

    //check for match
    if(packet_crc != crc)
        return 0;
     8a8:	00 e0       	ldi	r16, 0x00	; 0
     8aa:	10 e0       	ldi	r17, 0x00	; 0
        memcpy(payload_out, packet_in+AX25_PAYLOAD_OFFSET, len);
        payload_out[len]=0;
    }

    return len;
}
     8ac:	c8 01       	movw	r24, r16
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
     8b2:	1f 91       	pop	r17
     8b4:	0f 91       	pop	r16
     8b6:	ff 90       	pop	r15
     8b8:	ef 90       	pop	r14
     8ba:	df 90       	pop	r13
     8bc:	cf 90       	pop	r12
     8be:	bf 90       	pop	r11
     8c0:	af 90       	pop	r10
     8c2:	08 95       	ret

000008c4 <eth_compute_crc>:
        0xA005713C, 0xBDB26158, 0x9B6B51F4, 0x86DC4190,
        0xD6D930AC, 0xCB6E20C8, 0xEDB71064, 0xF0000000
    };

    static uint16_t eth_compute_crc(uint8_t* buf, uint16_t len)
    {
     8c4:	af 92       	push	r10
     8c6:	bf 92       	push	r11
     8c8:	df 92       	push	r13
     8ca:	ef 92       	push	r14
     8cc:	ff 92       	push	r15
     8ce:	0f 93       	push	r16
     8d0:	1f 93       	push	r17
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	5b 01       	movw	r10, r22
    	uint16_t n;
    	uint32_t crc=0;
        for (n=0; n<len; n++)
     8d8:	e8 2f       	mov	r30, r24
     8da:	f9 2f       	mov	r31, r25
    };

    static uint16_t eth_compute_crc(uint8_t* buf, uint16_t len)
    {
    	uint16_t n;
    	uint32_t crc=0;
     8dc:	20 e0       	ldi	r18, 0x00	; 0
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	a9 01       	movw	r20, r18
        for (n=0; n<len; n++)
     8e2:	60 e0       	ldi	r22, 0x00	; 0
     8e4:	70 e0       	ldi	r23, 0x00	; 0
     8e6:	4f c0       	rjmp	.+158    	; 0x986 <eth_compute_crc+0xc2>
        {
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 0)) & 0x0F];  /* lower nibble */
     8e8:	79 01       	movw	r14, r18
     8ea:	8a 01       	movw	r16, r20
     8ec:	a4 e0       	ldi	r26, 0x04	; 4
     8ee:	16 95       	lsr	r17
     8f0:	07 95       	ror	r16
     8f2:	f7 94       	ror	r15
     8f4:	e7 94       	ror	r14
     8f6:	aa 95       	dec	r26
     8f8:	d1 f7       	brne	.-12     	; 0x8ee <eth_compute_crc+0x2a>
     8fa:	d1 90       	ld	r13, Z+
     8fc:	8d 2d       	mov	r24, r13
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	a0 e0       	ldi	r26, 0x00	; 0
     902:	b0 e0       	ldi	r27, 0x00	; 0
     904:	82 27       	eor	r24, r18
     906:	93 27       	eor	r25, r19
     908:	a4 27       	eor	r26, r20
     90a:	b5 27       	eor	r27, r21
     90c:	8f 70       	andi	r24, 0x0F	; 15
     90e:	90 70       	andi	r25, 0x00	; 0
     910:	a0 70       	andi	r26, 0x00	; 0
     912:	b0 70       	andi	r27, 0x00	; 0
     914:	88 0f       	add	r24, r24
     916:	99 1f       	adc	r25, r25
     918:	88 0f       	add	r24, r24
     91a:	99 1f       	adc	r25, r25
     91c:	86 56       	subi	r24, 0x66	; 102
     91e:	9b 4f       	sbci	r25, 0xFB	; 251
     920:	ec 01       	movw	r28, r24
     922:	88 81       	ld	r24, Y
     924:	99 81       	ldd	r25, Y+1	; 0x01
     926:	aa 81       	ldd	r26, Y+2	; 0x02
     928:	bb 81       	ldd	r27, Y+3	; 0x03
     92a:	8e 25       	eor	r24, r14
     92c:	9f 25       	eor	r25, r15
     92e:	a0 27       	eor	r26, r16
     930:	b1 27       	eor	r27, r17
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 4)) & 0x0F];  /* upper nibble */
     932:	7c 01       	movw	r14, r24
     934:	8d 01       	movw	r16, r26
     936:	34 e0       	ldi	r19, 0x04	; 4
     938:	16 95       	lsr	r17
     93a:	07 95       	ror	r16
     93c:	f7 94       	ror	r15
     93e:	e7 94       	ror	r14
     940:	3a 95       	dec	r19
     942:	d1 f7       	brne	.-12     	; 0x938 <eth_compute_crc+0x74>
     944:	d2 94       	swap	r13
     946:	2f e0       	ldi	r18, 0x0F	; 15
     948:	d2 22       	and	r13, r18
     94a:	2d 2d       	mov	r18, r13
     94c:	30 e0       	ldi	r19, 0x00	; 0
     94e:	40 e0       	ldi	r20, 0x00	; 0
     950:	50 e0       	ldi	r21, 0x00	; 0
     952:	28 27       	eor	r18, r24
     954:	39 27       	eor	r19, r25
     956:	4a 27       	eor	r20, r26
     958:	5b 27       	eor	r21, r27
     95a:	2f 70       	andi	r18, 0x0F	; 15
     95c:	30 70       	andi	r19, 0x00	; 0
     95e:	40 70       	andi	r20, 0x00	; 0
     960:	50 70       	andi	r21, 0x00	; 0
     962:	22 0f       	add	r18, r18
     964:	33 1f       	adc	r19, r19
     966:	22 0f       	add	r18, r18
     968:	33 1f       	adc	r19, r19
     96a:	26 56       	subi	r18, 0x66	; 102
     96c:	3b 4f       	sbci	r19, 0xFB	; 251
     96e:	d9 01       	movw	r26, r18
     970:	2d 91       	ld	r18, X+
     972:	3d 91       	ld	r19, X+
     974:	4d 91       	ld	r20, X+
     976:	5c 91       	ld	r21, X
     978:	13 97       	sbiw	r26, 0x03	; 3
     97a:	2e 25       	eor	r18, r14
     97c:	3f 25       	eor	r19, r15
     97e:	40 27       	eor	r20, r16
     980:	51 27       	eor	r21, r17

    static uint16_t eth_compute_crc(uint8_t* buf, uint16_t len)
    {
    	uint16_t n;
    	uint32_t crc=0;
        for (n=0; n<len; n++)
     982:	6f 5f       	subi	r22, 0xFF	; 255
     984:	7f 4f       	sbci	r23, 0xFF	; 255
     986:	6a 15       	cp	r22, r10
     988:	7b 05       	cpc	r23, r11
     98a:	08 f4       	brcc	.+2      	; 0x98e <eth_compute_crc+0xca>
     98c:	ad cf       	rjmp	.-166    	; 0x8e8 <eth_compute_crc+0x24>
        {
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 0)) & 0x0F];  /* lower nibble */
            crc = (crc >> 4) ^ eth_crc_table[(crc ^ (buf[n] >> 4)) & 0x0F];  /* upper nibble */
        }
        return crc;
    }
     98e:	c9 01       	movw	r24, r18
     990:	df 91       	pop	r29
     992:	cf 91       	pop	r28
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	ff 90       	pop	r15
     99a:	ef 90       	pop	r14
     99c:	df 90       	pop	r13
     99e:	bf 90       	pop	r11
     9a0:	af 90       	pop	r10
     9a2:	08 95       	ret

000009a4 <eth_initialize_network>:


    void eth_initialize_network(uint8_t* myEth)
    {
     9a4:	28 2f       	mov	r18, r24
     9a6:	39 2f       	mov	r19, r25
     9a8:	d9 01       	movw	r26, r18
     9aa:	e0 ee       	ldi	r30, 0xE0	; 224
     9ac:	f4 e0       	ldi	r31, 0x04	; 4
        uint32_t i;
        for(i=0; i<6; i++)
            local_eth_address[i] = myEth[i];
     9ae:	8d 91       	ld	r24, X+
     9b0:	81 93       	st	Z+, r24


    void eth_initialize_network(uint8_t* myEth)
    {
        uint32_t i;
        for(i=0; i<6; i++)
     9b2:	84 e0       	ldi	r24, 0x04	; 4
     9b4:	e6 3e       	cpi	r30, 0xE6	; 230
     9b6:	f8 07       	cpc	r31, r24
     9b8:	d1 f7       	brne	.-12     	; 0x9ae <eth_initialize_network+0xa>
            local_eth_address[i] = myEth[i];
    }
     9ba:	08 95       	ret

000009bc <eth_get_local_address>:

    uint8_t* eth_get_local_address(uint8_t* eth_out)
    {
        uint8_t i;

        if(eth_out!=NULL)
     9bc:	00 97       	sbiw	r24, 0x00	; 0
     9be:	49 f0       	breq	.+18     	; 0x9d2 <eth_get_local_address+0x16>
     9c0:	e0 ee       	ldi	r30, 0xE0	; 224
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	dc 01       	movw	r26, r24
        {
            for(i=0; i<6; i++)
                eth_out[i] = local_eth_address[i];
     9c6:	81 91       	ld	r24, Z+
     9c8:	8d 93       	st	X+, r24
    {
        uint8_t i;

        if(eth_out!=NULL)
        {
            for(i=0; i<6; i++)
     9ca:	84 e0       	ldi	r24, 0x04	; 4
     9cc:	e6 3e       	cpi	r30, 0xE6	; 230
     9ce:	f8 07       	cpc	r31, r24
     9d0:	d1 f7       	brne	.-12     	; 0x9c6 <eth_get_local_address+0xa>
                eth_out[i] = local_eth_address[i];
        }
        return local_eth_address;
    }
     9d2:	80 ee       	ldi	r24, 0xE0	; 224
     9d4:	94 e0       	ldi	r25, 0x04	; 4
     9d6:	08 95       	ret

000009d8 <eth_get_broadcast_address>:

    uint8_t* eth_get_broadcast_address(uint8_t* eth_out)
    {
        uint8_t i;

        if(eth_out!=NULL)
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	49 f0       	breq	.+18     	; 0x9ee <eth_get_broadcast_address+0x16>
     9dc:	ea ed       	ldi	r30, 0xDA	; 218
     9de:	f4 e0       	ldi	r31, 0x04	; 4
     9e0:	dc 01       	movw	r26, r24
        {
            for(i=0; i<6; i++)
                eth_out[i] = eth_broadcast_address[i];
     9e2:	81 91       	ld	r24, Z+
     9e4:	8d 93       	st	X+, r24
    {
        uint8_t i;

        if(eth_out!=NULL)
        {
            for(i=0; i<6; i++)
     9e6:	84 e0       	ldi	r24, 0x04	; 4
     9e8:	e0 3e       	cpi	r30, 0xE0	; 224
     9ea:	f8 07       	cpc	r31, r24
     9ec:	d1 f7       	brne	.-12     	; 0x9e2 <eth_get_broadcast_address+0xa>
                eth_out[i] = eth_broadcast_address[i];
        }
        return eth_broadcast_address;
    }
     9ee:	8a ed       	ldi	r24, 0xDA	; 218
     9f0:	94 e0       	ldi	r25, 0x04	; 4
     9f2:	08 95       	ret

000009f4 <eth_create_packet>:
     *
     * note: since our application won't and can't use csma/cd this implementation ignores the padding which is used for csma/cd
     * therefore this packet may contain payloads with lengths lower then 40 bytes
     */
    uint32_t eth_create_packet(uint8_t* src_in, uint8_t* dst_in, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
    {
     9f4:	ef 92       	push	r14
     9f6:	ff 92       	push	r15
     9f8:	0f 93       	push	r16
     9fa:	1f 93       	push	r17
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	79 01       	movw	r14, r18
     a02:	e8 01       	movw	r28, r16
        uint32_t crc=0;
        uint16_t len=0;
        uint16_t eth_len=0;

        //check for input errors
        if(payload_length > ETH_MAX_PAYLOAD_LENGTH || packet_out==NULL)
     a04:	21 e2       	ldi	r18, 0x21	; 33
     a06:	e2 16       	cp	r14, r18
     a08:	22 e0       	ldi	r18, 0x02	; 2
     a0a:	f2 06       	cpc	r15, r18
     a0c:	88 f5       	brcc	.+98     	; 0xa70 <eth_create_packet+0x7c>
     a0e:	20 97       	sbiw	r28, 0x00	; 0
     a10:	79 f1       	breq	.+94     	; 0xa70 <eth_create_packet+0x7c>
            return 0;

        //destination address
        memcpy(packet_out+ETH_DESTINATION_OFFSET, dst_in, ETH_DESTINATION_LENGTH);
     a12:	d8 01       	movw	r26, r16
     a14:	26 2f       	mov	r18, r22
     a16:	37 2f       	mov	r19, r23
     a18:	f9 01       	movw	r30, r18
     a1a:	26 e0       	ldi	r18, 0x06	; 6
     a1c:	01 90       	ld	r0, Z+
     a1e:	0d 92       	st	X+, r0
     a20:	21 50       	subi	r18, 0x01	; 1
     a22:	e1 f7       	brne	.-8      	; 0xa1c <eth_create_packet+0x28>
        len+=ETH_DESTINATION_LENGTH;

        //source address
        memcpy(packet_out+ETH_SOURCE_OFFSET, src_in, ETH_SOURCE_LENGTH);
     a24:	de 01       	movw	r26, r28
     a26:	16 96       	adiw	r26, 0x06	; 6
     a28:	fc 01       	movw	r30, r24
     a2a:	86 e0       	ldi	r24, 0x06	; 6
     a2c:	01 90       	ld	r0, Z+
     a2e:	0d 92       	st	X+, r0
     a30:	81 50       	subi	r24, 0x01	; 1
     a32:	e1 f7       	brne	.-8      	; 0xa2c <eth_create_packet+0x38>
        len+=ETH_SOURCE_LENGTH;

        //packet length
        eth_len=ETH_DESTINATION_LENGTH+ETH_SOURCE_LENGTH+ETH_LENGTH_LENGTH+payload_length+ETH_FCS_LENGTH;
     a34:	87 01       	movw	r16, r14
     a36:	0e 5e       	subi	r16, 0xEE	; 238
     a38:	1f 4f       	sbci	r17, 0xFF	; 255
        packet_out[len]=eth_len>>8 & 0xFF;
     a3a:	1c 87       	std	Y+12, r17	; 0x0c
        packet_out[len+1]=eth_len & 0xFF;
     a3c:	0d 87       	std	Y+13, r16	; 0x0d
        len+=ETH_LENGTH_LENGTH;

        //payload
        memcpy(packet_out+ETH_PAYLOAD_OFFSET, payload_in, payload_length);
     a3e:	9e 01       	movw	r18, r28
     a40:	22 5f       	subi	r18, 0xF2	; 242
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	c9 01       	movw	r24, r18
     a46:	ba 01       	movw	r22, r20
     a48:	a7 01       	movw	r20, r14
     a4a:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
        len+=payload_length;
     a4e:	8e e0       	ldi	r24, 0x0E	; 14
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	e8 0e       	add	r14, r24
     a54:	f9 1e       	adc	r15, r25

        //fcs (crc32)
        crc=eth_compute_crc(packet_out, len);
     a56:	ce 01       	movw	r24, r28
     a58:	b7 01       	movw	r22, r14
     a5a:	0e 94 62 04 	call	0x8c4	; 0x8c4 <eth_compute_crc>

        packet_out[len]=crc>>24 & 0xFF;
     a5e:	ce 0d       	add	r28, r14
     a60:	df 1d       	adc	r29, r15
     a62:	18 82       	st	Y, r1
        packet_out[len+1]=crc>>16 & 0xFF;
     a64:	19 82       	std	Y+1, r1	; 0x01
        packet_out[len+2]=crc>>8 & 0xFF;
     a66:	9a 83       	std	Y+2, r25	; 0x02
        packet_out[len+3]=crc & 0xFF;
     a68:	8b 83       	std	Y+3, r24	; 0x03
        len+=ETH_FCS_LENGTH;

        return len;
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	03 c0       	rjmp	.+6      	; 0xa76 <eth_create_packet+0x82>
        uint16_t len=0;
        uint16_t eth_len=0;

        //check for input errors
        if(payload_length > ETH_MAX_PAYLOAD_LENGTH || packet_out==NULL)
            return 0;
     a70:	00 e0       	ldi	r16, 0x00	; 0
     a72:	10 e0       	ldi	r17, 0x00	; 0
     a74:	98 01       	movw	r18, r16
        packet_out[len+2]=crc>>8 & 0xFF;
        packet_out[len+3]=crc & 0xFF;
        len+=ETH_FCS_LENGTH;

        return len;
    }
     a76:	b8 01       	movw	r22, r16
     a78:	c9 01       	movw	r24, r18
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	ff 90       	pop	r15
     a84:	ef 90       	pop	r14
     a86:	08 95       	ret

00000a88 <eth_check_destination>:
     * checks the destination of the packet_in with my_dst
     * if packet_dst is not null pointer writes the packet's destination to packet_dst
     * returns zero if the addresses match
     */
    uint8_t eth_check_destination(uint8_t* my_dst, uint8_t* packet_dst, uint8_t* packet_in)
    {
     a88:	0f 93       	push	r16
     a8a:	1f 93       	push	r17
     a8c:	cf 93       	push	r28
     a8e:	df 93       	push	r29
     a90:	eb 01       	movw	r28, r22
     a92:	8a 01       	movw	r16, r20
        uint8_t result;
        //check for address match
        result=memcmp(my_dst, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     a94:	ba 01       	movw	r22, r20
     a96:	46 e0       	ldi	r20, 0x06	; 6
     a98:	50 e0       	ldi	r21, 0x00	; 0
     a9a:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
        if(result)
     a9e:	88 23       	and	r24, r24
     aa0:	39 f0       	breq	.+14     	; 0xab0 <eth_check_destination+0x28>
        {
            result=memcmp(eth_broadcast_address, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     aa2:	8a ed       	ldi	r24, 0xDA	; 218
     aa4:	94 e0       	ldi	r25, 0x04	; 4
     aa6:	b8 01       	movw	r22, r16
     aa8:	46 e0       	ldi	r20, 0x06	; 6
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
        }

        //copy the destination address in the packet
        if(packet_dst!=NULL)
     ab0:	20 97       	sbiw	r28, 0x00	; 0
     ab2:	41 f0       	breq	.+16     	; 0xac4 <eth_check_destination+0x3c>
        	memcpy(packet_dst, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     ab4:	20 2f       	mov	r18, r16
     ab6:	31 2f       	mov	r19, r17
     ab8:	f9 01       	movw	r30, r18
     aba:	96 e0       	ldi	r25, 0x06	; 6
     abc:	01 90       	ld	r0, Z+
     abe:	09 92       	st	Y+, r0
     ac0:	91 50       	subi	r25, 0x01	; 1
     ac2:	e1 f7       	brne	.-8      	; 0xabc <eth_check_destination+0x34>
        return result;
    }
     ac4:	df 91       	pop	r29
     ac6:	cf 91       	pop	r28
     ac8:	1f 91       	pop	r17
     aca:	0f 91       	pop	r16
     acc:	08 95       	ret

00000ace <eth_open_packet>:
     * before writing anything it first checks the checksum, if the checksum doesn't match,
     * null is written to all pointers and function returns 0
     * on a successful opening function returns the length of the packet
     */
    uint16_t eth_open_packet(uint8_t* src_out, uint8_t* dst_out, uint8_t* payload_out, uint8_t* packet_in, uint16_t packet_length)
    {
     ace:	6f 92       	push	r6
     ad0:	7f 92       	push	r7
     ad2:	8f 92       	push	r8
     ad4:	9f 92       	push	r9
     ad6:	af 92       	push	r10
     ad8:	bf 92       	push	r11
     ada:	cf 92       	push	r12
     adc:	df 92       	push	r13
     ade:	ef 92       	push	r14
     ae0:	ff 92       	push	r15
     ae2:	0f 93       	push	r16
     ae4:	1f 93       	push	r17
     ae6:	cf 93       	push	r28
     ae8:	df 93       	push	r29
     aea:	3a 01       	movw	r6, r20
     aec:	e9 01       	movw	r28, r18
     aee:	68 01       	movw	r12, r16
        uint16_t len=0;
        uint16_t eth_len=0;
        uint32_t crc=0, packet_crc=0;
        //copy destination address
        if(dst_out!=NULL)
     af0:	61 15       	cp	r22, r1
     af2:	71 05       	cpc	r23, r1
     af4:	51 f0       	breq	.+20     	; 0xb0a <eth_open_packet+0x3c>
        	memcpy(dst_out, packet_in+ETH_DESTINATION_OFFSET, ETH_DESTINATION_LENGTH);
     af6:	a9 01       	movw	r20, r18
     af8:	26 e0       	ldi	r18, 0x06	; 6
     afa:	da 01       	movw	r26, r20
     afc:	0d 90       	ld	r0, X+
     afe:	ad 01       	movw	r20, r26
     b00:	db 01       	movw	r26, r22
     b02:	0d 92       	st	X+, r0
     b04:	bd 01       	movw	r22, r26
     b06:	21 50       	subi	r18, 0x01	; 1
     b08:	c1 f7       	brne	.-16     	; 0xafa <eth_open_packet+0x2c>

        //copy source address
        if(src_out!=NULL)
     b0a:	00 97       	sbiw	r24, 0x00	; 0
     b0c:	61 f0       	breq	.+24     	; 0xb26 <eth_open_packet+0x58>
        	memcpy(src_out, packet_in+ETH_SOURCE_OFFSET, ETH_SOURCE_LENGTH);
     b0e:	ae 01       	movw	r20, r28
     b10:	4a 5f       	subi	r20, 0xFA	; 250
     b12:	5f 4f       	sbci	r21, 0xFF	; 255
     b14:	26 e0       	ldi	r18, 0x06	; 6
     b16:	da 01       	movw	r26, r20
     b18:	0d 90       	ld	r0, X+
     b1a:	ad 01       	movw	r20, r26
     b1c:	dc 01       	movw	r26, r24
     b1e:	0d 92       	st	X+, r0
     b20:	cd 01       	movw	r24, r26
     b22:	21 50       	subi	r18, 0x01	; 1
     b24:	c1 f7       	brne	.-16     	; 0xb16 <eth_open_packet+0x48>

        //copy ethernet packet length
        eth_len=packet_in[ETH_LENGTH_OFFSET] & 0xFF;
     b26:	8c 85       	ldd	r24, Y+12	; 0x0c
        eth_len=eth_len<<8;
     b28:	f8 2f       	mov	r31, r24
     b2a:	e0 e0       	ldi	r30, 0x00	; 0
        eth_len|=packet_in[ETH_LENGTH_OFFSET+1] & 0xFF;
     b2c:	8d 85       	ldd	r24, Y+13	; 0x0d
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	e8 2b       	or	r30, r24
     b32:	f9 2b       	or	r31, r25

        //printf("packet_length=%d\neth_len=%d\n",packet_length, eth_len);
        //calculate payload length
        if(packet_length!=eth_len)
     b34:	ce 16       	cp	r12, r30
     b36:	df 06       	cpc	r13, r31
     b38:	09 f0       	breq	.+2      	; 0xb3c <eth_open_packet+0x6e>
     b3a:	4c c0       	rjmp	.+152    	; 0xbd4 <eth_open_packet+0x106>
        	return 0;

        len=eth_len-ETH_DESTINATION_LENGTH-ETH_SOURCE_LENGTH-ETH_LENGTH_LENGTH-ETH_FCS_LENGTH;
     b3c:	86 01       	movw	r16, r12
     b3e:	02 51       	subi	r16, 0x12	; 18
     b40:	10 40       	sbci	r17, 0x00	; 0

        //copy the crc came with packet
        packet_crc=packet_in[ETH_PAYLOAD_OFFSET+len] & 0xFF;
     b42:	7e 01       	movw	r14, r28
     b44:	e0 0e       	add	r14, r16
     b46:	f1 1e       	adc	r15, r17
     b48:	f7 01       	movw	r30, r14
     b4a:	86 85       	ldd	r24, Z+14	; 0x0e
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	a0 e0       	ldi	r26, 0x00	; 0
     b50:	b0 e0       	ldi	r27, 0x00	; 0
        packet_crc=packet_crc<<8;
     b52:	ba 2f       	mov	r27, r26
     b54:	a9 2f       	mov	r26, r25
     b56:	98 2f       	mov	r25, r24
     b58:	88 27       	eor	r24, r24
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+1] & 0xFF;
     b5a:	27 85       	ldd	r18, Z+15	; 0x0f
     b5c:	30 e0       	ldi	r19, 0x00	; 0
     b5e:	40 e0       	ldi	r20, 0x00	; 0
     b60:	50 e0       	ldi	r21, 0x00	; 0
     b62:	82 2b       	or	r24, r18
     b64:	93 2b       	or	r25, r19
     b66:	a4 2b       	or	r26, r20
     b68:	b5 2b       	or	r27, r21
        packet_crc=packet_crc<<8;
     b6a:	ba 2f       	mov	r27, r26
     b6c:	a9 2f       	mov	r26, r25
     b6e:	98 2f       	mov	r25, r24
     b70:	88 27       	eor	r24, r24
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+2] & 0xFF;
     b72:	20 89       	ldd	r18, Z+16	; 0x10
     b74:	30 e0       	ldi	r19, 0x00	; 0
     b76:	40 e0       	ldi	r20, 0x00	; 0
     b78:	50 e0       	ldi	r21, 0x00	; 0
     b7a:	82 2b       	or	r24, r18
     b7c:	93 2b       	or	r25, r19
     b7e:	a4 2b       	or	r26, r20
     b80:	b5 2b       	or	r27, r21
        packet_crc=packet_crc<<8;
     b82:	88 24       	eor	r8, r8
     b84:	98 2e       	mov	r9, r24
     b86:	a9 2e       	mov	r10, r25
     b88:	ba 2e       	mov	r11, r26
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+3] & 0xFF;

        //calculate fcs (crc32)
        crc=eth_compute_crc(packet_in, eth_len-ETH_FCS_LENGTH);
     b8a:	b6 01       	movw	r22, r12
     b8c:	64 50       	subi	r22, 0x04	; 4
     b8e:	70 40       	sbci	r23, 0x00	; 0
     b90:	ce 01       	movw	r24, r28
     b92:	0e 94 62 04 	call	0x8c4	; 0x8c4 <eth_compute_crc>
        packet_crc=packet_crc<<8;
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+1] & 0xFF;
        packet_crc=packet_crc<<8;
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+2] & 0xFF;
        packet_crc=packet_crc<<8;
        packet_crc|=packet_in[ETH_PAYLOAD_OFFSET+len+3] & 0xFF;
     b96:	d7 01       	movw	r26, r14
     b98:	51 96       	adiw	r26, 0x11	; 17
     b9a:	2c 91       	ld	r18, X
     b9c:	30 e0       	ldi	r19, 0x00	; 0
     b9e:	40 e0       	ldi	r20, 0x00	; 0
     ba0:	50 e0       	ldi	r21, 0x00	; 0
     ba2:	28 29       	or	r18, r8
     ba4:	39 29       	or	r19, r9
     ba6:	4a 29       	or	r20, r10
     ba8:	5b 29       	or	r21, r11

        //calculate fcs (crc32)
        crc=eth_compute_crc(packet_in, eth_len-ETH_FCS_LENGTH);
     baa:	a0 e0       	ldi	r26, 0x00	; 0
     bac:	b0 e0       	ldi	r27, 0x00	; 0

        //check for match
        if(packet_crc != crc)
     bae:	28 17       	cp	r18, r24
     bb0:	39 07       	cpc	r19, r25
     bb2:	4a 07       	cpc	r20, r26
     bb4:	5b 07       	cpc	r21, r27
     bb6:	71 f4       	brne	.+28     	; 0xbd4 <eth_open_packet+0x106>
            return 0;


        if(payload_out!=NULL)
     bb8:	61 14       	cp	r6, r1
     bba:	71 04       	cpc	r7, r1
     bbc:	69 f0       	breq	.+26     	; 0xbd8 <eth_open_packet+0x10a>
        {
            memcpy(payload_out, packet_in+ETH_PAYLOAD_OFFSET, len);
     bbe:	2e 96       	adiw	r28, 0x0e	; 14
     bc0:	c3 01       	movw	r24, r6
     bc2:	be 01       	movw	r22, r28
     bc4:	a8 01       	movw	r20, r16
     bc6:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
            payload_out[len]=0;
     bca:	f3 01       	movw	r30, r6
     bcc:	e0 0f       	add	r30, r16
     bce:	f1 1f       	adc	r31, r17
     bd0:	10 82       	st	Z, r1
     bd2:	02 c0       	rjmp	.+4      	; 0xbd8 <eth_open_packet+0x10a>
        //calculate fcs (crc32)
        crc=eth_compute_crc(packet_in, eth_len-ETH_FCS_LENGTH);

        //check for match
        if(packet_crc != crc)
            return 0;
     bd4:	00 e0       	ldi	r16, 0x00	; 0
     bd6:	10 e0       	ldi	r17, 0x00	; 0
            memcpy(payload_out, packet_in+ETH_PAYLOAD_OFFSET, len);
            payload_out[len]=0;
        }

        return len;
    }
     bd8:	c8 01       	movw	r24, r16
     bda:	df 91       	pop	r29
     bdc:	cf 91       	pop	r28
     bde:	1f 91       	pop	r17
     be0:	0f 91       	pop	r16
     be2:	ff 90       	pop	r15
     be4:	ef 90       	pop	r14
     be6:	df 90       	pop	r13
     be8:	cf 90       	pop	r12
     bea:	bf 90       	pop	r11
     bec:	af 90       	pop	r10
     bee:	9f 90       	pop	r9
     bf0:	8f 90       	pop	r8
     bf2:	7f 90       	pop	r7
     bf4:	6f 90       	pop	r6
     bf6:	08 95       	ret

00000bf8 <isManchester_encoded>:
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
0x0, 0x0, 0x0, 0x0, };

inline uint8_t isManchester_encoded(uint8_t byte)
{
	return me_valid_tab[byte];
     bf8:	e6 ee       	ldi	r30, 0xE6	; 230
     bfa:	f7 e0       	ldi	r31, 0x07	; 7
     bfc:	e8 0f       	add	r30, r24
     bfe:	f1 1d       	adc	r31, r1
}
     c00:	80 81       	ld	r24, Z
     c02:	08 95       	ret

00000c04 <manchester_encode>:

uint16_t manchester_encode(uint8_t* input, uint8_t* output, uint16_t size)
{
     c04:	ef 92       	push	r14
     c06:	ff 92       	push	r15
     c08:	cf 93       	push	r28
     c0a:	df 93       	push	r29
	uint16_t i, j = 0;
	for(i = 0; i<size; i++)
     c0c:	e6 2f       	mov	r30, r22
     c0e:	f7 2f       	mov	r31, r23
     c10:	e8 2e       	mov	r14, r24
     c12:	e7 01       	movw	r28, r14
     c14:	7e 01       	movw	r14, r28
     c16:	f9 2e       	mov	r15, r25
     c18:	e7 01       	movw	r28, r14
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	16 c0       	rjmp	.+44     	; 0xc4c <manchester_encode+0x48>
inline uint8_t isManchester_encoded(uint8_t byte)
{
	return me_valid_tab[byte];
}

uint16_t manchester_encode(uint8_t* input, uint8_t* output, uint16_t size)
     c20:	9e 01       	movw	r18, r28
{
	uint16_t i, j = 0;
	for(i = 0; i<size; i++)
	{
		output[j++] = (me_encode_tab[input[i]]>>8)&0xFF;
     c22:	a9 91       	ld	r26, Y+
     c24:	b0 e0       	ldi	r27, 0x00	; 0
     c26:	aa 0f       	add	r26, r26
     c28:	bb 1f       	adc	r27, r27
     c2a:	aa 51       	subi	r26, 0x1A	; 26
     c2c:	ba 4f       	sbci	r27, 0xFA	; 250
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	6c 91       	ld	r22, X
     c32:	60 83       	st	Z, r22
		output[j++] = me_encode_tab[input[i]]&0xFF;
     c34:	d9 01       	movw	r26, r18
     c36:	2c 91       	ld	r18, X
     c38:	a2 2f       	mov	r26, r18
     c3a:	b0 e0       	ldi	r27, 0x00	; 0
     c3c:	aa 0f       	add	r26, r26
     c3e:	bb 1f       	adc	r27, r27
     c40:	aa 51       	subi	r26, 0x1A	; 26
     c42:	ba 4f       	sbci	r27, 0xFA	; 250
     c44:	2c 91       	ld	r18, X
     c46:	21 83       	std	Z+1, r18	; 0x01
}

uint16_t manchester_encode(uint8_t* input, uint8_t* output, uint16_t size)
{
	uint16_t i, j = 0;
	for(i = 0; i<size; i++)
     c48:	01 96       	adiw	r24, 0x01	; 1
     c4a:	32 96       	adiw	r30, 0x02	; 2
     c4c:	84 17       	cp	r24, r20
     c4e:	95 07       	cpc	r25, r21
     c50:	38 f3       	brcs	.-50     	; 0xc20 <manchester_encode+0x1c>
     c52:	44 0f       	add	r20, r20
     c54:	55 1f       	adc	r21, r21
	{
		output[j++] = (me_encode_tab[input[i]]>>8)&0xFF;
		output[j++] = me_encode_tab[input[i]]&0xFF;
	}
	return j;
}
     c56:	ca 01       	movw	r24, r20
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	ff 90       	pop	r15
     c5e:	ef 90       	pop	r14
     c60:	08 95       	ret

00000c62 <manchester_decode>:
uint16_t manchester_decode(uint8_t* input, uint8_t* output, uint16_t size)
{
     c62:	cf 93       	push	r28
     c64:	df 93       	push	r29
	uint16_t i, k = 0;
     c66:	e8 2f       	mov	r30, r24
     c68:	f9 2f       	mov	r31, r25
     c6a:	86 2f       	mov	r24, r22
     c6c:	97 2f       	mov	r25, r23
     c6e:	ec 01       	movw	r28, r24
     c70:	20 e0       	ldi	r18, 0x00	; 0
     c72:	30 e0       	ldi	r19, 0x00	; 0
	for(i = 0; i<size; i+=2)
     c74:	11 c0       	rjmp	.+34     	; 0xc98 <manchester_decode+0x36>
	{
		output[k++] = (me_decode_tab[input[i]]<<4)|me_decode_tab[input[i+1]];
     c76:	a0 81       	ld	r26, Z
     c78:	b0 e0       	ldi	r27, 0x00	; 0
     c7a:	aa 51       	subi	r26, 0x1A	; 26
     c7c:	bb 4f       	sbci	r27, 0xFB	; 251
     c7e:	8c 91       	ld	r24, X
     c80:	82 95       	swap	r24
     c82:	80 7f       	andi	r24, 0xF0	; 240
     c84:	a1 81       	ldd	r26, Z+1	; 0x01
     c86:	b0 e0       	ldi	r27, 0x00	; 0
     c88:	aa 51       	subi	r26, 0x1A	; 26
     c8a:	bb 4f       	sbci	r27, 0xFB	; 251
     c8c:	9c 91       	ld	r25, X
     c8e:	89 2b       	or	r24, r25
     c90:	89 93       	st	Y+, r24
     c92:	2f 5f       	subi	r18, 0xFF	; 255
     c94:	3f 4f       	sbci	r19, 0xFF	; 255
     c96:	32 96       	adiw	r30, 0x02	; 2
	return j;
}
uint16_t manchester_decode(uint8_t* input, uint8_t* output, uint16_t size)
{
	uint16_t i, k = 0;
	for(i = 0; i<size; i+=2)
     c98:	c9 01       	movw	r24, r18
     c9a:	88 0f       	add	r24, r24
     c9c:	99 1f       	adc	r25, r25
     c9e:	84 17       	cp	r24, r20
     ca0:	95 07       	cpc	r25, r21
     ca2:	48 f3       	brcs	.-46     	; 0xc76 <manchester_decode+0x14>
	{
		output[k++] = (me_decode_tab[input[i]]<<4)|me_decode_tab[input[i+1]];
	}
	return k;
}
     ca4:	c9 01       	movw	r24, r18
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	08 95       	ret

00000cac <tftp_initialize>:
static uint16_t tftp_src_port=71;
static dataQueuerfptr_t mainDataQueuer;

uint8_t tftp_initialize(dataQueuerfptr_t dataQueuer)
{
    mainDataQueuer=dataQueuer;
     cac:	90 93 79 13 	sts	0x1379, r25
     cb0:	80 93 78 13 	sts	0x1378, r24
    return 0;
}

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
     cb4:	10 92 72 13 	sts	0x1372, r1
    mainDataQueuer=dataQueuer;
    tftp_setStatus(TFTP_STATUS_IDLE);
    //for testing
    //timers_create_timer("TFTP Timer", &tftp_timer, 3, 0);
    return 0;
}
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	08 95       	ret

00000cbc <tftp_setStatus>:

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
     cbc:	80 93 72 13 	sts	0x1372, r24
}
     cc0:	08 95       	ret

00000cc2 <tftp_transfer_src_port>:
uint16_t tftp_transfer_src_port(void)
{
    return tftp_src_port;
}
     cc2:	80 91 70 0b 	lds	r24, 0x0B70
     cc6:	90 91 71 0b 	lds	r25, 0x0B71
     cca:	08 95       	ret

00000ccc <tftp_transfer_dst_port>:
uint16_t tftp_transfer_dst_port(void)
{
    return tftp_dst_port;
}
     ccc:	80 91 6e 0b 	lds	r24, 0x0B6E
     cd0:	90 91 6f 0b 	lds	r25, 0x0B6F
     cd4:	08 95       	ret

00000cd6 <tftp_getRandomRetransmissionTime>:
uint8_t tftp_getRandomRetransmissionTime(void)
{
    uint8_t time = TFTP_ACK_TIMEOUT_MIN + (TFTP_ACK_TIMEOUT_MAX-TFTP_ACK_TIMEOUT_MIN+1)*(((float)rand())/((float)RAND_MAX));
     cd6:	0e 94 31 4b 	call	0x9662	; 0x9662 <rand>
     cda:	9c 01       	movw	r18, r24
     cdc:	b9 01       	movw	r22, r18
     cde:	88 27       	eor	r24, r24
     ce0:	77 fd       	sbrc	r23, 7
     ce2:	80 95       	com	r24
     ce4:	98 2f       	mov	r25, r24
     ce6:	0e 94 c7 47 	call	0x8f8e	; 0x8f8e <__floatsisf>
     cea:	20 e0       	ldi	r18, 0x00	; 0
     cec:	3e ef       	ldi	r19, 0xFE	; 254
     cee:	4f ef       	ldi	r20, 0xFF	; 255
     cf0:	56 e4       	ldi	r21, 0x46	; 70
     cf2:	0e 94 e9 46 	call	0x8dd2	; 0x8dd2 <__divsf3>
     cf6:	9b 01       	movw	r18, r22
     cf8:	ac 01       	movw	r20, r24
     cfa:	0e 94 91 45 	call	0x8b22	; 0x8b22 <__addsf3>
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	30 e0       	ldi	r19, 0x00	; 0
     d02:	40 e8       	ldi	r20, 0x80	; 128
     d04:	5f e3       	ldi	r21, 0x3F	; 63
     d06:	0e 94 91 45 	call	0x8b22	; 0x8b22 <__addsf3>
     d0a:	0e 94 1b 44 	call	0x8836	; 0x8836 <__fixunssfsi>
     d0e:	86 2f       	mov	r24, r22
    //PRINTF_D("time=%d\n", time);
    return time;
}
     d10:	08 95       	ret

00000d12 <tftp_sendSingleBlockData>:
uint8_t tftp_sendSingleBlockData(uint8_t* dst_ip, uint8_t* data_ptr, uint16_t data_len, uint8_t* remote_filename)
{
     d12:	af 92       	push	r10
     d14:	bf 92       	push	r11
     d16:	cf 92       	push	r12
     d18:	df 92       	push	r13
     d1a:	ef 92       	push	r14
     d1c:	ff 92       	push	r15
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	7c 01       	movw	r14, r24
     d28:	6b 01       	movw	r12, r22
     d2a:	8a 01       	movw	r16, r20
     d2c:	e9 01       	movw	r28, r18
	uint8_t filenameCheck=0;

	if(data_len>450)
     d2e:	21 e0       	ldi	r18, 0x01	; 1
     d30:	43 3c       	cpi	r20, 0xC3	; 195
     d32:	52 07       	cpc	r21, r18
     d34:	b0 f0       	brcs	.+44     	; 0xd62 <tftp_sendSingleBlockData+0x50>
	{
		printf("input data too large, %d\n", data_len);
     d36:	00 d0       	rcall	.+0      	; 0xd38 <tftp_sendSingleBlockData+0x26>
     d38:	00 d0       	rcall	.+0      	; 0xd3a <tftp_sendSingleBlockData+0x28>
     d3a:	86 ee       	ldi	r24, 0xE6	; 230
     d3c:	98 e0       	ldi	r25, 0x08	; 8
     d3e:	ad b7       	in	r26, 0x3d	; 61
     d40:	be b7       	in	r27, 0x3e	; 62
     d42:	12 96       	adiw	r26, 0x02	; 2
     d44:	9c 93       	st	X, r25
     d46:	8e 93       	st	-X, r24
     d48:	11 97       	sbiw	r26, 0x01	; 1
     d4a:	14 96       	adiw	r26, 0x04	; 4
     d4c:	5c 93       	st	X, r21
     d4e:	4e 93       	st	-X, r20
     d50:	13 97       	sbiw	r26, 0x03	; 3
     d52:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		return (-1);
     d56:	0f 90       	pop	r0
     d58:	0f 90       	pop	r0
     d5a:	0f 90       	pop	r0
     d5c:	0f 90       	pop	r0
     d5e:	8f ef       	ldi	r24, 0xFF	; 255
     d60:	45 c1       	rjmp	.+650    	; 0xfec <tftp_sendSingleBlockData+0x2da>
	}
	printf("destination = ");
     d62:	00 d0       	rcall	.+0      	; 0xd64 <tftp_sendSingleBlockData+0x52>
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	99 e0       	ldi	r25, 0x09	; 9
     d68:	ed b7       	in	r30, 0x3d	; 61
     d6a:	fe b7       	in	r31, 0x3e	; 62
     d6c:	92 83       	std	Z+2, r25	; 0x02
     d6e:	81 83       	std	Z+1, r24	; 0x01
     d70:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
	print_addr_dec(dst_ip);
     d74:	0f 90       	pop	r0
     d76:	0f 90       	pop	r0
     d78:	c7 01       	movw	r24, r14
     d7a:	0e 94 22 10 	call	0x2044	; 0x2044 <print_addr_dec>
//	printf("local-data-length = %d\n", data_len);
	filenameCheck |= (data_ptr==NULL);
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	c1 14       	cp	r12, r1
     d82:	d1 04       	cpc	r13, r1
     d84:	09 f0       	breq	.+2      	; 0xd88 <tftp_sendSingleBlockData+0x76>
     d86:	80 e0       	ldi	r24, 0x00	; 0
	filenameCheck = filenameCheck<<1;
     d88:	b8 2e       	mov	r11, r24
     d8a:	bb 0c       	add	r11, r11
//	printf("remote-filename = '%s'\n", remote_filename);
	filenameCheck |= (remote_filename==NULL || remote_filename[0]==0x00 );
     d8c:	20 97       	sbiw	r28, 0x00	; 0
     d8e:	41 f0       	breq	.+16     	; 0xda0 <tftp_sendSingleBlockData+0x8e>
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	90 e0       	ldi	r25, 0x00	; 0
     d94:	28 81       	ld	r18, Y
     d96:	22 23       	and	r18, r18
     d98:	29 f0       	breq	.+10     	; 0xda4 <tftp_sendSingleBlockData+0x92>
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	90 e0       	ldi	r25, 0x00	; 0
     d9e:	02 c0       	rjmp	.+4      	; 0xda4 <tftp_sendSingleBlockData+0x92>
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	b8 2a       	or	r11, r24
//	printf("filename-check = 0x%02x\n", filenameCheck);
	if(filenameCheck & 0x02)
     da6:	b1 fe       	sbrs	r11, 1
     da8:	06 c0       	rjmp	.+12     	; 0xdb6 <tftp_sendSingleBlockData+0xa4>
	{
		printf("empty local data ptr\n");
     daa:	8f e0       	ldi	r24, 0x0F	; 15
     dac:	99 e0       	ldi	r25, 0x09	; 9
     dae:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
		return (-2);
     db2:	8e ef       	ldi	r24, 0xFE	; 254
     db4:	1b c1       	rjmp	.+566    	; 0xfec <tftp_sendSingleBlockData+0x2da>
	}
	if(filenameCheck & 0x01)
     db6:	b0 fe       	sbrs	r11, 0
     db8:	06 c0       	rjmp	.+12     	; 0xdc6 <tftp_sendSingleBlockData+0xb4>
	{
		printf("empty remote filename, using default filename = "TFTP_DEFAULT_FILENAME"\n");
     dba:	84 e2       	ldi	r24, 0x24	; 36
     dbc:	99 e0       	ldi	r25, 0x09	; 9
     dbe:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
		remote_filename=TFTP_DEFAULT_FILENAME;
     dc2:	c0 e6       	ldi	r28, 0x60	; 96
     dc4:	d9 e0       	ldi	r29, 0x09	; 9
	}
	if(filenameCheck == 0x03)
     dc6:	fb 2d       	mov	r31, r11
     dc8:	f3 30       	cpi	r31, 0x03	; 3
     dca:	79 f4       	brne	.+30     	; 0xdea <tftp_sendSingleBlockData+0xd8>
	{
		printf("empty input filenames");
     dcc:	00 d0       	rcall	.+0      	; 0xdce <tftp_sendSingleBlockData+0xbc>
     dce:	8c e6       	ldi	r24, 0x6C	; 108
     dd0:	99 e0       	ldi	r25, 0x09	; 9
     dd2:	ad b7       	in	r26, 0x3d	; 61
     dd4:	be b7       	in	r27, 0x3e	; 62
     dd6:	12 96       	adiw	r26, 0x02	; 2
     dd8:	9c 93       	st	X, r25
     dda:	8e 93       	st	-X, r24
     ddc:	11 97       	sbiw	r26, 0x01	; 1
     dde:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		return (-3);
     de2:	0f 90       	pop	r0
     de4:	0f 90       	pop	r0
     de6:	8d ef       	ldi	r24, 0xFD	; 253
     de8:	01 c1       	rjmp	.+514    	; 0xfec <tftp_sendSingleBlockData+0x2da>
	}
    lastMessage.payloadLength=0;
     dea:	10 92 6d 13 	sts	0x136D, r1
     dee:	10 92 6c 13 	sts	0x136C, r1
    //put opcode in
    lastMessage.opcode=TFTP_OPCODE_WRQ_SINGLE;
     df2:	86 e0       	ldi	r24, 0x06	; 6
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	90 93 67 11 	sts	0x1167, r25
     dfa:	80 93 66 11 	sts	0x1166, r24
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
     dfe:	86 e5       	ldi	r24, 0x56	; 86
     e00:	91 e1       	ldi	r25, 0x11	; 17
     e02:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
     e06:	ac e5       	ldi	r26, 0x5C	; 92
     e08:	b1 e1       	ldi	r27, 0x11	; 17
     e0a:	8e 2d       	mov	r24, r14
     e0c:	9f 2d       	mov	r25, r15
     e0e:	fc 01       	movw	r30, r24
     e10:	86 e0       	ldi	r24, 0x06	; 6
     e12:	01 90       	ld	r0, Z+
     e14:	0d 92       	st	X+, r0
     e16:	81 50       	subi	r24, 0x01	; 1
     e18:	e1 f7       	brne	.-8      	; 0xe12 <tftp_sendSingleBlockData+0x100>
    //select destination port
    lastMessage.dst_port=69;
     e1a:	85 e4       	ldi	r24, 0x45	; 69
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	90 93 65 11 	sts	0x1165, r25
     e22:	80 93 64 11 	sts	0x1164, r24
    //select a random src port
    do
    {
        lastMessage.src_port= 65535*(((float)rand())/((float)RAND_MAX));
     e26:	0e 94 31 4b 	call	0x9662	; 0x9662 <rand>
     e2a:	fc 01       	movw	r30, r24
     e2c:	bf 01       	movw	r22, r30
     e2e:	88 27       	eor	r24, r24
     e30:	77 fd       	sbrc	r23, 7
     e32:	80 95       	com	r24
     e34:	98 2f       	mov	r25, r24
     e36:	0e 94 c7 47 	call	0x8f8e	; 0x8f8e <__floatsisf>
     e3a:	20 e0       	ldi	r18, 0x00	; 0
     e3c:	3e ef       	ldi	r19, 0xFE	; 254
     e3e:	4f ef       	ldi	r20, 0xFF	; 255
     e40:	56 e4       	ldi	r21, 0x46	; 70
     e42:	0e 94 e9 46 	call	0x8dd2	; 0x8dd2 <__divsf3>
     e46:	20 e0       	ldi	r18, 0x00	; 0
     e48:	3f ef       	ldi	r19, 0xFF	; 255
     e4a:	4f e7       	ldi	r20, 0x7F	; 127
     e4c:	57 e4       	ldi	r21, 0x47	; 71
     e4e:	0e 94 ef 45 	call	0x8bde	; 0x8bde <__mulsf3>
     e52:	0e 94 1b 44 	call	0x8836	; 0x8836 <__fixunssfsi>
     e56:	70 93 63 11 	sts	0x1163, r23
     e5a:	60 93 62 11 	sts	0x1162, r22
    }while(lastMessage.src_port==69 || lastMessage.src_port==0);
     e5e:	65 34       	cpi	r22, 0x45	; 69
     e60:	71 05       	cpc	r23, r1
     e62:	09 f3       	breq	.-62     	; 0xe26 <tftp_sendSingleBlockData+0x114>
     e64:	61 15       	cp	r22, r1
     e66:	71 05       	cpc	r23, r1
     e68:	f1 f2       	breq	.-68     	; 0xe26 <tftp_sendSingleBlockData+0x114>
    //assign the tft_src_port
    tftp_src_port=lastMessage.src_port;
     e6a:	70 93 71 0b 	sts	0x0B71, r23
     e6e:	60 93 70 0b 	sts	0x0B70, r22
    printf("tftp src port = %d\n", tftp_src_port);
     e72:	00 d0       	rcall	.+0      	; 0xe74 <tftp_sendSingleBlockData+0x162>
     e74:	00 d0       	rcall	.+0      	; 0xe76 <tftp_sendSingleBlockData+0x164>
     e76:	ed b7       	in	r30, 0x3d	; 61
     e78:	fe b7       	in	r31, 0x3e	; 62
     e7a:	31 96       	adiw	r30, 0x01	; 1
     e7c:	22 e8       	ldi	r18, 0x82	; 130
     e7e:	39 e0       	ldi	r19, 0x09	; 9
     e80:	ad b7       	in	r26, 0x3d	; 61
     e82:	be b7       	in	r27, 0x3e	; 62
     e84:	12 96       	adiw	r26, 0x02	; 2
     e86:	3c 93       	st	X, r19
     e88:	2e 93       	st	-X, r18
     e8a:	11 97       	sbiw	r26, 0x01	; 1
     e8c:	73 83       	std	Z+3, r23	; 0x03
     e8e:	62 83       	std	Z+2, r22	; 0x02
     e90:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
     e94:	e0 90 6c 13 	lds	r14, 0x136C
     e98:	f0 90 6d 13 	lds	r15, 0x136D
     e9c:	f7 01       	movw	r30, r14
     e9e:	ea 5a       	subi	r30, 0xAA	; 170
     ea0:	fe 4e       	sbci	r31, 0xEE	; 238
     ea2:	12 8a       	std	Z+18, r1	; 0x12
     ea4:	08 94       	sec
     ea6:	e1 1c       	adc	r14, r1
     ea8:	f1 1c       	adc	r15, r1
    lastMessage.payload[lastMessage.payloadLength++] = TFTP_OPCODE_WRQ_SINGLE;
     eaa:	f7 01       	movw	r30, r14
     eac:	ea 5a       	subi	r30, 0xAA	; 170
     eae:	fe 4e       	sbci	r31, 0xEE	; 238
     eb0:	86 e0       	ldi	r24, 0x06	; 6
     eb2:	82 8b       	std	Z+18, r24	; 0x12
     eb4:	08 94       	sec
     eb6:	e1 1c       	adc	r14, r1
     eb8:	f1 1c       	adc	r15, r1
     eba:	f0 92 6d 13 	sts	0x136D, r15
     ebe:	e0 92 6c 13 	sts	0x136C, r14
    memcpy(lastMessage.payload+lastMessage.payloadLength, remote_filename, strnlen(remote_filename, 16));
     ec2:	0f 90       	pop	r0
     ec4:	0f 90       	pop	r0
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	ce 01       	movw	r24, r28
     ecc:	60 e1       	ldi	r22, 0x10	; 16
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	0e 94 6c 4b 	call	0x96d8	; 0x96d8 <strnlen>
     ed4:	ac 01       	movw	r20, r24
     ed6:	97 01       	movw	r18, r14
     ed8:	28 59       	subi	r18, 0x98	; 152
     eda:	3e 4e       	sbci	r19, 0xEE	; 238
     edc:	c9 01       	movw	r24, r18
     ede:	be 01       	movw	r22, r28
     ee0:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    lastMessage.payloadLength+=strnlen(remote_filename, 16);
     ee4:	ce 01       	movw	r24, r28
     ee6:	60 e1       	ldi	r22, 0x10	; 16
     ee8:	70 e0       	ldi	r23, 0x00	; 0
     eea:	0e 94 6c 4b 	call	0x96d8	; 0x96d8 <strnlen>
     eee:	20 91 6c 13 	lds	r18, 0x136C
     ef2:	30 91 6d 13 	lds	r19, 0x136D
     ef6:	28 0f       	add	r18, r24
     ef8:	39 1f       	adc	r19, r25
     efa:	30 93 6d 13 	sts	0x136D, r19
     efe:	20 93 6c 13 	sts	0x136C, r18
    printf("remote_filename = '%s'\n", remote_filename);
     f02:	00 d0       	rcall	.+0      	; 0xf04 <tftp_sendSingleBlockData+0x1f2>
     f04:	00 d0       	rcall	.+0      	; 0xf06 <tftp_sendSingleBlockData+0x1f4>
     f06:	86 e9       	ldi	r24, 0x96	; 150
     f08:	99 e0       	ldi	r25, 0x09	; 9
     f0a:	ad b7       	in	r26, 0x3d	; 61
     f0c:	be b7       	in	r27, 0x3e	; 62
     f0e:	12 96       	adiw	r26, 0x02	; 2
     f10:	9c 93       	st	X, r25
     f12:	8e 93       	st	-X, r24
     f14:	11 97       	sbiw	r26, 0x01	; 1
     f16:	14 96       	adiw	r26, 0x04	; 4
     f18:	dc 93       	st	X, r29
     f1a:	ce 93       	st	-X, r28
     f1c:	13 97       	sbiw	r26, 0x03	; 3
     f1e:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    memcpy(lastMessage.payload+lastMessage.payloadLength, "\0netascii\0", 10);
     f22:	e0 91 6c 13 	lds	r30, 0x136C
     f26:	f0 91 6d 13 	lds	r31, 0x136D
     f2a:	e8 59       	subi	r30, 0x98	; 152
     f2c:	fe 4e       	sbci	r31, 0xEE	; 238
     f2e:	ae ea       	ldi	r26, 0xAE	; 174
     f30:	b9 e0       	ldi	r27, 0x09	; 9
     f32:	8a e0       	ldi	r24, 0x0A	; 10
     f34:	0d 90       	ld	r0, X+
     f36:	01 92       	st	Z+, r0
     f38:	81 50       	subi	r24, 0x01	; 1
     f3a:	e1 f7       	brne	.-8      	; 0xf34 <tftp_sendSingleBlockData+0x222>
    lastMessage.payloadLength+=10;
     f3c:	20 91 6c 13 	lds	r18, 0x136C
     f40:	30 91 6d 13 	lds	r19, 0x136D
     f44:	26 5f       	subi	r18, 0xF6	; 246
     f46:	3f 4f       	sbci	r19, 0xFF	; 255
     f48:	30 93 6d 13 	sts	0x136D, r19
     f4c:	20 93 6c 13 	sts	0x136C, r18
    lastMessage.append=0;
     f50:	10 92 70 13 	sts	0x1370, r1
    memcpy(&(lastMessage.payload[lastMessage.payloadLength]), data_ptr, data_len);
     f54:	28 59       	subi	r18, 0x98	; 152
     f56:	3e 4e       	sbci	r19, 0xEE	; 238
     f58:	0f 90       	pop	r0
     f5a:	0f 90       	pop	r0
     f5c:	0f 90       	pop	r0
     f5e:	0f 90       	pop	r0
     f60:	c9 01       	movw	r24, r18
     f62:	b6 01       	movw	r22, r12
     f64:	a8 01       	movw	r20, r16
     f66:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    lastMessage.payloadLength+=data_len;
     f6a:	80 91 6c 13 	lds	r24, 0x136C
     f6e:	90 91 6d 13 	lds	r25, 0x136D
     f72:	80 0f       	add	r24, r16
     f74:	91 1f       	adc	r25, r17
     f76:	90 93 6d 13 	sts	0x136D, r25
     f7a:	80 93 6c 13 	sts	0x136C, r24

    //put the block number in
    lastMessage.blockNumber = blockNumber=0;
     f7e:	10 92 77 13 	sts	0x1377, r1
     f82:	10 92 76 13 	sts	0x1376, r1
     f86:	10 92 6f 13 	sts	0x136F, r1
     f8a:	10 92 6e 13 	sts	0x136E, r1

    //set a timer to exit after a certain amount of time
	timers_create_timer(TFTP_SINGLE_BLOCK_WAIT_TIME, 128);
     f8e:	81 e0       	ldi	r24, 0x01	; 1
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	60 e8       	ldi	r22, 0x80	; 128
     f94:	70 e0       	ldi	r23, 0x00	; 0
     f96:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>


    //reset acks
    ackNumber=-1;
     f9a:	8f ef       	ldi	r24, 0xFF	; 255
     f9c:	9f ef       	ldi	r25, 0xFF	; 255
     f9e:	90 93 74 13 	sts	0x1374, r25
     fa2:	80 93 73 13 	sts	0x1373, r24
    blockNumber=0;
     fa6:	10 92 77 13 	sts	0x1377, r1
     faa:	10 92 76 13 	sts	0x1376, r1
    isRequestOwner=1;
     fae:	81 e0       	ldi	r24, 0x01	; 1
     fb0:	80 93 71 13 	sts	0x1371, r24
    timeouts=0;
     fb4:	10 92 75 13 	sts	0x1375, r1
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
     fb8:	c0 91 78 13 	lds	r28, 0x1378
     fbc:	d0 91 79 13 	lds	r29, 0x1379
     fc0:	80 e0       	ldi	r24, 0x00	; 0
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
     fc8:	60 91 62 11 	lds	r22, 0x1162
     fcc:	70 91 63 11 	lds	r23, 0x1163
     fd0:	20 91 64 11 	lds	r18, 0x1164
     fd4:	30 91 65 11 	lds	r19, 0x1165
     fd8:	e0 90 6c 13 	lds	r14, 0x136C
     fdc:	f0 90 6d 13 	lds	r15, 0x136D
     fe0:	4c e5       	ldi	r20, 0x5C	; 92
     fe2:	51 e1       	ldi	r21, 0x11	; 17
     fe4:	08 e6       	ldi	r16, 0x68	; 104
     fe6:	11 e1       	ldi	r17, 0x11	; 17
     fe8:	fe 01       	movw	r30, r28
     fea:	09 95       	icall
}
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	0f 91       	pop	r16
     ff4:	ff 90       	pop	r15
     ff6:	ef 90       	pop	r14
     ff8:	df 90       	pop	r13
     ffa:	cf 90       	pop	r12
     ffc:	bf 90       	pop	r11
     ffe:	af 90       	pop	r10
    1000:	08 95       	ret

00001002 <tftp_sendRequest>:
uint8_t tftp_sendRequest(uint8_t opcode, uint8_t* dst_ip, uint8_t* local_databuffer, uint16_t local_databuffer_len, uint8_t* remote_filename, uint8_t remote_filename_len, uint8_t append)
{
    1002:	6f 92       	push	r6
    1004:	7f 92       	push	r7
    1006:	8f 92       	push	r8
    1008:	9f 92       	push	r9
    100a:	af 92       	push	r10
    100c:	bf 92       	push	r11
    100e:	cf 92       	push	r12
    1010:	df 92       	push	r13
    1012:	ef 92       	push	r14
    1014:	ff 92       	push	r15
    1016:	0f 93       	push	r16
    1018:	1f 93       	push	r17
    101a:	cf 93       	push	r28
    101c:	df 93       	push	r29
    101e:	f8 2e       	mov	r15, r24
    1020:	96 2e       	mov	r9, r22
    1022:	d7 2e       	mov	r13, r23
    1024:	5a 01       	movw	r10, r20
    1026:	39 01       	movw	r6, r18
    1028:	e8 01       	movw	r28, r16
	uint8_t filenameCheck=0;
	PRINTF_D("destination = ");
    102a:	00 d0       	rcall	.+0      	; 0x102c <tftp_sendRequest+0x2a>
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	99 e0       	ldi	r25, 0x09	; 9
    1030:	ad b7       	in	r26, 0x3d	; 61
    1032:	be b7       	in	r27, 0x3e	; 62
    1034:	12 96       	adiw	r26, 0x02	; 2
    1036:	9c 93       	st	X, r25
    1038:	8e 93       	st	-X, r24
    103a:	11 97       	sbiw	r26, 0x01	; 1
    103c:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
	print_addr_dec(dst_ip);
    1040:	0f 90       	pop	r0
    1042:	0f 90       	pop	r0
    1044:	89 2d       	mov	r24, r9
    1046:	9d 2d       	mov	r25, r13
    1048:	0e 94 22 10 	call	0x2044	; 0x2044 <print_addr_dec>
	filenameCheck |= (local_databuffer==NULL);
    104c:	11 e0       	ldi	r17, 0x01	; 1
    104e:	a1 14       	cp	r10, r1
    1050:	b1 04       	cpc	r11, r1
    1052:	09 f0       	breq	.+2      	; 0x1056 <tftp_sendRequest+0x54>
    1054:	10 e0       	ldi	r17, 0x00	; 0
	filenameCheck = filenameCheck<<1;
    1056:	11 0f       	add	r17, r17
	//PRINTF_D("remote-filename = '%s' -> %d\n", remote_filename, remote_filename_len);
	filenameCheck |= (remote_filename==NULL || remote_filename_len==0 || remote_filename[0]==0x00 );
    1058:	20 97       	sbiw	r28, 0x00	; 0
    105a:	51 f0       	breq	.+20     	; 0x1070 <tftp_sendRequest+0x6e>
    105c:	ee 20       	and	r14, r14
    105e:	41 f0       	breq	.+16     	; 0x1070 <tftp_sendRequest+0x6e>
    1060:	81 e0       	ldi	r24, 0x01	; 1
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	28 81       	ld	r18, Y
    1066:	22 23       	and	r18, r18
    1068:	29 f0       	breq	.+10     	; 0x1074 <tftp_sendRequest+0x72>
    106a:	80 e0       	ldi	r24, 0x00	; 0
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	02 c0       	rjmp	.+4      	; 0x1074 <tftp_sendRequest+0x72>
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	18 2b       	or	r17, r24
	//PRINTF_D("filename-check = 0x%02x\n", filenameCheck);
	if(filenameCheck & 0x02)
    1076:	11 ff       	sbrs	r17, 1
    1078:	05 c0       	rjmp	.+10     	; 0x1084 <tftp_sendRequest+0x82>
	{
		PRINTF_D("null pointer, exiting\n");
    107a:	89 eb       	ldi	r24, 0xB9	; 185
    107c:	99 e0       	ldi	r25, 0x09	; 9
    107e:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
    1082:	43 c1       	rjmp	.+646    	; 0x130a <tftp_sendRequest+0x308>
		return -1;
	}
	if(filenameCheck & 0x01)
    1084:	10 ff       	sbrs	r17, 0
    1086:	08 c0       	rjmp	.+16     	; 0x1098 <tftp_sendRequest+0x96>
	{
		PRINTF_D("empty remote filename, using default 'sensors.dat'\n");
    1088:	8f ec       	ldi	r24, 0xCF	; 207
    108a:	99 e0       	ldi	r25, 0x09	; 9
    108c:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
		remote_filename="sensors.dat";
    1090:	c0 e6       	ldi	r28, 0x60	; 96
    1092:	d9 e0       	ldi	r29, 0x09	; 9
		remote_filename_len=strlen("sensors.dat");
    1094:	8b e0       	ldi	r24, 0x0B	; 11
    1096:	e8 2e       	mov	r14, r24
	}
	if(filenameCheck == 0x03)
    1098:	13 30       	cpi	r17, 0x03	; 3
    109a:	09 f4       	brne	.+2      	; 0x109e <tftp_sendRequest+0x9c>
    109c:	36 c1       	rjmp	.+620    	; 0x130a <tftp_sendRequest+0x308>
	{
		return -1;
	}
    if(opcode == TFTP_OPCODE_RRQ)
    109e:	bf 2d       	mov	r27, r15
    10a0:	b1 30       	cpi	r27, 0x01	; 1
    10a2:	29 f4       	brne	.+10     	; 0x10ae <tftp_sendRequest+0xac>
    {
    	printf("radiotftp_process does not receive files\n");
    10a4:	82 e0       	ldi	r24, 0x02	; 2
    10a6:	9a e0       	ldi	r25, 0x0A	; 10
    10a8:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
    10ac:	21 c0       	rjmp	.+66     	; 0x10f0 <tftp_sendRequest+0xee>
    }
    else if(opcode == TFTP_OPCODE_WRQ)
    10ae:	ef 2d       	mov	r30, r15
    10b0:	e2 30       	cpi	r30, 0x02	; 2
    10b2:	09 f0       	breq	.+2      	; 0x10b6 <tftp_sendRequest+0xb4>
    10b4:	2c c1       	rjmp	.+600    	; 0x130e <tftp_sendRequest+0x30c>
    return 0;
}

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	80 93 72 13 	sts	0x1372, r24
    	printf("radiotftp_process does not receive files\n");
    }
    else if(opcode == TFTP_OPCODE_WRQ)
    {
        tftp_setStatus(TFTP_STATUS_SENDING);
        data_buffer = local_databuffer;
    10bc:	b0 92 7d 13 	sts	0x137D, r11
    10c0:	a0 92 7c 13 	sts	0x137C, r10
        if(data_buffer == NULL)
    10c4:	a1 14       	cp	r10, r1
    10c6:	b1 04       	cpc	r11, r1
    10c8:	79 f4       	brne	.+30     	; 0x10e8 <tftp_sendRequest+0xe6>
        {
            PRINTF_D("error opening file for read");
    10ca:	00 d0       	rcall	.+0      	; 0x10cc <tftp_sendRequest+0xca>
    10cc:	8b e2       	ldi	r24, 0x2B	; 43
    10ce:	9a e0       	ldi	r25, 0x0A	; 10
    10d0:	ad b7       	in	r26, 0x3d	; 61
    10d2:	be b7       	in	r27, 0x3e	; 62
    10d4:	12 96       	adiw	r26, 0x02	; 2
    10d6:	9c 93       	st	X, r25
    10d8:	8e 93       	st	-X, r24
    10da:	11 97       	sbiw	r26, 0x01	; 1
    10dc:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
            return (-13);
    10e0:	0f 90       	pop	r0
    10e2:	0f 90       	pop	r0
    10e4:	83 ef       	ldi	r24, 0xF3	; 243
    10e6:	14 c1       	rjmp	.+552    	; 0x1310 <tftp_sendRequest+0x30e>
        }
        fileLen=local_databuffer_len;
    10e8:	70 92 7b 13 	sts	0x137B, r7
    10ec:	60 92 7a 13 	sts	0x137A, r6
    }
    else
    {
        return -10;
    }
    lastMessage.payloadLength=0;
    10f0:	10 92 6d 13 	sts	0x136D, r1
    10f4:	10 92 6c 13 	sts	0x136C, r1
    //put opcode in
    lastMessage.opcode=opcode;
    10f8:	f0 92 66 11 	sts	0x1166, r15
    10fc:	10 92 67 11 	sts	0x1167, r1
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
    1100:	86 e5       	ldi	r24, 0x56	; 86
    1102:	91 e1       	ldi	r25, 0x11	; 17
    1104:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
    1108:	ac e5       	ldi	r26, 0x5C	; 92
    110a:	b1 e1       	ldi	r27, 0x11	; 17
    110c:	89 2d       	mov	r24, r9
    110e:	9d 2d       	mov	r25, r13
    1110:	fc 01       	movw	r30, r24
    1112:	86 e0       	ldi	r24, 0x06	; 6
    1114:	01 90       	ld	r0, Z+
    1116:	0d 92       	st	X+, r0
    1118:	81 50       	subi	r24, 0x01	; 1
    111a:	e1 f7       	brne	.-8      	; 0x1114 <tftp_sendRequest+0x112>
    //select destination port
    lastMessage.dst_port=69;
    111c:	85 e4       	ldi	r24, 0x45	; 69
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	90 93 65 11 	sts	0x1165, r25
    1124:	80 93 64 11 	sts	0x1164, r24
    //select a random src port
    do
    {
        lastMessage.src_port= 65535*(((float)rand())/((float)RAND_MAX));
    1128:	0e 94 31 4b 	call	0x9662	; 0x9662 <rand>
    112c:	fc 01       	movw	r30, r24
    112e:	bf 01       	movw	r22, r30
    1130:	88 27       	eor	r24, r24
    1132:	77 fd       	sbrc	r23, 7
    1134:	80 95       	com	r24
    1136:	98 2f       	mov	r25, r24
    1138:	0e 94 c7 47 	call	0x8f8e	; 0x8f8e <__floatsisf>
    113c:	20 e0       	ldi	r18, 0x00	; 0
    113e:	3e ef       	ldi	r19, 0xFE	; 254
    1140:	4f ef       	ldi	r20, 0xFF	; 255
    1142:	56 e4       	ldi	r21, 0x46	; 70
    1144:	0e 94 e9 46 	call	0x8dd2	; 0x8dd2 <__divsf3>
    1148:	20 e0       	ldi	r18, 0x00	; 0
    114a:	3f ef       	ldi	r19, 0xFF	; 255
    114c:	4f e7       	ldi	r20, 0x7F	; 127
    114e:	57 e4       	ldi	r21, 0x47	; 71
    1150:	0e 94 ef 45 	call	0x8bde	; 0x8bde <__mulsf3>
    1154:	0e 94 1b 44 	call	0x8836	; 0x8836 <__fixunssfsi>
    1158:	70 93 63 11 	sts	0x1163, r23
    115c:	60 93 62 11 	sts	0x1162, r22
    }while(lastMessage.src_port==69 || lastMessage.src_port==0);
    1160:	65 34       	cpi	r22, 0x45	; 69
    1162:	71 05       	cpc	r23, r1
    1164:	09 f3       	breq	.-62     	; 0x1128 <tftp_sendRequest+0x126>
    1166:	61 15       	cp	r22, r1
    1168:	71 05       	cpc	r23, r1
    116a:	f1 f2       	breq	.-68     	; 0x1128 <tftp_sendRequest+0x126>
    //assign the tft_src_port
    tftp_src_port=lastMessage.src_port;
    116c:	70 93 71 0b 	sts	0x0B71, r23
    1170:	60 93 70 0b 	sts	0x0B70, r22
    PRINTF_D("tftp src port = %d\n", tftp_src_port);
    1174:	00 d0       	rcall	.+0      	; 0x1176 <tftp_sendRequest+0x174>
    1176:	00 d0       	rcall	.+0      	; 0x1178 <tftp_sendRequest+0x176>
    1178:	ed b7       	in	r30, 0x3d	; 61
    117a:	fe b7       	in	r31, 0x3e	; 62
    117c:	31 96       	adiw	r30, 0x01	; 1
    117e:	22 e8       	ldi	r18, 0x82	; 130
    1180:	39 e0       	ldi	r19, 0x09	; 9
    1182:	ad b7       	in	r26, 0x3d	; 61
    1184:	be b7       	in	r27, 0x3e	; 62
    1186:	12 96       	adiw	r26, 0x02	; 2
    1188:	3c 93       	st	X, r19
    118a:	2e 93       	st	-X, r18
    118c:	11 97       	sbiw	r26, 0x01	; 1
    118e:	73 83       	std	Z+3, r23	; 0x03
    1190:	62 83       	std	Z+2, r22	; 0x02
    1192:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    1196:	20 91 6c 13 	lds	r18, 0x136C
    119a:	30 91 6d 13 	lds	r19, 0x136D
    119e:	f9 01       	movw	r30, r18
    11a0:	ea 5a       	subi	r30, 0xAA	; 170
    11a2:	fe 4e       	sbci	r31, 0xEE	; 238
    11a4:	12 8a       	std	Z+18, r1	; 0x12
    11a6:	2f 5f       	subi	r18, 0xFF	; 255
    11a8:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = opcode;
    11aa:	f9 01       	movw	r30, r18
    11ac:	ea 5a       	subi	r30, 0xAA	; 170
    11ae:	fe 4e       	sbci	r31, 0xEE	; 238
    11b0:	f2 8a       	std	Z+18, r15	; 0x12
    11b2:	2f 5f       	subi	r18, 0xFF	; 255
    11b4:	3f 4f       	sbci	r19, 0xFF	; 255
    11b6:	30 93 6d 13 	sts	0x136D, r19
    11ba:	20 93 6c 13 	sts	0x136C, r18
    memcpy(lastMessage.payload+lastMessage.payloadLength, remote_filename, remote_filename_len);
    11be:	ae 2c       	mov	r10, r14
    11c0:	bb 24       	eor	r11, r11
    11c2:	28 59       	subi	r18, 0x98	; 152
    11c4:	3e 4e       	sbci	r19, 0xEE	; 238
    11c6:	0f 90       	pop	r0
    11c8:	0f 90       	pop	r0
    11ca:	0f 90       	pop	r0
    11cc:	0f 90       	pop	r0
    11ce:	c9 01       	movw	r24, r18
    11d0:	be 01       	movw	r22, r28
    11d2:	4e 2d       	mov	r20, r14
    11d4:	50 e0       	ldi	r21, 0x00	; 0
    11d6:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    lastMessage.payloadLength+=remote_filename_len;
    11da:	80 91 6c 13 	lds	r24, 0x136C
    11de:	90 91 6d 13 	lds	r25, 0x136D
    11e2:	8a 0d       	add	r24, r10
    11e4:	9b 1d       	adc	r25, r11
    11e6:	90 93 6d 13 	sts	0x136D, r25
    11ea:	80 93 6c 13 	sts	0x136C, r24
    PRINTF_D("remote_filename = '%s'\n", remote_filename);
    11ee:	00 d0       	rcall	.+0      	; 0x11f0 <tftp_sendRequest+0x1ee>
    11f0:	00 d0       	rcall	.+0      	; 0x11f2 <tftp_sendRequest+0x1f0>
    11f2:	86 e9       	ldi	r24, 0x96	; 150
    11f4:	99 e0       	ldi	r25, 0x09	; 9
    11f6:	ad b7       	in	r26, 0x3d	; 61
    11f8:	be b7       	in	r27, 0x3e	; 62
    11fa:	12 96       	adiw	r26, 0x02	; 2
    11fc:	9c 93       	st	X, r25
    11fe:	8e 93       	st	-X, r24
    1200:	11 97       	sbiw	r26, 0x01	; 1
    1202:	14 96       	adiw	r26, 0x04	; 4
    1204:	dc 93       	st	X, r29
    1206:	ce 93       	st	-X, r28
    1208:	13 97       	sbiw	r26, 0x03	; 3
    120a:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    memcpy(lastMessage.payload+lastMessage.payloadLength, "\0netascii\0", 10);
    120e:	e0 91 6c 13 	lds	r30, 0x136C
    1212:	f0 91 6d 13 	lds	r31, 0x136D
    1216:	e8 59       	subi	r30, 0x98	; 152
    1218:	fe 4e       	sbci	r31, 0xEE	; 238
    121a:	ae ea       	ldi	r26, 0xAE	; 174
    121c:	b9 e0       	ldi	r27, 0x09	; 9
    121e:	8a e0       	ldi	r24, 0x0A	; 10
    1220:	0d 90       	ld	r0, X+
    1222:	01 92       	st	Z+, r0
    1224:	81 50       	subi	r24, 0x01	; 1
    1226:	e1 f7       	brne	.-8      	; 0x1220 <tftp_sendRequest+0x21e>
    lastMessage.payloadLength+=10;
    1228:	20 91 6c 13 	lds	r18, 0x136C
    122c:	30 91 6d 13 	lds	r19, 0x136D
    1230:	c9 01       	movw	r24, r18
    1232:	0a 96       	adiw	r24, 0x0a	; 10
    1234:	90 93 6d 13 	sts	0x136D, r25
    1238:	80 93 6c 13 	sts	0x136C, r24
    if(append)
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	cc 20       	and	r12, r12
    1246:	b9 f0       	breq	.+46     	; 0x1276 <tftp_sendRequest+0x274>
    {
    	memcpy(lastMessage.payload+lastMessage.payloadLength, "append\0", 7);
    1248:	dc 01       	movw	r26, r24
    124a:	a8 59       	subi	r26, 0x98	; 152
    124c:	be 4e       	sbci	r27, 0xEE	; 238
    124e:	e7 e4       	ldi	r30, 0x47	; 71
    1250:	fa e0       	ldi	r31, 0x0A	; 10
    1252:	87 e0       	ldi	r24, 0x07	; 7
    1254:	01 90       	ld	r0, Z+
    1256:	0d 92       	st	X+, r0
    1258:	81 50       	subi	r24, 0x01	; 1
    125a:	e1 f7       	brne	.-8      	; 0x1254 <tftp_sendRequest+0x252>
    	lastMessage.payloadLength+=7;
    125c:	80 91 6c 13 	lds	r24, 0x136C
    1260:	90 91 6d 13 	lds	r25, 0x136D
    1264:	07 96       	adiw	r24, 0x07	; 7
    1266:	90 93 6d 13 	sts	0x136D, r25
    126a:	80 93 6c 13 	sts	0x136C, r24
    	lastMessage.append=1;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	80 93 70 13 	sts	0x1370, r24
    1274:	0c c0       	rjmp	.+24     	; 0x128e <tftp_sendRequest+0x28c>
    }
    else
    {
    	lastMessage.payload[lastMessage.payloadLength]='\0';
    1276:	8a 5a       	subi	r24, 0xAA	; 170
    1278:	9e 4e       	sbci	r25, 0xEE	; 238
    127a:	fc 01       	movw	r30, r24
    127c:	12 8a       	std	Z+18, r1	; 0x12
    	lastMessage.payloadLength++;
    127e:	25 5f       	subi	r18, 0xF5	; 245
    1280:	3f 4f       	sbci	r19, 0xFF	; 255
    1282:	30 93 6d 13 	sts	0x136D, r19
    1286:	20 93 6c 13 	sts	0x136C, r18
    	lastMessage.append=0;
    128a:	10 92 70 13 	sts	0x1370, r1
    }
    //put the block number in
    lastMessage.blockNumber = blockNumber=0;
    128e:	10 92 77 13 	sts	0x1377, r1
    1292:	10 92 76 13 	sts	0x1376, r1
    1296:	10 92 6f 13 	sts	0x136F, r1
    129a:	10 92 6e 13 	sts	0x136E, r1
    	//set up retransmit timer
    if(opcode==TFTP_OPCODE_WRQ || opcode==TFTP_OPCODE_RRQ)
    129e:	8f 2d       	mov	r24, r15
    12a0:	81 50       	subi	r24, 0x01	; 1
    12a2:	82 30       	cpi	r24, 0x02	; 2
    12a4:	40 f4       	brcc	.+16     	; 0x12b6 <tftp_sendRequest+0x2b4>
    {
    	timers_create_timer(tftp_getRandomRetransmissionTime()+1, 128);
    12a6:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <tftp_getRandomRetransmissionTime>
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	60 e8       	ldi	r22, 0x80	; 128
    12b0:	70 e0       	ldi	r23, 0x00	; 0
    12b2:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>
    }
    //reset acks
    ackNumber=-1;
    12b6:	8f ef       	ldi	r24, 0xFF	; 255
    12b8:	9f ef       	ldi	r25, 0xFF	; 255
    12ba:	90 93 74 13 	sts	0x1374, r25
    12be:	80 93 73 13 	sts	0x1373, r24
    blockNumber=0;
    12c2:	10 92 77 13 	sts	0x1377, r1
    12c6:	10 92 76 13 	sts	0x1376, r1
    isRequestOwner=1;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	80 93 71 13 	sts	0x1371, r24
    timeouts=0;
    12d0:	10 92 75 13 	sts	0x1375, r1
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    12d4:	c0 91 78 13 	lds	r28, 0x1378
    12d8:	d0 91 79 13 	lds	r29, 0x1379
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    12e4:	60 91 62 11 	lds	r22, 0x1162
    12e8:	70 91 63 11 	lds	r23, 0x1163
    12ec:	20 91 64 11 	lds	r18, 0x1164
    12f0:	30 91 65 11 	lds	r19, 0x1165
    12f4:	e0 90 6c 13 	lds	r14, 0x136C
    12f8:	f0 90 6d 13 	lds	r15, 0x136D
    12fc:	4c e5       	ldi	r20, 0x5C	; 92
    12fe:	51 e1       	ldi	r21, 0x11	; 17
    1300:	08 e6       	ldi	r16, 0x68	; 104
    1302:	11 e1       	ldi	r17, 0x11	; 17
    1304:	fe 01       	movw	r30, r28
    1306:	09 95       	icall
    1308:	03 c0       	rjmp	.+6      	; 0x1310 <tftp_sendRequest+0x30e>
		remote_filename="sensors.dat";
		remote_filename_len=strlen("sensors.dat");
	}
	if(filenameCheck == 0x03)
	{
		return -1;
    130a:	8f ef       	ldi	r24, 0xFF	; 255
    130c:	01 c0       	rjmp	.+2      	; 0x1310 <tftp_sendRequest+0x30e>
        }
        fileLen=local_databuffer_len;
    }
    else
    {
        return -10;
    130e:	86 ef       	ldi	r24, 0xF6	; 246
    ackNumber=-1;
    blockNumber=0;
    isRequestOwner=1;
    timeouts=0;
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
}
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
    1316:	0f 91       	pop	r16
    1318:	ff 90       	pop	r15
    131a:	ef 90       	pop	r14
    131c:	df 90       	pop	r13
    131e:	cf 90       	pop	r12
    1320:	bf 90       	pop	r11
    1322:	af 90       	pop	r10
    1324:	9f 90       	pop	r9
    1326:	8f 90       	pop	r8
    1328:	7f 90       	pop	r7
    132a:	6f 90       	pop	r6
    132c:	08 95       	ret

0000132e <tftp_sendData>:
uint8_t tftp_sendData(uint8_t* dst_ip, uint8_t blockNum)
{
    132e:	cf 92       	push	r12
    1330:	df 92       	push	r13
    1332:	ef 92       	push	r14
    1334:	ff 92       	push	r15
    1336:	0f 93       	push	r16
    1338:	1f 93       	push	r17
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	8c 01       	movw	r16, r24
    1340:	e6 2e       	mov	r14, r22
    uint16_t curPos, writeLen;
//    PRINTF_D("tftp_sendData\n");
    lastMessage.payloadLength=0;
    1342:	10 92 6d 13 	sts	0x136D, r1
    1346:	10 92 6c 13 	sts	0x136C, r1
    //put opcode in
    lastMessage.opcode=TFTP_OPCODE_DATA;
    134a:	23 e0       	ldi	r18, 0x03	; 3
    134c:	30 e0       	ldi	r19, 0x00	; 0
    134e:	30 93 67 11 	sts	0x1167, r19
    1352:	20 93 66 11 	sts	0x1166, r18
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
    1356:	86 e5       	ldi	r24, 0x56	; 86
    1358:	91 e1       	ldi	r25, 0x11	; 17
    135a:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
    135e:	ac e5       	ldi	r26, 0x5C	; 92
    1360:	b1 e1       	ldi	r27, 0x11	; 17
    1362:	80 2f       	mov	r24, r16
    1364:	91 2f       	mov	r25, r17
    1366:	fc 01       	movw	r30, r24
    1368:	86 e0       	ldi	r24, 0x06	; 6
    136a:	01 90       	ld	r0, Z+
    136c:	0d 92       	st	X+, r0
    136e:	81 50       	subi	r24, 0x01	; 1
    1370:	e1 f7       	brne	.-8      	; 0x136a <tftp_sendData+0x3c>
    //select destination port
    lastMessage.dst_port=tftp_dst_port;
    1372:	80 91 6e 0b 	lds	r24, 0x0B6E
    1376:	90 91 6f 0b 	lds	r25, 0x0B6F
    137a:	90 93 65 11 	sts	0x1165, r25
    137e:	80 93 64 11 	sts	0x1164, r24
    //select a random src port
    lastMessage.src_port=tftp_src_port;
    1382:	80 91 70 0b 	lds	r24, 0x0B70
    1386:	90 91 71 0b 	lds	r25, 0x0B71
    138a:	90 93 63 11 	sts	0x1163, r25
    138e:	80 93 62 11 	sts	0x1162, r24
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    1392:	40 91 6c 13 	lds	r20, 0x136C
    1396:	50 91 6d 13 	lds	r21, 0x136D
    139a:	fa 01       	movw	r30, r20
    139c:	ea 5a       	subi	r30, 0xAA	; 170
    139e:	fe 4e       	sbci	r31, 0xEE	; 238
    13a0:	12 8a       	std	Z+18, r1	; 0x12
    13a2:	4f 5f       	subi	r20, 0xFF	; 255
    13a4:	5f 4f       	sbci	r21, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = lastMessage.opcode;
    13a6:	fa 01       	movw	r30, r20
    13a8:	ea 5a       	subi	r30, 0xAA	; 170
    13aa:	fe 4e       	sbci	r31, 0xEE	; 238
    13ac:	80 91 66 11 	lds	r24, 0x1166
    13b0:	82 8b       	std	Z+18, r24	; 0x12
    13b2:	4f 5f       	subi	r20, 0xFF	; 255
    13b4:	5f 4f       	sbci	r21, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    13b6:	fa 01       	movw	r30, r20
    13b8:	ea 5a       	subi	r30, 0xAA	; 170
    13ba:	fe 4e       	sbci	r31, 0xEE	; 238
    13bc:	12 8a       	std	Z+18, r1	; 0x12
    13be:	4f 5f       	subi	r20, 0xFF	; 255
    13c0:	5f 4f       	sbci	r21, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = blockNum;
    13c2:	fa 01       	movw	r30, r20
    13c4:	ea 5a       	subi	r30, 0xAA	; 170
    13c6:	fe 4e       	sbci	r31, 0xEE	; 238
    13c8:	e2 8a       	std	Z+18, r14	; 0x12
    13ca:	4f 5f       	subi	r20, 0xFF	; 255
    13cc:	5f 4f       	sbci	r21, 0xFF	; 255
    13ce:	50 93 6d 13 	sts	0x136D, r21
    13d2:	40 93 6c 13 	sts	0x136C, r20
    //copy the data
#if 0
    curPos=buffer_pos; //this one was found to be faulty in case of retransmission
#else
    curPos=TFTP_MAX_BLOCK_SIZE*(blockNum-1);
    13d6:	8e 2d       	mov	r24, r14
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	01 97       	sbiw	r24, 0x01	; 1
    13dc:	98 2f       	mov	r25, r24
    13de:	88 27       	eor	r24, r24
    13e0:	99 0f       	add	r25, r25
#endif
//    PRINTF_D("tftp_sendData: before memcpy\n");
    if(fileLen-curPos < TFTP_MAX_BLOCK_SIZE)
    13e2:	c0 91 7a 13 	lds	r28, 0x137A
    13e6:	d0 91 7b 13 	lds	r29, 0x137B
    13ea:	c8 1b       	sub	r28, r24
    13ec:	d9 0b       	sbc	r29, r25
    13ee:	22 e0       	ldi	r18, 0x02	; 2
    13f0:	c0 30       	cpi	r28, 0x00	; 0
    13f2:	d2 07       	cpc	r29, r18
    13f4:	10 f0       	brcs	.+4      	; 0x13fa <tftp_sendData+0xcc>
    	writeLen=fileLen-curPos;
    else
    	writeLen=TFTP_MAX_BLOCK_SIZE;
    13f6:	c0 e0       	ldi	r28, 0x00	; 0
    13f8:	d2 e0       	ldi	r29, 0x02	; 2
    memcpy(lastMessage.payload+lastMessage.payloadLength, data_buffer+curPos, writeLen);
    13fa:	48 59       	subi	r20, 0x98	; 152
    13fc:	5e 4e       	sbci	r21, 0xEE	; 238
    13fe:	20 91 7c 13 	lds	r18, 0x137C
    1402:	30 91 7d 13 	lds	r19, 0x137D
    1406:	28 0f       	add	r18, r24
    1408:	39 1f       	adc	r19, r25
    140a:	ca 01       	movw	r24, r20
    140c:	b9 01       	movw	r22, r18
    140e:	ae 01       	movw	r20, r28
    1410:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    lastMessage.payloadLength+=writeLen;
    1414:	80 91 6c 13 	lds	r24, 0x136C
    1418:	90 91 6d 13 	lds	r25, 0x136D
    141c:	8c 0f       	add	r24, r28
    141e:	9d 1f       	adc	r25, r29
    1420:	90 93 6d 13 	sts	0x136D, r25
    1424:	80 93 6c 13 	sts	0x136C, r24
    curPos+=writeLen;

//    PRINTF_D("tftp_sendData: after memcpy\n");
    //put the block number in
    lastMessage.blockNumber = blockNum;
    1428:	e0 92 6e 13 	sts	0x136E, r14
    142c:	10 92 6f 13 	sts	0x136F, r1
    //set up retransmit timer
    timers_create_timer(tftp_getRandomRetransmissionTime(), 128);
    1430:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <tftp_getRandomRetransmissionTime>
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	60 e8       	ldi	r22, 0x80	; 128
    1438:	70 e0       	ldi	r23, 0x00	; 0
    143a:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>
    PRINTF_D("sent data size = %u\n", lastMessage.payloadLength);
    143e:	00 d0       	rcall	.+0      	; 0x1440 <tftp_sendData+0x112>
    1440:	00 d0       	rcall	.+0      	; 0x1442 <tftp_sendData+0x114>
    1442:	8f e4       	ldi	r24, 0x4F	; 79
    1444:	9a e0       	ldi	r25, 0x0A	; 10
    1446:	ed b7       	in	r30, 0x3d	; 61
    1448:	fe b7       	in	r31, 0x3e	; 62
    144a:	92 83       	std	Z+2, r25	; 0x02
    144c:	81 83       	std	Z+1, r24	; 0x01
    144e:	80 91 6c 13 	lds	r24, 0x136C
    1452:	90 91 6d 13 	lds	r25, 0x136D
    1456:	94 83       	std	Z+4, r25	; 0x04
    1458:	83 83       	std	Z+3, r24	; 0x03
    145a:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    145e:	c0 91 78 13 	lds	r28, 0x1378
    1462:	d0 91 79 13 	lds	r29, 0x1379
    1466:	0f 90       	pop	r0
    1468:	0f 90       	pop	r0
    146a:	0f 90       	pop	r0
    146c:	0f 90       	pop	r0
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    1476:	60 91 62 11 	lds	r22, 0x1162
    147a:	70 91 63 11 	lds	r23, 0x1163
    147e:	20 91 64 11 	lds	r18, 0x1164
    1482:	30 91 65 11 	lds	r19, 0x1165
    1486:	e0 90 6c 13 	lds	r14, 0x136C
    148a:	f0 90 6d 13 	lds	r15, 0x136D
    148e:	4c e5       	ldi	r20, 0x5C	; 92
    1490:	51 e1       	ldi	r21, 0x11	; 17
    1492:	08 e6       	ldi	r16, 0x68	; 104
    1494:	11 e1       	ldi	r17, 0x11	; 17
    1496:	fe 01       	movw	r30, r28
    1498:	09 95       	icall
}
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	1f 91       	pop	r17
    14a0:	0f 91       	pop	r16
    14a2:	ff 90       	pop	r15
    14a4:	ef 90       	pop	r14
    14a6:	df 90       	pop	r13
    14a8:	cf 90       	pop	r12
    14aa:	08 95       	ret

000014ac <tftp_sendError>:
uint8_t tftp_sendError(uint8_t type, uint8_t* dst_ip, uint16_t dst_prt, uint8_t* additionalInfo, uint8_t infoLen)
{
    14ac:	cf 92       	push	r12
    14ae:	df 92       	push	r13
    14b0:	ef 92       	push	r14
    14b2:	ff 92       	push	r15
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	df 93       	push	r29
    14ba:	cf 93       	push	r28
    14bc:	00 d0       	rcall	.+0      	; 0x14be <tftp_sendError+0x12>
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	18 2f       	mov	r17, r24
    14c4:	6a 01       	movw	r12, r20
    14c6:	79 01       	movw	r14, r18
    lastMessage.payloadLength=0;
    14c8:	10 92 6d 13 	sts	0x136D, r1
    14cc:	10 92 6c 13 	sts	0x136C, r1
    //put opcode in
    lastMessage.opcode=TFTP_OPCODE_ERROR;
    14d0:	85 e0       	ldi	r24, 0x05	; 5
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	90 93 67 11 	sts	0x1167, r25
    14d8:	80 93 66 11 	sts	0x1166, r24
    //put source ip in
    udp_get_localhost_ip(lastMessage.src);
    14dc:	86 e5       	ldi	r24, 0x56	; 86
    14de:	91 e1       	ldi	r25, 0x11	; 17
    14e0:	69 83       	std	Y+1, r22	; 0x01
    14e2:	7a 83       	std	Y+2, r23	; 0x02
    14e4:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    //put destination ip in
    memcpy(lastMessage.dst, dst_ip, 6);
    14e8:	ac e5       	ldi	r26, 0x5C	; 92
    14ea:	b1 e1       	ldi	r27, 0x11	; 17
    14ec:	69 81       	ldd	r22, Y+1	; 0x01
    14ee:	7a 81       	ldd	r23, Y+2	; 0x02
    14f0:	86 2f       	mov	r24, r22
    14f2:	97 2f       	mov	r25, r23
    14f4:	fc 01       	movw	r30, r24
    14f6:	86 e0       	ldi	r24, 0x06	; 6
    14f8:	01 90       	ld	r0, Z+
    14fa:	0d 92       	st	X+, r0
    14fc:	81 50       	subi	r24, 0x01	; 1
    14fe:	e1 f7       	brne	.-8      	; 0x14f8 <tftp_sendError+0x4c>
    //select destination port
    lastMessage.dst_port=dst_prt;
    1500:	d0 92 65 11 	sts	0x1165, r13
    1504:	c0 92 64 11 	sts	0x1164, r12
    //select a random src port
    lastMessage.src_port=tftp_src_port;
    1508:	80 91 70 0b 	lds	r24, 0x0B70
    150c:	90 91 71 0b 	lds	r25, 0x0B71
    1510:	90 93 63 11 	sts	0x1163, r25
    1514:	80 93 62 11 	sts	0x1162, r24
    //create the payload
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    1518:	20 91 6c 13 	lds	r18, 0x136C
    151c:	30 91 6d 13 	lds	r19, 0x136D
    1520:	f9 01       	movw	r30, r18
    1522:	ea 5a       	subi	r30, 0xAA	; 170
    1524:	fe 4e       	sbci	r31, 0xEE	; 238
    1526:	12 8a       	std	Z+18, r1	; 0x12
    1528:	2f 5f       	subi	r18, 0xFF	; 255
    152a:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = lastMessage.opcode;
    152c:	f9 01       	movw	r30, r18
    152e:	ea 5a       	subi	r30, 0xAA	; 170
    1530:	fe 4e       	sbci	r31, 0xEE	; 238
    1532:	80 91 66 11 	lds	r24, 0x1166
    1536:	82 8b       	std	Z+18, r24	; 0x12
    1538:	2f 5f       	subi	r18, 0xFF	; 255
    153a:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = 0x00;
    153c:	f9 01       	movw	r30, r18
    153e:	ea 5a       	subi	r30, 0xAA	; 170
    1540:	fe 4e       	sbci	r31, 0xEE	; 238
    1542:	12 8a       	std	Z+18, r1	; 0x12
    1544:	2f 5f       	subi	r18, 0xFF	; 255
    1546:	3f 4f       	sbci	r19, 0xFF	; 255
    lastMessage.payload[lastMessage.payloadLength++] = type;
    1548:	f9 01       	movw	r30, r18
    154a:	ea 5a       	subi	r30, 0xAA	; 170
    154c:	fe 4e       	sbci	r31, 0xEE	; 238
    154e:	12 8b       	std	Z+18, r17	; 0x12
    1550:	2f 5f       	subi	r18, 0xFF	; 255
    1552:	3f 4f       	sbci	r19, 0xFF	; 255
    1554:	30 93 6d 13 	sts	0x136D, r19
    1558:	20 93 6c 13 	sts	0x136C, r18
    //copy the info
    if(additionalInfo!=NULL)
    155c:	e1 14       	cp	r14, r1
    155e:	f1 04       	cpc	r15, r1
    1560:	a1 f0       	breq	.+40     	; 0x158a <tftp_sendError+0xde>
    {
    	memcpy(lastMessage.payload+lastMessage.payloadLength, additionalInfo, infoLen);
    1562:	c0 2e       	mov	r12, r16
    1564:	dd 24       	eor	r13, r13
    1566:	28 59       	subi	r18, 0x98	; 152
    1568:	3e 4e       	sbci	r19, 0xEE	; 238
    156a:	c9 01       	movw	r24, r18
    156c:	b7 01       	movw	r22, r14
    156e:	40 2f       	mov	r20, r16
    1570:	50 e0       	ldi	r21, 0x00	; 0
    1572:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
        lastMessage.payloadLength+=infoLen;
    1576:	80 91 6c 13 	lds	r24, 0x136C
    157a:	90 91 6d 13 	lds	r25, 0x136D
    157e:	8c 0d       	add	r24, r12
    1580:	9d 1d       	adc	r25, r13
    1582:	90 93 6d 13 	sts	0x136D, r25
    1586:	80 93 6c 13 	sts	0x136C, r24
    }
    //set up retransmit timer
    //PRINTF_D("sent error size = %d\n", lastMessage.payloadLength);
    return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    158a:	c0 90 78 13 	lds	r12, 0x1378
    158e:	d0 90 79 13 	lds	r13, 0x1379
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	90 e0       	ldi	r25, 0x00	; 0
    1596:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    159a:	60 91 62 11 	lds	r22, 0x1162
    159e:	70 91 63 11 	lds	r23, 0x1163
    15a2:	20 91 64 11 	lds	r18, 0x1164
    15a6:	30 91 65 11 	lds	r19, 0x1165
    15aa:	e0 90 6c 13 	lds	r14, 0x136C
    15ae:	f0 90 6d 13 	lds	r15, 0x136D
    15b2:	4c e5       	ldi	r20, 0x5C	; 92
    15b4:	51 e1       	ldi	r21, 0x11	; 17
    15b6:	08 e6       	ldi	r16, 0x68	; 104
    15b8:	11 e1       	ldi	r17, 0x11	; 17
    15ba:	f6 01       	movw	r30, r12
    15bc:	09 95       	icall
}
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	cf 91       	pop	r28
    15c4:	df 91       	pop	r29
    15c6:	1f 91       	pop	r17
    15c8:	0f 91       	pop	r16
    15ca:	ff 90       	pop	r15
    15cc:	ef 90       	pop	r14
    15ce:	df 90       	pop	r13
    15d0:	cf 90       	pop	r12
    15d2:	08 95       	ret

000015d4 <tftp_sendAck>:
uint8_t tftp_sendAck(uint8_t* dst_ip, uint8_t blockNum)
{
    15d4:	cf 92       	push	r12
    15d6:	df 92       	push	r13
    15d8:	ef 92       	push	r14
    15da:	ff 92       	push	r15
    15dc:	0f 93       	push	r16
    15de:	1f 93       	push	r17
    15e0:	df 93       	push	r29
    15e2:	cf 93       	push	r28
    15e4:	00 d0       	rcall	.+0      	; 0x15e6 <tftp_sendAck+0x12>
    15e6:	00 d0       	rcall	.+0      	; 0x15e8 <tftp_sendAck+0x14>
    15e8:	cd b7       	in	r28, 0x3d	; 61
    15ea:	de b7       	in	r29, 0x3e	; 62
    15ec:	8c 01       	movw	r16, r24
    uint16_t i=0;
    uint8_t buffer[4];
    //create the payload
    buffer[i++]=0x00;
    15ee:	19 82       	std	Y+1, r1	; 0x01
    buffer[i++]=TFTP_OPCODE_ACK;
    15f0:	84 e0       	ldi	r24, 0x04	; 4
    15f2:	8a 83       	std	Y+2, r24	; 0x02
    buffer[i++]= (blockNum>>8)&0xFF;
    15f4:	1b 82       	std	Y+3, r1	; 0x03
    buffer[i++]= (blockNum&0xFF);
    15f6:	6c 83       	std	Y+4, r22	; 0x04

    PRINTF_D("sent ack size = %d\n", i);
    15f8:	00 d0       	rcall	.+0      	; 0x15fa <tftp_sendAck+0x26>
    15fa:	00 d0       	rcall	.+0      	; 0x15fc <tftp_sendAck+0x28>
    15fc:	84 e6       	ldi	r24, 0x64	; 100
    15fe:	9a e0       	ldi	r25, 0x0A	; 10
    1600:	ed b7       	in	r30, 0x3d	; 61
    1602:	fe b7       	in	r31, 0x3e	; 62
    1604:	92 83       	std	Z+2, r25	; 0x02
    1606:	81 83       	std	Z+1, r24	; 0x01
    1608:	84 e0       	ldi	r24, 0x04	; 4
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	94 83       	std	Z+4, r25	; 0x04
    160e:	83 83       	std	Z+3, r24	; 0x03
    1610:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    return mainDataQueuer(udp_get_localhost_ip(NULL), tftp_src_port, dst_ip, tftp_dst_port, buffer, i);
    1614:	c0 90 78 13 	lds	r12, 0x1378
    1618:	d0 90 79 13 	lds	r13, 0x1379
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	0f 90       	pop	r0
    1622:	0f 90       	pop	r0
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    162c:	60 91 70 0b 	lds	r22, 0x0B70
    1630:	70 91 71 0b 	lds	r23, 0x0B71
    1634:	20 91 6e 0b 	lds	r18, 0x0B6E
    1638:	30 91 6f 0b 	lds	r19, 0x0B6F
    163c:	a8 01       	movw	r20, r16
    163e:	8e 01       	movw	r16, r28
    1640:	0f 5f       	subi	r16, 0xFF	; 255
    1642:	1f 4f       	sbci	r17, 0xFF	; 255
    1644:	e4 e0       	ldi	r30, 0x04	; 4
    1646:	ee 2e       	mov	r14, r30
    1648:	f1 2c       	mov	r15, r1
    164a:	f6 01       	movw	r30, r12
    164c:	09 95       	icall
}
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	0f 90       	pop	r0
    1654:	0f 90       	pop	r0
    1656:	cf 91       	pop	r28
    1658:	df 91       	pop	r29
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	ff 90       	pop	r15
    1660:	ef 90       	pop	r14
    1662:	df 90       	pop	r13
    1664:	cf 90       	pop	r12
    1666:	08 95       	ret

00001668 <tftp_transfer>:

PACKET_HANDLER_FUNCTION(tftp_transfer)
{
    1668:	af 92       	push	r10
    166a:	bf 92       	push	r11
    166c:	cf 92       	push	r12
    166e:	df 92       	push	r13
    1670:	ef 92       	push	r14
    1672:	ff 92       	push	r15
    1674:	0f 93       	push	r16
    1676:	1f 93       	push	r17
    1678:	cf 93       	push	r28
    167a:	df 93       	push	r29
    167c:	5c 01       	movw	r10, r24
    167e:	6b 01       	movw	r12, r22
    uint8_t result=0;
    uint16_t opcode, block, error, i=0;

    //PRINTF_D("%s\n", payload);
    //read in the opcode
    opcode = payload[i++] & 0xFF;
    1680:	f8 01       	movw	r30, r16
    1682:	90 81       	ld	r25, Z
    opcode <<= 8;
    opcode |= payload[i++] & 0xFF;
    1684:	81 81       	ldd	r24, Z+1	; 0x01

    //check the opcode
    if(status==TFTP_STATUS_SENDING)
    1686:	40 91 72 13 	lds	r20, 0x1372
    168a:	41 30       	cpi	r20, 0x01	; 1
    168c:	09 f0       	breq	.+2      	; 0x1690 <tftp_transfer+0x28>
    168e:	a3 c0       	rjmp	.+326    	; 0x17d6 <tftp_transfer+0x16e>
    uint16_t opcode, block, error, i=0;

    //PRINTF_D("%s\n", payload);
    //read in the opcode
    opcode = payload[i++] & 0xFF;
    opcode <<= 8;
    1690:	39 2f       	mov	r19, r25
    1692:	20 e0       	ldi	r18, 0x00	; 0
    opcode |= payload[i++] & 0xFF;
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	82 2b       	or	r24, r18
    1698:	93 2b       	or	r25, r19

    //check the opcode
    if(status==TFTP_STATUS_SENDING)
    {
        if(opcode==TFTP_OPCODE_ACK)
    169a:	84 30       	cpi	r24, 0x04	; 4
    169c:	91 05       	cpc	r25, r1
    169e:	09 f0       	breq	.+2      	; 0x16a2 <tftp_transfer+0x3a>
    16a0:	49 c0       	rjmp	.+146    	; 0x1734 <tftp_transfer+0xcc>
        {
            if(timers_cancel_timer())
    16a2:	0e 94 ac 0c 	call	0x1958	; 0x1958 <timers_cancel_timer>
    16a6:	88 23       	and	r24, r24
    16a8:	21 f0       	breq	.+8      	; 0x16b2 <tftp_transfer+0x4a>
                PRINTF_D("couldnt cancel timer\n");
    16aa:	88 e7       	ldi	r24, 0x78	; 120
    16ac:	9a e0       	ldi	r25, 0x0A	; 10
    16ae:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
            block = payload[i++] & 0xFF;
    16b2:	f8 01       	movw	r30, r16
            block <<= 8;
    16b4:	e0 e0       	ldi	r30, 0x00	; 0
    16b6:	ef 01       	movw	r28, r30
            block |= payload[i++] & 0xFF;
    16b8:	f8 01       	movw	r30, r16
    16ba:	83 81       	ldd	r24, Z+3	; 0x03
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	c8 2b       	or	r28, r24
    16c0:	d9 2b       	or	r29, r25
            ackNumber = block;
    16c2:	d0 93 74 13 	sts	0x1374, r29
    16c6:	c0 93 73 13 	sts	0x1373, r28
            PRINTF_D("tftp wrq ack #%d received\n", block);
    16ca:	00 d0       	rcall	.+0      	; 0x16cc <tftp_transfer+0x64>
    16cc:	00 d0       	rcall	.+0      	; 0x16ce <tftp_transfer+0x66>
    16ce:	8d e8       	ldi	r24, 0x8D	; 141
    16d0:	9a e0       	ldi	r25, 0x0A	; 10
    16d2:	ed b7       	in	r30, 0x3d	; 61
    16d4:	fe b7       	in	r31, 0x3e	; 62
    16d6:	92 83       	std	Z+2, r25	; 0x02
    16d8:	81 83       	std	Z+1, r24	; 0x01
    16da:	d4 83       	std	Z+4, r29	; 0x04
    16dc:	c3 83       	std	Z+3, r28	; 0x03
    16de:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
            //prepare and send next packet

            tftp_dst_port=src_port;
    16e2:	d0 92 6f 0b 	sts	0x0B6F, r13
    16e6:	c0 92 6e 0b 	sts	0x0B6E, r12
            timeouts=0;
    16ea:	10 92 75 13 	sts	0x1375, r1
            result=tftp_sendData(src, ackNumber+1);
    16ee:	0f 90       	pop	r0
    16f0:	0f 90       	pop	r0
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	60 91 73 13 	lds	r22, 0x1373
    16fa:	6f 5f       	subi	r22, 0xFF	; 255
    16fc:	c5 01       	movw	r24, r10
    16fe:	0e 94 97 09 	call	0x132e	; 0x132e <tftp_sendData>
            if(result)
    1702:	88 23       	and	r24, r24
    1704:	09 f4       	brne	.+2      	; 0x1708 <tftp_transfer+0xa0>
    1706:	68 c0       	rjmp	.+208    	; 0x17d8 <tftp_transfer+0x170>
            {
                PRINTF_D("!!! couldn't send data #%d\n", ackNumber+1);
    1708:	00 d0       	rcall	.+0      	; 0x170a <tftp_transfer+0xa2>
    170a:	00 d0       	rcall	.+0      	; 0x170c <tftp_transfer+0xa4>
    170c:	88 ea       	ldi	r24, 0xA8	; 168
    170e:	9a e0       	ldi	r25, 0x0A	; 10
    1710:	ed b7       	in	r30, 0x3d	; 61
    1712:	fe b7       	in	r31, 0x3e	; 62
    1714:	92 83       	std	Z+2, r25	; 0x02
    1716:	81 83       	std	Z+1, r24	; 0x01
    1718:	80 91 73 13 	lds	r24, 0x1373
    171c:	90 91 74 13 	lds	r25, 0x1374
    1720:	01 96       	adiw	r24, 0x01	; 1
    1722:	94 83       	std	Z+4, r25	; 0x04
    1724:	83 83       	std	Z+3, r24	; 0x03
    1726:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	51 c0       	rjmp	.+162    	; 0x17d6 <tftp_transfer+0x16e>
            }
            return 0;
        }
        else if(opcode==TFTP_OPCODE_ERROR)
    1734:	85 30       	cpi	r24, 0x05	; 5
    1736:	91 05       	cpc	r25, r1
    1738:	09 f0       	breq	.+2      	; 0x173c <tftp_transfer+0xd4>
    173a:	4d c0       	rjmp	.+154    	; 0x17d6 <tftp_transfer+0x16e>
        {
            //read in the error code
            error = payload[i++] & 0xFF;
    173c:	f8 01       	movw	r30, r16
    173e:	82 81       	ldd	r24, Z+2	; 0x02
            error <<= 8;
    1740:	f8 2e       	mov	r15, r24
    1742:	ee 24       	eor	r14, r14
            error |= payload[i++] & 0xFF;
    1744:	83 81       	ldd	r24, Z+3	; 0x03
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	e8 2a       	or	r14, r24
    174a:	f9 2a       	or	r15, r25
        	timers_cancel_timer();
    174c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <timers_cancel_timer>

            if(error==TFTP_ERROR_SEE_MESSAGE)
    1750:	e1 14       	cp	r14, r1
    1752:	f1 04       	cpc	r15, r1
    1754:	41 f5       	brne	.+80     	; 0x17a6 <tftp_transfer+0x13e>
            {
                PRINTF_D("tftp error received -> %s\n", payload+i);
    1756:	00 d0       	rcall	.+0      	; 0x1758 <tftp_transfer+0xf0>
    1758:	00 d0       	rcall	.+0      	; 0x175a <tftp_transfer+0xf2>
    175a:	84 ec       	ldi	r24, 0xC4	; 196
    175c:	9a e0       	ldi	r25, 0x0A	; 10
    175e:	ed b7       	in	r30, 0x3d	; 61
    1760:	fe b7       	in	r31, 0x3e	; 62
    1762:	92 83       	std	Z+2, r25	; 0x02
    1764:	81 83       	std	Z+1, r24	; 0x01
    1766:	0c 5f       	subi	r16, 0xFC	; 252
    1768:	1f 4f       	sbci	r17, 0xFF	; 255
    176a:	14 83       	std	Z+4, r17	; 0x04
    176c:	03 83       	std	Z+3, r16	; 0x03
    176e:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
                if(!strncmp("TRANSMISSION COMPLETE", payload+i, strlen("TRANSMISSION COMPLETE")))
    1772:	0f 90       	pop	r0
    1774:	0f 90       	pop	r0
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	8f ed       	ldi	r24, 0xDF	; 223
    177c:	9a e0       	ldi	r25, 0x0A	; 10
    177e:	b8 01       	movw	r22, r16
    1780:	45 e1       	ldi	r20, 0x15	; 21
    1782:	50 e0       	ldi	r21, 0x00	; 0
    1784:	0e 94 5e 4b 	call	0x96bc	; 0x96bc <strncmp>
    1788:	00 97       	sbiw	r24, 0x00	; 0
    178a:	e9 f4       	brne	.+58     	; 0x17c6 <tftp_transfer+0x15e>
                {
                    if(isRequestOwner)
    178c:	80 91 71 13 	lds	r24, 0x1371
    1790:	88 23       	and	r24, r24
    1792:	09 f5       	brne	.+66     	; 0x17d6 <tftp_transfer+0x16e>
                    {
                    	return 0;
                    }
                    ackNumber=lastMessage.blockNumber;
    1794:	80 91 6e 13 	lds	r24, 0x136E
    1798:	90 91 6f 13 	lds	r25, 0x136F
    179c:	90 93 74 13 	sts	0x1374, r25
    17a0:	80 93 73 13 	sts	0x1373, r24
    17a4:	10 c0       	rjmp	.+32     	; 0x17c6 <tftp_transfer+0x15e>
                }
            }
            else
            {
                PRINTF_D("tftp error received %d\n", error);
    17a6:	00 d0       	rcall	.+0      	; 0x17a8 <tftp_transfer+0x140>
    17a8:	00 d0       	rcall	.+0      	; 0x17aa <tftp_transfer+0x142>
    17aa:	85 ef       	ldi	r24, 0xF5	; 245
    17ac:	9a e0       	ldi	r25, 0x0A	; 10
    17ae:	ed b7       	in	r30, 0x3d	; 61
    17b0:	fe b7       	in	r31, 0x3e	; 62
    17b2:	92 83       	std	Z+2, r25	; 0x02
    17b4:	81 83       	std	Z+1, r24	; 0x01
    17b6:	f4 82       	std	Z+4, r15	; 0x04
    17b8:	e3 82       	std	Z+3, r14	; 0x03
    17ba:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	0f 90       	pop	r0
    17c4:	0f 90       	pop	r0
            }
            //return to pending status
            status=TFTP_STATUS_IDLE;
    17c6:	10 92 72 13 	sts	0x1372, r1
            if(isRequestOwner)
    17ca:	80 91 71 13 	lds	r24, 0x1371
    17ce:	88 23       	and	r24, r24
    17d0:	11 f0       	breq	.+4      	; 0x17d6 <tftp_transfer+0x16e>
            	return -16;
    17d2:	80 ef       	ldi	r24, 0xF0	; 240
    17d4:	01 c0       	rjmp	.+2      	; 0x17d8 <tftp_transfer+0x170>
    {
        //silent discard
        return 0;
    }

    return result;
    17d6:	80 e0       	ldi	r24, 0x00	; 0
}
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	ff 90       	pop	r15
    17e2:	ef 90       	pop	r14
    17e4:	df 90       	pop	r13
    17e6:	cf 90       	pop	r12
    17e8:	bf 90       	pop	r11
    17ea:	af 90       	pop	r10
    17ec:	08 95       	ret

000017ee <tftp_timer_handler>:
TIMER_HANDLER_FUNCTION(tftp_timer_handler)
{
    17ee:	ef 92       	push	r14
    17f0:	ff 92       	push	r15
    17f2:	0f 93       	push	r16
    17f4:	1f 93       	push	r17
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
	//TODO something is really weird here with the control statements
	if(lastMessage.opcode==TFTP_OPCODE_WRQ_SINGLE)
    17fa:	80 91 66 11 	lds	r24, 0x1166
    17fe:	90 91 67 11 	lds	r25, 0x1167
    1802:	86 30       	cpi	r24, 0x06	; 6
    1804:	91 05       	cpc	r25, r1
    1806:	29 f4       	brne	.+10     	; 0x1812 <tftp_timer_handler+0x24>
	{
		printf("connection closed\n");
    1808:	8d e0       	ldi	r24, 0x0D	; 13
    180a:	9b e0       	ldi	r25, 0x0B	; 11
    180c:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
    1810:	77 c0       	rjmp	.+238    	; 0x1900 <tftp_timer_handler+0x112>
		if(isRequestOwner)
			return 0;
	}
	else
	{
		if(status==TFTP_STATUS_SENDING)
    1812:	80 91 72 13 	lds	r24, 0x1372
    1816:	81 30       	cpi	r24, 0x01	; 1
    1818:	09 f0       	breq	.+2      	; 0x181c <tftp_timer_handler+0x2e>
    181a:	72 c0       	rjmp	.+228    	; 0x1900 <tftp_timer_handler+0x112>
		{
			PRINTF_D("tftp_timer_handler\n");
    181c:	8f e1       	ldi	r24, 0x1F	; 31
    181e:	9b e0       	ldi	r25, 0x0B	; 11
    1820:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
			//if the last taken block number is less than the last transmitted ack number
			//or if we sent a write request and couldn't get an ack yet
			if( (lastMessage.blockNumber>ackNumber) || (lastMessage.opcode==TFTP_OPCODE_WRQ))
    1824:	80 91 73 13 	lds	r24, 0x1373
    1828:	90 91 74 13 	lds	r25, 0x1374
    182c:	20 91 6e 13 	lds	r18, 0x136E
    1830:	30 91 6f 13 	lds	r19, 0x136F
    1834:	82 17       	cp	r24, r18
    1836:	93 07       	cpc	r25, r19
    1838:	40 f0       	brcs	.+16     	; 0x184a <tftp_timer_handler+0x5c>
    183a:	20 91 66 11 	lds	r18, 0x1166
    183e:	30 91 67 11 	lds	r19, 0x1167
    1842:	22 30       	cpi	r18, 0x02	; 2
    1844:	31 05       	cpc	r19, r1
    1846:	09 f0       	breq	.+2      	; 0x184a <tftp_timer_handler+0x5c>
    1848:	5b c0       	rjmp	.+182    	; 0x1900 <tftp_timer_handler+0x112>
			{
				timeouts++;
    184a:	40 91 75 13 	lds	r20, 0x1375
    184e:	4f 5f       	subi	r20, 0xFF	; 255
    1850:	40 93 75 13 	sts	0x1375, r20
				PRINTF_D("tftp ack timer timeout %d, timeouts=%d\n", ackNumber, timeouts);
    1854:	00 d0       	rcall	.+0      	; 0x1856 <tftp_timer_handler+0x68>
    1856:	00 d0       	rcall	.+0      	; 0x1858 <tftp_timer_handler+0x6a>
    1858:	00 d0       	rcall	.+0      	; 0x185a <tftp_timer_handler+0x6c>
    185a:	ed b7       	in	r30, 0x3d	; 61
    185c:	fe b7       	in	r31, 0x3e	; 62
    185e:	31 96       	adiw	r30, 0x01	; 1
    1860:	22 e3       	ldi	r18, 0x32	; 50
    1862:	3b e0       	ldi	r19, 0x0B	; 11
    1864:	ad b7       	in	r26, 0x3d	; 61
    1866:	be b7       	in	r27, 0x3e	; 62
    1868:	12 96       	adiw	r26, 0x02	; 2
    186a:	3c 93       	st	X, r19
    186c:	2e 93       	st	-X, r18
    186e:	11 97       	sbiw	r26, 0x01	; 1
    1870:	93 83       	std	Z+3, r25	; 0x03
    1872:	82 83       	std	Z+2, r24	; 0x02
    1874:	44 83       	std	Z+4, r20	; 0x04
    1876:	15 82       	std	Z+5, r1	; 0x05
    1878:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>

				if(timeouts>=TFTP_MAX_TIMEOUTS)
    187c:	8d b7       	in	r24, 0x3d	; 61
    187e:	9e b7       	in	r25, 0x3e	; 62
    1880:	06 96       	adiw	r24, 0x06	; 6
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	9e bf       	out	0x3e, r25	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	8d bf       	out	0x3d, r24	; 61
    188c:	80 91 75 13 	lds	r24, 0x1375
    1890:	8a 30       	cpi	r24, 0x0A	; 10
    1892:	a0 f0       	brcs	.+40     	; 0x18bc <tftp_timer_handler+0xce>
    return 0;
}

void tftp_setStatus(uint8_t newStatus)
{
    status=newStatus;
    1894:	10 92 72 13 	sts	0x1372, r1
				PRINTF_D("tftp ack timer timeout %d, timeouts=%d\n", ackNumber, timeouts);

				if(timeouts>=TFTP_MAX_TIMEOUTS)
				{
					tftp_setStatus(TFTP_STATUS_IDLE);
					blockNumber=0;
    1898:	10 92 77 13 	sts	0x1377, r1
    189c:	10 92 76 13 	sts	0x1376, r1
					ackNumber=0;
    18a0:	10 92 74 13 	sts	0x1374, r1
    18a4:	10 92 73 13 	sts	0x1373, r1
					PRINTF_D("connection canceled\n");
    18a8:	8a e5       	ldi	r24, 0x5A	; 90
    18aa:	9b e0       	ldi	r25, 0x0B	; 11
    18ac:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
					if(isRequestOwner)
    18b0:	80 91 71 13 	lds	r24, 0x1371
    18b4:	88 23       	and	r24, r24
    18b6:	21 f1       	breq	.+72     	; 0x1900 <tftp_timer_handler+0x112>
						return (-18);
    18b8:	8e ee       	ldi	r24, 0xEE	; 238
    18ba:	23 c0       	rjmp	.+70     	; 0x1902 <tftp_timer_handler+0x114>
					return 0;
				}

				//set up retransmit timer
				timers_create_timer(tftp_getRandomRetransmissionTime(), 128);
    18bc:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <tftp_getRandomRetransmissionTime>
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	60 e8       	ldi	r22, 0x80	; 128
    18c4:	70 e0       	ldi	r23, 0x00	; 0
    18c6:	0e 94 8e 0c 	call	0x191c	; 0x191c <timers_create_timer>
				//retransmit
				return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
    18ca:	c0 91 78 13 	lds	r28, 0x1378
    18ce:	d0 91 79 13 	lds	r29, 0x1379
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    18da:	60 91 62 11 	lds	r22, 0x1162
    18de:	70 91 63 11 	lds	r23, 0x1163
    18e2:	20 91 64 11 	lds	r18, 0x1164
    18e6:	30 91 65 11 	lds	r19, 0x1165
    18ea:	e0 90 6c 13 	lds	r14, 0x136C
    18ee:	f0 90 6d 13 	lds	r15, 0x136D
    18f2:	4c e5       	ldi	r20, 0x5C	; 92
    18f4:	51 e1       	ldi	r21, 0x11	; 17
    18f6:	08 e6       	ldi	r16, 0x68	; 104
    18f8:	11 e1       	ldi	r17, 0x11	; 17
    18fa:	fe 01       	movw	r30, r28
    18fc:	09 95       	icall
    18fe:	01 c0       	rjmp	.+2      	; 0x1902 <tftp_timer_handler+0x114>
					blockNumber=0;
					ackNumber=0;
					PRINTF_D("connection canceled\n");
					if(isRequestOwner)
						return (-18);
					return 0;
    1900:	80 e0       	ldi	r24, 0x00	; 0
				return mainDataQueuer(udp_get_localhost_ip(NULL), lastMessage.src_port, lastMessage.dst, lastMessage.dst_port, lastMessage.payload, lastMessage.payloadLength);
			}
		}
	}
	return 0;
}
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	1f 91       	pop	r17
    1908:	0f 91       	pop	r16
    190a:	ff 90       	pop	r15
    190c:	ef 90       	pop	r14
    190e:	08 95       	ret

00001910 <timers_initialize>:
static struct ctimer alarm_timer;
void (*mainTimerHandler)(void*);

uint8_t timers_initialize( void(*handlerfptr)(void* ))
{
    mainTimerHandler=handlerfptr;
    1910:	90 93 10 2e 	sts	0x2E10, r25
    1914:	80 93 0f 2e 	sts	0x2E0F, r24
    return 0;
}
    1918:	80 e0       	ldi	r24, 0x00	; 0
    191a:	08 95       	ret

0000191c <timers_create_timer>:

uint8_t timers_create_timer( int expireS, int expireMS)
{
    191c:	9c 01       	movw	r18, r24
    191e:	cb 01       	movw	r24, r22
	ctimer_set(&alarm_timer, (expireS*CLOCK_SECOND)+(expireMS*CLOCK_SECOND/1000), mainTimerHandler, 0);
    1920:	96 95       	lsr	r25
    1922:	98 2f       	mov	r25, r24
    1924:	88 27       	eor	r24, r24
    1926:	97 95       	ror	r25
    1928:	87 95       	ror	r24
    192a:	68 ee       	ldi	r22, 0xE8	; 232
    192c:	73 e0       	ldi	r23, 0x03	; 3
    192e:	0e 94 77 4a 	call	0x94ee	; 0x94ee <__divmodhi4>
    1932:	36 95       	lsr	r19
    1934:	32 2f       	mov	r19, r18
    1936:	22 27       	eor	r18, r18
    1938:	37 95       	ror	r19
    193a:	27 95       	ror	r18
    193c:	62 0f       	add	r22, r18
    193e:	73 1f       	adc	r23, r19
    1940:	40 91 0f 2e 	lds	r20, 0x2E0F
    1944:	50 91 10 2e 	lds	r21, 0x2E10
    1948:	8e e7       	ldi	r24, 0x7E	; 126
    194a:	93 e1       	ldi	r25, 0x13	; 19
    194c:	20 e0       	ldi	r18, 0x00	; 0
    194e:	30 e0       	ldi	r19, 0x00	; 0
    1950:	0e 94 f7 17 	call	0x2fee	; 0x2fee <ctimer_set>
	return 0;
}
    1954:	80 e0       	ldi	r24, 0x00	; 0
    1956:	08 95       	ret

00001958 <timers_cancel_timer>:
uint8_t timers_cancel_timer(void)
{
	ctimer_stop(&alarm_timer);
    1958:	8e e7       	ldi	r24, 0x7E	; 126
    195a:	93 e1       	ldi	r25, 0x13	; 19
    195c:	0e 94 7e 18 	call	0x30fc	; 0x30fc <ctimer_stop>
    return 0;
}
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	08 95       	ret

00001964 <udp_calculate_checksum>:
static dataQueuerfptr_t mainDataQueuer;
static uint8_t local_ip_address[6]={127, 0, 0, 0, 0, 1};
static const uint8_t udp_broadcast_address[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static uint16_t udp_calculate_checksum(uint8_t* src_addr, uint8_t* dest_addr, uint8_t* payload, uint16_t udp_len)
{
    1964:	2f 92       	push	r2
    1966:	3f 92       	push	r3
    1968:	4f 92       	push	r4
    196a:	5f 92       	push	r5
    196c:	6f 92       	push	r6
    196e:	7f 92       	push	r7
    1970:	8f 92       	push	r8
    1972:	9f 92       	push	r9
    1974:	af 92       	push	r10
    1976:	bf 92       	push	r11
    1978:	cf 92       	push	r12
    197a:	df 92       	push	r13
    197c:	ef 92       	push	r14
    197e:	ff 92       	push	r15
    1980:	0f 93       	push	r16
    1982:	1f 93       	push	r17
    1984:	df 93       	push	r29
    1986:	cf 93       	push	r28
    1988:	00 d0       	rcall	.+0      	; 0x198a <udp_calculate_checksum+0x26>
    198a:	00 d0       	rcall	.+0      	; 0x198c <udp_calculate_checksum+0x28>
    198c:	00 d0       	rcall	.+0      	; 0x198e <udp_calculate_checksum+0x2a>
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
    1992:	78 2e       	mov	r7, r24
    1994:	89 2e       	mov	r8, r25
    1996:	66 2e       	mov	r6, r22
    1998:	97 2e       	mov	r9, r23
    199a:	b9 01       	movw	r22, r18
            word16 =((payload[i]<<8)&0xFF00);
        sum = sum + (uint32_t)word16;
    }

    // add the UDP pseudo header which contains the IP source and destinationn addresses
    for (i=0;i<6;i=i+2)
    199c:	e4 2f       	mov	r30, r20
    199e:	f5 2f       	mov	r31, r21
    uint8_t prot_udp=17;
    uint16_t word16;
    uint32_t sum;

    //initialize sum to zero
    sum=0;
    19a0:	20 e0       	ldi	r18, 0x00	; 0
    19a2:	30 e0       	ldi	r19, 0x00	; 0
    19a4:	a9 01       	movw	r20, r18

    // make 16 bit words out of every two adjacent 8 bit words and
    // calculate the sum of all 16 vit words
    for (i=0; i<udp_len-8; i=i+2)
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	90 e0       	ldi	r25, 0x00	; 0
    19aa:	dc 01       	movw	r26, r24
    19ac:	8b 01       	movw	r16, r22
    19ae:	08 50       	subi	r16, 0x08	; 8
    19b0:	10 40       	sbci	r17, 0x00	; 0
    19b2:	58 01       	movw	r10, r16
    19b4:	cc 24       	eor	r12, r12
    19b6:	dd 24       	eor	r13, r13
    19b8:	79 01       	movw	r14, r18
    19ba:	8a 01       	movw	r16, r20
    19bc:	3e 82       	std	Y+6, r3	; 0x06
    19be:	2d 82       	std	Y+5, r2	; 0x05
    19c0:	21 c0       	rjmp	.+66     	; 0x1a04 <udp_calculate_checksum+0xa0>
    {
        if(i+1<udp_len-8)
    19c2:	9c 01       	movw	r18, r24
    19c4:	ad 01       	movw	r20, r26
    19c6:	2f 5f       	subi	r18, 0xFF	; 255
    19c8:	3f 4f       	sbci	r19, 0xFF	; 255
    19ca:	4f 4f       	sbci	r20, 0xFF	; 255
    19cc:	5f 4f       	sbci	r21, 0xFF	; 255
    19ce:	30 80       	ld	r3, Z
    19d0:	2a 15       	cp	r18, r10
    19d2:	3b 05       	cpc	r19, r11
    19d4:	4c 05       	cpc	r20, r12
    19d6:	5d 05       	cpc	r21, r13
    19d8:	40 f4       	brcc	.+16     	; 0x19ea <udp_calculate_checksum+0x86>
            word16 =((payload[i]<<8)&0xFF00)+(payload[i+1]&0x00FF);
    19da:	3e 82       	std	Y+6, r3	; 0x06
    19dc:	1d 82       	std	Y+5, r1	; 0x05
    19de:	21 81       	ldd	r18, Z+1	; 0x01
    19e0:	4d 80       	ldd	r4, Y+5	; 0x05
    19e2:	5e 80       	ldd	r5, Y+6	; 0x06
    19e4:	42 0e       	add	r4, r18
    19e6:	51 1c       	adc	r5, r1
    19e8:	02 c0       	rjmp	.+4      	; 0x19ee <udp_calculate_checksum+0x8a>
        else
            word16 =((payload[i]<<8)&0xFF00);
    19ea:	53 2c       	mov	r5, r3
    19ec:	44 24       	eor	r4, r4
        sum = sum + (uint32_t)word16;
    19ee:	92 01       	movw	r18, r4
    19f0:	40 e0       	ldi	r20, 0x00	; 0
    19f2:	50 e0       	ldi	r21, 0x00	; 0
    19f4:	e2 0e       	add	r14, r18
    19f6:	f3 1e       	adc	r15, r19
    19f8:	04 1f       	adc	r16, r20
    19fa:	15 1f       	adc	r17, r21
    //initialize sum to zero
    sum=0;

    // make 16 bit words out of every two adjacent 8 bit words and
    // calculate the sum of all 16 vit words
    for (i=0; i<udp_len-8; i=i+2)
    19fc:	02 96       	adiw	r24, 0x02	; 2
    19fe:	a1 1d       	adc	r26, r1
    1a00:	b1 1d       	adc	r27, r1
    1a02:	32 96       	adiw	r30, 0x02	; 2
    1a04:	8a 15       	cp	r24, r10
    1a06:	9b 05       	cpc	r25, r11
    1a08:	ac 05       	cpc	r26, r12
    1a0a:	bd 05       	cpc	r27, r13
    1a0c:	d0 f2       	brcs	.-76     	; 0x19c2 <udp_calculate_checksum+0x5e>
    1a0e:	a8 01       	movw	r20, r16
    1a10:	97 01       	movw	r18, r14
    1a12:	e7 2d       	mov	r30, r7
    1a14:	f8 2d       	mov	r31, r8
    1a16:	80 e0       	ldi	r24, 0x00	; 0
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	7c 01       	movw	r14, r24
    }

    // add the UDP pseudo header which contains the IP source and destinationn addresses
    for (i=0;i<6;i=i+2)
    {
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
    1a1c:	40 80       	ld	r4, Z
    1a1e:	4a 82       	std	Y+2, r4	; 0x02
    1a20:	19 82       	std	Y+1, r1	; 0x01
    1a22:	81 81       	ldd	r24, Z+1	; 0x01
    1a24:	09 81       	ldd	r16, Y+1	; 0x01
    1a26:	1a 81       	ldd	r17, Y+2	; 0x02
    1a28:	08 0f       	add	r16, r24
    1a2a:	11 1d       	adc	r17, r1
    1a2c:	c8 01       	movw	r24, r16
        sum=sum+word16;
    1a2e:	a0 e0       	ldi	r26, 0x00	; 0
    1a30:	b0 e0       	ldi	r27, 0x00	; 0
    1a32:	28 0f       	add	r18, r24
    1a34:	39 1f       	adc	r19, r25
    1a36:	4a 1f       	adc	r20, r26
    1a38:	5b 1f       	adc	r21, r27
    1a3a:	08 94       	sec
    1a3c:	e1 1c       	adc	r14, r1
    1a3e:	f1 1c       	adc	r15, r1
    1a40:	32 96       	adiw	r30, 0x02	; 2
            word16 =((payload[i]<<8)&0xFF00);
        sum = sum + (uint32_t)word16;
    }

    // add the UDP pseudo header which contains the IP source and destinationn addresses
    for (i=0;i<6;i=i+2)
    1a42:	13 e0       	ldi	r17, 0x03	; 3
    1a44:	e1 16       	cp	r14, r17
    1a46:	f1 04       	cpc	r15, r1
    1a48:	49 f7       	brne	.-46     	; 0x1a1c <udp_calculate_checksum+0xb8>
    1a4a:	e6 2d       	mov	r30, r6
    1a4c:	f9 2d       	mov	r31, r9
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	7c 01       	movw	r14, r24
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
        sum=sum+word16;
    }
    for (i=0;i<6;i=i+2)
    {
        word16 =((dest_addr[i]<<8)&0xFF00)+(dest_addr[i+1]&0xFF);
    1a54:	80 81       	ld	r24, Z
    1a56:	8c 83       	std	Y+4, r24	; 0x04
    1a58:	1b 82       	std	Y+3, r1	; 0x03
    1a5a:	81 81       	ldd	r24, Z+1	; 0x01
    1a5c:	ab 81       	ldd	r26, Y+3	; 0x03
    1a5e:	bc 81       	ldd	r27, Y+4	; 0x04
    1a60:	a8 0f       	add	r26, r24
    1a62:	b1 1d       	adc	r27, r1
    1a64:	cd 01       	movw	r24, r26
        sum=sum+word16;
    1a66:	a0 e0       	ldi	r26, 0x00	; 0
    1a68:	b0 e0       	ldi	r27, 0x00	; 0
    1a6a:	28 0f       	add	r18, r24
    1a6c:	39 1f       	adc	r19, r25
    1a6e:	4a 1f       	adc	r20, r26
    1a70:	5b 1f       	adc	r21, r27
    1a72:	08 94       	sec
    1a74:	e1 1c       	adc	r14, r1
    1a76:	f1 1c       	adc	r15, r1
    1a78:	32 96       	adiw	r30, 0x02	; 2
    for (i=0;i<6;i=i+2)
    {
        word16 =((src_addr[i]<<8)&0xFF00)+(src_addr[i+1]&0xFF);
        sum=sum+word16;
    }
    for (i=0;i<6;i=i+2)
    1a7a:	b3 e0       	ldi	r27, 0x03	; 3
    1a7c:	eb 16       	cp	r14, r27
    1a7e:	f1 04       	cpc	r15, r1
    1a80:	49 f7       	brne	.-46     	; 0x1a54 <udp_calculate_checksum+0xf0>
    {
        word16 =((dest_addr[i]<<8)&0xFF00)+(dest_addr[i+1]&0xFF);
        sum=sum+word16;
    }
    // the protocol number and the length of the UDP packet
    sum = sum + prot_udp + udp_len;
    1a82:	80 e0       	ldi	r24, 0x00	; 0
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	6f 5e       	subi	r22, 0xEF	; 239
    1a88:	7f 4f       	sbci	r23, 0xFF	; 255
    1a8a:	8f 4f       	sbci	r24, 0xFF	; 255
    1a8c:	9f 4f       	sbci	r25, 0xFF	; 255
    1a8e:	02 c0       	rjmp	.+4      	; 0x1a94 <udp_calculate_checksum+0x130>

    // keep only the last 16 bits of the 32 bit calculated sum and add the carries
    while (sum>>16)
    {
        sum = (sum & 0xFFFF)+(sum >> 16);
    1a90:	80 70       	andi	r24, 0x00	; 0
    1a92:	90 70       	andi	r25, 0x00	; 0
    1a94:	62 0f       	add	r22, r18
    1a96:	73 1f       	adc	r23, r19
    1a98:	84 1f       	adc	r24, r20
    1a9a:	95 1f       	adc	r25, r21
    }
    // the protocol number and the length of the UDP packet
    sum = sum + prot_udp + udp_len;

    // keep only the last 16 bits of the 32 bit calculated sum and add the carries
    while (sum>>16)
    1a9c:	9c 01       	movw	r18, r24
    1a9e:	44 27       	eor	r20, r20
    1aa0:	55 27       	eor	r21, r21
    1aa2:	21 15       	cp	r18, r1
    1aa4:	31 05       	cpc	r19, r1
    1aa6:	41 05       	cpc	r20, r1
    1aa8:	51 05       	cpc	r21, r1
    1aaa:	91 f7       	brne	.-28     	; 0x1a90 <udp_calculate_checksum+0x12c>
    {
        sum = (sum & 0xFFFF)+(sum >> 16);
    }

    // Take the one's complement of sum
    sum = ~sum;
    1aac:	9b 01       	movw	r18, r22
    1aae:	ac 01       	movw	r20, r24
    1ab0:	20 95       	com	r18
    1ab2:	30 95       	com	r19
    1ab4:	40 95       	com	r20
    1ab6:	50 95       	com	r21

    return ((uint16_t) (sum&0xFFFF));
}
    1ab8:	c9 01       	movw	r24, r18
    1aba:	26 96       	adiw	r28, 0x06	; 6
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	cd bf       	out	0x3d, r28	; 61
    1ac6:	cf 91       	pop	r28
    1ac8:	df 91       	pop	r29
    1aca:	1f 91       	pop	r17
    1acc:	0f 91       	pop	r16
    1ace:	ff 90       	pop	r15
    1ad0:	ef 90       	pop	r14
    1ad2:	df 90       	pop	r13
    1ad4:	cf 90       	pop	r12
    1ad6:	bf 90       	pop	r11
    1ad8:	af 90       	pop	r10
    1ada:	9f 90       	pop	r9
    1adc:	8f 90       	pop	r8
    1ade:	7f 90       	pop	r7
    1ae0:	6f 90       	pop	r6
    1ae2:	5f 90       	pop	r5
    1ae4:	4f 90       	pop	r4
    1ae6:	3f 90       	pop	r3
    1ae8:	2f 90       	pop	r2
    1aea:	08 95       	ret

00001aec <udp_get_data_queuer_fptr>:

dataQueuerfptr_t udp_get_data_queuer_fptr(void)
{
    return mainDataQueuer;
}
    1aec:	80 91 8e 13 	lds	r24, 0x138E
    1af0:	90 91 8f 13 	lds	r25, 0x138F
    1af4:	08 95       	ret

00001af6 <udp_initialize_ip_network>:

void udp_initialize_ip_network(uint8_t* myIpAddress, dataQueuerfptr_t dataQueuer)
{
    1af6:	28 2f       	mov	r18, r24
    1af8:	39 2f       	mov	r19, r25
    1afa:	d9 01       	movw	r26, r18
    1afc:	e8 e7       	ldi	r30, 0x78	; 120
    1afe:	fb e0       	ldi	r31, 0x0B	; 11
    uint32_t i;
    for(i=0; i<6; i++)
        local_ip_address[i] = myIpAddress[i];
    1b00:	8d 91       	ld	r24, X+
    1b02:	81 93       	st	Z+, r24
}

void udp_initialize_ip_network(uint8_t* myIpAddress, dataQueuerfptr_t dataQueuer)
{
    uint32_t i;
    for(i=0; i<6; i++)
    1b04:	8b e0       	ldi	r24, 0x0B	; 11
    1b06:	ee 37       	cpi	r30, 0x7E	; 126
    1b08:	f8 07       	cpc	r31, r24
    1b0a:	d1 f7       	brne	.-12     	; 0x1b00 <udp_initialize_ip_network+0xa>
        local_ip_address[i] = myIpAddress[i];

    mainDataQueuer=dataQueuer;
    1b0c:	70 93 8f 13 	sts	0x138F, r23
    1b10:	60 93 8e 13 	sts	0x138E, r22
}
    1b14:	08 95       	ret

00001b16 <udp_get_localhost_ip>:

uint8_t* udp_get_localhost_ip(uint8_t* ip_out)
{
    uint8_t i;

    if(ip_out!=NULL)
    1b16:	00 97       	sbiw	r24, 0x00	; 0
    1b18:	49 f0       	breq	.+18     	; 0x1b2c <udp_get_localhost_ip+0x16>
    1b1a:	e8 e7       	ldi	r30, 0x78	; 120
    1b1c:	fb e0       	ldi	r31, 0x0B	; 11
    1b1e:	dc 01       	movw	r26, r24
    {
        for(i=0; i<6; i++)
            ip_out[i] = local_ip_address[i];
    1b20:	81 91       	ld	r24, Z+
    1b22:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(ip_out!=NULL)
    {
        for(i=0; i<6; i++)
    1b24:	8b e0       	ldi	r24, 0x0B	; 11
    1b26:	ee 37       	cpi	r30, 0x7E	; 126
    1b28:	f8 07       	cpc	r31, r24
    1b2a:	d1 f7       	brne	.-12     	; 0x1b20 <udp_get_localhost_ip+0xa>
            ip_out[i] = local_ip_address[i];
    }
    return local_ip_address;
}
    1b2c:	88 e7       	ldi	r24, 0x78	; 120
    1b2e:	9b e0       	ldi	r25, 0x0B	; 11
    1b30:	08 95       	ret

00001b32 <udp_get_broadcast_ip>:
uint8_t* udp_get_broadcast_ip(uint8_t* ip_out)
{
    uint8_t i;

    if(ip_out!=NULL)
    1b32:	00 97       	sbiw	r24, 0x00	; 0
    1b34:	49 f0       	breq	.+18     	; 0x1b48 <udp_get_broadcast_ip+0x16>
    1b36:	e2 e7       	ldi	r30, 0x72	; 114
    1b38:	fb e0       	ldi	r31, 0x0B	; 11
    1b3a:	dc 01       	movw	r26, r24
    {
        for(i=0; i<6; i++)
            ip_out[i] = udp_broadcast_address[i];
    1b3c:	81 91       	ld	r24, Z+
    1b3e:	8d 93       	st	X+, r24
{
    uint8_t i;

    if(ip_out!=NULL)
    {
        for(i=0; i<6; i++)
    1b40:	8b e0       	ldi	r24, 0x0B	; 11
    1b42:	e8 37       	cpi	r30, 0x78	; 120
    1b44:	f8 07       	cpc	r31, r24
    1b46:	d1 f7       	brne	.-12     	; 0x1b3c <udp_get_broadcast_ip+0xa>
            ip_out[i] = udp_broadcast_address[i];
    }
    return udp_broadcast_address;
}
    1b48:	82 e7       	ldi	r24, 0x72	; 114
    1b4a:	9b e0       	ldi	r25, 0x0B	; 11
    1b4c:	08 95       	ret

00001b4e <udp_create_packet>:

uint16_t udp_create_packet(uint8_t* src_in, uint16_t src_port, uint8_t* dst_in, uint16_t dst_port, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
{
    1b4e:	7f 92       	push	r7
    1b50:	8f 92       	push	r8
    1b52:	9f 92       	push	r9
    1b54:	af 92       	push	r10
    1b56:	bf 92       	push	r11
    1b58:	cf 92       	push	r12
    1b5a:	df 92       	push	r13
    1b5c:	ef 92       	push	r14
    1b5e:	ff 92       	push	r15
    1b60:	0f 93       	push	r16
    1b62:	1f 93       	push	r17
    1b64:	cf 93       	push	r28
    1b66:	df 93       	push	r29
    1b68:	72 2e       	mov	r7, r18
    1b6a:	58 01       	movw	r10, r16
    1b6c:	e6 01       	movw	r28, r12
    uint16_t len=0, udp_checksum=0;
    uint8_t i;
    //check for input errors
    if(payload_length > UDP_MAX_PAYLOAD_LENGTH || packet_out==NULL)
    1b6e:	25 e0       	ldi	r18, 0x05	; 5
    1b70:	e2 16       	cp	r14, r18
    1b72:	22 e0       	ldi	r18, 0x02	; 2
    1b74:	f2 06       	cpc	r15, r18
    1b76:	08 f0       	brcs	.+2      	; 0x1b7a <udp_create_packet+0x2c>
    1b78:	44 c0       	rjmp	.+136    	; 0x1c02 <udp_create_packet+0xb4>
    1b7a:	20 97       	sbiw	r28, 0x00	; 0
    1b7c:	09 f4       	brne	.+2      	; 0x1b80 <udp_create_packet+0x32>
    1b7e:	41 c0       	rjmp	.+130    	; 0x1c02 <udp_create_packet+0xb4>

    //IPv6 Headers

    //paste version and priority
    uint8_t version_priority=0x62; //IPv6=6 & FTP prio=2
    packet_out[IPV6_VERSION_PRIORITY_OFFSET]=version_priority;
    1b80:	e2 e6       	ldi	r30, 0x62	; 98
    1b82:	e8 83       	st	Y, r30
    len+=IPV6_VERSION_PRIORITY_LENGTH;

    //paste flow label -> last 2 bytes of the source address and last byte of source port
    packet_out[IPV6_FLOW_LABEL_OFFSET]=src_in[4];
    1b84:	dc 01       	movw	r26, r24
    1b86:	14 96       	adiw	r26, 0x04	; 4
    1b88:	ec 91       	ld	r30, X
    1b8a:	14 97       	sbiw	r26, 0x04	; 4
    1b8c:	e9 83       	std	Y+1, r30	; 0x01
    packet_out[IPV6_FLOW_LABEL_OFFSET+1]=src_in[5];
    1b8e:	15 96       	adiw	r26, 0x05	; 5
    1b90:	ec 91       	ld	r30, X
    1b92:	15 97       	sbiw	r26, 0x05	; 5
    1b94:	ea 83       	std	Y+2, r30	; 0x02
    packet_out[IPV6_FLOW_LABEL_OFFSET+2]=(src_port & 0xFF);
    1b96:	6b 83       	std	Y+3, r22	; 0x03
    len+=IPV6_FLOW_LABEL_LENGTH;

    //paste the payload length
    payload_length+=8; //add udp headers
    1b98:	87 01       	movw	r16, r14
    1b9a:	08 5f       	subi	r16, 0xF8	; 248
    1b9c:	1f 4f       	sbci	r17, 0xFF	; 255
    packet_out[IPV6_PAYLOAD_LENGTH_OFFSET]=((payload_length>>8) & 0xFF);
    1b9e:	c1 2e       	mov	r12, r17
    1ba0:	1c 83       	std	Y+4, r17	; 0x04
    packet_out[IPV6_PAYLOAD_LENGTH_OFFSET+1]=(payload_length & 0xFF);
    1ba2:	d0 2e       	mov	r13, r16
    1ba4:	0d 83       	std	Y+5, r16	; 0x05
    len+=IPV6_PAYLOAD_LENGTH_LENGTH;

    //paste the next header -> UDP
    packet_out[IPV6_NEXT_HEADER_OFFSET]=17; //UDP
    1ba6:	e1 e1       	ldi	r30, 0x11	; 17
    1ba8:	ee 83       	std	Y+6, r30	; 0x06
    len+=IPV6_NEXT_HEADER_LENGTH;
    
    //paste the hop limit
    packet_out[IPV6_HOP_LIMIT_OFFSET]=IPV6_HOP_LIMIT;
    1baa:	e2 e0       	ldi	r30, 0x02	; 2
    1bac:	ef 83       	std	Y+7, r30	; 0x07
            ip_out[i] = udp_broadcast_address[i];
    }
    return udp_broadcast_address;
}

uint16_t udp_create_packet(uint8_t* src_in, uint16_t src_port, uint8_t* dst_in, uint16_t dst_port, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
    1bae:	fe 01       	movw	r30, r28
    1bb0:	38 96       	adiw	r30, 0x08	; 8
    //paste the hop limit
    packet_out[IPV6_HOP_LIMIT_OFFSET]=IPV6_HOP_LIMIT;
    len+=IPV6_HOP_LIMIT_LENGTH;

    //paste the source address
    for(i=0; i<6; i++)
    1bb2:	99 24       	eor	r9, r9
        packet_out[IPV6_SOURCE_OFFSET+i]=src_in[i];
    1bb4:	8d 90       	ld	r8, X+
    1bb6:	81 92       	st	Z+, r8
    //paste the hop limit
    packet_out[IPV6_HOP_LIMIT_OFFSET]=IPV6_HOP_LIMIT;
    len+=IPV6_HOP_LIMIT_LENGTH;

    //paste the source address
    for(i=0; i<6; i++)
    1bb8:	93 94       	inc	r9
    1bba:	29 2d       	mov	r18, r9
    1bbc:	26 30       	cpi	r18, 0x06	; 6
    1bbe:	d1 f7       	brne	.-12     	; 0x1bb4 <udp_create_packet+0x66>
    1bc0:	a4 2f       	mov	r26, r20
    1bc2:	b5 2f       	mov	r27, r21
            ip_out[i] = udp_broadcast_address[i];
    }
    return udp_broadcast_address;
}

uint16_t udp_create_packet(uint8_t* src_in, uint16_t src_port, uint8_t* dst_in, uint16_t dst_port, uint8_t* payload_in, uint16_t payload_length, uint8_t* packet_out)
    1bc4:	fe 01       	movw	r30, r28
    1bc6:	3e 96       	adiw	r30, 0x0e	; 14
    1bc8:	99 24       	eor	r9, r9
        packet_out[IPV6_SOURCE_OFFSET+i]=src_in[i];
    len+=IPV6_SOURCE_LENGTH;

    //paste the destination address
    for(i=0; i<6; i++)
        packet_out[IPV6_DESTINATION_OFFSET+i]=dst_in[i];
    1bca:	8d 90       	ld	r8, X+
    1bcc:	81 92       	st	Z+, r8
    for(i=0; i<6; i++)
        packet_out[IPV6_SOURCE_OFFSET+i]=src_in[i];
    len+=IPV6_SOURCE_LENGTH;

    //paste the destination address
    for(i=0; i<6; i++)
    1bce:	93 94       	inc	r9
    1bd0:	29 2d       	mov	r18, r9
    1bd2:	26 30       	cpi	r18, 0x06	; 6
    1bd4:	d1 f7       	brne	.-12     	; 0x1bca <udp_create_packet+0x7c>
    len+=IPV6_DESTINATION_LENGTH;

    //UDP Headers

    //source port
    packet_out[UDP_SOURCE_PORT_OFFSET]=((src_port>>8) & 0xFF);
    1bd6:	7c 8b       	std	Y+20, r23	; 0x14
    packet_out[UDP_SOURCE_PORT_OFFSET+1]=(src_port & 0xFF);
    1bd8:	6d 8b       	std	Y+21, r22	; 0x15
    len+=UDP_SOURCE_PORT_LENGTH;

    //destination port
    packet_out[UDP_DESTINATION_PORT_OFFSET]=((dst_port>>8) & 0xFF);
    1bda:	3e 8b       	std	Y+22, r19	; 0x16
    packet_out[UDP_DESTINATION_PORT_OFFSET+1]=(dst_port & 0xFF);
    1bdc:	7f 8a       	std	Y+23, r7	; 0x17
    len+=UDP_DESTINATION_PORT_LENGTH;

    //udp length = data+udp headers
    //we've already added 8 to payload_length above, we don't do it again
    packet_out[UDP_LENGTH_OFFSET]=((payload_length>>8) & 0xFF);
    1bde:	c8 8e       	std	Y+24, r12	; 0x18
    packet_out[UDP_LENGTH_OFFSET+1]=(payload_length & 0xFF);
    1be0:	d9 8e       	std	Y+25, r13	; 0x19
    len+=UDP_LENGTH_LENGTH;

    //udp checksum
    //we've already added 8 to payload_length above, we don't do it again
    udp_checksum=udp_calculate_checksum(src_in, dst_in, payload_in, payload_length);
    1be2:	ba 01       	movw	r22, r20
    1be4:	a5 01       	movw	r20, r10
    1be6:	98 01       	movw	r18, r16
    1be8:	0e 94 b2 0c 	call	0x1964	; 0x1964 <udp_calculate_checksum>
    packet_out[UDP_CHECKSUM_OFFSET]=((udp_checksum>>8) & 0xFF);
    1bec:	9a 8f       	std	Y+26, r25	; 0x1a
    packet_out[UDP_CHECKSUM_OFFSET+1]=(udp_checksum & 0xFF);
    1bee:	8b 8f       	std	Y+27, r24	; 0x1b
    len+=UDP_CHECKSUM_LENGTH;

    memcpy(packet_out+UDP_PAYLOAD_OFFSET, payload_in, payload_length-8);
    1bf0:	6c 96       	adiw	r28, 0x1c	; 28
    1bf2:	ce 01       	movw	r24, r28
    1bf4:	b5 01       	movw	r22, r10
    1bf6:	a7 01       	movw	r20, r14
    1bf8:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    
    len+=payload_length-8;
    1bfc:	0c 5e       	subi	r16, 0xEC	; 236
    1bfe:	1f 4f       	sbci	r17, 0xFF	; 255
    
    return len;
    1c00:	02 c0       	rjmp	.+4      	; 0x1c06 <udp_create_packet+0xb8>
{
    uint16_t len=0, udp_checksum=0;
    uint8_t i;
    //check for input errors
    if(payload_length > UDP_MAX_PAYLOAD_LENGTH || packet_out==NULL)
        return 0;
    1c02:	00 e0       	ldi	r16, 0x00	; 0
    1c04:	10 e0       	ldi	r17, 0x00	; 0
    memcpy(packet_out+UDP_PAYLOAD_OFFSET, payload_in, payload_length-8);
    
    len+=payload_length-8;
    
    return len;
}
    1c06:	c8 01       	movw	r24, r16
    1c08:	df 91       	pop	r29
    1c0a:	cf 91       	pop	r28
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	cf 90       	pop	r12
    1c18:	bf 90       	pop	r11
    1c1a:	af 90       	pop	r10
    1c1c:	9f 90       	pop	r9
    1c1e:	8f 90       	pop	r8
    1c20:	7f 90       	pop	r7
    1c22:	08 95       	ret

00001c24 <udp_check_destination>:

uint8_t udp_check_destination(uint8_t* my_dst, uint8_t* packet_dst, uint8_t* packet_in)
{
    1c24:	0f 93       	push	r16
    1c26:	1f 93       	push	r17
    1c28:	cf 93       	push	r28
    1c2a:	df 93       	push	r29
    1c2c:	8b 01       	movw	r16, r22
    1c2e:	ea 01       	movw	r28, r20
    uint8_t result;
    
    //check for address match
    result=memcmp(my_dst, packet_in+IPV6_DESTINATION_OFFSET, IPV6_DESTINATION_LENGTH);
    1c30:	2e 96       	adiw	r28, 0x0e	; 14
    1c32:	be 01       	movw	r22, r28
    1c34:	46 e0       	ldi	r20, 0x06	; 6
    1c36:	50 e0       	ldi	r21, 0x00	; 0
    1c38:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
    if(result)
    1c3c:	88 23       	and	r24, r24
    1c3e:	39 f0       	breq	.+14     	; 0x1c4e <udp_check_destination+0x2a>
    {
        result=memcmp(udp_broadcast_address, packet_in+IPV6_DESTINATION_OFFSET, IPV6_DESTINATION_LENGTH);
    1c40:	82 e7       	ldi	r24, 0x72	; 114
    1c42:	9b e0       	ldi	r25, 0x0B	; 11
    1c44:	be 01       	movw	r22, r28
    1c46:	46 e0       	ldi	r20, 0x06	; 6
    1c48:	50 e0       	ldi	r21, 0x00	; 0
    1c4a:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
    }

    //copy the destination address in the packet
    if(packet_dst!=NULL)
    1c4e:	01 15       	cp	r16, r1
    1c50:	11 05       	cpc	r17, r1
    1c52:	31 f0       	breq	.+12     	; 0x1c60 <udp_check_destination+0x3c>
    	memcpy(packet_dst, packet_in+IPV6_DESTINATION_OFFSET, IPV6_DESTINATION_LENGTH);
    1c54:	f8 01       	movw	r30, r16
    1c56:	96 e0       	ldi	r25, 0x06	; 6
    1c58:	09 90       	ld	r0, Y+
    1c5a:	01 92       	st	Z+, r0
    1c5c:	91 50       	subi	r25, 0x01	; 1
    1c5e:	e1 f7       	brne	.-8      	; 0x1c58 <udp_check_destination+0x34>
    
    return result;
}
    1c60:	df 91       	pop	r29
    1c62:	cf 91       	pop	r28
    1c64:	1f 91       	pop	r17
    1c66:	0f 91       	pop	r16
    1c68:	08 95       	ret

00001c6a <udp_open_packet_extended>:
                                    uint8_t* flow_label_out,
                                    uint8_t* hop_limit_out,
                                    uint8_t* next_header_out,
                                    uint8_t* version_out,
                                    uint8_t* priority_out)
{
    1c6a:	2f 92       	push	r2
    1c6c:	3f 92       	push	r3
    1c6e:	4f 92       	push	r4
    1c70:	5f 92       	push	r5
    1c72:	6f 92       	push	r6
    1c74:	7f 92       	push	r7
    1c76:	8f 92       	push	r8
    1c78:	9f 92       	push	r9
    1c7a:	af 92       	push	r10
    1c7c:	bf 92       	push	r11
    1c7e:	cf 92       	push	r12
    1c80:	df 92       	push	r13
    1c82:	ef 92       	push	r14
    1c84:	ff 92       	push	r15
    1c86:	0f 93       	push	r16
    1c88:	1f 93       	push	r17
    1c8a:	df 93       	push	r29
    1c8c:	cf 93       	push	r28
    1c8e:	00 d0       	rcall	.+0      	; 0x1c90 <udp_open_packet_extended+0x26>
    1c90:	00 d0       	rcall	.+0      	; 0x1c92 <udp_open_packet_extended+0x28>
    1c92:	00 d0       	rcall	.+0      	; 0x1c94 <udp_open_packet_extended+0x2a>
    1c94:	cd b7       	in	r28, 0x3d	; 61
    1c96:	de b7       	in	r29, 0x3e	; 62
    1c98:	2c 01       	movw	r4, r24
    1c9a:	f9 01       	movw	r30, r18
    1c9c:	18 01       	movw	r2, r16
    1c9e:	87 01       	movw	r16, r14
    1ca0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ca2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ca4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1ca6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    uint16_t udp_len_from_udp=0;
    uint16_t udp_checksum=0;
    uint16_t calculated_checksum=0;

    //copy version and priority
    if(version_out!=NULL)
    1ca8:	00 97       	sbiw	r24, 0x00	; 0
    1caa:	31 f0       	breq	.+12     	; 0x1cb8 <udp_open_packet_extended+0x4e>
        *version_out=packet_in[IPV6_VERSION_PRIORITY_OFFSET] & 0xF0;
    1cac:	d7 01       	movw	r26, r14
    1cae:	ec 90       	ld	r14, X
    1cb0:	b0 ef       	ldi	r27, 0xF0	; 240
    1cb2:	eb 22       	and	r14, r27
    1cb4:	dc 01       	movw	r26, r24
    1cb6:	ec 92       	st	X, r14

    if(priority_out!=NULL)
    1cb8:	21 15       	cp	r18, r1
    1cba:	31 05       	cpc	r19, r1
    1cbc:	29 f0       	breq	.+10     	; 0x1cc8 <udp_open_packet_extended+0x5e>
        *priority_out=packet_in[IPV6_VERSION_PRIORITY_OFFSET] & 0x0F;
    1cbe:	d8 01       	movw	r26, r16
    1cc0:	8c 91       	ld	r24, X
    1cc2:	8f 70       	andi	r24, 0x0F	; 15
    1cc4:	d9 01       	movw	r26, r18
    1cc6:	8c 93       	st	X, r24

    //copy flow label
    if(flow_label_out!=NULL)
    1cc8:	c1 14       	cp	r12, r1
    1cca:	d1 04       	cpc	r13, r1
    1ccc:	79 f0       	breq	.+30     	; 0x1cec <udp_open_packet_extended+0x82>
    	memcpy(flow_label_out, packet_in+IPV6_FLOW_LABEL_OFFSET, IPV6_FLOW_LABEL_LENGTH);
    1cce:	c8 01       	movw	r24, r16
    1cd0:	01 96       	adiw	r24, 0x01	; 1
    1cd2:	23 e0       	ldi	r18, 0x03	; 3
    1cd4:	7f 01       	movw	r14, r30
    1cd6:	d5 01       	movw	r26, r10
    1cd8:	fc 01       	movw	r30, r24
    1cda:	01 90       	ld	r0, Z+
    1cdc:	cf 01       	movw	r24, r30
    1cde:	f6 01       	movw	r30, r12
    1ce0:	01 92       	st	Z+, r0
    1ce2:	6f 01       	movw	r12, r30
    1ce4:	21 50       	subi	r18, 0x01	; 1
    1ce6:	c1 f7       	brne	.-16     	; 0x1cd8 <udp_open_packet_extended+0x6e>
    1ce8:	f7 01       	movw	r30, r14
    1cea:	5d 01       	movw	r10, r26

    udp_len_from_ip = (packet_in[IPV6_PAYLOAD_LENGTH_OFFSET] & 0x00FF);
    1cec:	d8 01       	movw	r26, r16
    1cee:	14 96       	adiw	r26, 0x04	; 4
    1cf0:	8c 91       	ld	r24, X
    1cf2:	14 97       	sbiw	r26, 0x04	; 4
    udp_len_from_ip = udp_len_from_ip<<8;
    1cf4:	78 2e       	mov	r7, r24
    1cf6:	66 24       	eor	r6, r6
    udp_len_from_ip |= (packet_in[IPV6_PAYLOAD_LENGTH_OFFSET+1] & 0x00FF);
    1cf8:	15 96       	adiw	r26, 0x05	; 5
    1cfa:	8c 91       	ld	r24, X
    1cfc:	15 97       	sbiw	r26, 0x05	; 5
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	68 2a       	or	r6, r24
    1d02:	79 2a       	or	r7, r25

    if(next_header_out!=NULL)
    1d04:	81 14       	cp	r8, r1
    1d06:	91 04       	cpc	r9, r1
    1d08:	21 f0       	breq	.+8      	; 0x1d12 <udp_open_packet_extended+0xa8>
    	memcpy(next_header_out, packet_in+IPV6_NEXT_HEADER_OFFSET, IPV6_NEXT_HEADER_LENGTH);
    1d0a:	16 96       	adiw	r26, 0x06	; 6
    1d0c:	8c 91       	ld	r24, X
    1d0e:	d4 01       	movw	r26, r8
    1d10:	8c 93       	st	X, r24

    if(hop_limit_out!=NULL)
    1d12:	a1 14       	cp	r10, r1
    1d14:	b1 04       	cpc	r11, r1
    1d16:	29 f0       	breq	.+10     	; 0x1d22 <udp_open_packet_extended+0xb8>
    	memcpy(hop_limit_out, packet_in+IPV6_HOP_LIMIT_OFFSET, IPV6_HOP_LIMIT_LENGTH);
    1d18:	d8 01       	movw	r26, r16
    1d1a:	17 96       	adiw	r26, 0x07	; 7
    1d1c:	8c 91       	ld	r24, X
    1d1e:	d5 01       	movw	r26, r10
    1d20:	8c 93       	st	X, r24

    //copy source address
    if(src_out!=NULL)
    1d22:	41 14       	cp	r4, r1
    1d24:	51 04       	cpc	r5, r1
    1d26:	59 f0       	breq	.+22     	; 0x1d3e <udp_open_packet_extended+0xd4>
    	memcpy(src_out, packet_in+IPV6_SOURCE_OFFSET, IPV6_SOURCE_LENGTH);
    1d28:	d8 01       	movw	r26, r16
    1d2a:	18 96       	adiw	r26, 0x08	; 8
    1d2c:	86 e0       	ldi	r24, 0x06	; 6
    1d2e:	9f 01       	movw	r18, r30
    1d30:	0d 90       	ld	r0, X+
    1d32:	f2 01       	movw	r30, r4
    1d34:	01 92       	st	Z+, r0
    1d36:	2f 01       	movw	r4, r30
    1d38:	81 50       	subi	r24, 0x01	; 1
    1d3a:	d1 f7       	brne	.-12     	; 0x1d30 <udp_open_packet_extended+0xc6>
    1d3c:	f9 01       	movw	r30, r18

    //copy destination address
    if(dst_out!=NULL)
    1d3e:	41 15       	cp	r20, r1
    1d40:	51 05       	cpc	r21, r1
    1d42:	59 f0       	breq	.+22     	; 0x1d5a <udp_open_packet_extended+0xf0>
    	memcpy(dst_out, packet_in+IPV6_DESTINATION_OFFSET, IPV6_DESTINATION_LENGTH);
    1d44:	d8 01       	movw	r26, r16
    1d46:	1e 96       	adiw	r26, 0x0e	; 14
    1d48:	86 e0       	ldi	r24, 0x06	; 6
    1d4a:	9f 01       	movw	r18, r30
    1d4c:	0d 90       	ld	r0, X+
    1d4e:	fa 01       	movw	r30, r20
    1d50:	01 92       	st	Z+, r0
    1d52:	af 01       	movw	r20, r30
    1d54:	81 50       	subi	r24, 0x01	; 1
    1d56:	d1 f7       	brne	.-12     	; 0x1d4c <udp_open_packet_extended+0xe2>
    1d58:	f9 01       	movw	r30, r18

    //copy source port
    if(src_port_out!=NULL)
    1d5a:	61 15       	cp	r22, r1
    1d5c:	71 05       	cpc	r23, r1
    1d5e:	a1 f0       	breq	.+40     	; 0x1d88 <udp_open_packet_extended+0x11e>
    {
        *src_port_out=packet_in[UDP_SOURCE_PORT_OFFSET] & 0xFF;
    1d60:	d8 01       	movw	r26, r16
    1d62:	54 96       	adiw	r26, 0x14	; 20
    1d64:	8c 91       	ld	r24, X
        *src_port_out<<=8;
    1d66:	8a 83       	std	Y+2, r24	; 0x02
    1d68:	19 82       	std	Y+1, r1	; 0x01
    1d6a:	29 81       	ldd	r18, Y+1	; 0x01
    1d6c:	3a 81       	ldd	r19, Y+2	; 0x02
    1d6e:	db 01       	movw	r26, r22
    1d70:	2d 93       	st	X+, r18
    1d72:	3c 93       	st	X, r19
        *src_port_out|=packet_in[UDP_SOURCE_PORT_OFFSET+1] & 0xFF;
    1d74:	d8 01       	movw	r26, r16
    1d76:	55 96       	adiw	r26, 0x15	; 21
    1d78:	8c 91       	ld	r24, X
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	82 2b       	or	r24, r18
    1d7e:	93 2b       	or	r25, r19
    1d80:	db 01       	movw	r26, r22
    1d82:	11 96       	adiw	r26, 0x01	; 1
    1d84:	9c 93       	st	X, r25
    1d86:	8e 93       	st	-X, r24
    }

    //copy destination port
    if(dst_port_out!=NULL)
    1d88:	30 97       	sbiw	r30, 0x00	; 0
    1d8a:	89 f0       	breq	.+34     	; 0x1dae <udp_open_packet_extended+0x144>
    {
        *dst_port_out=packet_in[UDP_DESTINATION_PORT_OFFSET] & 0xFF;
    1d8c:	d8 01       	movw	r26, r16
    1d8e:	56 96       	adiw	r26, 0x16	; 22
    1d90:	8c 91       	ld	r24, X
    1d92:	56 97       	sbiw	r26, 0x16	; 22
        *dst_port_out<<=8;
    1d94:	8c 83       	std	Y+4, r24	; 0x04
    1d96:	1b 82       	std	Y+3, r1	; 0x03
    1d98:	2b 81       	ldd	r18, Y+3	; 0x03
    1d9a:	3c 81       	ldd	r19, Y+4	; 0x04
    1d9c:	31 83       	std	Z+1, r19	; 0x01
    1d9e:	20 83       	st	Z, r18
        *dst_port_out|=packet_in[UDP_DESTINATION_PORT_OFFSET+1] & 0xFF;
    1da0:	57 96       	adiw	r26, 0x17	; 23
    1da2:	8c 91       	ld	r24, X
    1da4:	90 e0       	ldi	r25, 0x00	; 0
    1da6:	82 2b       	or	r24, r18
    1da8:	93 2b       	or	r25, r19
    1daa:	91 83       	std	Z+1, r25	; 0x01
    1dac:	80 83       	st	Z, r24
    }

    //copy and check udp length
    udp_len_from_udp = packet_in[UDP_LENGTH_OFFSET];
    udp_len_from_udp = udp_len_from_udp<<8;
    1dae:	d8 01       	movw	r26, r16
    1db0:	58 96       	adiw	r26, 0x18	; 24
    1db2:	3c 91       	ld	r19, X
    1db4:	58 97       	sbiw	r26, 0x18	; 24
    1db6:	20 e0       	ldi	r18, 0x00	; 0
    udp_len_from_udp |= packet_in[UDP_LENGTH_OFFSET+1] & 0xFF;
    1db8:	59 96       	adiw	r26, 0x19	; 25
    1dba:	8c 91       	ld	r24, X
    1dbc:	59 97       	sbiw	r26, 0x19	; 25
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	82 2b       	or	r24, r18
    1dc2:	93 2b       	or	r25, r19


    if(udp_len_from_ip != udp_len_from_udp)
    1dc4:	68 16       	cp	r6, r24
    1dc6:	79 06       	cpc	r7, r25
    1dc8:	29 f5       	brne	.+74     	; 0x1e14 <udp_open_packet_extended+0x1aa>
        return 0;
    else
        len = udp_len_from_udp;

    //copy checksum and check
    udp_checksum = (packet_in[UDP_CHECKSUM_OFFSET] & 0xFF);
    1dca:	5a 96       	adiw	r26, 0x1a	; 26
    1dcc:	8c 91       	ld	r24, X
    udp_checksum = udp_checksum<<8;
    1dce:	8e 83       	std	Y+6, r24	; 0x06
    1dd0:	1d 82       	std	Y+5, r1	; 0x05
    udp_checksum |= (packet_in[UDP_CHECKSUM_OFFSET+1] & 0xFF);

    calculated_checksum=udp_calculate_checksum(packet_in+IPV6_SOURCE_OFFSET, packet_in+IPV6_DESTINATION_OFFSET, packet_in+UDP_PAYLOAD_OFFSET, len);
    1dd2:	3c e1       	ldi	r19, 0x1C	; 28
    1dd4:	e3 2e       	mov	r14, r19
    1dd6:	f1 2c       	mov	r15, r1
    1dd8:	e0 0e       	add	r14, r16
    1dda:	f1 1e       	adc	r15, r17
    1ddc:	b8 01       	movw	r22, r16
    1dde:	62 5f       	subi	r22, 0xF2	; 242
    1de0:	7f 4f       	sbci	r23, 0xFF	; 255
    1de2:	c8 01       	movw	r24, r16
    1de4:	08 96       	adiw	r24, 0x08	; 8
    1de6:	a7 01       	movw	r20, r14
    1de8:	93 01       	movw	r18, r6
    1dea:	0e 94 b2 0c 	call	0x1964	; 0x1964 <udp_calculate_checksum>
        len = udp_len_from_udp;

    //copy checksum and check
    udp_checksum = (packet_in[UDP_CHECKSUM_OFFSET] & 0xFF);
    udp_checksum = udp_checksum<<8;
    udp_checksum |= (packet_in[UDP_CHECKSUM_OFFSET+1] & 0xFF);
    1dee:	f8 01       	movw	r30, r16
    1df0:	23 8d       	ldd	r18, Z+27	; 0x1b
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	4d 81       	ldd	r20, Y+5	; 0x05
    1df6:	5e 81       	ldd	r21, Y+6	; 0x06
    1df8:	24 2b       	or	r18, r20
    1dfa:	35 2b       	or	r19, r21

    calculated_checksum=udp_calculate_checksum(packet_in+IPV6_SOURCE_OFFSET, packet_in+IPV6_DESTINATION_OFFSET, packet_in+UDP_PAYLOAD_OFFSET, len);
    
    if(udp_checksum != calculated_checksum)
    1dfc:	28 17       	cp	r18, r24
    1dfe:	39 07       	cpc	r19, r25
    1e00:	49 f4       	brne	.+18     	; 0x1e14 <udp_open_packet_extended+0x1aa>
        return 0;
    //finally copy the payload itself
    if(payload_out != NULL)
    1e02:	21 14       	cp	r2, r1
    1e04:	31 04       	cpc	r3, r1
    1e06:	49 f0       	breq	.+18     	; 0x1e1a <udp_open_packet_extended+0x1b0>
        memcpy(payload_out, packet_in+UDP_PAYLOAD_OFFSET, len);
    1e08:	c1 01       	movw	r24, r2
    1e0a:	b7 01       	movw	r22, r14
    1e0c:	a3 01       	movw	r20, r6
    1e0e:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    1e12:	03 c0       	rjmp	.+6      	; 0x1e1a <udp_open_packet_extended+0x1b0>
    udp_checksum |= (packet_in[UDP_CHECKSUM_OFFSET+1] & 0xFF);

    calculated_checksum=udp_calculate_checksum(packet_in+IPV6_SOURCE_OFFSET, packet_in+IPV6_DESTINATION_OFFSET, packet_in+UDP_PAYLOAD_OFFSET, len);
    
    if(udp_checksum != calculated_checksum)
        return 0;
    1e14:	20 e0       	ldi	r18, 0x00	; 0
    1e16:	30 e0       	ldi	r19, 0x00	; 0
    1e18:	01 c0       	rjmp	.+2      	; 0x1e1c <udp_open_packet_extended+0x1b2>
    //finally copy the payload itself
    if(payload_out != NULL)
    1e1a:	93 01       	movw	r18, r6
        memcpy(payload_out, packet_in+UDP_PAYLOAD_OFFSET, len);

    return len;
}
    1e1c:	c9 01       	movw	r24, r18
    1e1e:	26 96       	adiw	r28, 0x06	; 6
    1e20:	0f b6       	in	r0, 0x3f	; 63
    1e22:	f8 94       	cli
    1e24:	de bf       	out	0x3e, r29	; 62
    1e26:	0f be       	out	0x3f, r0	; 63
    1e28:	cd bf       	out	0x3d, r28	; 61
    1e2a:	cf 91       	pop	r28
    1e2c:	df 91       	pop	r29
    1e2e:	1f 91       	pop	r17
    1e30:	0f 91       	pop	r16
    1e32:	ff 90       	pop	r15
    1e34:	ef 90       	pop	r14
    1e36:	df 90       	pop	r13
    1e38:	cf 90       	pop	r12
    1e3a:	bf 90       	pop	r11
    1e3c:	af 90       	pop	r10
    1e3e:	9f 90       	pop	r9
    1e40:	8f 90       	pop	r8
    1e42:	7f 90       	pop	r7
    1e44:	6f 90       	pop	r6
    1e46:	5f 90       	pop	r5
    1e48:	4f 90       	pop	r4
    1e4a:	3f 90       	pop	r3
    1e4c:	2f 90       	pop	r2
    1e4e:	08 95       	ret

00001e50 <udp_open_packet>:
uint16_t udp_open_packet(uint8_t* src_out, uint16_t* src_port_out,
                                    uint8_t* dst_out, uint16_t* dst_port_out,
                                    uint8_t* payload_out,
                                    uint8_t* packet_in
                            )
{
    1e50:	8f 92       	push	r8
    1e52:	9f 92       	push	r9
    1e54:	af 92       	push	r10
    1e56:	bf 92       	push	r11
    1e58:	cf 92       	push	r12
    1e5a:	df 92       	push	r13
    1e5c:	ef 92       	push	r14
    1e5e:	ff 92       	push	r15
    1e60:	0f 93       	push	r16
    1e62:	1f 93       	push	r17
    return udp_open_packet_extended(src_out, src_port_out, dst_out, dst_port_out, payload_out, packet_in, NULL, NULL, NULL, NULL, NULL);
    1e64:	00 d0       	rcall	.+0      	; 0x1e66 <udp_open_packet+0x16>
    1e66:	00 d0       	rcall	.+0      	; 0x1e68 <udp_open_packet+0x18>
    1e68:	ed b7       	in	r30, 0x3d	; 61
    1e6a:	fe b7       	in	r31, 0x3e	; 62
    1e6c:	12 82       	std	Z+2, r1	; 0x02
    1e6e:	11 82       	std	Z+1, r1	; 0x01
    1e70:	14 82       	std	Z+4, r1	; 0x04
    1e72:	13 82       	std	Z+3, r1	; 0x03
    1e74:	cc 24       	eor	r12, r12
    1e76:	dd 24       	eor	r13, r13
    1e78:	aa 24       	eor	r10, r10
    1e7a:	bb 24       	eor	r11, r11
    1e7c:	88 24       	eor	r8, r8
    1e7e:	99 24       	eor	r9, r9
    1e80:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <udp_open_packet_extended>
    1e84:	0f 90       	pop	r0
    1e86:	0f 90       	pop	r0
    1e88:	0f 90       	pop	r0
    1e8a:	0f 90       	pop	r0
}
    1e8c:	1f 91       	pop	r17
    1e8e:	0f 91       	pop	r16
    1e90:	ff 90       	pop	r15
    1e92:	ef 90       	pop	r14
    1e94:	df 90       	pop	r13
    1e96:	cf 90       	pop	r12
    1e98:	bf 90       	pop	r11
    1e9a:	af 90       	pop	r10
    1e9c:	9f 90       	pop	r9
    1e9e:	8f 90       	pop	r8
    1ea0:	08 95       	ret

00001ea2 <text_to_ip>:
#include "radiotftp.h"

uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
{
	uint8_t i;
	uint8_t point=0;
    1ea2:	fc 01       	movw	r30, r24
#include <stdlib.h>

#include "util.h"
#include "radiotftp.h"

uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
    1ea4:	9c 01       	movw	r18, r24
    1ea6:	26 0f       	add	r18, r22
    1ea8:	31 1d       	adc	r19, r1
{
	uint8_t i;
	uint8_t point=0;
	uint8_t sum=0;
    1eaa:	40 e0       	ldi	r20, 0x00	; 0
#include "radiotftp.h"

uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
{
	uint8_t i;
	uint8_t point=0;
    1eac:	60 e0       	ldi	r22, 0x00	; 0
	uint8_t sum=0;
	for(i=0; i<in_length; i++)
    1eae:	16 c0       	rjmp	.+44     	; 0x1edc <text_to_ip+0x3a>
	{
		if(in_and_out[i]=='.' || in_and_out[i]==':' || in_and_out[i]==0x00)
    1eb0:	51 91       	ld	r21, Z+
    1eb2:	5e 32       	cpi	r21, 0x2E	; 46
    1eb4:	21 f0       	breq	.+8      	; 0x1ebe <text_to_ip+0x1c>
    1eb6:	5a 33       	cpi	r21, 0x3A	; 58
    1eb8:	11 f0       	breq	.+4      	; 0x1ebe <text_to_ip+0x1c>
    1eba:	55 23       	and	r21, r21
    1ebc:	39 f4       	brne	.+14     	; 0x1ecc <text_to_ip+0x2a>
		{
			in_and_out[point++]=sum;
    1ebe:	dc 01       	movw	r26, r24
    1ec0:	a6 0f       	add	r26, r22
    1ec2:	b1 1d       	adc	r27, r1
    1ec4:	4c 93       	st	X, r20
    1ec6:	6f 5f       	subi	r22, 0xFF	; 255
			sum=0;
    1ec8:	40 e0       	ldi	r20, 0x00	; 0
    1eca:	08 c0       	rjmp	.+16     	; 0x1edc <text_to_ip+0x3a>
//			printf("\n");
		}
		else
		{
			sum = (sum*10) + (in_and_out[i]-'0');
    1ecc:	44 0f       	add	r20, r20
    1ece:	74 2f       	mov	r23, r20
    1ed0:	77 0f       	add	r23, r23
    1ed2:	77 0f       	add	r23, r23
    1ed4:	74 0f       	add	r23, r20
    1ed6:	45 2f       	mov	r20, r21
    1ed8:	40 53       	subi	r20, 0x30	; 48
    1eda:	47 0f       	add	r20, r23
uint8_t text_to_ip(uint8_t* in_and_out, uint8_t in_length)
{
	uint8_t i;
	uint8_t point=0;
	uint8_t sum=0;
	for(i=0; i<in_length; i++)
    1edc:	e2 17       	cp	r30, r18
    1ede:	f3 07       	cpc	r31, r19
    1ee0:	39 f7       	brne	.-50     	; 0x1eb0 <text_to_ip+0xe>
			sum = (sum*10) + (in_and_out[i]-'0');
//			printf("sum=%d ", sum);
		}
	}
	return 0;
}
    1ee2:	80 e0       	ldi	r24, 0x00	; 0
    1ee4:	08 95       	ret

00001ee6 <readnline>:
uint8_t readnline(FILE* fptr, uint8_t* out, uint8_t length)
{
    1ee6:	ef 92       	push	r14
    1ee8:	ff 92       	push	r15
    1eea:	0f 93       	push	r16
    1eec:	1f 93       	push	r17
    1eee:	cf 93       	push	r28
    1ef0:	df 93       	push	r29
    1ef2:	7c 01       	movw	r14, r24
    1ef4:	eb 01       	movw	r28, r22
    1ef6:	04 2f       	mov	r16, r20
	uint8_t previ=0, i=0;
    1ef8:	10 e0       	ldi	r17, 0x00	; 0
    1efa:	01 c0       	rjmp	.+2      	; 0x1efe <readnline+0x18>
	do
	{
		previ=i;
		i+=fread(out+i, 1, 1, fptr);
	} while(out[i-1]!='\n' && i<length && previ!=i);
    1efc:	18 2f       	mov	r17, r24
{
	uint8_t previ=0, i=0;
	do
	{
		previ=i;
		i+=fread(out+i, 1, 1, fptr);
    1efe:	ce 01       	movw	r24, r28
    1f00:	81 0f       	add	r24, r17
    1f02:	91 1d       	adc	r25, r1
    1f04:	61 e0       	ldi	r22, 0x01	; 1
    1f06:	70 e0       	ldi	r23, 0x00	; 0
    1f08:	41 e0       	ldi	r20, 0x01	; 1
    1f0a:	50 e0       	ldi	r21, 0x00	; 0
    1f0c:	97 01       	movw	r18, r14
    1f0e:	0e 94 a3 4b 	call	0x9746	; 0x9746 <fread>
    1f12:	81 0f       	add	r24, r17
	} while(out[i-1]!='\n' && i<length && previ!=i);
    1f14:	e8 2f       	mov	r30, r24
    1f16:	f0 e0       	ldi	r31, 0x00	; 0
    1f18:	31 97       	sbiw	r30, 0x01	; 1
    1f1a:	ec 0f       	add	r30, r28
    1f1c:	fd 1f       	adc	r31, r29
    1f1e:	90 81       	ld	r25, Z
    1f20:	9a 30       	cpi	r25, 0x0A	; 10
    1f22:	21 f0       	breq	.+8      	; 0x1f2c <readnline+0x46>
    1f24:	80 17       	cp	r24, r16
    1f26:	10 f4       	brcc	.+4      	; 0x1f2c <readnline+0x46>
    1f28:	18 17       	cp	r17, r24
    1f2a:	41 f7       	brne	.-48     	; 0x1efc <readnline+0x16>
	out[i-1]=0;
    1f2c:	10 82       	st	Z, r1
	return 0;
}
    1f2e:	80 e0       	ldi	r24, 0x00	; 0
    1f30:	df 91       	pop	r29
    1f32:	cf 91       	pop	r28
    1f34:	1f 91       	pop	r17
    1f36:	0f 91       	pop	r16
    1f38:	ff 90       	pop	r15
    1f3a:	ef 90       	pop	r14
    1f3c:	08 95       	ret

00001f3e <print_callsign>:
void print_callsign(uint8_t* callsign)
{
    1f3e:	ef 92       	push	r14
    1f40:	ff 92       	push	r15
    1f42:	0f 93       	push	r16
    1f44:	1f 93       	push	r17
    1f46:	df 93       	push	r29
    1f48:	cf 93       	push	r28
    1f4a:	0f 92       	push	r0
    1f4c:	cd b7       	in	r28, 0x3d	; 61
    1f4e:	de b7       	in	r29, 0x3e	; 62
    1f50:	8c 01       	movw	r16, r24
	uint8_t i;
	for(i=0; i<6; i++)
    1f52:	7c 01       	movw	r14, r24
    1f54:	20 e0       	ldi	r18, 0x00	; 0
	{
		if(callsign[i]>=32 && callsign[i]<=125 )
    1f56:	d7 01       	movw	r26, r14
    1f58:	8d 91       	ld	r24, X+
    1f5a:	7d 01       	movw	r14, r26
    1f5c:	98 2f       	mov	r25, r24
    1f5e:	90 52       	subi	r25, 0x20	; 32
    1f60:	9e 35       	cpi	r25, 0x5E	; 94
    1f62:	48 f4       	brcc	.+18     	; 0x1f76 <print_callsign+0x38>
			putchar(callsign[i]);
    1f64:	60 91 c6 36 	lds	r22, 0x36C6
    1f68:	70 91 c7 36 	lds	r23, 0x36C7
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	29 83       	std	Y+1, r18	; 0x01
    1f70:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    1f74:	29 81       	ldd	r18, Y+1	; 0x01
	return 0;
}
void print_callsign(uint8_t* callsign)
{
	uint8_t i;
	for(i=0; i<6; i++)
    1f76:	2f 5f       	subi	r18, 0xFF	; 255
    1f78:	26 30       	cpi	r18, 0x06	; 6
    1f7a:	69 f7       	brne	.-38     	; 0x1f56 <print_callsign+0x18>
	{
		if(callsign[i]>=32 && callsign[i]<=125 )
			putchar(callsign[i]);
	}
	printf("%d", callsign[6]);
    1f7c:	00 d0       	rcall	.+0      	; 0x1f7e <print_callsign+0x40>
    1f7e:	00 d0       	rcall	.+0      	; 0x1f80 <print_callsign+0x42>
    1f80:	ed b7       	in	r30, 0x3d	; 61
    1f82:	fe b7       	in	r31, 0x3e	; 62
    1f84:	31 96       	adiw	r30, 0x01	; 1
    1f86:	8e e7       	ldi	r24, 0x7E	; 126
    1f88:	9b e0       	ldi	r25, 0x0B	; 11
    1f8a:	ad b7       	in	r26, 0x3d	; 61
    1f8c:	be b7       	in	r27, 0x3e	; 62
    1f8e:	12 96       	adiw	r26, 0x02	; 2
    1f90:	9c 93       	st	X, r25
    1f92:	8e 93       	st	-X, r24
    1f94:	11 97       	sbiw	r26, 0x01	; 1
    1f96:	d8 01       	movw	r26, r16
    1f98:	16 96       	adiw	r26, 0x06	; 6
    1f9a:	8c 91       	ld	r24, X
    1f9c:	82 83       	std	Z+2, r24	; 0x02
    1f9e:	13 82       	std	Z+3, r1	; 0x03
    1fa0:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
	putchar('\n');
    1fa4:	0f 90       	pop	r0
    1fa6:	0f 90       	pop	r0
    1fa8:	0f 90       	pop	r0
    1faa:	0f 90       	pop	r0
    1fac:	60 91 c6 36 	lds	r22, 0x36C6
    1fb0:	70 91 c7 36 	lds	r23, 0x36C7
    1fb4:	8a e0       	ldi	r24, 0x0A	; 10
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
}
    1fbc:	0f 90       	pop	r0
    1fbe:	cf 91       	pop	r28
    1fc0:	df 91       	pop	r29
    1fc2:	1f 91       	pop	r17
    1fc4:	0f 91       	pop	r16
    1fc6:	ff 90       	pop	r15
    1fc8:	ef 90       	pop	r14
    1fca:	08 95       	ret

00001fcc <print_addr_hex>:
void print_addr_hex(uint8_t* addr)
{
    1fcc:	cf 93       	push	r28
    1fce:	df 93       	push	r29
    1fd0:	dc 01       	movw	r26, r24
	printf("%x:%x:%x:%x:%x:%x\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
    1fd2:	8d b7       	in	r24, 0x3d	; 61
    1fd4:	9e b7       	in	r25, 0x3e	; 62
    1fd6:	0e 97       	sbiw	r24, 0x0e	; 14
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	9e bf       	out	0x3e, r25	; 62
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	8d bf       	out	0x3d, r24	; 61
    1fe2:	ed b7       	in	r30, 0x3d	; 61
    1fe4:	fe b7       	in	r31, 0x3e	; 62
    1fe6:	31 96       	adiw	r30, 0x01	; 1
    1fe8:	81 e8       	ldi	r24, 0x81	; 129
    1fea:	9b e0       	ldi	r25, 0x0B	; 11
    1fec:	cd b7       	in	r28, 0x3d	; 61
    1fee:	de b7       	in	r29, 0x3e	; 62
    1ff0:	9a 83       	std	Y+2, r25	; 0x02
    1ff2:	89 83       	std	Y+1, r24	; 0x01
    1ff4:	8c 91       	ld	r24, X
    1ff6:	82 83       	std	Z+2, r24	; 0x02
    1ff8:	13 82       	std	Z+3, r1	; 0x03
    1ffa:	11 96       	adiw	r26, 0x01	; 1
    1ffc:	8c 91       	ld	r24, X
    1ffe:	11 97       	sbiw	r26, 0x01	; 1
    2000:	84 83       	std	Z+4, r24	; 0x04
    2002:	15 82       	std	Z+5, r1	; 0x05
    2004:	12 96       	adiw	r26, 0x02	; 2
    2006:	8c 91       	ld	r24, X
    2008:	12 97       	sbiw	r26, 0x02	; 2
    200a:	86 83       	std	Z+6, r24	; 0x06
    200c:	17 82       	std	Z+7, r1	; 0x07
    200e:	13 96       	adiw	r26, 0x03	; 3
    2010:	8c 91       	ld	r24, X
    2012:	13 97       	sbiw	r26, 0x03	; 3
    2014:	80 87       	std	Z+8, r24	; 0x08
    2016:	11 86       	std	Z+9, r1	; 0x09
    2018:	14 96       	adiw	r26, 0x04	; 4
    201a:	8c 91       	ld	r24, X
    201c:	14 97       	sbiw	r26, 0x04	; 4
    201e:	82 87       	std	Z+10, r24	; 0x0a
    2020:	13 86       	std	Z+11, r1	; 0x0b
    2022:	15 96       	adiw	r26, 0x05	; 5
    2024:	8c 91       	ld	r24, X
    2026:	84 87       	std	Z+12, r24	; 0x0c
    2028:	15 86       	std	Z+13, r1	; 0x0d
    202a:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    202e:	8d b7       	in	r24, 0x3d	; 61
    2030:	9e b7       	in	r25, 0x3e	; 62
    2032:	0e 96       	adiw	r24, 0x0e	; 14
    2034:	0f b6       	in	r0, 0x3f	; 63
    2036:	f8 94       	cli
    2038:	9e bf       	out	0x3e, r25	; 62
    203a:	0f be       	out	0x3f, r0	; 63
    203c:	8d bf       	out	0x3d, r24	; 61
}
    203e:	df 91       	pop	r29
    2040:	cf 91       	pop	r28
    2042:	08 95       	ret

00002044 <print_addr_dec>:
void print_addr_dec(uint8_t* addr)
{
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	dc 01       	movw	r26, r24
	printf("%d.%d.%d.%d.%d.%d\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
    204a:	8d b7       	in	r24, 0x3d	; 61
    204c:	9e b7       	in	r25, 0x3e	; 62
    204e:	0e 97       	sbiw	r24, 0x0e	; 14
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	9e bf       	out	0x3e, r25	; 62
    2056:	0f be       	out	0x3f, r0	; 63
    2058:	8d bf       	out	0x3d, r24	; 61
    205a:	ed b7       	in	r30, 0x3d	; 61
    205c:	fe b7       	in	r31, 0x3e	; 62
    205e:	31 96       	adiw	r30, 0x01	; 1
    2060:	84 e9       	ldi	r24, 0x94	; 148
    2062:	9b e0       	ldi	r25, 0x0B	; 11
    2064:	cd b7       	in	r28, 0x3d	; 61
    2066:	de b7       	in	r29, 0x3e	; 62
    2068:	9a 83       	std	Y+2, r25	; 0x02
    206a:	89 83       	std	Y+1, r24	; 0x01
    206c:	8c 91       	ld	r24, X
    206e:	82 83       	std	Z+2, r24	; 0x02
    2070:	13 82       	std	Z+3, r1	; 0x03
    2072:	11 96       	adiw	r26, 0x01	; 1
    2074:	8c 91       	ld	r24, X
    2076:	11 97       	sbiw	r26, 0x01	; 1
    2078:	84 83       	std	Z+4, r24	; 0x04
    207a:	15 82       	std	Z+5, r1	; 0x05
    207c:	12 96       	adiw	r26, 0x02	; 2
    207e:	8c 91       	ld	r24, X
    2080:	12 97       	sbiw	r26, 0x02	; 2
    2082:	86 83       	std	Z+6, r24	; 0x06
    2084:	17 82       	std	Z+7, r1	; 0x07
    2086:	13 96       	adiw	r26, 0x03	; 3
    2088:	8c 91       	ld	r24, X
    208a:	13 97       	sbiw	r26, 0x03	; 3
    208c:	80 87       	std	Z+8, r24	; 0x08
    208e:	11 86       	std	Z+9, r1	; 0x09
    2090:	14 96       	adiw	r26, 0x04	; 4
    2092:	8c 91       	ld	r24, X
    2094:	14 97       	sbiw	r26, 0x04	; 4
    2096:	82 87       	std	Z+10, r24	; 0x0a
    2098:	13 86       	std	Z+11, r1	; 0x0b
    209a:	15 96       	adiw	r26, 0x05	; 5
    209c:	8c 91       	ld	r24, X
    209e:	84 87       	std	Z+12, r24	; 0x0c
    20a0:	15 86       	std	Z+13, r1	; 0x0d
    20a2:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    20a6:	8d b7       	in	r24, 0x3d	; 61
    20a8:	9e b7       	in	r25, 0x3e	; 62
    20aa:	0e 96       	adiw	r24, 0x0e	; 14
    20ac:	0f b6       	in	r0, 0x3f	; 63
    20ae:	f8 94       	cli
    20b0:	9e bf       	out	0x3e, r25	; 62
    20b2:	0f be       	out	0x3f, r0	; 63
    20b4:	8d bf       	out	0x3d, r24	; 61
}
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	08 95       	ret

000020bc <printAsciiHex>:

#include <stdio.h>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
{
    20bc:	2f 92       	push	r2
    20be:	3f 92       	push	r3
    20c0:	4f 92       	push	r4
    20c2:	5f 92       	push	r5
    20c4:	6f 92       	push	r6
    20c6:	7f 92       	push	r7
    20c8:	8f 92       	push	r8
    20ca:	9f 92       	push	r9
    20cc:	af 92       	push	r10
    20ce:	bf 92       	push	r11
    20d0:	cf 92       	push	r12
    20d2:	df 92       	push	r13
    20d4:	ef 92       	push	r14
    20d6:	ff 92       	push	r15
    20d8:	0f 93       	push	r16
    20da:	1f 93       	push	r17
    20dc:	cf 93       	push	r28
    20de:	df 93       	push	r29
    20e0:	38 2f       	mov	r19, r24
    20e2:	29 2f       	mov	r18, r25
    20e4:	6b 01       	movw	r12, r22
			putchar('\n');
		}
		else if(i==nread)
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
    20e6:	cb 01       	movw	r24, r22
    20e8:	60 e1       	ldi	r22, 0x10	; 16
    20ea:	70 e0       	ldi	r23, 0x00	; 0
    20ec:	0e 94 77 4a 	call	0x94ee	; 0x94ee <__divmodhi4>
    20f0:	5c 01       	movw	r10, r24
    20f2:	aa 0c       	add	r10, r10
    20f4:	bb 1c       	adc	r11, r11
    20f6:	a8 0e       	add	r10, r24
    20f8:	b9 1e       	adc	r11, r25
    20fa:	b0 94       	com	r11
    20fc:	a1 94       	neg	r10
    20fe:	b1 08       	sbc	r11, r1
    2100:	b3 94       	inc	r11
    2102:	8f e2       	ldi	r24, 0x2F	; 47
    2104:	90 e0       	ldi	r25, 0x00	; 0
    2106:	a8 0e       	add	r10, r24
    2108:	b9 1e       	adc	r11, r25
				putchar(' ');
			putchar('\t');
			for(j=(nread/COLUMN_SIZE)*COLUMN_SIZE; j<nread; j++)
    210a:	3b 01       	movw	r6, r22
    210c:	44 e0       	ldi	r20, 0x04	; 4
    210e:	66 0c       	add	r6, r6
    2110:	77 1c       	adc	r7, r7
    2112:	4a 95       	dec	r20
    2114:	e1 f7       	brne	.-8      	; 0x210e <printAsciiHex+0x52>
    2116:	e3 2e       	mov	r14, r19
    2118:	f2 2e       	mov	r15, r18
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
{
	int i,j;
	for(i = 1; i <= nread; i++)
    211a:	c1 e0       	ldi	r28, 0x01	; 1
    211c:	d0 e0       	ldi	r29, 0x00	; 0
	{
		printf("%02x", buffer[i - 1] & (0xFF));
    211e:	97 ea       	ldi	r25, 0xA7	; 167
    2120:	49 2e       	mov	r4, r25
    2122:	9b e0       	ldi	r25, 0x0B	; 11
    2124:	59 2e       	mov	r5, r25

#include <stdio.h>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
    2126:	17 01       	movw	r2, r14
    2128:	26 0c       	add	r2, r6
    212a:	37 1c       	adc	r3, r7
{
	int i,j;
	for(i = 1; i <= nread; i++)
    212c:	82 c0       	rjmp	.+260    	; 0x2232 <printAsciiHex+0x176>
	{
		printf("%02x", buffer[i - 1] & (0xFF));
    212e:	f7 01       	movw	r30, r14
    2130:	81 91       	ld	r24, Z+
    2132:	7f 01       	movw	r14, r30
    2134:	00 d0       	rcall	.+0      	; 0x2136 <printAsciiHex+0x7a>
    2136:	00 d0       	rcall	.+0      	; 0x2138 <printAsciiHex+0x7c>
    2138:	ed b7       	in	r30, 0x3d	; 61
    213a:	fe b7       	in	r31, 0x3e	; 62
    213c:	52 82       	std	Z+2, r5	; 0x02
    213e:	41 82       	std	Z+1, r4	; 0x01
    2140:	83 83       	std	Z+3, r24	; 0x03
    2142:	14 82       	std	Z+4, r1	; 0x04
    2144:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		if(i%2==0 && i!=0)
    2148:	0f 90       	pop	r0
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	c0 fd       	sbrc	r28, 0
    2152:	04 c0       	rjmp	.+8      	; 0x215c <printAsciiHex+0xa0>
			printf(" ");
    2154:	80 e2       	ldi	r24, 0x20	; 32
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	0e 94 13 4c 	call	0x9826	; 0x9826 <putchar>
		if(i%COLUMN_SIZE == 0)
    215c:	ce 01       	movw	r24, r28
    215e:	8f 70       	andi	r24, 0x0F	; 15
    2160:	90 70       	andi	r25, 0x00	; 0
    2162:	00 97       	sbiw	r24, 0x00	; 0
    2164:	41 f5       	brne	.+80     	; 0x21b6 <printAsciiHex+0xfa>
		{
			putchar('\t');
    2166:	60 91 c6 36 	lds	r22, 0x36C6
    216a:	70 91 c7 36 	lds	r23, 0x36C7
    216e:	89 e0       	ldi	r24, 0x09	; 9
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    2176:	80 ef       	ldi	r24, 0xF0	; 240
    2178:	88 2e       	mov	r8, r24
    217a:	8f ef       	ldi	r24, 0xFF	; 255
    217c:	98 2e       	mov	r9, r24
    217e:	8e 0c       	add	r8, r14
    2180:	9f 1c       	adc	r9, r15
			for(j=i-COLUMN_SIZE; j<i; j++)
    2182:	01 e1       	ldi	r16, 0x11	; 17
    2184:	10 e0       	ldi	r17, 0x00	; 0
    2186:	13 c0       	rjmp	.+38     	; 0x21ae <printAsciiHex+0xf2>
			{
				if(buffer[j] >= 32 && buffer[j] <= 126)
    2188:	f4 01       	movw	r30, r8
    218a:	81 91       	ld	r24, Z+
    218c:	4f 01       	movw	r8, r30
    218e:	98 2f       	mov	r25, r24
    2190:	90 52       	subi	r25, 0x20	; 32
    2192:	60 91 c6 36 	lds	r22, 0x36C6
    2196:	70 91 c7 36 	lds	r23, 0x36C7
    219a:	9f 35       	cpi	r25, 0x5F	; 95
    219c:	20 f4       	brcc	.+8      	; 0x21a6 <printAsciiHex+0xea>
					putchar(buffer[j]);
    219e:	99 27       	eor	r25, r25
    21a0:	87 fd       	sbrc	r24, 7
    21a2:	90 95       	com	r25
    21a4:	02 c0       	rjmp	.+4      	; 0x21aa <printAsciiHex+0xee>
				else
					putchar('.');
    21a6:	8e e2       	ldi	r24, 0x2E	; 46
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    21ae:	01 50       	subi	r16, 0x01	; 1
    21b0:	10 40       	sbci	r17, 0x00	; 0
		if(i%2==0 && i!=0)
			printf(" ");
		if(i%COLUMN_SIZE == 0)
		{
			putchar('\t');
			for(j=i-COLUMN_SIZE; j<i; j++)
    21b2:	51 f7       	brne	.-44     	; 0x2188 <printAsciiHex+0xcc>
    21b4:	35 c0       	rjmp	.+106    	; 0x2220 <printAsciiHex+0x164>
				else
					putchar('.');
			}
			putchar('\n');
		}
		else if(i==nread)
    21b6:	cc 15       	cp	r28, r12
    21b8:	dd 05       	cpc	r29, r13
    21ba:	d1 f5       	brne	.+116    	; 0x2230 <printAsciiHex+0x174>
    21bc:	00 e0       	ldi	r16, 0x00	; 0
    21be:	10 e0       	ldi	r17, 0x00	; 0
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
				putchar(' ');
    21c0:	60 91 c6 36 	lds	r22, 0x36C6
    21c4:	70 91 c7 36 	lds	r23, 0x36C7
    21c8:	80 e2       	ldi	r24, 0x20	; 32
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
			putchar('\n');
		}
		else if(i==nread)
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
    21d0:	0f 5f       	subi	r16, 0xFF	; 255
    21d2:	1f 4f       	sbci	r17, 0xFF	; 255
    21d4:	a0 16       	cp	r10, r16
    21d6:	b1 06       	cpc	r11, r17
    21d8:	9c f7       	brge	.-26     	; 0x21c0 <printAsciiHex+0x104>
				putchar(' ');
			putchar('\t');
    21da:	60 91 c6 36 	lds	r22, 0x36C6
    21de:	70 91 c7 36 	lds	r23, 0x36C7
    21e2:	89 e0       	ldi	r24, 0x09	; 9
    21e4:	90 e0       	ldi	r25, 0x00	; 0
    21e6:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>

#include <stdio.h>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
    21ea:	41 01       	movw	r8, r2
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
				putchar(' ');
			putchar('\t');
			for(j=(nread/COLUMN_SIZE)*COLUMN_SIZE; j<nread; j++)
    21ec:	83 01       	movw	r16, r6
    21ee:	15 c0       	rjmp	.+42     	; 0x221a <printAsciiHex+0x15e>
			{
				if(buffer[j] >= 32 && buffer[j] <= 126)
    21f0:	f4 01       	movw	r30, r8
    21f2:	81 91       	ld	r24, Z+
    21f4:	4f 01       	movw	r8, r30
    21f6:	98 2f       	mov	r25, r24
    21f8:	90 52       	subi	r25, 0x20	; 32
    21fa:	60 91 c6 36 	lds	r22, 0x36C6
    21fe:	70 91 c7 36 	lds	r23, 0x36C7
    2202:	9f 35       	cpi	r25, 0x5F	; 95
    2204:	20 f4       	brcc	.+8      	; 0x220e <printAsciiHex+0x152>
					putchar(buffer[j]);
    2206:	99 27       	eor	r25, r25
    2208:	87 fd       	sbrc	r24, 7
    220a:	90 95       	com	r25
    220c:	02 c0       	rjmp	.+4      	; 0x2212 <printAsciiHex+0x156>
				else
					putchar('.');
    220e:	8e e2       	ldi	r24, 0x2E	; 46
    2210:	90 e0       	ldi	r25, 0x00	; 0
    2212:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
		{

			for(j=0; j<(COLUMN_SIZE-(nread%COLUMN_SIZE))*3; j++)
				putchar(' ');
			putchar('\t');
			for(j=(nread/COLUMN_SIZE)*COLUMN_SIZE; j<nread; j++)
    2216:	0f 5f       	subi	r16, 0xFF	; 255
    2218:	1f 4f       	sbci	r17, 0xFF	; 255
    221a:	0c 15       	cp	r16, r12
    221c:	1d 05       	cpc	r17, r13
    221e:	44 f3       	brlt	.-48     	; 0x21f0 <printAsciiHex+0x134>
				if(buffer[j] >= 32 && buffer[j] <= 126)
					putchar(buffer[j]);
				else
					putchar('.');
			}
			putchar('\n');
    2220:	60 91 c6 36 	lds	r22, 0x36C6
    2224:	70 91 c7 36 	lds	r23, 0x36C7
    2228:	8a e0       	ldi	r24, 0x0A	; 10
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
#include "printAsciiHex.h"

void printAsciiHex(char* buffer, int nread)
{
	int i,j;
	for(i = 1; i <= nread; i++)
    2230:	21 96       	adiw	r28, 0x01	; 1
    2232:	cc 16       	cp	r12, r28
    2234:	dd 06       	cpc	r13, r29
    2236:	0c f0       	brlt	.+2      	; 0x223a <printAsciiHex+0x17e>
    2238:	7a cf       	rjmp	.-268    	; 0x212e <printAsciiHex+0x72>
					putchar('.');
			}
			putchar('\n');
		}
	}
	putchar('\n');
    223a:	60 91 c6 36 	lds	r22, 0x36C6
    223e:	70 91 c7 36 	lds	r23, 0x36C7
    2242:	8a e0       	ldi	r24, 0x0A	; 10
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
}
    224a:	df 91       	pop	r29
    224c:	cf 91       	pop	r28
    224e:	1f 91       	pop	r17
    2250:	0f 91       	pop	r16
    2252:	ff 90       	pop	r15
    2254:	ef 90       	pop	r14
    2256:	df 90       	pop	r13
    2258:	cf 90       	pop	r12
    225a:	bf 90       	pop	r11
    225c:	af 90       	pop	r10
    225e:	9f 90       	pop	r9
    2260:	8f 90       	pop	r8
    2262:	7f 90       	pop	r7
    2264:	6f 90       	pop	r6
    2266:	5f 90       	pop	r5
    2268:	4f 90       	pop	r4
    226a:	3f 90       	pop	r3
    226c:	2f 90       	pop	r2
    226e:	08 95       	ret

00002270 <uart0_rx>:
	timer_flag = 1;
	process_post(&radiotftp_process, PROCESS_EVENT_TIMER, NULL);
}

int uart0_rx(unsigned char receivedByte)
{
    2270:	68 2f       	mov	r22, r24
	//stdin
	rs232_send(RS232_PORT_0, receivedByte);
    2272:	80 e0       	ldi	r24, 0x00	; 0
    2274:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>
	return 0;
}
    2278:	80 e0       	ldi	r24, 0x00	; 0
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	08 95       	ret

0000227e <queueSerialData>:
{
	return numBytesToSend;
}

uint8_t queueSerialData(uint8_t* src, uint16_t src_port, uint8_t* dst, uint16_t dst_port, uint8_t* dataptr, uint16_t datalen)
{
    227e:	cf 92       	push	r12
    2280:	df 92       	push	r13
    2282:	ef 92       	push	r14
    2284:	ff 92       	push	r15
    2286:	0f 93       	push	r16
    2288:	1f 93       	push	r17
    228a:	cf 93       	push	r28
    228c:	df 93       	push	r29
    228e:	f8 01       	movw	r30, r16
    2290:	67 01       	movw	r12, r14
	uint16_t idx = 0, len = 0;

	wdt_reset();
    2292:	a8 95       	wdr
	if(queue_flag)
    2294:	a0 91 93 13 	lds	r26, 0x1393
    2298:	aa 23       	and	r26, r26
    229a:	09 f0       	breq	.+2      	; 0x229e <queueSerialData+0x20>
    229c:	6b c0       	rjmp	.+214    	; 0x2374 <queueSerialData+0xf6>
	{
		return -1;
	}

	memcpy(transmit_buffer, preamble, PREAMBLE_LENGTH);
    229e:	cc ec       	ldi	r28, 0xCC	; 204
    22a0:	d0 e2       	ldi	r29, 0x20	; 32
    22a2:	a0 e3       	ldi	r26, 0x30	; 48
    22a4:	bd e0       	ldi	r27, 0x0D	; 13
    22a6:	0a e0       	ldi	r16, 0x0A	; 10
    22a8:	0d 90       	ld	r0, X+
    22aa:	09 92       	st	Y+, r0
    22ac:	01 50       	subi	r16, 0x01	; 1
    22ae:	e1 f7       	brne	.-8      	; 0x22a8 <queueSerialData+0x2a>
	idx += PREAMBLE_LENGTH;

	memcpy(transmit_buffer+idx, syncword, SYNC_LENGTH);
    22b0:	e0 90 3a 0d 	lds	r14, 0x0D3A
    22b4:	f0 90 3b 0d 	lds	r15, 0x0D3B
    22b8:	00 91 3c 0d 	lds	r16, 0x0D3C
    22bc:	10 91 3d 0d 	lds	r17, 0x0D3D
    22c0:	e0 92 d6 20 	sts	0x20D6, r14
    22c4:	f0 92 d7 20 	sts	0x20D7, r15
    22c8:	00 93 d8 20 	sts	0x20D8, r16
    22cc:	10 93 d9 20 	sts	0x20D9, r17
	idx += SYNC_LENGTH;

	//PRINTF_D("udp payload: %s\n", dataptr);
	len = udp_create_packet(src, src_port, dst, dst_port, dataptr, datalen, udp_buffer);
    22d0:	8f 01       	movw	r16, r30
    22d2:	76 01       	movw	r14, r12
    22d4:	e4 eb       	ldi	r30, 0xB4	; 180
    22d6:	ce 2e       	mov	r12, r30
    22d8:	ee e1       	ldi	r30, 0x1E	; 30
    22da:	de 2e       	mov	r13, r30
    22dc:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <udp_create_packet>
    22e0:	ec 01       	movw	r28, r24
	if(len==0)
    22e2:	00 97       	sbiw	r24, 0x00	; 0
    22e4:	31 f4       	brne	.+12     	; 0x22f2 <queueSerialData+0x74>
	{
		PRINTF_D("couldn't prepare udp packet\n");
    22e6:	8c ea       	ldi	r24, 0xAC	; 172
    22e8:	9b e0       	ldi	r25, 0x0B	; 11
    22ea:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
		return -2;
    22ee:	8e ef       	ldi	r24, 0xFE	; 254
    22f0:	42 c0       	rjmp	.+132    	; 0x2376 <queueSerialData+0xf8>
		return -3;
	}
	len = manchester_encode(ethernet_buffer, manchester_buffer, len);
#elif AX25_ENABLED==1
	//PRINTF_D("ax25 payload: %s\n", udp_buffer);
	len = ax25_create_ui_packet(ax25_get_local_callsign(NULL), ax25_get_broadcast_callsign(NULL), udp_buffer, len, ax25_buffer);
    22f2:	80 e0       	ldi	r24, 0x00	; 0
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	0e 94 84 03 	call	0x708	; 0x708 <ax25_get_local_callsign>
    22fa:	8c 01       	movw	r16, r24
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	0e 94 92 03 	call	0x724	; 0x724 <ax25_get_broadcast_callsign>
    2304:	bc 01       	movw	r22, r24
    2306:	c8 01       	movw	r24, r16
    2308:	44 eb       	ldi	r20, 0xB4	; 180
    230a:	5e e1       	ldi	r21, 0x1E	; 30
    230c:	9e 01       	movw	r18, r28
    230e:	02 e7       	ldi	r16, 0x72	; 114
    2310:	1c e1       	ldi	r17, 0x1C	; 28
    2312:	0e 94 a0 03 	call	0x740	; 0x740 <ax25_create_ui_packet>
    2316:	9b 01       	movw	r18, r22
    2318:	ac 01       	movw	r20, r24
	if(len==0)
    231a:	61 15       	cp	r22, r1
    231c:	71 05       	cpc	r23, r1
    231e:	31 f4       	brne	.+12     	; 0x232c <queueSerialData+0xae>
	{
		PRINTF_D("couldn't prepare ax25 packet\n");
    2320:	88 ec       	ldi	r24, 0xC8	; 200
    2322:	9b e0       	ldi	r25, 0x0B	; 11
    2324:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
		return -3;
    2328:	8d ef       	ldi	r24, 0xFD	; 253
    232a:	25 c0       	rjmp	.+74     	; 0x2376 <queueSerialData+0xf8>
	}
	len = manchester_encode(ax25_buffer, manchester_buffer, len);
    232c:	0e e0       	ldi	r16, 0x0E	; 14
    232e:	18 e1       	ldi	r17, 0x18	; 24
    2330:	82 e7       	ldi	r24, 0x72	; 114
    2332:	9c e1       	ldi	r25, 0x1C	; 28
    2334:	b8 01       	movw	r22, r16
    2336:	a9 01       	movw	r20, r18
    2338:	0e 94 02 06 	call	0xc04	; 0xc04 <manchester_encode>
    233c:	ec 01       	movw	r28, r24
#else
	len = manchester_encode(udp_buffer, manchester_buffer, len);
#endif

	memcpy(&transmit_buffer[idx], manchester_buffer, len);
    233e:	2a ed       	ldi	r18, 0xDA	; 218
    2340:	30 e2       	ldi	r19, 0x20	; 32
    2342:	c9 01       	movw	r24, r18
    2344:	b8 01       	movw	r22, r16
    2346:	ae 01       	movw	r20, r28
    2348:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
	idx += len;

	transmit_buffer[idx++] = END_OF_FILE;
    234c:	fe 01       	movw	r30, r28
    234e:	e6 52       	subi	r30, 0x26	; 38
    2350:	ff 4d       	sbci	r31, 0xDF	; 223
    2352:	8c e1       	ldi	r24, 0x1C	; 28
    2354:	80 83       	st	Z, r24
	transmit_buffer[idx++] = 0;
    2356:	fe 01       	movw	r30, r28
    2358:	e5 52       	subi	r30, 0x25	; 37
    235a:	ff 4d       	sbci	r31, 0xDF	; 223
    235c:	10 82       	st	Z, r1

	queue_flag = 1;
    235e:	81 e0       	ldi	r24, 0x01	; 1
    2360:	80 93 93 13 	sts	0x1393, r24

	memcpy(&transmit_buffer[idx], manchester_buffer, len);
	idx += len;

	transmit_buffer[idx++] = END_OF_FILE;
	transmit_buffer[idx++] = 0;
    2364:	60 96       	adiw	r28, 0x10	; 16

	queue_flag = 1;
	transmit_length = idx;
    2366:	d0 93 41 25 	sts	0x2541, r29
    236a:	c0 93 40 25 	sts	0x2540, r28

	//print_time("data queued");
	wdt_reset();
    236e:	a8 95       	wdr

	return 0;
    2370:	80 e0       	ldi	r24, 0x00	; 0
    2372:	01 c0       	rjmp	.+2      	; 0x2376 <queueSerialData+0xf8>
	uint16_t idx = 0, len = 0;

	wdt_reset();
	if(queue_flag)
	{
		return -1;
    2374:	8f ef       	ldi	r24, 0xFF	; 255

	//print_time("data queued");
	wdt_reset();

	return 0;
}
    2376:	df 91       	pop	r29
    2378:	cf 91       	pop	r28
    237a:	1f 91       	pop	r17
    237c:	0f 91       	pop	r16
    237e:	ff 90       	pop	r15
    2380:	ef 90       	pop	r14
    2382:	df 90       	pop	r13
    2384:	cf 90       	pop	r12
    2386:	08 95       	ret

00002388 <uart1_rx>:
	//stdin
	rs232_send(RS232_PORT_0, receivedByte);
	return 0;
}
int uart1_rx(unsigned char receivedByte)
{
    2388:	1f 93       	push	r17
    238a:	18 2f       	mov	r17, r24
	//radiometrix
//	putchar(receivedByte);
	if(sync_passed)
    238c:	80 91 96 13 	lds	r24, 0x1396
    2390:	88 23       	and	r24, r24
    2392:	f1 f1       	breq	.+124    	; 0x2410 <uart1_rx+0x88>
	{
		if(receivedByte==END_OF_FILE || !isManchester_encoded(receivedByte) )
    2394:	1c 31       	cpi	r17, 0x1C	; 28
    2396:	29 f0       	breq	.+10     	; 0x23a2 <uart1_rx+0x1a>
    2398:	81 2f       	mov	r24, r17
    239a:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <isManchester_encoded>
    239e:	88 23       	and	r24, r24
    23a0:	21 f5       	brne	.+72     	; 0x23ea <uart1_rx+0x62>
		{
			putchar('\n');
    23a2:	60 91 c6 36 	lds	r22, 0x36C6
    23a6:	70 91 c7 36 	lds	r23, 0x36C7
    23aa:	8a e0       	ldi	r24, 0x0A	; 10
    23ac:	90 e0       	ldi	r25, 0x00	; 0
    23ae:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
			sync_passed = 0;
    23b2:	10 92 96 13 	sts	0x1396, r1
			saved_io_index = io_index;
    23b6:	80 91 42 25 	lds	r24, 0x2542
    23ba:	90 91 43 25 	lds	r25, 0x2543
    23be:	90 93 99 13 	sts	0x1399, r25
    23c2:	80 93 98 13 	sts	0x1398, r24
			io_flag=1;
    23c6:	81 e0       	ldi	r24, 0x01	; 1
    23c8:	80 93 90 13 	sts	0x1390, r24
			if(process_post(&radiotftp_process, PROCESS_EVENT_COM, (void*) io)==PROCESS_ERR_FULL)
    23cc:	87 e5       	ldi	r24, 0x57	; 87
    23ce:	9d e0       	ldi	r25, 0x0D	; 13
    23d0:	69 e8       	ldi	r22, 0x89	; 137
    23d2:	4a e9       	ldi	r20, 0x9A	; 154
    23d4:	53 e1       	ldi	r21, 0x13	; 19
    23d6:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <process_post>
    23da:	81 30       	cpi	r24, 0x01	; 1
    23dc:	91 05       	cpc	r25, r1
    23de:	79 f5       	brne	.+94     	; 0x243e <uart1_rx+0xb6>
			{
				printf("incoming transmission discarded\n");
    23e0:	85 ee       	ldi	r24, 0xE5	; 229
    23e2:	9b e0       	ldi	r25, 0x0B	; 11
    23e4:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
    23e8:	2a c0       	rjmp	.+84     	; 0x243e <uart1_rx+0xb6>
			}
		}
		else
		{
			io[io_index] = receivedByte;
    23ea:	20 91 42 25 	lds	r18, 0x2542
    23ee:	30 91 43 25 	lds	r19, 0x2543
    23f2:	f9 01       	movw	r30, r18
    23f4:	e6 56       	subi	r30, 0x66	; 102
    23f6:	fc 4e       	sbci	r31, 0xEC	; 236
    23f8:	10 83       	st	Z, r17
			io_index = ((io_index+1)%sizeof(io));
    23fa:	c9 01       	movw	r24, r18
    23fc:	01 96       	adiw	r24, 0x01	; 1
    23fe:	64 e7       	ldi	r22, 0x74	; 116
    2400:	74 e0       	ldi	r23, 0x04	; 4
    2402:	0e 94 63 4a 	call	0x94c6	; 0x94c6 <__udivmodhi4>
    2406:	90 93 43 25 	sts	0x2543, r25
    240a:	80 93 42 25 	sts	0x2542, r24
    240e:	17 c0       	rjmp	.+46     	; 0x243e <uart1_rx+0xb6>
		}
	}
	else
	{
		if(receivedByte==syncword[sync_counter])
    2410:	80 91 97 13 	lds	r24, 0x1397
    2414:	e8 2f       	mov	r30, r24
    2416:	f0 e0       	ldi	r31, 0x00	; 0
    2418:	e6 5c       	subi	r30, 0xC6	; 198
    241a:	f2 4f       	sbci	r31, 0xF2	; 242
    241c:	90 81       	ld	r25, Z
    241e:	19 17       	cp	r17, r25
    2420:	61 f4       	brne	.+24     	; 0x243a <uart1_rx+0xb2>
		{
			//one more step closer to
			sync_counter++;
    2422:	8f 5f       	subi	r24, 0xFF	; 255
    2424:	80 93 97 13 	sts	0x1397, r24
			//PRINTF_D("sync counting=%d\n", sync_counter);
			if(sync_counter==SYNC_LENGTH)
    2428:	84 30       	cpi	r24, 0x04	; 4
    242a:	49 f4       	brne	.+18     	; 0x243e <uart1_rx+0xb6>
			{
				io_index=0;
    242c:	10 92 43 25 	sts	0x2543, r1
    2430:	10 92 42 25 	sts	0x2542, r1
				sync_passed = 1;
    2434:	81 e0       	ldi	r24, 0x01	; 1
    2436:	80 93 96 13 	sts	0x1396, r24
			}
		}
		else
		{
			//reset the sync counter
			sync_counter = 0;
    243a:	10 92 97 13 	sts	0x1397, r1
		}
	}
	return 0;
}
    243e:	80 e0       	ldi	r24, 0x00	; 0
    2440:	90 e0       	ldi	r25, 0x00	; 0
    2442:	1f 91       	pop	r17
    2444:	08 95       	ret

00002446 <radiotftpAlarm_callback>:
PROCESS(radiotftp_process, "Radiotftp Process");

void radiotftpAlarm_callback(void* data)
{
	//PRINTF_D("main timer handler\n");
	timer_flag = 1;
    2446:	81 e0       	ldi	r24, 0x01	; 1
    2448:	80 93 92 13 	sts	0x1392, r24
	process_post(&radiotftp_process, PROCESS_EVENT_TIMER, NULL);
    244c:	87 e5       	ldi	r24, 0x57	; 87
    244e:	9d e0       	ldi	r25, 0x0D	; 13
    2450:	68 e8       	ldi	r22, 0x88	; 136
    2452:	40 e0       	ldi	r20, 0x00	; 0
    2454:	50 e0       	ldi	r21, 0x00	; 0
    2456:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <process_post>
}
    245a:	08 95       	ret

0000245c <setRTS>:
	return 0;
}

uint8_t setRTS(uint8_t level)
{
	if(level)
    245c:	88 23       	and	r24, r24
    245e:	11 f0       	breq	.+4      	; 0x2464 <setRTS+0x8>
		SET_BIT(PORTF, 0);
    2460:	88 9a       	sbi	0x11, 0	; 17
    2462:	01 c0       	rjmp	.+2      	; 0x2466 <setRTS+0xa>
	else
		CLR_BIT(PORTF, 0);
    2464:	88 98       	cbi	0x11, 0	; 17
	return READ_BIT(PORTF, 0);
    2466:	81 b3       	in	r24, 0x11	; 17
}
    2468:	81 70       	andi	r24, 0x01	; 1
    246a:	08 95       	ret

0000246c <radiotftp_setNumBytesToSend>:

void radiotftp_setNumBytesToSend(uint16_t numBytes)
{
//	PRINTF_D("setting num of bytes to send %d\n", numBytes);
	ATOMIC_SET(numBytesToSend, numBytes);
    246c:	f8 94       	cli
    246e:	90 93 95 13 	sts	0x1395, r25
    2472:	80 93 94 13 	sts	0x1394, r24
    2476:	78 94       	sei
}
    2478:	08 95       	ret

0000247a <radiotftp_getNumBytesToSend>:

uint16_t radiotftp_getNumBytesToSend()
{
	return numBytesToSend;
    247a:	20 91 94 13 	lds	r18, 0x1394
    247e:	30 91 95 13 	lds	r19, 0x1395
}
    2482:	c9 01       	movw	r24, r18
    2484:	08 95       	ret

00002486 <transmitSerialData>:

	return 0;
}

uint16_t transmitSerialData(void)
{
    2486:	0f 93       	push	r16
    2488:	1f 93       	push	r17
    248a:	cf 93       	push	r28
    248c:	df 93       	push	r29
	uint16_t i = 0;

	wdt_reset();
    248e:	a8 95       	wdr
	setRTS(0);
    2490:	80 e0       	ldi	r24, 0x00	; 0
    2492:	0e 94 2e 12 	call	0x245c	; 0x245c <setRTS>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2496:	8f e3       	ldi	r24, 0x3F	; 63
    2498:	9c e9       	ldi	r25, 0x9C	; 156
    249a:	01 97       	sbiw	r24, 0x01	; 1
    249c:	f1 f7       	brne	.-4      	; 0x249a <transmitSerialData+0x14>
    249e:	00 c0       	rjmp	.+0      	; 0x24a0 <transmitSerialData+0x1a>
    24a0:	00 00       	nop
	_delay_ms(2e1);

	ATOMIC_BEGIN();
    24a2:	f8 94       	cli
    24a4:	0c ec       	ldi	r16, 0xCC	; 204
    24a6:	10 e2       	ldi	r17, 0x20	; 32
	for(i = 0; i<transmit_length; i++)
    24a8:	c0 e0       	ldi	r28, 0x00	; 0
    24aa:	d0 e0       	ldi	r29, 0x00	; 0
    24ac:	07 c0       	rjmp	.+14     	; 0x24bc <transmitSerialData+0x36>
	{
		//NOTE: rs232_send has caused problems before
		//while (!READ_BIT(UCSR1A, UDRE1));
		//UDR1 = transmit_buffer[i];
		rs232_send(RS232_PORT_1, transmit_buffer[i]);
    24ae:	f8 01       	movw	r30, r16
    24b0:	61 91       	ld	r22, Z+
    24b2:	8f 01       	movw	r16, r30
    24b4:	81 e0       	ldi	r24, 0x01	; 1
    24b6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>
	wdt_reset();
	setRTS(0);
	_delay_ms(2e1);

	ATOMIC_BEGIN();
	for(i = 0; i<transmit_length; i++)
    24ba:	21 96       	adiw	r28, 0x01	; 1
    24bc:	80 91 40 25 	lds	r24, 0x2540
    24c0:	90 91 41 25 	lds	r25, 0x2541
    24c4:	c8 17       	cp	r28, r24
    24c6:	d9 07       	cpc	r29, r25
    24c8:	90 f3       	brcs	.-28     	; 0x24ae <transmitSerialData+0x28>
		//while (!READ_BIT(UCSR1A, UDRE1));
		//UDR1 = transmit_buffer[i];
		rs232_send(RS232_PORT_1, transmit_buffer[i]);
		//rs232_send(RS232_PORT_0, transmit_buffer[i]);
	}
	while (!READ_BIT(UCSR1A, UDRE1));
    24ca:	80 91 c8 00 	lds	r24, 0x00C8
    24ce:	85 ff       	sbrs	r24, 5
    24d0:	fc cf       	rjmp	.-8      	; 0x24ca <transmitSerialData+0x44>
	ATOMIC_END();
    24d2:	78 94       	sei
    24d4:	8f e3       	ldi	r24, 0x3F	; 63
    24d6:	9c e9       	ldi	r25, 0x9C	; 156
    24d8:	01 97       	sbiw	r24, 0x01	; 1
    24da:	f1 f7       	brne	.-4      	; 0x24d8 <transmitSerialData+0x52>
    24dc:	00 c0       	rjmp	.+0      	; 0x24de <transmitSerialData+0x58>
    24de:	00 00       	nop

	_delay_ms(2e1);
	setRTS(1);
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	0e 94 2e 12 	call	0x245c	; 0x245c <setRTS>
	wdt_reset();
    24e6:	a8 95       	wdr


	//print_time("data sent");

	return 0;
}
    24e8:	80 e0       	ldi	r24, 0x00	; 0
    24ea:	90 e0       	ldi	r25, 0x00	; 0
    24ec:	df 91       	pop	r29
    24ee:	cf 91       	pop	r28
    24f0:	1f 91       	pop	r17
    24f2:	0f 91       	pop	r16
    24f4:	08 95       	ret

000024f6 <udp_packet_demultiplexer>:

uint8_t udp_packet_demultiplexer(uint8_t* src, uint16_t src_port, uint8_t* dst, uint16_t dst_port, uint8_t* payload, uint16_t len)
{
    24f6:	8f 92       	push	r8
    24f8:	9f 92       	push	r9
    24fa:	af 92       	push	r10
    24fc:	bf 92       	push	r11
    24fe:	cf 92       	push	r12
    2500:	df 92       	push	r13
    2502:	ef 92       	push	r14
    2504:	ff 92       	push	r15
    2506:	0f 93       	push	r16
    2508:	1f 93       	push	r17
    250a:	cf 93       	push	r28
    250c:	df 93       	push	r29
    250e:	ec 01       	movw	r28, r24
    2510:	4b 01       	movw	r8, r22
    2512:	5a 01       	movw	r10, r20
    2514:	69 01       	movw	r12, r18
//    PRINTF_D("== udp packet handler ==\n");
//    PRINTF_D("== SRC: %02x.%02x.%02x.%02x.%02x.%02x:%d ==\n", src[0], src[1], src[2], src[3], src[4], src[5], src_port);
//    PRINTF_D("== DST: %02x.%02x.%02x.%02x.%02x.%02x:%d ==\n", dst[0], dst[1], dst[2], dst[3], dst[4], dst[5], dst_port);

	uint8_t different = 0;
	wdt_reset();
    2516:	a8 95       	wdr

	//check for address match
	different = memcmp(udp_get_localhost_ip(NULL), dst, IPV6_DESTINATION_LENGTH);
    2518:	80 e0       	ldi	r24, 0x00	; 0
    251a:	90 e0       	ldi	r25, 0x00	; 0
    251c:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    2520:	b5 01       	movw	r22, r10
    2522:	46 e0       	ldi	r20, 0x06	; 6
    2524:	50 e0       	ldi	r21, 0x00	; 0
    2526:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
	if(different)
    252a:	88 23       	and	r24, r24
    252c:	61 f0       	breq	.+24     	; 0x2546 <udp_packet_demultiplexer+0x50>
	{
		different = memcmp(udp_get_broadcast_ip(NULL), dst, IPV6_DESTINATION_LENGTH);
    252e:	80 e0       	ldi	r24, 0x00	; 0
    2530:	90 e0       	ldi	r25, 0x00	; 0
    2532:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <udp_get_broadcast_ip>
    2536:	b5 01       	movw	r22, r10
    2538:	46 e0       	ldi	r20, 0x06	; 6
    253a:	50 e0       	ldi	r21, 0x00	; 0
    253c:	0e 94 41 4b 	call	0x9682	; 0x9682 <memcmp>
	}

	if(!different)
    2540:	88 23       	and	r24, r24
    2542:	09 f0       	breq	.+2      	; 0x2546 <udp_packet_demultiplexer+0x50>
    2544:	58 c0       	rjmp	.+176    	; 0x25f6 <udp_packet_demultiplexer+0x100>
		 {
		 //PRINTF_D("tftp negotiate port\n");
		 tftp_negotiate(src, src_port, dst, dst_port, payload, len - 8);
		 }
		 else */
		if(dst_port==tftp_transfer_src_port())
    2546:	0e 94 61 06 	call	0xcc2	; 0xcc2 <tftp_transfer_src_port>
    254a:	c8 16       	cp	r12, r24
    254c:	d9 06       	cpc	r13, r25
    254e:	59 f4       	brne	.+22     	; 0x2566 <udp_packet_demultiplexer+0x70>
		{
			//PRINTF_D("tftp negotiate port\n");
			tftp_transfer(src, src_port, dst, dst_port, payload, len-8);
    2550:	88 ef       	ldi	r24, 0xF8	; 248
    2552:	9f ef       	ldi	r25, 0xFF	; 255
    2554:	e8 0e       	add	r14, r24
    2556:	f9 1e       	adc	r15, r25
    2558:	ce 01       	movw	r24, r28
    255a:	b4 01       	movw	r22, r8
    255c:	a5 01       	movw	r20, r10
    255e:	96 01       	movw	r18, r12
    2560:	0e 94 34 0b 	call	0x1668	; 0x1668 <tftp_transfer>
    2564:	56 c0       	rjmp	.+172    	; 0x2612 <udp_packet_demultiplexer+0x11c>
		}
		else if(dst_port==HELLO_WORLD_PORT)
    2566:	99 e3       	ldi	r25, 0x39	; 57
    2568:	c9 16       	cp	r12, r25
    256a:	90 e3       	ldi	r25, 0x30	; 48
    256c:	d9 06       	cpc	r13, r25
    256e:	71 f5       	brne	.+92     	; 0x25cc <udp_packet_demultiplexer+0xd6>
		{
			PRINTF_D("New neighbour:\nIP = %d.%d.%d.%d.%d.%d\n", src[0], src[1], src[2], src[3], src[4], src[5]);
    2570:	ad b7       	in	r26, 0x3d	; 61
    2572:	be b7       	in	r27, 0x3e	; 62
    2574:	1e 97       	sbiw	r26, 0x0e	; 14
    2576:	0f b6       	in	r0, 0x3f	; 63
    2578:	f8 94       	cli
    257a:	be bf       	out	0x3e, r27	; 62
    257c:	0f be       	out	0x3f, r0	; 63
    257e:	ad bf       	out	0x3d, r26	; 61
    2580:	ed b7       	in	r30, 0x3d	; 61
    2582:	fe b7       	in	r31, 0x3e	; 62
    2584:	31 96       	adiw	r30, 0x01	; 1
    2586:	85 e0       	ldi	r24, 0x05	; 5
    2588:	9c e0       	ldi	r25, 0x0C	; 12
    258a:	12 96       	adiw	r26, 0x02	; 2
    258c:	9c 93       	st	X, r25
    258e:	8e 93       	st	-X, r24
    2590:	11 97       	sbiw	r26, 0x01	; 1
    2592:	88 81       	ld	r24, Y
    2594:	82 83       	std	Z+2, r24	; 0x02
    2596:	13 82       	std	Z+3, r1	; 0x03
    2598:	89 81       	ldd	r24, Y+1	; 0x01
    259a:	84 83       	std	Z+4, r24	; 0x04
    259c:	15 82       	std	Z+5, r1	; 0x05
    259e:	8a 81       	ldd	r24, Y+2	; 0x02
    25a0:	86 83       	std	Z+6, r24	; 0x06
    25a2:	17 82       	std	Z+7, r1	; 0x07
    25a4:	8b 81       	ldd	r24, Y+3	; 0x03
    25a6:	80 87       	std	Z+8, r24	; 0x08
    25a8:	11 86       	std	Z+9, r1	; 0x09
    25aa:	8c 81       	ldd	r24, Y+4	; 0x04
    25ac:	82 87       	std	Z+10, r24	; 0x0a
    25ae:	13 86       	std	Z+11, r1	; 0x0b
    25b0:	8d 81       	ldd	r24, Y+5	; 0x05
    25b2:	84 87       	std	Z+12, r24	; 0x0c
    25b4:	15 86       	std	Z+13, r1	; 0x0d
    25b6:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    25ba:	ed b7       	in	r30, 0x3d	; 61
    25bc:	fe b7       	in	r31, 0x3e	; 62
    25be:	3e 96       	adiw	r30, 0x0e	; 14
    25c0:	0f b6       	in	r0, 0x3f	; 63
    25c2:	f8 94       	cli
    25c4:	fe bf       	out	0x3e, r31	; 62
    25c6:	0f be       	out	0x3f, r0	; 63
    25c8:	ed bf       	out	0x3d, r30	; 61
    25ca:	23 c0       	rjmp	.+70     	; 0x2612 <udp_packet_demultiplexer+0x11c>
		}
		else
		{
			PRINTF_D("packet received for unassigned port: %d\n", dst_port);
    25cc:	00 d0       	rcall	.+0      	; 0x25ce <udp_packet_demultiplexer+0xd8>
    25ce:	00 d0       	rcall	.+0      	; 0x25d0 <udp_packet_demultiplexer+0xda>
    25d0:	8c e2       	ldi	r24, 0x2C	; 44
    25d2:	9c e0       	ldi	r25, 0x0C	; 12
    25d4:	ad b7       	in	r26, 0x3d	; 61
    25d6:	be b7       	in	r27, 0x3e	; 62
    25d8:	12 96       	adiw	r26, 0x02	; 2
    25da:	9c 93       	st	X, r25
    25dc:	8e 93       	st	-X, r24
    25de:	11 97       	sbiw	r26, 0x01	; 1
    25e0:	14 96       	adiw	r26, 0x04	; 4
    25e2:	dc 92       	st	X, r13
    25e4:	ce 92       	st	-X, r12
    25e6:	13 97       	sbiw	r26, 0x03	; 3
    25e8:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
    25ec:	0f 90       	pop	r0
    25ee:	0f 90       	pop	r0
    25f0:	0f 90       	pop	r0
    25f2:	0f 90       	pop	r0
    25f4:	0e c0       	rjmp	.+28     	; 0x2612 <udp_packet_demultiplexer+0x11c>
	}
	else
	{
		//nothing to do here yet
		//may be for routing purposes...
		PRINTF_D("packet for someone else: ");
    25f6:	00 d0       	rcall	.+0      	; 0x25f8 <udp_packet_demultiplexer+0x102>
    25f8:	85 e5       	ldi	r24, 0x55	; 85
    25fa:	9c e0       	ldi	r25, 0x0C	; 12
    25fc:	ed b7       	in	r30, 0x3d	; 61
    25fe:	fe b7       	in	r31, 0x3e	; 62
    2600:	92 83       	std	Z+2, r25	; 0x02
    2602:	81 83       	std	Z+1, r24	; 0x01
    2604:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		print_addr_dec(dst);
    2608:	0f 90       	pop	r0
    260a:	0f 90       	pop	r0
    260c:	c5 01       	movw	r24, r10
    260e:	0e 94 22 10 	call	0x2044	; 0x2044 <print_addr_dec>

	}
	return 0;
}
    2612:	80 e0       	ldi	r24, 0x00	; 0
    2614:	df 91       	pop	r29
    2616:	cf 91       	pop	r28
    2618:	1f 91       	pop	r17
    261a:	0f 91       	pop	r16
    261c:	ff 90       	pop	r15
    261e:	ef 90       	pop	r14
    2620:	df 90       	pop	r13
    2622:	cf 90       	pop	r12
    2624:	bf 90       	pop	r11
    2626:	af 90       	pop	r10
    2628:	9f 90       	pop	r9
    262a:	8f 90       	pop	r8
    262c:	08 95       	ret

0000262e <process_thread_radiotftp_process>:
PROCESS_THREAD(radiotftp_process, ev, data)
{
    262e:	cf 92       	push	r12
    2630:	ef 92       	push	r14
    2632:	ff 92       	push	r15
    2634:	0f 93       	push	r16
    2636:	1f 93       	push	r17
    2638:	cf 93       	push	r28
    263a:	df 93       	push	r29
    263c:	ec 01       	movw	r28, r24
    263e:	8a 01       	movw	r16, r20
	uint16_t i, temp_io_index;
	int16_t result = 0;
	static struct etimer wait_timer;
	PROCESS_BEGIN()
    2640:	88 81       	ld	r24, Y
    2642:	99 81       	ldd	r25, Y+1	; 0x01
    2644:	00 97       	sbiw	r24, 0x00	; 0
    2646:	31 f0       	breq	.+12     	; 0x2654 <process_thread_radiotftp_process+0x26>
    2648:	21 e0       	ldi	r18, 0x01	; 1
    264a:	8f 36       	cpi	r24, 0x6F	; 111
    264c:	92 07       	cpc	r25, r18
    264e:	09 f0       	breq	.+2      	; 0x2652 <process_thread_radiotftp_process+0x24>
    2650:	1f c1       	rjmp	.+574    	; 0x2890 <process_thread_radiotftp_process+0x262>
    2652:	85 c0       	rjmp	.+266    	; 0x275e <process_thread_radiotftp_process+0x130>
		;
		PRINTF_D("%s begin\n", PROCESS_CURRENT()->name);
    2654:	00 d0       	rcall	.+0      	; 0x2656 <process_thread_radiotftp_process+0x28>
    2656:	00 d0       	rcall	.+0      	; 0x2658 <process_thread_radiotftp_process+0x2a>
    2658:	8f e6       	ldi	r24, 0x6F	; 111
    265a:	9c e0       	ldi	r25, 0x0C	; 12
    265c:	ed b7       	in	r30, 0x3d	; 61
    265e:	fe b7       	in	r31, 0x3e	; 62
    2660:	92 83       	std	Z+2, r25	; 0x02
    2662:	81 83       	std	Z+1, r24	; 0x01
    2664:	e0 91 46 25 	lds	r30, 0x2546
    2668:	f0 91 47 25 	lds	r31, 0x2547
    266c:	82 81       	ldd	r24, Z+2	; 0x02
    266e:	93 81       	ldd	r25, Z+3	; 0x03
    2670:	ed b7       	in	r30, 0x3d	; 61
    2672:	fe b7       	in	r31, 0x3e	; 62
    2674:	94 83       	std	Z+4, r25	; 0x04
    2676:	83 83       	std	Z+3, r24	; 0x03
    2678:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>

		SET_BIT(DDRF, 0);
    267c:	80 9a       	sbi	0x10, 0	; 16
		SET_BIT(MCUCR, PUD);
    267e:	85 b7       	in	r24, 0x35	; 53
    2680:	80 61       	ori	r24, 0x10	; 16
    2682:	85 bf       	out	0x35, r24	; 53
		SET_BIT(DPDS0, PFDRV1);
    2684:	80 91 36 01 	lds	r24, 0x0136
    2688:	80 68       	ori	r24, 0x80	; 128
    268a:	80 93 36 01 	sts	0x0136, r24
		SET_BIT(DPDS0, PFDRV0);
    268e:	80 91 36 01 	lds	r24, 0x0136
    2692:	80 64       	ori	r24, 0x40	; 64
    2694:	80 93 36 01 	sts	0x0136, r24

		CLR_BIT(DDRE, 0);
    2698:	68 98       	cbi	0x0d, 0	; 13
		SET_BIT(DDRE, 1);
    269a:	69 9a       	sbi	0x0d, 1	; 13
		SET_BIT(DDRE, 2);
    269c:	6a 9a       	sbi	0x0d, 2	; 13
		SET_BIT(DDRE, 3);
    269e:	6b 9a       	sbi	0x0d, 3	; 13
		SET_BIT(DDRE, 4);
    26a0:	6c 9a       	sbi	0x0d, 4	; 13
		CLR_BIT(DDRE, 5);
    26a2:	6d 98       	cbi	0x0d, 5	; 13

		SET_BIT(PORTE, 2);
    26a4:	72 9a       	sbi	0x0e, 2	; 14
		SET_BIT(PORTE, 3);
    26a6:	73 9a       	sbi	0x0e, 3	; 14
		SET_BIT(PORTE, 4);
    26a8:	74 9a       	sbi	0x0e, 4	; 14

		rs232_init(RS232_PORT_0, USART_BAUD_38400, USART_PARITY_NONE|USART_STOP_BITS_1|USART_DATA_BITS_8|USART_RECEIVER_ENABLE|USART_INTERRUPT_RX_COMPLETE);
    26aa:	0f 90       	pop	r0
    26ac:	0f 90       	pop	r0
    26ae:	0f 90       	pop	r0
    26b0:	0f 90       	pop	r0
    26b2:	80 e0       	ldi	r24, 0x00	; 0
    26b4:	6c e0       	ldi	r22, 0x0C	; 12
    26b6:	46 e9       	ldi	r20, 0x96	; 150
    26b8:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <rs232_init>
		rs232_set_input(RS232_PORT_0, uart0_rx);
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	68 e3       	ldi	r22, 0x38	; 56
    26c0:	71 e1       	ldi	r23, 0x11	; 17
    26c2:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <rs232_set_input>

		rs232_init(RS232_PORT_1, USART_BAUD_4800, USART_PARITY_NONE|USART_STOP_BITS_1|USART_DATA_BITS_8|USART_RECEIVER_ENABLE|USART_INTERRUPT_RX_COMPLETE);
    26c6:	81 e0       	ldi	r24, 0x01	; 1
    26c8:	67 e6       	ldi	r22, 0x67	; 103
    26ca:	46 e9       	ldi	r20, 0x96	; 150
    26cc:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <rs232_init>
		rs232_set_input(RS232_PORT_1, uart1_rx);
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	64 ec       	ldi	r22, 0xC4	; 196
    26d4:	71 e1       	ldi	r23, 0x11	; 17
    26d6:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <rs232_set_input>
		 ATOMIC_SET(io_index, 0);
		 ATOMIC_SET(io_flag, 0);
		 }
		 }*/

		timers_initialize(radiotftpAlarm_callback);
    26da:	83 e2       	ldi	r24, 0x23	; 35
    26dc:	92 e1       	ldi	r25, 0x12	; 18
    26de:	0e 94 88 0c 	call	0x1910	; 0x1910 <timers_initialize>
#if AX25_ENABLED==1
		ax25_initialize_network(my_ax25_callsign);
    26e2:	8e e3       	ldi	r24, 0x3E	; 62
    26e4:	9d e0       	ldi	r25, 0x0D	; 13
    26e6:	0e 94 78 03 	call	0x6f0	; 0x6f0 <ax25_initialize_network>
		PRINTF_D("AX25 CALLSIGN = ");
    26ea:	00 d0       	rcall	.+0      	; 0x26ec <process_thread_radiotftp_process+0xbe>
    26ec:	89 e7       	ldi	r24, 0x79	; 121
    26ee:	9c e0       	ldi	r25, 0x0C	; 12
    26f0:	ed b7       	in	r30, 0x3d	; 61
    26f2:	fe b7       	in	r31, 0x3e	; 62
    26f4:	92 83       	std	Z+2, r25	; 0x02
    26f6:	81 83       	std	Z+1, r24	; 0x01
    26f8:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		print_callsign(ax25_get_local_callsign(NULL));
    26fc:	0f 90       	pop	r0
    26fe:	0f 90       	pop	r0
    2700:	80 e0       	ldi	r24, 0x00	; 0
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	0e 94 84 03 	call	0x708	; 0x708 <ax25_get_local_callsign>
    2708:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <print_callsign>
#elif ETHERNET_ENABLED==1
		eth_initialize_network(my_eth_address);
		PRINTF_D("Ethernet Address = ");
		print_addr_hex(eth_get_local_address(NULL));
#endif
		udp_initialize_ip_network(my_ip_address, &queueSerialData);
    270c:	8a e2       	ldi	r24, 0x2A	; 42
    270e:	9d e0       	ldi	r25, 0x0D	; 13
    2710:	6f e3       	ldi	r22, 0x3F	; 63
    2712:	71 e1       	ldi	r23, 0x11	; 17
    2714:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <udp_initialize_ip_network>
		PRINTF_D("IPv6 Address = ");
    2718:	00 d0       	rcall	.+0      	; 0x271a <process_thread_radiotftp_process+0xec>
    271a:	8a e8       	ldi	r24, 0x8A	; 138
    271c:	9c e0       	ldi	r25, 0x0C	; 12
    271e:	ed b7       	in	r30, 0x3d	; 61
    2720:	fe b7       	in	r31, 0x3e	; 62
    2722:	92 83       	std	Z+2, r25	; 0x02
    2724:	81 83       	std	Z+1, r24	; 0x01
    2726:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
		print_addr_dec(udp_get_localhost_ip(NULL));
    272a:	0f 90       	pop	r0
    272c:	0f 90       	pop	r0
    272e:	80 e0       	ldi	r24, 0x00	; 0
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <udp_get_localhost_ip>
    2736:	0e 94 22 10 	call	0x2044	; 0x2044 <print_addr_dec>
		tftp_initialize(udp_get_data_queuer_fptr());
    273a:	0e 94 76 0d 	call	0x1aec	; 0x1aec <udp_get_data_queuer_fptr>
    273e:	0e 94 56 06 	call	0xcac	; 0xcac <tftp_initialize>

		//entering the main while loop
		PRINTF_D("started listening...\n");
    2742:	8a e9       	ldi	r24, 0x9A	; 154
    2744:	9c e0       	ldi	r25, 0x0C	; 12
    2746:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
		{
			/* usage
			 * radiotftp_setNumBytesToSend(500);
			 * process_post_synch(&radiotftp_process, PROCESS_EVENT_CONTINUE, io);
			 */
			PRINTF_D("waiting for an event/flag\n");
    274a:	8f ea       	ldi	r24, 0xAF	; 175
    274c:	9c e0       	ldi	r25, 0x0C	; 12
    274e:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
			PROCESS_WAIT_EVENT();
    2752:	8f e6       	ldi	r24, 0x6F	; 111
    2754:	91 e0       	ldi	r25, 0x01	; 1
    2756:	99 83       	std	Y+1, r25	; 0x01
    2758:	88 83       	st	Y, r24
    275a:	81 e0       	ldi	r24, 0x01	; 1
    275c:	9c c0       	rjmp	.+312    	; 0x2896 <process_thread_radiotftp_process+0x268>
			//PROCESS_WAIT_EVENT_UNTIL(timer_flag || queue_flag || io_flag || numBytesToSend);
			if(numBytesToSend)
    275e:	80 91 94 13 	lds	r24, 0x1394
    2762:	90 91 95 13 	lds	r25, 0x1395
    2766:	00 97       	sbiw	r24, 0x00	; 0
    2768:	59 f1       	breq	.+86     	; 0x27c0 <process_thread_radiotftp_process+0x192>
			{
				PRINTF_D("starting to send request, numBytes=%d\n", numBytesToSend);
    276a:	80 91 94 13 	lds	r24, 0x1394
    276e:	90 91 95 13 	lds	r25, 0x1395
    2772:	00 d0       	rcall	.+0      	; 0x2774 <process_thread_radiotftp_process+0x146>
    2774:	00 d0       	rcall	.+0      	; 0x2776 <process_thread_radiotftp_process+0x148>
    2776:	29 ec       	ldi	r18, 0xC9	; 201
    2778:	3c e0       	ldi	r19, 0x0C	; 12
    277a:	ed b7       	in	r30, 0x3d	; 61
    277c:	fe b7       	in	r31, 0x3e	; 62
    277e:	32 83       	std	Z+2, r19	; 0x02
    2780:	21 83       	std	Z+1, r18	; 0x01
    2782:	94 83       	std	Z+4, r25	; 0x04
    2784:	83 83       	std	Z+3, r24	; 0x03
    2786:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <printf>
#if RADIOTFTP_ENABLE_ACKNOWLEDGMENTS
				tftp_sendRequest(TFTP_OPCODE_WRQ, udp_get_broadcast_ip(NULL), (uint8_t*) data, numBytesToSend, REMOTE_FILENAME, strlen(REMOTE_FILENAME), APPEND);
    278a:	0f 90       	pop	r0
    278c:	0f 90       	pop	r0
    278e:	0f 90       	pop	r0
    2790:	0f 90       	pop	r0
    2792:	80 e0       	ldi	r24, 0x00	; 0
    2794:	90 e0       	ldi	r25, 0x00	; 0
    2796:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <udp_get_broadcast_ip>
    279a:	bc 01       	movw	r22, r24
    279c:	20 91 94 13 	lds	r18, 0x1394
    27a0:	30 91 95 13 	lds	r19, 0x1395
    27a4:	82 e0       	ldi	r24, 0x02	; 2
    27a6:	a8 01       	movw	r20, r16
    27a8:	00 ef       	ldi	r16, 0xF0	; 240
    27aa:	1c e0       	ldi	r17, 0x0C	; 12
    27ac:	ab e0       	ldi	r26, 0x0B	; 11
    27ae:	ea 2e       	mov	r14, r26
    27b0:	cc 24       	eor	r12, r12
    27b2:	c3 94       	inc	r12
    27b4:	0e 94 01 08 	call	0x1002	; 0x1002 <tftp_sendRequest>
#else
				tftp_sendSingleBlockData(udp_get_broadcast_ip(NULL), (uint8_t*)data, numBytesToSend, REMOTE_FILENAME);
#endif
				numBytesToSend = 0;
    27b8:	10 92 95 13 	sts	0x1395, r1
    27bc:	10 92 94 13 	sts	0x1394, r1
			}
			if(timer_flag)
    27c0:	80 91 92 13 	lds	r24, 0x1392
    27c4:	88 23       	and	r24, r24
    27c6:	41 f0       	breq	.+16     	; 0x27d8 <process_thread_radiotftp_process+0x1aa>
			{
				PRINTF_D("timer_flag=1\n");
    27c8:	8c ef       	ldi	r24, 0xFC	; 252
    27ca:	9c e0       	ldi	r25, 0x0C	; 12
    27cc:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
				tftp_timer_handler();
    27d0:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <tftp_timer_handler>
				timer_flag = 0;
    27d4:	10 92 92 13 	sts	0x1392, r1
			}
			if(queue_flag)
    27d8:	80 91 93 13 	lds	r24, 0x1393
    27dc:	88 23       	and	r24, r24
    27de:	61 f0       	breq	.+24     	; 0x27f8 <process_thread_radiotftp_process+0x1ca>
			{
				if(!sync_passed&&sync_counter<1)
    27e0:	80 91 96 13 	lds	r24, 0x1396
    27e4:	88 23       	and	r24, r24
    27e6:	41 f4       	brne	.+16     	; 0x27f8 <process_thread_radiotftp_process+0x1ca>
    27e8:	80 91 97 13 	lds	r24, 0x1397
    27ec:	88 23       	and	r24, r24
    27ee:	21 f4       	brne	.+8      	; 0x27f8 <process_thread_radiotftp_process+0x1ca>
					 do
					 {
					 PROCESS_YIELD();
					 } while(ev != PROCESS_EVENT_TIMER);
					 */
					transmitSerialData();
    27f0:	0e 94 43 12 	call	0x2486	; 0x2486 <transmitSerialData>
					queue_flag = 0;
    27f4:	10 92 93 13 	sts	0x1393, r1
				}
			}
			if(io_flag)
    27f8:	80 91 90 13 	lds	r24, 0x1390
    27fc:	88 23       	and	r24, r24
    27fe:	09 f4       	brne	.+2      	; 0x2802 <process_thread_radiotftp_process+0x1d4>
    2800:	42 c0       	rjmp	.+132    	; 0x2886 <process_thread_radiotftp_process+0x258>
			{
				//PRINTF_D("# of bytes read = %d\n", saved_io_index);
				ATOMIC_SET(temp_io_index, saved_io_index);
    2802:	f8 94       	cli
    2804:	40 91 98 13 	lds	r20, 0x1398
    2808:	50 91 99 13 	lds	r21, 0x1399
    280c:	78 94       	sei
				result = manchester_decode(io, manchester_buffer, temp_io_index);
    280e:	8a e9       	ldi	r24, 0x9A	; 154
    2810:	93 e1       	ldi	r25, 0x13	; 19
    2812:	6e e0       	ldi	r22, 0x0E	; 14
    2814:	78 e1       	ldi	r23, 0x18	; 24
    2816:	0e 94 31 06 	call	0xc62	; 0xc62 <manchester_decode>
    281a:	8c 01       	movw	r16, r24
#if ETHERNET_ENABLED==1
				result = eth_open_packet(NULL, NULL, ethernet_buffer, manchester_buffer, result);
#elif AX25_ENABLED==1
				result = ax25_open_ui_packet(NULL, NULL, ax25_buffer, manchester_buffer, result);
    281c:	80 e0       	ldi	r24, 0x00	; 0
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	60 e0       	ldi	r22, 0x00	; 0
    2822:	70 e0       	ldi	r23, 0x00	; 0
    2824:	42 e7       	ldi	r20, 0x72	; 114
    2826:	5c e1       	ldi	r21, 0x1C	; 28
    2828:	2e e0       	ldi	r18, 0x0E	; 14
    282a:	38 e1       	ldi	r19, 0x18	; 24
    282c:	0e 94 0d 04 	call	0x81a	; 0x81a <ax25_open_ui_packet>
#else
				result = 1;
#endif
				if(result)
    2830:	00 97       	sbiw	r24, 0x00	; 0
    2832:	29 f1       	breq	.+74     	; 0x287e <process_thread_radiotftp_process+0x250>
				{
					//PRINTF_D("%s\n",buf);
#if ETHERNET_ENABLED==1
					result = udp_open_packet(udp_src, &udp_src_prt, udp_dst, &udp_dst_prt, udp_buffer, ethernet_buffer);
#elif AX25_ENABLED==1
					result = udp_open_packet(udp_src, &udp_src_prt, udp_dst, &udp_dst_prt, udp_buffer, ax25_buffer);
    2834:	84 ea       	ldi	r24, 0xA4	; 164
    2836:	9e e1       	ldi	r25, 0x1E	; 30
    2838:	6a ea       	ldi	r22, 0xAA	; 170
    283a:	7e e1       	ldi	r23, 0x1E	; 30
    283c:	4c ea       	ldi	r20, 0xAC	; 172
    283e:	5e e1       	ldi	r21, 0x1E	; 30
    2840:	22 eb       	ldi	r18, 0xB2	; 178
    2842:	3e e1       	ldi	r19, 0x1E	; 30
    2844:	04 eb       	ldi	r16, 0xB4	; 180
    2846:	1e e1       	ldi	r17, 0x1E	; 30
    2848:	f2 e7       	ldi	r31, 0x72	; 114
    284a:	ef 2e       	mov	r14, r31
    284c:	fc e1       	ldi	r31, 0x1C	; 28
    284e:	ff 2e       	mov	r15, r31
    2850:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <udp_open_packet>
    2854:	7c 01       	movw	r14, r24
#else
					result = udp_open_packet(udp_src, &udp_src_prt, udp_dst, &udp_dst_prt, udp_buffer, manchester_buffer);
#endif
					if(result)
    2856:	00 97       	sbiw	r24, 0x00	; 0
    2858:	79 f0       	breq	.+30     	; 0x2878 <process_thread_radiotftp_process+0x24a>
					{
						//PRINTF_D("%s\n",buf);
						udp_packet_demultiplexer(udp_src, udp_src_prt, udp_dst, udp_dst_prt, udp_buffer, result);
    285a:	60 91 aa 1e 	lds	r22, 0x1EAA
    285e:	70 91 ab 1e 	lds	r23, 0x1EAB
    2862:	20 91 b2 1e 	lds	r18, 0x1EB2
    2866:	30 91 b3 1e 	lds	r19, 0x1EB3
    286a:	84 ea       	ldi	r24, 0xA4	; 164
    286c:	9e e1       	ldi	r25, 0x1E	; 30
    286e:	4c ea       	ldi	r20, 0xAC	; 172
    2870:	5e e1       	ldi	r21, 0x1E	; 30
    2872:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <udp_packet_demultiplexer>
    2876:	07 c0       	rjmp	.+14     	; 0x2886 <process_thread_radiotftp_process+0x258>
					}
					else
					{
						PRINTF_D("!udp discarded!\n");
    2878:	89 e0       	ldi	r24, 0x09	; 9
    287a:	9d e0       	ldi	r25, 0x0D	; 13
    287c:	02 c0       	rjmp	.+4      	; 0x2882 <process_thread_radiotftp_process+0x254>
				else
				{
#if ETHERNET_ENABLED==1
					PRINTF_D("!eth discarded!\n");
#elif AX25_ENABLED==1
					PRINTF_D("!ax25_discarded!\n");
    287e:	89 e1       	ldi	r24, 0x19	; 25
    2880:	9d e0       	ldi	r25, 0x0D	; 13
    2882:	0e 94 1a 4c 	call	0x9834	; 0x9834 <puts>
#endif
				}
			}
			ATOMIC_SET(io_flag, 0);
    2886:	f8 94       	cli
    2888:	10 92 90 13 	sts	0x1390, r1
    288c:	78 94       	sei
		}
    288e:	5d cf       	rjmp	.-326    	; 0x274a <process_thread_radiotftp_process+0x11c>

	PROCESS_END();
    2890:	19 82       	std	Y+1, r1	; 0x01
    2892:	18 82       	st	Y, r1
    2894:	83 e0       	ldi	r24, 0x03	; 3
}
    2896:	df 91       	pop	r29
    2898:	cf 91       	pop	r28
    289a:	1f 91       	pop	r17
    289c:	0f 91       	pop	r16
    289e:	ff 90       	pop	r15
    28a0:	ef 90       	pop	r14
    28a2:	cf 90       	pop	r12
    28a4:	08 95       	ret

000028a6 <call_process>:
  process_current = old_current;
}
/*---------------------------------------------------------------------------*/
static void
call_process(struct process *p, process_event_t ev, process_data_t data)
{
    28a6:	1f 93       	push	r17
    28a8:	cf 93       	push	r28
    28aa:	df 93       	push	r29
    28ac:	ec 01       	movw	r28, r24
    28ae:	16 2f       	mov	r17, r22
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
    28b0:	88 85       	ldd	r24, Y+8	; 0x08
    28b2:	80 ff       	sbrs	r24, 0
    28b4:	1d c0       	rjmp	.+58     	; 0x28f0 <call_process+0x4a>
     p->thread != NULL) {
    28b6:	ec 81       	ldd	r30, Y+4	; 0x04
    28b8:	fd 81       	ldd	r31, Y+5	; 0x05
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
    28ba:	30 97       	sbiw	r30, 0x00	; 0
    28bc:	c9 f0       	breq	.+50     	; 0x28f0 <call_process+0x4a>
     p->thread != NULL) {
    PRINTF("process: calling process '%s' with event %d\n", PROCESS_NAME_STRING(p), ev);
    process_current = p;
    28be:	d0 93 47 25 	sts	0x2547, r29
    28c2:	c0 93 46 25 	sts	0x2546, r28
    p->state = PROCESS_STATE_CALLED;
    28c6:	82 e0       	ldi	r24, 0x02	; 2
    28c8:	88 87       	std	Y+8, r24	; 0x08
    ret = p->thread(&p->pt, ev, data);
    28ca:	ce 01       	movw	r24, r28
    28cc:	06 96       	adiw	r24, 0x06	; 6
    28ce:	09 95       	icall
    28d0:	99 27       	eor	r25, r25
    28d2:	87 fd       	sbrc	r24, 7
    28d4:	90 95       	com	r25
    if(ret == PT_EXITED ||
    28d6:	02 97       	sbiw	r24, 0x02	; 2
    28d8:	82 30       	cpi	r24, 0x02	; 2
    28da:	91 05       	cpc	r25, r1
    28dc:	10 f0       	brcs	.+4      	; 0x28e2 <call_process+0x3c>
       ret == PT_ENDED ||
    28de:	13 38       	cpi	r17, 0x83	; 131
    28e0:	29 f4       	brne	.+10     	; 0x28ec <call_process+0x46>
       ev == PROCESS_EVENT_EXIT) {
      exit_process(p, p);
    28e2:	ce 01       	movw	r24, r28
    28e4:	be 01       	movw	r22, r28
    28e6:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <exit_process>
    28ea:	02 c0       	rjmp	.+4      	; 0x28f0 <call_process+0x4a>
    } else {
      p->state = PROCESS_STATE_RUNNING;
    28ec:	81 e0       	ldi	r24, 0x01	; 1
    28ee:	88 87       	std	Y+8, r24	; 0x08
    }
  }
}
    28f0:	df 91       	pop	r29
    28f2:	cf 91       	pop	r28
    28f4:	1f 91       	pop	r17
    28f6:	08 95       	ret

000028f8 <exit_process>:
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
}
/*---------------------------------------------------------------------------*/
static void
exit_process(struct process *p, struct process *fromprocess)
{
    28f8:	cf 92       	push	r12
    28fa:	df 92       	push	r13
    28fc:	ef 92       	push	r14
    28fe:	ff 92       	push	r15
    2900:	0f 93       	push	r16
    2902:	1f 93       	push	r17
    2904:	cf 93       	push	r28
    2906:	df 93       	push	r29
    2908:	ec 01       	movw	r28, r24
    290a:	7b 01       	movw	r14, r22
  register struct process *q;
  struct process *old_current = process_current;
    290c:	c0 90 46 25 	lds	r12, 0x2546
    2910:	d0 90 47 25 	lds	r13, 0x2547

  PRINTF("process: exit_process '%s'\n", PROCESS_NAME_STRING(p));

  /* Make sure the process is in the process list before we try to
     exit it. */
  for(q = process_list; q != p && q != NULL; q = q->next);
    2914:	00 91 44 25 	lds	r16, 0x2544
    2918:	10 91 45 25 	lds	r17, 0x2545
    291c:	f8 01       	movw	r30, r16
    291e:	03 c0       	rjmp	.+6      	; 0x2926 <exit_process+0x2e>
    2920:	01 90       	ld	r0, Z+
    2922:	f0 81       	ld	r31, Z
    2924:	e0 2d       	mov	r30, r0
    2926:	ec 17       	cp	r30, r28
    2928:	fd 07       	cpc	r31, r29
    292a:	19 f0       	breq	.+6      	; 0x2932 <exit_process+0x3a>
    292c:	30 97       	sbiw	r30, 0x00	; 0
    292e:	c1 f7       	brne	.-16     	; 0x2920 <exit_process+0x28>
    2930:	46 c0       	rjmp	.+140    	; 0x29be <exit_process+0xc6>
  if(q == NULL) {
    2932:	20 97       	sbiw	r28, 0x00	; 0
    2934:	09 f4       	brne	.+2      	; 0x2938 <exit_process+0x40>
    2936:	43 c0       	rjmp	.+134    	; 0x29be <exit_process+0xc6>
    return;
  }

  if(process_is_running(p)) {
    2938:	88 85       	ldd	r24, Y+8	; 0x08
    293a:	88 23       	and	r24, r24
    293c:	09 f1       	breq	.+66     	; 0x2980 <exit_process+0x88>
    /* Process was running */
    p->state = PROCESS_STATE_NONE;
    293e:	18 86       	std	Y+8, r1	; 0x08
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
    2940:	0b c0       	rjmp	.+22     	; 0x2958 <exit_process+0x60>
      if(p != q) {
    2942:	c0 17       	cp	r28, r16
    2944:	d1 07       	cpc	r29, r17
    2946:	29 f0       	breq	.+10     	; 0x2952 <exit_process+0x5a>
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
    2948:	c8 01       	movw	r24, r16
    294a:	67 e8       	ldi	r22, 0x87	; 135
    294c:	ae 01       	movw	r20, r28
    294e:	0e 94 53 14 	call	0x28a6	; 0x28a6 <call_process>
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
    2952:	f8 01       	movw	r30, r16
    2954:	00 81       	ld	r16, Z
    2956:	11 81       	ldd	r17, Z+1	; 0x01
    2958:	01 15       	cp	r16, r1
    295a:	11 05       	cpc	r17, r1
    295c:	91 f7       	brne	.-28     	; 0x2942 <exit_process+0x4a>
      if(p != q) {
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
      }
    }

    if(p->thread != NULL && p != fromprocess) {
    295e:	ec 81       	ldd	r30, Y+4	; 0x04
    2960:	fd 81       	ldd	r31, Y+5	; 0x05
    2962:	30 97       	sbiw	r30, 0x00	; 0
    2964:	69 f0       	breq	.+26     	; 0x2980 <exit_process+0x88>
    2966:	ce 15       	cp	r28, r14
    2968:	df 05       	cpc	r29, r15
    296a:	51 f0       	breq	.+20     	; 0x2980 <exit_process+0x88>
      /* Post the exit event to the process that is about to exit. */
      process_current = p;
    296c:	d0 93 47 25 	sts	0x2547, r29
    2970:	c0 93 46 25 	sts	0x2546, r28
      p->thread(&p->pt, PROCESS_EVENT_EXIT, NULL);
    2974:	ce 01       	movw	r24, r28
    2976:	06 96       	adiw	r24, 0x06	; 6
    2978:	63 e8       	ldi	r22, 0x83	; 131
    297a:	40 e0       	ldi	r20, 0x00	; 0
    297c:	50 e0       	ldi	r21, 0x00	; 0
    297e:	09 95       	icall
    }
  }

  if(p == process_list) {
    2980:	e0 91 44 25 	lds	r30, 0x2544
    2984:	f0 91 45 25 	lds	r31, 0x2545
    2988:	ce 17       	cp	r28, r30
    298a:	df 07       	cpc	r29, r31
    298c:	91 f4       	brne	.+36     	; 0x29b2 <exit_process+0xba>
    process_list = process_list->next;
    298e:	88 81       	ld	r24, Y
    2990:	99 81       	ldd	r25, Y+1	; 0x01
    2992:	90 93 45 25 	sts	0x2545, r25
    2996:	80 93 44 25 	sts	0x2544, r24
    299a:	0d c0       	rjmp	.+26     	; 0x29b6 <exit_process+0xbe>
  } else {
    for(q = process_list; q != NULL; q = q->next) {
      if(q->next == p) {
    299c:	80 81       	ld	r24, Z
    299e:	91 81       	ldd	r25, Z+1	; 0x01
    29a0:	8c 17       	cp	r24, r28
    29a2:	9d 07       	cpc	r25, r29
    29a4:	29 f4       	brne	.+10     	; 0x29b0 <exit_process+0xb8>
	q->next = p->next;
    29a6:	88 81       	ld	r24, Y
    29a8:	99 81       	ldd	r25, Y+1	; 0x01
    29aa:	91 83       	std	Z+1, r25	; 0x01
    29ac:	80 83       	st	Z, r24
	break;
    29ae:	03 c0       	rjmp	.+6      	; 0x29b6 <exit_process+0xbe>

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
      if(q->next == p) {
    29b0:	fc 01       	movw	r30, r24
  }

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
    29b2:	30 97       	sbiw	r30, 0x00	; 0
    29b4:	99 f7       	brne	.-26     	; 0x299c <exit_process+0xa4>
	break;
      }
    }
  }

  process_current = old_current;
    29b6:	d0 92 47 25 	sts	0x2547, r13
    29ba:	c0 92 46 25 	sts	0x2546, r12
}
    29be:	df 91       	pop	r29
    29c0:	cf 91       	pop	r28
    29c2:	1f 91       	pop	r17
    29c4:	0f 91       	pop	r16
    29c6:	ff 90       	pop	r15
    29c8:	ef 90       	pop	r14
    29ca:	df 90       	pop	r13
    29cc:	cf 90       	pop	r12
    29ce:	08 95       	ret

000029d0 <do_poll>:
 * Call each process' poll handler.
 */
/*---------------------------------------------------------------------------*/
static void
do_poll(void)
{
    29d0:	1f 93       	push	r17
    29d2:	cf 93       	push	r28
    29d4:	df 93       	push	r29
  struct process *p;

  poll_requested = 0;
    29d6:	10 92 48 25 	sts	0x2548, r1
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    29da:	c0 91 44 25 	lds	r28, 0x2544
    29de:	d0 91 45 25 	lds	r29, 0x2545
    if(p->needspoll) {
      p->state = PROCESS_STATE_RUNNING;
    29e2:	11 e0       	ldi	r17, 0x01	; 1
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    29e4:	0e c0       	rjmp	.+28     	; 0x2a02 <do_poll+0x32>
    if(p->needspoll) {
    29e6:	89 85       	ldd	r24, Y+9	; 0x09
    29e8:	88 23       	and	r24, r24
    29ea:	41 f0       	breq	.+16     	; 0x29fc <do_poll+0x2c>
      p->state = PROCESS_STATE_RUNNING;
    29ec:	18 87       	std	Y+8, r17	; 0x08
      p->needspoll = 0;
    29ee:	19 86       	std	Y+9, r1	; 0x09
      call_process(p, PROCESS_EVENT_POLL, NULL);
    29f0:	ce 01       	movw	r24, r28
    29f2:	62 e8       	ldi	r22, 0x82	; 130
    29f4:	40 e0       	ldi	r20, 0x00	; 0
    29f6:	50 e0       	ldi	r21, 0x00	; 0
    29f8:	0e 94 53 14 	call	0x28a6	; 0x28a6 <call_process>
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
    29fc:	09 90       	ld	r0, Y+
    29fe:	d8 81       	ld	r29, Y
    2a00:	c0 2d       	mov	r28, r0
    2a02:	20 97       	sbiw	r28, 0x00	; 0
    2a04:	81 f7       	brne	.-32     	; 0x29e6 <do_poll+0x16>
      p->state = PROCESS_STATE_RUNNING;
      p->needspoll = 0;
      call_process(p, PROCESS_EVENT_POLL, NULL);
    }
  }
}
    2a06:	df 91       	pop	r29
    2a08:	cf 91       	pop	r28
    2a0a:	1f 91       	pop	r17
    2a0c:	08 95       	ret

00002a0e <process_alloc_event>:

/*---------------------------------------------------------------------------*/
process_event_t
process_alloc_event(void)
{
  return lastevent++;
    2a0e:	80 91 f3 25 	lds	r24, 0x25F3
    2a12:	98 2f       	mov	r25, r24
    2a14:	9f 5f       	subi	r25, 0xFF	; 255
    2a16:	90 93 f3 25 	sts	0x25F3, r25
}
    2a1a:	08 95       	ret

00002a1c <process_exit>:
}
/*---------------------------------------------------------------------------*/
void
process_exit(struct process *p)
{
  exit_process(p, PROCESS_CURRENT());
    2a1c:	60 91 46 25 	lds	r22, 0x2546
    2a20:	70 91 47 25 	lds	r23, 0x2547
    2a24:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <exit_process>
}
    2a28:	08 95       	ret

00002a2a <process_init>:
/*---------------------------------------------------------------------------*/
void
process_init(void)
{
  lastevent = PROCESS_EVENT_MAX;
    2a2a:	8a e8       	ldi	r24, 0x8A	; 138
    2a2c:	80 93 f3 25 	sts	0x25F3, r24

  nevents = fevent = 0;
    2a30:	10 92 4a 25 	sts	0x254A, r1
    2a34:	10 92 49 25 	sts	0x2549, r1
#if PROCESS_CONF_STATS
  process_maxevents = 0;
#endif /* PROCESS_CONF_STATS */

  process_current = process_list = NULL;
    2a38:	10 92 45 25 	sts	0x2545, r1
    2a3c:	10 92 44 25 	sts	0x2544, r1
    2a40:	10 92 47 25 	sts	0x2547, r1
    2a44:	10 92 46 25 	sts	0x2546, r1
}
    2a48:	08 95       	ret

00002a4a <process_run>:
/*---------------------------------------------------------------------------*/
int
process_run(void)
{
  /* Process poll events. */
  if(poll_requested) {
    2a4a:	80 91 48 25 	lds	r24, 0x2548
    2a4e:	88 23       	and	r24, r24
    2a50:	11 f0       	breq	.+4      	; 0x2a56 <process_run+0xc>
    do_poll();
    2a52:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <do_poll>
   * delivered to any of them. If so, we call the event handler
   * function for the process. We only process one event at a time and
   * call the poll handlers inbetween.
   */

  if(nevents > 0) {
    2a56:	70 91 49 25 	lds	r23, 0x2549
    2a5a:	77 23       	and	r23, r23
    2a5c:	09 f4       	brne	.+2      	; 0x2a60 <process_run+0x16>
    2a5e:	55 c0       	rjmp	.+170    	; 0x2b0a <process_run+0xc0>
    
    /* There are events that we should deliver. */
    ev = events[fevent].ev;
    2a60:	20 91 4a 25 	lds	r18, 0x254A
    2a64:	30 e0       	ldi	r19, 0x00	; 0
    2a66:	f9 01       	movw	r30, r18
    2a68:	ee 0f       	add	r30, r30
    2a6a:	ff 1f       	adc	r31, r31
    2a6c:	ee 0f       	add	r30, r30
    2a6e:	ff 1f       	adc	r31, r31
    2a70:	e2 0f       	add	r30, r18
    2a72:	f3 1f       	adc	r31, r19
    2a74:	e5 5b       	subi	r30, 0xB5	; 181
    2a76:	fa 4d       	sbci	r31, 0xDA	; 218
    2a78:	60 81       	ld	r22, Z
    2a7a:	60 93 f2 25 	sts	0x25F2, r22
    
    data = events[fevent].data;
    2a7e:	41 81       	ldd	r20, Z+1	; 0x01
    2a80:	52 81       	ldd	r21, Z+2	; 0x02
    2a82:	50 93 f1 25 	sts	0x25F1, r21
    2a86:	40 93 f0 25 	sts	0x25F0, r20
    receiver = events[fevent].p;
    2a8a:	83 81       	ldd	r24, Z+3	; 0x03
    2a8c:	94 81       	ldd	r25, Z+4	; 0x04
    2a8e:	90 93 ef 25 	sts	0x25EF, r25
    2a92:	80 93 ee 25 	sts	0x25EE, r24

    /* Since we have seen the new event, we move pointer upwards
       and decrese the number of events. */
    fevent = (fevent + 1) % PROCESS_CONF_NUMEVENTS;
    2a96:	2f 5f       	subi	r18, 0xFF	; 255
    2a98:	3f 4f       	sbci	r19, 0xFF	; 255
    2a9a:	2f 71       	andi	r18, 0x1F	; 31
    2a9c:	30 70       	andi	r19, 0x00	; 0
    2a9e:	20 93 4a 25 	sts	0x254A, r18
    --nevents;
    2aa2:	71 50       	subi	r23, 0x01	; 1
    2aa4:	70 93 49 25 	sts	0x2549, r23

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
    2aa8:	00 97       	sbiw	r24, 0x00	; 0
    2aaa:	41 f5       	brne	.+80     	; 0x2afc <process_run+0xb2>
      for(p = process_list; p != NULL; p = p->next) {
    2aac:	80 91 44 25 	lds	r24, 0x2544
    2ab0:	90 91 45 25 	lds	r25, 0x2545
    2ab4:	18 c0       	rjmp	.+48     	; 0x2ae6 <process_run+0x9c>

	/* If we have been requested to poll a process, we do this in
	   between processing the broadcast event. */
	if(poll_requested) {
    2ab6:	80 91 48 25 	lds	r24, 0x2548
    2aba:	88 23       	and	r24, r24
    2abc:	11 f0       	breq	.+4      	; 0x2ac2 <process_run+0x78>
	  do_poll();
    2abe:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <do_poll>
	}
	call_process(p, ev, data);
    2ac2:	40 91 f0 25 	lds	r20, 0x25F0
    2ac6:	50 91 f1 25 	lds	r21, 0x25F1
    2aca:	80 91 ec 25 	lds	r24, 0x25EC
    2ace:	90 91 ed 25 	lds	r25, 0x25ED
    2ad2:	60 91 f2 25 	lds	r22, 0x25F2
    2ad6:	0e 94 53 14 	call	0x28a6	; 0x28a6 <call_process>
    --nevents;

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
      for(p = process_list; p != NULL; p = p->next) {
    2ada:	e0 91 ec 25 	lds	r30, 0x25EC
    2ade:	f0 91 ed 25 	lds	r31, 0x25ED
    2ae2:	80 81       	ld	r24, Z
    2ae4:	91 81       	ldd	r25, Z+1	; 0x01
    2ae6:	90 93 ed 25 	sts	0x25ED, r25
    2aea:	80 93 ec 25 	sts	0x25EC, r24
    2aee:	80 91 ec 25 	lds	r24, 0x25EC
    2af2:	90 91 ed 25 	lds	r25, 0x25ED
    2af6:	00 97       	sbiw	r24, 0x00	; 0
    2af8:	f1 f6       	brne	.-68     	; 0x2ab6 <process_run+0x6c>
    2afa:	07 c0       	rjmp	.+14     	; 0x2b0a <process_run+0xc0>
    } else {
      /* This is not a broadcast event, so we deliver it to the
	 specified process. */
      /* If the event was an INIT event, we should also update the
	 state of the process. */
      if(ev == PROCESS_EVENT_INIT) {
    2afc:	61 38       	cpi	r22, 0x81	; 129
    2afe:	19 f4       	brne	.+6      	; 0x2b06 <process_run+0xbc>
	receiver->state = PROCESS_STATE_RUNNING;
    2b00:	21 e0       	ldi	r18, 0x01	; 1
    2b02:	fc 01       	movw	r30, r24
    2b04:	20 87       	std	Z+8, r18	; 0x08
      }

      /* Make sure that the process actually is running. */
      call_process(receiver, ev, data);
    2b06:	0e 94 53 14 	call	0x28a6	; 0x28a6 <call_process>
  }

  /* Process one event from the queue */
  do_event();

  return nevents + poll_requested;
    2b0a:	80 91 48 25 	lds	r24, 0x2548
    2b0e:	20 91 49 25 	lds	r18, 0x2549
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	28 0f       	add	r18, r24
    2b16:	31 1d       	adc	r19, r1
}
    2b18:	c9 01       	movw	r24, r18
    2b1a:	08 95       	ret

00002b1c <process_nevents>:
/*---------------------------------------------------------------------------*/
int
process_nevents(void)
{
  return nevents + poll_requested;
    2b1c:	80 91 48 25 	lds	r24, 0x2548
    2b20:	20 91 49 25 	lds	r18, 0x2549
    2b24:	30 e0       	ldi	r19, 0x00	; 0
    2b26:	28 0f       	add	r18, r24
    2b28:	31 1d       	adc	r19, r1
}
    2b2a:	c9 01       	movw	r24, r18
    2b2c:	08 95       	ret

00002b2e <process_post>:
    PRINTF("process_post: Process '%s' posts event %d to process '%s', nevents %d\n",
	   PROCESS_NAME_STRING(PROCESS_CURRENT()), ev,
	   p == PROCESS_BROADCAST? "<broadcast>": PROCESS_NAME_STRING(p), nevents);
  }
  
  if(nevents == PROCESS_CONF_NUMEVENTS) {
    2b2e:	70 91 49 25 	lds	r23, 0x2549
    2b32:	70 32       	cpi	r23, 0x20	; 32
    2b34:	d9 f0       	breq	.+54     	; 0x2b6c <process_post+0x3e>
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
  }
  
  snum = (process_num_events_t)(fevent + nevents) % PROCESS_CONF_NUMEVENTS;
    2b36:	20 91 4a 25 	lds	r18, 0x254A
    2b3a:	27 0f       	add	r18, r23
    2b3c:	2f 71       	andi	r18, 0x1F	; 31
    2b3e:	20 93 eb 25 	sts	0x25EB, r18
  events[snum].ev = ev;
    2b42:	30 e0       	ldi	r19, 0x00	; 0
    2b44:	f9 01       	movw	r30, r18
    2b46:	ee 0f       	add	r30, r30
    2b48:	ff 1f       	adc	r31, r31
    2b4a:	ee 0f       	add	r30, r30
    2b4c:	ff 1f       	adc	r31, r31
    2b4e:	e2 0f       	add	r30, r18
    2b50:	f3 1f       	adc	r31, r19
    2b52:	e5 5b       	subi	r30, 0xB5	; 181
    2b54:	fa 4d       	sbci	r31, 0xDA	; 218
    2b56:	60 83       	st	Z, r22
  events[snum].data = data;
    2b58:	52 83       	std	Z+2, r21	; 0x02
    2b5a:	41 83       	std	Z+1, r20	; 0x01
  events[snum].p = p;
    2b5c:	94 83       	std	Z+4, r25	; 0x04
    2b5e:	83 83       	std	Z+3, r24	; 0x03
  ++nevents;
    2b60:	7f 5f       	subi	r23, 0xFF	; 255
    2b62:	70 93 49 25 	sts	0x2549, r23
  if(nevents > process_maxevents) {
    process_maxevents = nevents;
  }
#endif /* PROCESS_CONF_STATS */
  
  return PROCESS_ERR_OK;
    2b66:	20 e0       	ldi	r18, 0x00	; 0
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    2b6a:	02 c0       	rjmp	.+4      	; 0x2b70 <process_post+0x42>
      printf("soft panic: event queue is full when broadcast event %d was posted from %s\n", ev, PROCESS_NAME_STRING(process_current));
    } else {
      printf("soft panic: event queue is full when event %d was posted to %s frpm %s\n", ev, PROCESS_NAME_STRING(p), PROCESS_NAME_STRING(process_current));
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
    2b6c:	21 e0       	ldi	r18, 0x01	; 1
    2b6e:	30 e0       	ldi	r19, 0x00	; 0
    process_maxevents = nevents;
  }
#endif /* PROCESS_CONF_STATS */
  
  return PROCESS_ERR_OK;
}
    2b70:	c9 01       	movw	r24, r18
    2b72:	08 95       	ret

00002b74 <process_post_synch>:
/*---------------------------------------------------------------------------*/
void
process_post_synch(struct process *p, process_event_t ev, process_data_t data)
{
    2b74:	cf 93       	push	r28
    2b76:	df 93       	push	r29
  struct process *caller = process_current;
    2b78:	c0 91 46 25 	lds	r28, 0x2546
    2b7c:	d0 91 47 25 	lds	r29, 0x2547

  call_process(p, ev, data);
    2b80:	0e 94 53 14 	call	0x28a6	; 0x28a6 <call_process>
  process_current = caller;
    2b84:	d0 93 47 25 	sts	0x2547, r29
    2b88:	c0 93 46 25 	sts	0x2546, r28
}
    2b8c:	df 91       	pop	r29
    2b8e:	cf 91       	pop	r28
    2b90:	08 95       	ret

00002b92 <process_start>:
  return lastevent++;
}
/*---------------------------------------------------------------------------*/
void
process_start(struct process *p, const char *arg)
{
    2b92:	fc 01       	movw	r30, r24
    2b94:	ab 01       	movw	r20, r22
  struct process *q;

  /* First make sure that we don't try to start a process that is
     already running. */
  for(q = process_list; q != p && q != NULL; q = q->next);
    2b96:	90 91 44 25 	lds	r25, 0x2544
    2b9a:	80 91 45 25 	lds	r24, 0x2545
    2b9e:	9c 01       	movw	r18, r24
    2ba0:	a3 2f       	mov	r26, r19
    2ba2:	b2 2f       	mov	r27, r18
    2ba4:	03 c0       	rjmp	.+6      	; 0x2bac <process_start+0x1a>
    2ba6:	0d 90       	ld	r0, X+
    2ba8:	bc 91       	ld	r27, X
    2baa:	a0 2d       	mov	r26, r0
    2bac:	ae 17       	cp	r26, r30
    2bae:	bf 07       	cpc	r27, r31
    2bb0:	91 f0       	breq	.+36     	; 0x2bd6 <process_start+0x44>
    2bb2:	10 97       	sbiw	r26, 0x00	; 0
    2bb4:	c1 f7       	brne	.-16     	; 0x2ba6 <process_start+0x14>

  /* If we found the process on the process list, we bail out. */
  if(q == p) {
    2bb6:	30 97       	sbiw	r30, 0x00	; 0
    2bb8:	71 f0       	breq	.+28     	; 0x2bd6 <process_start+0x44>
    return;
  }
  /* Put on the procs list.*/
  p->next = process_list;
    2bba:	90 83       	st	Z, r25
    2bbc:	81 83       	std	Z+1, r24	; 0x01
  process_list = p;
    2bbe:	f0 93 45 25 	sts	0x2545, r31
    2bc2:	e0 93 44 25 	sts	0x2544, r30
  p->state = PROCESS_STATE_RUNNING;
    2bc6:	81 e0       	ldi	r24, 0x01	; 1
    2bc8:	80 87       	std	Z+8, r24	; 0x08
  PT_INIT(&p->pt);
    2bca:	17 82       	std	Z+7, r1	; 0x07
    2bcc:	16 82       	std	Z+6, r1	; 0x06

  PRINTF("process: starting '%s'\n", PROCESS_NAME_STRING(p));

  /* Post a synchronous initialization event to the process. */
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
    2bce:	cf 01       	movw	r24, r30
    2bd0:	61 e8       	ldi	r22, 0x81	; 129
    2bd2:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <process_post_synch>
    2bd6:	08 95       	ret

00002bd8 <process_poll>:
  process_current = caller;
}
/*---------------------------------------------------------------------------*/
void
process_poll(struct process *p)
{
    2bd8:	fc 01       	movw	r30, r24
  if(p != NULL) {
    2bda:	00 97       	sbiw	r24, 0x00	; 0
    2bdc:	41 f0       	breq	.+16     	; 0x2bee <process_poll+0x16>
    if(p->state == PROCESS_STATE_RUNNING ||
    2bde:	80 85       	ldd	r24, Z+8	; 0x08
    2be0:	81 50       	subi	r24, 0x01	; 1
    2be2:	82 30       	cpi	r24, 0x02	; 2
    2be4:	20 f4       	brcc	.+8      	; 0x2bee <process_poll+0x16>
       p->state == PROCESS_STATE_CALLED) {
      p->needspoll = 1;
    2be6:	81 e0       	ldi	r24, 0x01	; 1
    2be8:	81 87       	std	Z+9, r24	; 0x09
      poll_requested = 1;
    2bea:	80 93 48 25 	sts	0x2548, r24
    2bee:	08 95       	ret

00002bf0 <process_is_running>:
}
/*---------------------------------------------------------------------------*/
int
process_is_running(struct process *p)
{
  return p->state != PROCESS_STATE_NONE;
    2bf0:	21 e0       	ldi	r18, 0x01	; 1
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	80 85       	ldd	r24, Z+8	; 0x08
    2bf8:	88 23       	and	r24, r24
    2bfa:	11 f4       	brne	.+4      	; 0x2c00 <process_is_running+0x10>
    2bfc:	20 e0       	ldi	r18, 0x00	; 0
    2bfe:	30 e0       	ldi	r19, 0x00	; 0
}
    2c00:	c9 01       	movw	r24, r18
    2c02:	08 95       	ret

00002c04 <update_time>:
{
  clock_time_t tdist;
  clock_time_t now;
  struct etimer *t;

  if (timerlist == NULL) {
    2c04:	80 91 f4 25 	lds	r24, 0x25F4
    2c08:	90 91 f5 25 	lds	r25, 0x25F5
    2c0c:	00 97       	sbiw	r24, 0x00	; 0
    2c0e:	29 f4       	brne	.+10     	; 0x2c1a <update_time+0x16>
    next_expiration = 0;
    2c10:	10 92 f7 25 	sts	0x25F7, r1
    2c14:	10 92 f6 25 	sts	0x25F6, r1
    2c18:	08 95       	ret
  } else {
    now = clock_time();
    2c1a:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    t = timerlist;
    2c1e:	e0 91 f4 25 	lds	r30, 0x25F4
    2c22:	f0 91 f5 25 	lds	r31, 0x25F5
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
    2c26:	22 81       	ldd	r18, Z+2	; 0x02
    2c28:	33 81       	ldd	r19, Z+3	; 0x03
    2c2a:	40 81       	ld	r20, Z
    2c2c:	51 81       	ldd	r21, Z+1	; 0x01
    2c2e:	24 0f       	add	r18, r20
    2c30:	35 1f       	adc	r19, r21
    2c32:	28 1b       	sub	r18, r24
    2c34:	39 0b       	sbc	r19, r25
    2c36:	0c c0       	rjmp	.+24     	; 0x2c50 <update_time+0x4c>
    for(t = t->next; t != NULL; t = t->next) {
      if(t->timer.start + t->timer.interval - now < tdist) {
    2c38:	42 81       	ldd	r20, Z+2	; 0x02
    2c3a:	53 81       	ldd	r21, Z+3	; 0x03
    2c3c:	60 81       	ld	r22, Z
    2c3e:	71 81       	ldd	r23, Z+1	; 0x01
    2c40:	46 0f       	add	r20, r22
    2c42:	57 1f       	adc	r21, r23
    2c44:	48 1b       	sub	r20, r24
    2c46:	59 0b       	sbc	r21, r25
  } else {
    now = clock_time();
    t = timerlist;
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
    for(t = t->next; t != NULL; t = t->next) {
    2c48:	42 17       	cp	r20, r18
    2c4a:	53 07       	cpc	r21, r19
    2c4c:	08 f4       	brcc	.+2      	; 0x2c50 <update_time+0x4c>
    2c4e:	9a 01       	movw	r18, r20
    2c50:	04 80       	ldd	r0, Z+4	; 0x04
    2c52:	f5 81       	ldd	r31, Z+5	; 0x05
    2c54:	e0 2d       	mov	r30, r0
    2c56:	30 97       	sbiw	r30, 0x00	; 0
    2c58:	79 f7       	brne	.-34     	; 0x2c38 <update_time+0x34>
      if(t->timer.start + t->timer.interval - now < tdist) {
	tdist = t->timer.start + t->timer.interval - now;
      }
    }
    next_expiration = now + tdist;
    2c5a:	28 0f       	add	r18, r24
    2c5c:	39 1f       	adc	r19, r25
    2c5e:	30 93 f7 25 	sts	0x25F7, r19
    2c62:	20 93 f6 25 	sts	0x25F6, r18
    2c66:	08 95       	ret

00002c68 <etimer_request_poll>:
}
/*---------------------------------------------------------------------------*/
void
etimer_request_poll(void)
{
  process_poll(&etimer_process);
    2c68:	8d e6       	ldi	r24, 0x6D	; 109
    2c6a:	9d e0       	ldi	r25, 0x0D	; 13
    2c6c:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <process_poll>
}
    2c70:	08 95       	ret

00002c72 <process_thread_etimer_process>:
    next_expiration = now + tdist;
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(etimer_process, ev, data)
{
    2c72:	cf 92       	push	r12
    2c74:	df 92       	push	r13
    2c76:	ef 92       	push	r14
    2c78:	ff 92       	push	r15
    2c7a:	0f 93       	push	r16
    2c7c:	1f 93       	push	r17
    2c7e:	cf 93       	push	r28
    2c80:	df 93       	push	r29
    2c82:	7c 01       	movw	r14, r24
  struct etimer *t, *u;
	
  PROCESS_BEGIN();
    2c84:	fc 01       	movw	r30, r24
    2c86:	80 81       	ld	r24, Z
    2c88:	91 81       	ldd	r25, Z+1	; 0x01
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	29 f0       	breq	.+10     	; 0x2c98 <process_thread_etimer_process+0x26>
    2c8e:	8a 35       	cpi	r24, 0x5A	; 90
    2c90:	91 05       	cpc	r25, r1
    2c92:	09 f0       	breq	.+2      	; 0x2c96 <process_thread_etimer_process+0x24>
    2c94:	6e c0       	rjmp	.+220    	; 0x2d72 <process_thread_etimer_process+0x100>
    2c96:	0b c0       	rjmp	.+22     	; 0x2cae <process_thread_etimer_process+0x3c>

  timerlist = NULL;
    2c98:	10 92 f5 25 	sts	0x25F5, r1
    2c9c:	10 92 f4 25 	sts	0x25F4, r1
  
  while(1) {
    PROCESS_YIELD();
    2ca0:	8a e5       	ldi	r24, 0x5A	; 90
    2ca2:	90 e0       	ldi	r25, 0x00	; 0
    2ca4:	f7 01       	movw	r30, r14
    2ca6:	91 83       	std	Z+1, r25	; 0x01
    2ca8:	80 83       	st	Z, r24
    2caa:	81 e0       	ldi	r24, 0x01	; 1
    2cac:	66 c0       	rjmp	.+204    	; 0x2d7a <process_thread_etimer_process+0x108>

    if(ev == PROCESS_EVENT_EXITED) {
    2cae:	67 38       	cpi	r22, 0x87	; 135
    2cb0:	49 f5       	brne	.+82     	; 0x2d04 <process_thread_etimer_process+0x92>
      struct process *p = data;
    2cb2:	ca 01       	movw	r24, r20
    2cb4:	e0 91 f4 25 	lds	r30, 0x25F4
    2cb8:	f0 91 f5 25 	lds	r31, 0x25F5

      while(timerlist != NULL && timerlist->p == p) {
    2cbc:	03 c0       	rjmp	.+6      	; 0x2cc4 <process_thread_etimer_process+0x52>
	timerlist = timerlist->next;
    2cbe:	04 80       	ldd	r0, Z+4	; 0x04
    2cc0:	f5 81       	ldd	r31, Z+5	; 0x05
    2cc2:	e0 2d       	mov	r30, r0
    PROCESS_YIELD();

    if(ev == PROCESS_EVENT_EXITED) {
      struct process *p = data;

      while(timerlist != NULL && timerlist->p == p) {
    2cc4:	30 97       	sbiw	r30, 0x00	; 0
    2cc6:	41 f3       	breq	.-48     	; 0x2c98 <process_thread_etimer_process+0x26>
    2cc8:	26 81       	ldd	r18, Z+6	; 0x06
    2cca:	37 81       	ldd	r19, Z+7	; 0x07
    2ccc:	28 17       	cp	r18, r24
    2cce:	39 07       	cpc	r19, r25
    2cd0:	b1 f3       	breq	.-20     	; 0x2cbe <process_thread_etimer_process+0x4c>
    2cd2:	e0 93 f4 25 	sts	0x25F4, r30
    2cd6:	f0 93 f5 25 	sts	0x25F5, r31
    2cda:	0f c0       	rjmp	.+30     	; 0x2cfa <process_thread_etimer_process+0x88>
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
	  if(t->next->p == p) {
    2cdc:	16 96       	adiw	r26, 0x06	; 6
    2cde:	2d 91       	ld	r18, X+
    2ce0:	3c 91       	ld	r19, X
    2ce2:	17 97       	sbiw	r26, 0x07	; 7
    2ce4:	28 17       	cp	r18, r24
    2ce6:	39 07       	cpc	r19, r25
    2ce8:	39 f4       	brne	.+14     	; 0x2cf8 <process_thread_etimer_process+0x86>
	    t->next = t->next->next;
    2cea:	14 96       	adiw	r26, 0x04	; 4
    2cec:	2d 91       	ld	r18, X+
    2cee:	3c 91       	ld	r19, X
    2cf0:	15 97       	sbiw	r26, 0x05	; 5
    2cf2:	35 83       	std	Z+5, r19	; 0x05
    2cf4:	24 83       	std	Z+4, r18	; 0x04
    2cf6:	df 01       	movw	r26, r30
    2cf8:	fd 01       	movw	r30, r26
	timerlist = timerlist->next;
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
    2cfa:	a4 81       	ldd	r26, Z+4	; 0x04
    2cfc:	b5 81       	ldd	r27, Z+5	; 0x05
    2cfe:	10 97       	sbiw	r26, 0x00	; 0
    2d00:	69 f7       	brne	.-38     	; 0x2cdc <process_thread_etimer_process+0x6a>
    2d02:	ce cf       	rjmp	.-100    	; 0x2ca0 <process_thread_etimer_process+0x2e>
	  } else
	    t = t->next;
	}
      }
      continue;
    } else if(ev != PROCESS_EVENT_POLL) {
    2d04:	62 38       	cpi	r22, 0x82	; 130
    2d06:	61 f6       	brne	.-104    	; 0x2ca0 <process_thread_etimer_process+0x2e>

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
    2d08:	c0 91 f4 25 	lds	r28, 0x25F4
    2d0c:	d0 91 f5 25 	lds	r29, 0x25F5
      continue;
    }

  again:
    
    u = NULL;
    2d10:	00 e0       	ldi	r16, 0x00	; 0
    2d12:	10 e0       	ldi	r17, 0x00	; 0
    
    for(t = timerlist; t != NULL; t = t->next) {
    2d14:	2b c0       	rjmp	.+86     	; 0x2d6c <process_thread_etimer_process+0xfa>
      if(timer_expired(&t->timer)) {
    2d16:	ce 01       	movw	r24, r28
    2d18:	0e 94 df 2c 	call	0x59be	; 0x59be <timer_expired>
    2d1c:	00 97       	sbiw	r24, 0x00	; 0
    2d1e:	f1 f0       	breq	.+60     	; 0x2d5c <process_thread_etimer_process+0xea>
	if(process_post(t->p, PROCESS_EVENT_TIMER, t) == PROCESS_ERR_OK) {
    2d20:	8e 81       	ldd	r24, Y+6	; 0x06
    2d22:	9f 81       	ldd	r25, Y+7	; 0x07
    2d24:	68 e8       	ldi	r22, 0x88	; 136
    2d26:	ae 01       	movw	r20, r28
    2d28:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <process_post>
    2d2c:	00 97       	sbiw	r24, 0x00	; 0
    2d2e:	a1 f4       	brne	.+40     	; 0x2d58 <process_thread_etimer_process+0xe6>
	  
	  /* Reset the process ID of the event timer, to signal that the
	     etimer has expired. This is later checked in the
	     etimer_expired() function. */
	  t->p = PROCESS_NONE;
    2d30:	1f 82       	std	Y+7, r1	; 0x07
    2d32:	1e 82       	std	Y+6, r1	; 0x06
    2d34:	8c 81       	ldd	r24, Y+4	; 0x04
    2d36:	9d 81       	ldd	r25, Y+5	; 0x05
	  if(u != NULL) {
    2d38:	01 15       	cp	r16, r1
    2d3a:	11 05       	cpc	r17, r1
    2d3c:	21 f0       	breq	.+8      	; 0x2d46 <process_thread_etimer_process+0xd4>
	    u->next = t->next;
    2d3e:	f8 01       	movw	r30, r16
    2d40:	95 83       	std	Z+5, r25	; 0x05
    2d42:	84 83       	std	Z+4, r24	; 0x04
    2d44:	04 c0       	rjmp	.+8      	; 0x2d4e <process_thread_etimer_process+0xdc>
	  } else {
	    timerlist = t->next;
    2d46:	90 93 f5 25 	sts	0x25F5, r25
    2d4a:	80 93 f4 25 	sts	0x25F4, r24
	  }
	  t->next = NULL;
    2d4e:	1d 82       	std	Y+5, r1	; 0x05
    2d50:	1c 82       	std	Y+4, r1	; 0x04
	  update_time();
    2d52:	0e 94 02 16 	call	0x2c04	; 0x2c04 <update_time>
	  goto again;
    2d56:	d8 cf       	rjmp	.-80     	; 0x2d08 <process_thread_etimer_process+0x96>
	} else {
	  etimer_request_poll();
    2d58:	0e 94 34 16 	call	0x2c68	; 0x2c68 <etimer_request_poll>

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
    2d5c:	8e 01       	movw	r16, r28
    2d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d60:	8d 81       	ldd	r24, Y+5	; 0x05
    2d62:	c9 2e       	mov	r12, r25
    2d64:	e6 01       	movw	r28, r12
    2d66:	6e 01       	movw	r12, r28
    2d68:	d8 2e       	mov	r13, r24
    2d6a:	e6 01       	movw	r28, r12
    2d6c:	20 97       	sbiw	r28, 0x00	; 0
    2d6e:	99 f6       	brne	.-90     	; 0x2d16 <process_thread_etimer_process+0xa4>
    2d70:	97 cf       	rjmp	.-210    	; 0x2ca0 <process_thread_etimer_process+0x2e>
      u = t;
    }
    
  }
  
  PROCESS_END();
    2d72:	f7 01       	movw	r30, r14
    2d74:	11 82       	std	Z+1, r1	; 0x01
    2d76:	10 82       	st	Z, r1
    2d78:	83 e0       	ldi	r24, 0x03	; 3
}
    2d7a:	df 91       	pop	r29
    2d7c:	cf 91       	pop	r28
    2d7e:	1f 91       	pop	r17
    2d80:	0f 91       	pop	r16
    2d82:	ff 90       	pop	r15
    2d84:	ef 90       	pop	r14
    2d86:	df 90       	pop	r13
    2d88:	cf 90       	pop	r12
    2d8a:	08 95       	ret

00002d8c <add_timer>:
  process_poll(&etimer_process);
}
/*---------------------------------------------------------------------------*/
static void
add_timer(struct etimer *timer)
{
    2d8c:	cf 93       	push	r28
    2d8e:	df 93       	push	r29
    2d90:	ec 01       	movw	r28, r24
  struct etimer *t;

  etimer_request_poll();
    2d92:	0e 94 34 16 	call	0x2c68	; 0x2c68 <etimer_request_poll>

  if(timer->p != PROCESS_NONE) {
    2d96:	8e 81       	ldd	r24, Y+6	; 0x06
    2d98:	9f 81       	ldd	r25, Y+7	; 0x07
    2d9a:	00 97       	sbiw	r24, 0x00	; 0
    2d9c:	69 f0       	breq	.+26     	; 0x2db8 <add_timer+0x2c>
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
    2d9e:	e0 91 f4 25 	lds	r30, 0x25F4
    2da2:	f0 91 f5 25 	lds	r31, 0x25F5
    2da6:	06 c0       	rjmp	.+12     	; 0x2db4 <add_timer+0x28>
      if(t == timer) {
    2da8:	ec 17       	cp	r30, r28
    2daa:	fd 07       	cpc	r31, r29
    2dac:	a9 f0       	breq	.+42     	; 0x2dd8 <add_timer+0x4c>
  etimer_request_poll();

  if(timer->p != PROCESS_NONE) {
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
    2dae:	04 80       	ldd	r0, Z+4	; 0x04
    2db0:	f5 81       	ldd	r31, Z+5	; 0x05
    2db2:	e0 2d       	mov	r30, r0
    2db4:	30 97       	sbiw	r30, 0x00	; 0
    2db6:	c1 f7       	brne	.-16     	; 0x2da8 <add_timer+0x1c>
	return;
      }
    }
  }

  timer->p = PROCESS_CURRENT();
    2db8:	80 91 46 25 	lds	r24, 0x2546
    2dbc:	90 91 47 25 	lds	r25, 0x2547
    2dc0:	9f 83       	std	Y+7, r25	; 0x07
    2dc2:	8e 83       	std	Y+6, r24	; 0x06
  timer->next = timerlist;
    2dc4:	80 91 f4 25 	lds	r24, 0x25F4
    2dc8:	90 91 f5 25 	lds	r25, 0x25F5
    2dcc:	9d 83       	std	Y+5, r25	; 0x05
    2dce:	8c 83       	std	Y+4, r24	; 0x04
  timerlist = timer;
    2dd0:	d0 93 f5 25 	sts	0x25F5, r29
    2dd4:	c0 93 f4 25 	sts	0x25F4, r28

  update_time();
    2dd8:	0e 94 02 16 	call	0x2c04	; 0x2c04 <update_time>
}
    2ddc:	df 91       	pop	r29
    2dde:	cf 91       	pop	r28
    2de0:	08 95       	ret

00002de2 <etimer_set>:
/*---------------------------------------------------------------------------*/
void
etimer_set(struct etimer *et, clock_time_t interval)
{
    2de2:	cf 93       	push	r28
    2de4:	df 93       	push	r29
    2de6:	ec 01       	movw	r28, r24
  timer_set(&et->timer, interval);
    2de8:	0e 94 bf 2c 	call	0x597e	; 0x597e <timer_set>
  add_timer(et);
    2dec:	ce 01       	movw	r24, r28
    2dee:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <add_timer>
}
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	08 95       	ret

00002df8 <etimer_reset>:
/*---------------------------------------------------------------------------*/
void
etimer_reset(struct etimer *et)
{
    2df8:	cf 93       	push	r28
    2dfa:	df 93       	push	r29
    2dfc:	ec 01       	movw	r28, r24
  timer_reset(&et->timer);
    2dfe:	0e 94 cb 2c 	call	0x5996	; 0x5996 <timer_reset>
  add_timer(et);
    2e02:	ce 01       	movw	r24, r28
    2e04:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <add_timer>
}
    2e08:	df 91       	pop	r29
    2e0a:	cf 91       	pop	r28
    2e0c:	08 95       	ret

00002e0e <etimer_restart>:
/*---------------------------------------------------------------------------*/
void
etimer_restart(struct etimer *et)
{
    2e0e:	cf 93       	push	r28
    2e10:	df 93       	push	r29
    2e12:	ec 01       	movw	r28, r24
  timer_restart(&et->timer);
    2e14:	0e 94 d5 2c 	call	0x59aa	; 0x59aa <timer_restart>
  add_timer(et);
    2e18:	ce 01       	movw	r24, r28
    2e1a:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <add_timer>
}
    2e1e:	df 91       	pop	r29
    2e20:	cf 91       	pop	r28
    2e22:	08 95       	ret

00002e24 <etimer_adjust>:
/*---------------------------------------------------------------------------*/
void
etimer_adjust(struct etimer *et, int timediff)
{
    2e24:	fc 01       	movw	r30, r24
  et->timer.start += timediff;
    2e26:	80 81       	ld	r24, Z
    2e28:	91 81       	ldd	r25, Z+1	; 0x01
    2e2a:	86 0f       	add	r24, r22
    2e2c:	97 1f       	adc	r25, r23
    2e2e:	91 83       	std	Z+1, r25	; 0x01
    2e30:	80 83       	st	Z, r24
  update_time();
    2e32:	0e 94 02 16 	call	0x2c04	; 0x2c04 <update_time>
}
    2e36:	08 95       	ret

00002e38 <etimer_expired>:
/*---------------------------------------------------------------------------*/
int
etimer_expired(struct etimer *et)
{
  return et->p == PROCESS_NONE;
    2e38:	21 e0       	ldi	r18, 0x01	; 1
    2e3a:	30 e0       	ldi	r19, 0x00	; 0
    2e3c:	fc 01       	movw	r30, r24
    2e3e:	86 81       	ldd	r24, Z+6	; 0x06
    2e40:	97 81       	ldd	r25, Z+7	; 0x07
    2e42:	00 97       	sbiw	r24, 0x00	; 0
    2e44:	11 f0       	breq	.+4      	; 0x2e4a <etimer_expired+0x12>
    2e46:	20 e0       	ldi	r18, 0x00	; 0
    2e48:	30 e0       	ldi	r19, 0x00	; 0
}
    2e4a:	c9 01       	movw	r24, r18
    2e4c:	08 95       	ret

00002e4e <etimer_expiration_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_expiration_time(struct etimer *et)
{
    2e4e:	fc 01       	movw	r30, r24
  return et->timer.start + et->timer.interval;
    2e50:	22 81       	ldd	r18, Z+2	; 0x02
    2e52:	33 81       	ldd	r19, Z+3	; 0x03
    2e54:	80 81       	ld	r24, Z
    2e56:	91 81       	ldd	r25, Z+1	; 0x01
    2e58:	28 0f       	add	r18, r24
    2e5a:	39 1f       	adc	r19, r25
}
    2e5c:	c9 01       	movw	r24, r18
    2e5e:	08 95       	ret

00002e60 <etimer_start_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_start_time(struct etimer *et)
{
    2e60:	fc 01       	movw	r30, r24
  return et->timer.start;
}
    2e62:	80 81       	ld	r24, Z
    2e64:	91 81       	ldd	r25, Z+1	; 0x01
    2e66:	08 95       	ret

00002e68 <etimer_pending>:
/*---------------------------------------------------------------------------*/
int
etimer_pending(void)
{
  return timerlist != NULL;
    2e68:	21 e0       	ldi	r18, 0x01	; 1
    2e6a:	30 e0       	ldi	r19, 0x00	; 0
    2e6c:	80 91 f4 25 	lds	r24, 0x25F4
    2e70:	90 91 f5 25 	lds	r25, 0x25F5
    2e74:	00 97       	sbiw	r24, 0x00	; 0
    2e76:	11 f4       	brne	.+4      	; 0x2e7c <etimer_pending+0x14>
    2e78:	20 e0       	ldi	r18, 0x00	; 0
    2e7a:	30 e0       	ldi	r19, 0x00	; 0
}
    2e7c:	c9 01       	movw	r24, r18
    2e7e:	08 95       	ret

00002e80 <etimer_next_expiration_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
etimer_next_expiration_time(void)
{
  return etimer_pending() ? next_expiration : 0;
    2e80:	80 91 f4 25 	lds	r24, 0x25F4
    2e84:	90 91 f5 25 	lds	r25, 0x25F5
    2e88:	00 97       	sbiw	r24, 0x00	; 0
    2e8a:	29 f0       	breq	.+10     	; 0x2e96 <etimer_next_expiration_time+0x16>
    2e8c:	20 91 f6 25 	lds	r18, 0x25F6
    2e90:	30 91 f7 25 	lds	r19, 0x25F7
    2e94:	02 c0       	rjmp	.+4      	; 0x2e9a <etimer_next_expiration_time+0x1a>
    2e96:	20 e0       	ldi	r18, 0x00	; 0
    2e98:	30 e0       	ldi	r19, 0x00	; 0
}
    2e9a:	c9 01       	movw	r24, r18
    2e9c:	08 95       	ret

00002e9e <etimer_stop>:
/*---------------------------------------------------------------------------*/
void
etimer_stop(struct etimer *et)
{
    2e9e:	cf 93       	push	r28
    2ea0:	df 93       	push	r29
    2ea2:	ec 01       	movw	r28, r24
  struct etimer *t;

  /* First check if et is the first event timer on the list. */
  if(et == timerlist) {
    2ea4:	e0 91 f4 25 	lds	r30, 0x25F4
    2ea8:	f0 91 f5 25 	lds	r31, 0x25F5
    2eac:	8e 17       	cp	r24, r30
    2eae:	9f 07       	cpc	r25, r31
    2eb0:	41 f4       	brne	.+16     	; 0x2ec2 <etimer_stop+0x24>
    timerlist = timerlist->next;
    2eb2:	8c 81       	ldd	r24, Y+4	; 0x04
    2eb4:	9d 81       	ldd	r25, Y+5	; 0x05
    2eb6:	90 93 f5 25 	sts	0x25F5, r25
    2eba:	80 93 f4 25 	sts	0x25F4, r24
    2ebe:	14 c0       	rjmp	.+40     	; 0x2ee8 <etimer_stop+0x4a>
    update_time();
  } else {
    /* Else walk through the list and try to find the item before the
       et timer. */
    for(t = timerlist; t != NULL && t->next != et; t = t->next);
    2ec0:	fc 01       	movw	r30, r24
    2ec2:	30 97       	sbiw	r30, 0x00	; 0
    2ec4:	31 f0       	breq	.+12     	; 0x2ed2 <etimer_stop+0x34>
    2ec6:	84 81       	ldd	r24, Z+4	; 0x04
    2ec8:	95 81       	ldd	r25, Z+5	; 0x05
    2eca:	8c 17       	cp	r24, r28
    2ecc:	9d 07       	cpc	r25, r29
    2ece:	c1 f7       	brne	.-16     	; 0x2ec0 <etimer_stop+0x22>
    2ed0:	07 c0       	rjmp	.+14     	; 0x2ee0 <etimer_stop+0x42>
      update_time();
    }
  }

  /* Remove the next pointer from the item to be removed. */
  et->next = NULL;
    2ed2:	1d 82       	std	Y+5, r1	; 0x05
    2ed4:	1c 82       	std	Y+4, r1	; 0x04
  /* Set the timer as expired */
  et->p = PROCESS_NONE;
    2ed6:	1f 82       	std	Y+7, r1	; 0x07
    2ed8:	1e 82       	std	Y+6, r1	; 0x06
}
    2eda:	df 91       	pop	r29
    2edc:	cf 91       	pop	r28
    2ede:	08 95       	ret

    if(t != NULL) {
      /* We've found the item before the event timer that we are about
	 to remove. We point the items next pointer to the event after
	 the removed item. */
      t->next = et->next;
    2ee0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ee2:	9d 81       	ldd	r25, Y+5	; 0x05
    2ee4:	95 83       	std	Z+5, r25	; 0x05
    2ee6:	84 83       	std	Z+4, r24	; 0x04

      update_time();
    2ee8:	0e 94 02 16 	call	0x2c04	; 0x2c04 <update_time>
    2eec:	f2 cf       	rjmp	.-28     	; 0x2ed2 <etimer_stop+0x34>

00002eee <process_thread_ctimer_process>:
#endif

/*---------------------------------------------------------------------------*/
PROCESS(ctimer_process, "Ctimer process");
PROCESS_THREAD(ctimer_process, ev, data)
{
    2eee:	cf 92       	push	r12
    2ef0:	df 92       	push	r13
    2ef2:	ef 92       	push	r14
    2ef4:	ff 92       	push	r15
    2ef6:	0f 93       	push	r16
    2ef8:	1f 93       	push	r17
    2efa:	cf 93       	push	r28
    2efc:	df 93       	push	r29
    2efe:	8c 01       	movw	r16, r24
    2f00:	7a 01       	movw	r14, r20
  struct ctimer *c;
  PROCESS_BEGIN();
    2f02:	fc 01       	movw	r30, r24
    2f04:	80 81       	ld	r24, Z
    2f06:	91 81       	ldd	r25, Z+1	; 0x01
    2f08:	00 97       	sbiw	r24, 0x00	; 0
    2f0a:	29 f0       	breq	.+10     	; 0x2f16 <process_thread_ctimer_process+0x28>
    2f0c:	8b 34       	cpi	r24, 0x4B	; 75
    2f0e:	91 05       	cpc	r25, r1
    2f10:	09 f0       	breq	.+2      	; 0x2f14 <process_thread_ctimer_process+0x26>
    2f12:	51 c0       	rjmp	.+162    	; 0x2fb6 <process_thread_ctimer_process+0xc8>
    2f14:	1e c0       	rjmp	.+60     	; 0x2f52 <process_thread_ctimer_process+0x64>

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    2f16:	89 ef       	ldi	r24, 0xF9	; 249
    2f18:	95 e2       	ldi	r25, 0x25	; 37
    2f1a:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    2f1e:	c8 2e       	mov	r12, r24
    2f20:	e6 01       	movw	r28, r12
    2f22:	7e 01       	movw	r14, r28
    2f24:	f9 2e       	mov	r15, r25
    2f26:	e7 01       	movw	r28, r14
    2f28:	09 c0       	rjmp	.+18     	; 0x2f3c <process_thread_ctimer_process+0x4e>
    etimer_set(&c->etimer, c->etimer.timer.interval);
    2f2a:	6c 81       	ldd	r22, Y+4	; 0x04
    2f2c:	7d 81       	ldd	r23, Y+5	; 0x05
    2f2e:	ce 01       	movw	r24, r28
    2f30:	02 96       	adiw	r24, 0x02	; 2
    2f32:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <etimer_set>
PROCESS_THREAD(ctimer_process, ev, data)
{
  struct ctimer *c;
  PROCESS_BEGIN();

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    2f36:	09 90       	ld	r0, Y+
    2f38:	d8 81       	ld	r29, Y
    2f3a:	c0 2d       	mov	r28, r0
    2f3c:	20 97       	sbiw	r28, 0x00	; 0
    2f3e:	a9 f7       	brne	.-22     	; 0x2f2a <process_thread_ctimer_process+0x3c>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;
    2f40:	81 e0       	ldi	r24, 0x01	; 1
    2f42:	80 93 f8 25 	sts	0x25F8, r24

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    2f46:	8b e4       	ldi	r24, 0x4B	; 75
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	f8 01       	movw	r30, r16
    2f4c:	91 83       	std	Z+1, r25	; 0x01
    2f4e:	80 83       	st	Z, r24
    2f50:	37 c0       	rjmp	.+110    	; 0x2fc0 <process_thread_ctimer_process+0xd2>
    2f52:	68 38       	cpi	r22, 0x88	; 136
    2f54:	a9 f5       	brne	.+106    	; 0x2fc0 <process_thread_ctimer_process+0xd2>
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    2f56:	89 ef       	ldi	r24, 0xF9	; 249
    2f58:	95 e2       	ldi	r25, 0x25	; 37
    2f5a:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    2f5e:	c8 2e       	mov	r12, r24
    2f60:	e6 01       	movw	r28, r12
    2f62:	6e 01       	movw	r12, r28
    2f64:	d9 2e       	mov	r13, r25
    2f66:	e6 01       	movw	r28, r12
    2f68:	23 c0       	rjmp	.+70     	; 0x2fb0 <process_thread_ctimer_process+0xc2>
      if(&c->etimer == data) {
    2f6a:	ce 01       	movw	r24, r28
    2f6c:	02 96       	adiw	r24, 0x02	; 2
    2f6e:	e8 16       	cp	r14, r24
    2f70:	f9 06       	cpc	r15, r25
    2f72:	d9 f4       	brne	.+54     	; 0x2faa <process_thread_ctimer_process+0xbc>
	list_remove(ctimer_list, c);
    2f74:	89 ef       	ldi	r24, 0xF9	; 249
    2f76:	95 e2       	ldi	r25, 0x25	; 37
    2f78:	be 01       	movw	r22, r28
    2f7a:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
	PROCESS_CONTEXT_BEGIN(c->p);
    2f7e:	e0 90 46 25 	lds	r14, 0x2546
    2f82:	f0 90 47 25 	lds	r15, 0x2547
    2f86:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f88:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f8a:	90 93 47 25 	sts	0x2547, r25
    2f8e:	80 93 46 25 	sts	0x2546, r24
	if(c->f != NULL) {
    2f92:	ec 85       	ldd	r30, Y+12	; 0x0c
    2f94:	fd 85       	ldd	r31, Y+13	; 0x0d
    2f96:	30 97       	sbiw	r30, 0x00	; 0
    2f98:	19 f0       	breq	.+6      	; 0x2fa0 <process_thread_ctimer_process+0xb2>
	  c->f(c->ptr);
    2f9a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f9c:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f9e:	09 95       	icall
	}
	PROCESS_CONTEXT_END(c->p);
    2fa0:	f0 92 47 25 	sts	0x2547, r15
    2fa4:	e0 92 46 25 	sts	0x2546, r14
	break;
    2fa8:	ce cf       	rjmp	.-100    	; 0x2f46 <process_thread_ctimer_process+0x58>
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
    2faa:	09 90       	ld	r0, Y+
    2fac:	d8 81       	ld	r29, Y
    2fae:	c0 2d       	mov	r28, r0
    2fb0:	20 97       	sbiw	r28, 0x00	; 0
    2fb2:	d9 f6       	brne	.-74     	; 0x2f6a <process_thread_ctimer_process+0x7c>
    2fb4:	c8 cf       	rjmp	.-112    	; 0x2f46 <process_thread_ctimer_process+0x58>
	PROCESS_CONTEXT_END(c->p);
	break;
      }
    }
  }
  PROCESS_END();
    2fb6:	f8 01       	movw	r30, r16
    2fb8:	11 82       	std	Z+1, r1	; 0x01
    2fba:	10 82       	st	Z, r1
    2fbc:	83 e0       	ldi	r24, 0x03	; 3
    2fbe:	01 c0       	rjmp	.+2      	; 0x2fc2 <process_thread_ctimer_process+0xd4>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
	break;
      }
    }
  }
  PROCESS_END();
}
    2fc2:	df 91       	pop	r29
    2fc4:	cf 91       	pop	r28
    2fc6:	1f 91       	pop	r17
    2fc8:	0f 91       	pop	r16
    2fca:	ff 90       	pop	r15
    2fcc:	ef 90       	pop	r14
    2fce:	df 90       	pop	r13
    2fd0:	cf 90       	pop	r12
    2fd2:	08 95       	ret

00002fd4 <ctimer_init>:
/*---------------------------------------------------------------------------*/
void
ctimer_init(void)
{
  initialized = 0;
    2fd4:	10 92 f8 25 	sts	0x25F8, r1
  list_init(ctimer_list);
    2fd8:	89 ef       	ldi	r24, 0xF9	; 249
    2fda:	95 e2       	ldi	r25, 0x25	; 37
    2fdc:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <list_init>
  process_start(&ctimer_process, NULL);
    2fe0:	86 e8       	ldi	r24, 0x86	; 134
    2fe2:	9d e0       	ldi	r25, 0x0D	; 13
    2fe4:	60 e0       	ldi	r22, 0x00	; 0
    2fe6:	70 e0       	ldi	r23, 0x00	; 0
    2fe8:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <process_start>
}
    2fec:	08 95       	ret

00002fee <ctimer_set>:
/*---------------------------------------------------------------------------*/
void
ctimer_set(struct ctimer *c, clock_time_t t,
	   void (*f)(void *), void *ptr)
{
    2fee:	0f 93       	push	r16
    2ff0:	1f 93       	push	r17
    2ff2:	cf 93       	push	r28
    2ff4:	df 93       	push	r29
    2ff6:	ec 01       	movw	r28, r24
  PRINTF("ctimer_set %p %u\n", c, (unsigned)t);
  c->p = PROCESS_CURRENT();
    2ff8:	00 91 46 25 	lds	r16, 0x2546
    2ffc:	10 91 47 25 	lds	r17, 0x2547
    3000:	1b 87       	std	Y+11, r17	; 0x0b
    3002:	0a 87       	std	Y+10, r16	; 0x0a
  c->f = f;
    3004:	5d 87       	std	Y+13, r21	; 0x0d
    3006:	4c 87       	std	Y+12, r20	; 0x0c
  c->ptr = ptr;
    3008:	3f 87       	std	Y+15, r19	; 0x0f
    300a:	2e 87       	std	Y+14, r18	; 0x0e
  if(initialized) {
    300c:	80 91 f8 25 	lds	r24, 0x25F8
    3010:	88 23       	and	r24, r24
    3012:	79 f0       	breq	.+30     	; 0x3032 <ctimer_set+0x44>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    3014:	86 e8       	ldi	r24, 0x86	; 134
    3016:	9d e0       	ldi	r25, 0x0D	; 13
    3018:	90 93 47 25 	sts	0x2547, r25
    301c:	80 93 46 25 	sts	0x2546, r24
    etimer_set(&c->etimer, t);
    3020:	ce 01       	movw	r24, r28
    3022:	02 96       	adiw	r24, 0x02	; 2
    3024:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <etimer_set>
    PROCESS_CONTEXT_END(&ctimer_process);
    3028:	10 93 47 25 	sts	0x2547, r17
    302c:	00 93 46 25 	sts	0x2546, r16
    3030:	02 c0       	rjmp	.+4      	; 0x3036 <ctimer_set+0x48>
  } else {
    c->etimer.timer.interval = t;
    3032:	7d 83       	std	Y+5, r23	; 0x05
    3034:	6c 83       	std	Y+4, r22	; 0x04
  }

  list_remove(ctimer_list, c);
    3036:	89 ef       	ldi	r24, 0xF9	; 249
    3038:	95 e2       	ldi	r25, 0x25	; 37
    303a:	be 01       	movw	r22, r28
    303c:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
  list_add(ctimer_list, c);
    3040:	89 ef       	ldi	r24, 0xF9	; 249
    3042:	95 e2       	ldi	r25, 0x25	; 37
    3044:	be 01       	movw	r22, r28
    3046:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <list_add>
}
    304a:	df 91       	pop	r29
    304c:	cf 91       	pop	r28
    304e:	1f 91       	pop	r17
    3050:	0f 91       	pop	r16
    3052:	08 95       	ret

00003054 <ctimer_reset>:
/*---------------------------------------------------------------------------*/
void
ctimer_reset(struct ctimer *c)
{
    3054:	0f 93       	push	r16
    3056:	1f 93       	push	r17
    3058:	cf 93       	push	r28
    305a:	df 93       	push	r29
    305c:	ec 01       	movw	r28, r24
  if(initialized) {
    305e:	80 91 f8 25 	lds	r24, 0x25F8
    3062:	88 23       	and	r24, r24
    3064:	91 f0       	breq	.+36     	; 0x308a <ctimer_reset+0x36>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    3066:	00 91 46 25 	lds	r16, 0x2546
    306a:	10 91 47 25 	lds	r17, 0x2547
    306e:	86 e8       	ldi	r24, 0x86	; 134
    3070:	9d e0       	ldi	r25, 0x0D	; 13
    3072:	90 93 47 25 	sts	0x2547, r25
    3076:	80 93 46 25 	sts	0x2546, r24
    etimer_reset(&c->etimer);
    307a:	ce 01       	movw	r24, r28
    307c:	02 96       	adiw	r24, 0x02	; 2
    307e:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <etimer_reset>
    PROCESS_CONTEXT_END(&ctimer_process);
    3082:	10 93 47 25 	sts	0x2547, r17
    3086:	00 93 46 25 	sts	0x2546, r16
  }

  list_remove(ctimer_list, c);
    308a:	89 ef       	ldi	r24, 0xF9	; 249
    308c:	95 e2       	ldi	r25, 0x25	; 37
    308e:	be 01       	movw	r22, r28
    3090:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
  list_add(ctimer_list, c);
    3094:	89 ef       	ldi	r24, 0xF9	; 249
    3096:	95 e2       	ldi	r25, 0x25	; 37
    3098:	be 01       	movw	r22, r28
    309a:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <list_add>
}
    309e:	df 91       	pop	r29
    30a0:	cf 91       	pop	r28
    30a2:	1f 91       	pop	r17
    30a4:	0f 91       	pop	r16
    30a6:	08 95       	ret

000030a8 <ctimer_restart>:
/*---------------------------------------------------------------------------*/
void
ctimer_restart(struct ctimer *c)
{
    30a8:	0f 93       	push	r16
    30aa:	1f 93       	push	r17
    30ac:	cf 93       	push	r28
    30ae:	df 93       	push	r29
    30b0:	ec 01       	movw	r28, r24
  if(initialized) {
    30b2:	80 91 f8 25 	lds	r24, 0x25F8
    30b6:	88 23       	and	r24, r24
    30b8:	91 f0       	breq	.+36     	; 0x30de <ctimer_restart+0x36>
    PROCESS_CONTEXT_BEGIN(&ctimer_process);
    30ba:	00 91 46 25 	lds	r16, 0x2546
    30be:	10 91 47 25 	lds	r17, 0x2547
    30c2:	86 e8       	ldi	r24, 0x86	; 134
    30c4:	9d e0       	ldi	r25, 0x0D	; 13
    30c6:	90 93 47 25 	sts	0x2547, r25
    30ca:	80 93 46 25 	sts	0x2546, r24
    etimer_restart(&c->etimer);
    30ce:	ce 01       	movw	r24, r28
    30d0:	02 96       	adiw	r24, 0x02	; 2
    30d2:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <etimer_restart>
    PROCESS_CONTEXT_END(&ctimer_process);
    30d6:	10 93 47 25 	sts	0x2547, r17
    30da:	00 93 46 25 	sts	0x2546, r16
  }

  list_remove(ctimer_list, c);
    30de:	89 ef       	ldi	r24, 0xF9	; 249
    30e0:	95 e2       	ldi	r25, 0x25	; 37
    30e2:	be 01       	movw	r22, r28
    30e4:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
  list_add(ctimer_list, c);
    30e8:	89 ef       	ldi	r24, 0xF9	; 249
    30ea:	95 e2       	ldi	r25, 0x25	; 37
    30ec:	be 01       	movw	r22, r28
    30ee:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <list_add>
}
    30f2:	df 91       	pop	r29
    30f4:	cf 91       	pop	r28
    30f6:	1f 91       	pop	r17
    30f8:	0f 91       	pop	r16
    30fa:	08 95       	ret

000030fc <ctimer_stop>:
/*---------------------------------------------------------------------------*/
void
ctimer_stop(struct ctimer *c)
{
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
    3100:	ec 01       	movw	r28, r24
  if(initialized) {
    3102:	80 91 f8 25 	lds	r24, 0x25F8
    3106:	88 23       	and	r24, r24
    3108:	29 f0       	breq	.+10     	; 0x3114 <ctimer_stop+0x18>
    etimer_stop(&c->etimer);
    310a:	ce 01       	movw	r24, r28
    310c:	02 96       	adiw	r24, 0x02	; 2
    310e:	0e 94 4f 17 	call	0x2e9e	; 0x2e9e <etimer_stop>
    3112:	04 c0       	rjmp	.+8      	; 0x311c <ctimer_stop+0x20>
  } else {
    c->etimer.next = NULL;
    3114:	1f 82       	std	Y+7, r1	; 0x07
    3116:	1e 82       	std	Y+6, r1	; 0x06
    c->etimer.p = PROCESS_NONE;
    3118:	19 86       	std	Y+9, r1	; 0x09
    311a:	18 86       	std	Y+8, r1	; 0x08
  }
  list_remove(ctimer_list, c);
    311c:	89 ef       	ldi	r24, 0xF9	; 249
    311e:	95 e2       	ldi	r25, 0x25	; 37
    3120:	be 01       	movw	r22, r28
    3122:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
}
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	08 95       	ret

0000312c <ctimer_expired>:
/*---------------------------------------------------------------------------*/
int
ctimer_expired(struct ctimer *c)
{
    312c:	cf 93       	push	r28
    312e:	df 93       	push	r29
    3130:	ec 01       	movw	r28, r24
  struct ctimer *t;
  if(initialized) {
    3132:	80 91 f8 25 	lds	r24, 0x25F8
    3136:	88 23       	and	r24, r24
    3138:	31 f0       	breq	.+12     	; 0x3146 <ctimer_expired+0x1a>
    return etimer_expired(&c->etimer);
    313a:	ce 01       	movw	r24, r28
    313c:	02 96       	adiw	r24, 0x02	; 2
    313e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <etimer_expired>
    3142:	9c 01       	movw	r18, r24
    3144:	14 c0       	rjmp	.+40     	; 0x316e <ctimer_expired+0x42>
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    3146:	89 ef       	ldi	r24, 0xF9	; 249
    3148:	95 e2       	ldi	r25, 0x25	; 37
    314a:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    314e:	e8 2f       	mov	r30, r24
    3150:	f9 2f       	mov	r31, r25
    3152:	06 c0       	rjmp	.+12     	; 0x3160 <ctimer_expired+0x34>
    if(t == c) {
    3154:	ec 17       	cp	r30, r28
    3156:	fd 07       	cpc	r31, r29
    3158:	41 f0       	breq	.+16     	; 0x316a <ctimer_expired+0x3e>
{
  struct ctimer *t;
  if(initialized) {
    return etimer_expired(&c->etimer);
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    315a:	01 90       	ld	r0, Z+
    315c:	f0 81       	ld	r31, Z
    315e:	e0 2d       	mov	r30, r0
    3160:	30 97       	sbiw	r30, 0x00	; 0
    3162:	c1 f7       	brne	.-16     	; 0x3154 <ctimer_expired+0x28>
    if(t == c) {
      return 0;
    }
  }
  return 1;
    3164:	21 e0       	ldi	r18, 0x01	; 1
    3166:	30 e0       	ldi	r19, 0x00	; 0
    3168:	02 c0       	rjmp	.+4      	; 0x316e <ctimer_expired+0x42>
  if(initialized) {
    return etimer_expired(&c->etimer);
  }
  for(t = list_head(ctimer_list); t != NULL; t = t->next) {
    if(t == c) {
      return 0;
    316a:	20 e0       	ldi	r18, 0x00	; 0
    316c:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 1;
}
    316e:	c9 01       	movw	r24, r18
    3170:	df 91       	pop	r29
    3172:	cf 91       	pop	r28
    3174:	08 95       	ret

00003176 <rng_get_uint8>:
uint8_t
rng_get_uint8(void) {
#if 1
  /* Upper two RSSI reg bits (RND_VALUE) are random in rf231 */
  uint8_t j;
  j = (PHY_RSSI&0xc0) + ((PHY_RSSI>>2)&0x30) + ((PHY_RSSI>>4)&0x0c) + ((PHY_RSSI>>6)&0x03);
    3176:	e6 e4       	ldi	r30, 0x46	; 70
    3178:	f1 e0       	ldi	r31, 0x01	; 1
    317a:	30 81       	ld	r19, Z
    317c:	20 81       	ld	r18, Z
    317e:	90 81       	ld	r25, Z
    3180:	80 81       	ld	r24, Z
    3182:	82 95       	swap	r24
    3184:	86 95       	lsr	r24
    3186:	86 95       	lsr	r24
    3188:	83 70       	andi	r24, 0x03	; 3
    318a:	30 7c       	andi	r19, 0xC0	; 192
    318c:	83 0f       	add	r24, r19
    318e:	26 95       	lsr	r18
    3190:	26 95       	lsr	r18
    3192:	20 73       	andi	r18, 0x30	; 48
    3194:	82 0f       	add	r24, r18
    3196:	92 95       	swap	r25
    3198:	9c 70       	andi	r25, 0x0C	; 12
  }
  ADCSRA=0;                   //Disable ADC
#endif
  PRINTD("rng issues %d\n",j);
  return j;
}
    319a:	89 0f       	add	r24, r25
    319c:	08 95       	ret

0000319e <initialize>:

/*-------------------------Low level initialization------------------------*/
/*------Done in a subroutine to keep main routine stack usage small--------*/
void initialize(void)
{
    319e:	bf 92       	push	r11
    31a0:	cf 92       	push	r12
    31a2:	df 92       	push	r13
    31a4:	ef 92       	push	r14
    31a6:	ff 92       	push	r15
    31a8:	0f 93       	push	r16
    31aa:	1f 93       	push	r17
    31ac:	df 93       	push	r29
    31ae:	cf 93       	push	r28
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <initialize+0x14>
    31b2:	cd b7       	in	r28, 0x3d	; 61
    31b4:	de b7       	in	r29, 0x3e	; 62
  watchdog_init();
    31b6:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <watchdog_init>
  watchdog_start();
    31ba:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <watchdog_start>
#ifdef RAVEN_LCD_INTERFACE
  rs232_init(RS232_PORT_0, USART_BAUD_38400,USART_PARITY_NONE | USART_STOP_BITS_1 | USART_DATA_BITS_8);
  rs232_set_input(0,raven_lcd_serial_input);
#else
  /* Generic or slip connection on uart0 */
  rs232_init(RS232_PORT_0, USART_BAUD_38400,USART_PARITY_NONE | USART_STOP_BITS_1 | USART_DATA_BITS_8);
    31be:	80 e0       	ldi	r24, 0x00	; 0
    31c0:	6c e0       	ldi	r22, 0x0C	; 12
    31c2:	46 e0       	ldi	r20, 0x06	; 6
    31c4:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <rs232_init>
#endif
#endif

  /* Second rs232 port for debugging or slip alternative */
  rs232_init(RS232_PORT_1, USART_BAUD_57600,USART_PARITY_NONE | USART_STOP_BITS_1 | USART_DATA_BITS_8);
    31c8:	81 e0       	ldi	r24, 0x01	; 1
    31ca:	68 e0       	ldi	r22, 0x08	; 8
    31cc:	46 e0       	ldi	r20, 0x06	; 6
    31ce:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <rs232_init>
  /* Redirect stdout */
#if RF230BB_CONF_LEDONPORTE1 || defined(RAVEN_LCD_INTERFACE)
  rs232_redirect_stdout(RS232_PORT_1);
#else
  rs232_redirect_stdout(RS232_PORT_0);
    31d2:	80 e0       	ldi	r24, 0x00	; 0
    31d4:	0e 94 73 1d 	call	0x3ae6	; 0x3ae6 <rs232_redirect_stdout>
#endif
  clock_init();
    31d8:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <clock_init>

  if(MCUSR & (1<<PORF )) PRINTD("Power-on reset.\n");
    31dc:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<EXTRF)) PRINTD("External reset!\n");
    31de:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<BORF )) PRINTD("Brownout reset!\n");
    31e0:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<WDRF )) PRINTD("Watchdog reset!\n");
    31e2:	84 b7       	in	r24, 0x34	; 52
  if(MCUSR & (1<<JTRF )) PRINTD("JTAG reset!\n");
    31e4:	84 b7       	in	r24, 0x34	; 52
   * loop. In conjuction with PERIODICPRINTS, never-used stack will be printed
   * every STACKMONITOR seconds.
   */
{
extern uint16_t __bss_end;
uint16_t p=(uint16_t)&__bss_end;
    31e6:	ea ec       	ldi	r30, 0xCA	; 202
    31e8:	f6 e3       	ldi	r31, 0x36	; 54
    do {
      *(uint16_t *)p = 0x4242;
    31ea:	22 e4       	ldi	r18, 0x42	; 66
    31ec:	32 e4       	ldi	r19, 0x42	; 66
    31ee:	31 83       	std	Z+1, r19	; 0x01
    31f0:	20 83       	st	Z, r18
      p+=10;
    31f2:	3a 96       	adiw	r30, 0x0a	; 10
    } while (p<SP-10); //don't overwrite our own stack
    31f4:	8d b7       	in	r24, 0x3d	; 61
    31f6:	9e b7       	in	r25, 0x3e	; 62
    31f8:	0a 97       	sbiw	r24, 0x0a	; 10
    31fa:	e8 17       	cp	r30, r24
    31fc:	f9 07       	cpc	r31, r25
    31fe:	b8 f3       	brcs	.-18     	; 0x31ee <initialize+0x50>
 }
   clock_init();
}
#endif 

  PRINTA("\n*******Booting %s*******\n",CONTIKI_VERSION_STRING);
    3200:	00 d0       	rcall	.+0      	; 0x3202 <initialize+0x64>
    3202:	00 d0       	rcall	.+0      	; 0x3204 <initialize+0x66>
    3204:	80 eb       	ldi	r24, 0xB0	; 176
    3206:	91 e0       	ldi	r25, 0x01	; 1
    3208:	ad b7       	in	r26, 0x3d	; 61
    320a:	be b7       	in	r27, 0x3e	; 62
    320c:	12 96       	adiw	r26, 0x02	; 2
    320e:	9c 93       	st	X, r25
    3210:	8e 93       	st	-X, r24
    3212:	11 97       	sbiw	r26, 0x01	; 1
    3214:	80 e9       	ldi	r24, 0x90	; 144
    3216:	9d e0       	ldi	r25, 0x0D	; 13
    3218:	14 96       	adiw	r26, 0x04	; 4
    321a:	9c 93       	st	X, r25
    321c:	8e 93       	st	-X, r24
    321e:	13 97       	sbiw	r26, 0x03	; 3
    3220:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>

/* rtimers needed for radio cycling */
  rtimer_init();
    3224:	0f 90       	pop	r0
    3226:	0f 90       	pop	r0
    3228:	0f 90       	pop	r0
    322a:	0f 90       	pop	r0
    322c:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <rtimer_init>

 /* Initialize process subsystem */
  process_init();
    3230:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <process_init>

  /* etimers must be started before ctimer_init */
  process_start(&etimer_process, NULL);
    3234:	8d e6       	ldi	r24, 0x6D	; 109
    3236:	9d e0       	ldi	r25, 0x0D	; 13
    3238:	60 e0       	ldi	r22, 0x00	; 0
    323a:	70 e0       	ldi	r23, 0x00	; 0
    323c:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <process_start>
  ctimer_init();
    3240:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <ctimer_init>

  /* Start radio and radio receive process */
  NETSTACK_RADIO.init();
    3244:	e0 91 c1 0d 	lds	r30, 0x0DC1
    3248:	f0 91 c2 0d 	lds	r31, 0x0DC2
    324c:	09 95       	icall

/* Get a random seed for the 802.15.4 packet sequence number.
 * Some layers will ignore duplicates found in a history (e.g. Contikimac)
 * causing the initial packets to be ignored after a short-cycle restart.
 */
  random_init(rng_get_uint8());
    324e:	0e 94 bb 18 	call	0x3176	; 0x3176 <rng_get_uint8>
    3252:	90 e0       	ldi	r25, 0x00	; 0
    3254:	0e 94 7a 30 	call	0x60f4	; 0x60f4 <random_init>

  /* Set addresses BEFORE starting tcpip process */

  rimeaddr_t addr;

  if (params_get_eui64(addr.u8)) {
    3258:	ce 01       	movw	r24, r28
    325a:	01 96       	adiw	r24, 0x01	; 1
    325c:	0e 94 37 1b 	call	0x366e	; 0x366e <params_get_eui64>
    3260:	88 23       	and	r24, r24
    3262:	59 f0       	breq	.+22     	; 0x327a <initialize+0xdc>
      PRINTA("Random EUI64 address generated\n");
    3264:	00 d0       	rcall	.+0      	; 0x3266 <initialize+0xc8>
    3266:	80 e9       	ldi	r24, 0x90	; 144
    3268:	91 e0       	ldi	r25, 0x01	; 1
    326a:	ed b7       	in	r30, 0x3d	; 61
    326c:	fe b7       	in	r31, 0x3e	; 62
    326e:	92 83       	std	Z+2, r25	; 0x02
    3270:	81 83       	std	Z+1, r24	; 0x01
    3272:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
    3276:	0f 90       	pop	r0
    3278:	0f 90       	pop	r0
  node_id=get_panaddr_from_eeprom();
  addr.u8[1]=node_id&0xff;
  addr.u8[0]=(node_id&0xff00)>>8;
  PRINTA("Node ID from eeprom: %X\n",node_id);
#endif  
  rimeaddr_set_node_addr(&addr); 
    327a:	8e 01       	movw	r16, r28
    327c:	0f 5f       	subi	r16, 0xFF	; 255
    327e:	1f 4f       	sbci	r17, 0xFF	; 255
    3280:	c8 01       	movw	r24, r16
    3282:	0e 94 2b 25 	call	0x4a56	; 0x4a56 <rimeaddr_set_node_addr>

  rf230_set_pan_addr(params_get_panid(),params_get_panaddr(),(uint8_t *)&addr.u8);
    3286:	0e 94 41 1b 	call	0x3682	; 0x3682 <params_get_panid>
    328a:	7c 01       	movw	r14, r24
    328c:	0e 94 46 1b 	call	0x368c	; 0x368c <params_get_panaddr>
    3290:	bc 01       	movw	r22, r24
    3292:	c7 01       	movw	r24, r14
    3294:	a8 01       	movw	r20, r16
    3296:	0e 94 a4 20 	call	0x4148	; 0x4148 <rf230_set_pan_addr>
  rf230_set_channel(params_get_channel());
    329a:	0e 94 9f 1a 	call	0x353e	; 0x353e <params_get_channel>
    329e:	0e 94 89 20 	call	0x4112	; 0x4112 <rf230_set_channel>
  rf230_set_txpower(params_get_txpower());
    32a2:	0e 94 4b 1b 	call	0x3696	; 0x3696 <params_get_txpower>
    32a6:	0e 94 34 22 	call	0x4468	; 0x4468 <rf230_set_txpower>

#if UIP_CONF_IPV6
  PRINTA("EUI-64 MAC: %x-%x-%x-%x-%x-%x-%x-%x\n",addr.u8[0],addr.u8[1],addr.u8[2],addr.u8[3],addr.u8[4],addr.u8[5],addr.u8[6],addr.u8[7]);
#else
  PRINTA("MAC address ");
    32aa:	00 d0       	rcall	.+0      	; 0x32ac <initialize+0x10e>
    32ac:	83 e8       	ldi	r24, 0x83	; 131
    32ae:	91 e0       	ldi	r25, 0x01	; 1
    32b0:	ad b7       	in	r26, 0x3d	; 61
    32b2:	be b7       	in	r27, 0x3e	; 62
    32b4:	12 96       	adiw	r26, 0x02	; 2
    32b6:	9c 93       	st	X, r25
    32b8:	8e 93       	st	-X, r24
    32ba:	11 97       	sbiw	r26, 0x01	; 1
    32bc:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
  uint8_t i;
  for (i=sizeof(rimeaddr_t); i>0; i--){
    PRINTA("%x:",addr.u8[i-1]);
    32c0:	00 d0       	rcall	.+0      	; 0x32c2 <initialize+0x124>
    32c2:	ed b7       	in	r30, 0x3d	; 61
    32c4:	fe b7       	in	r31, 0x3e	; 62
    32c6:	31 96       	adiw	r30, 0x01	; 1
    32c8:	0f e7       	ldi	r16, 0x7F	; 127
    32ca:	11 e0       	ldi	r17, 0x01	; 1
    32cc:	ad b7       	in	r26, 0x3d	; 61
    32ce:	be b7       	in	r27, 0x3e	; 62
    32d0:	12 96       	adiw	r26, 0x02	; 2
    32d2:	1c 93       	st	X, r17
    32d4:	0e 93       	st	-X, r16
    32d6:	11 97       	sbiw	r26, 0x01	; 1
    32d8:	8a 81       	ldd	r24, Y+2	; 0x02
    32da:	82 83       	std	Z+2, r24	; 0x02
    32dc:	13 82       	std	Z+3, r1	; 0x03
    32de:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
    32e2:	ed b7       	in	r30, 0x3d	; 61
    32e4:	fe b7       	in	r31, 0x3e	; 62
    32e6:	31 96       	adiw	r30, 0x01	; 1
    32e8:	ad b7       	in	r26, 0x3d	; 61
    32ea:	be b7       	in	r27, 0x3e	; 62
    32ec:	12 96       	adiw	r26, 0x02	; 2
    32ee:	1c 93       	st	X, r17
    32f0:	0e 93       	st	-X, r16
    32f2:	11 97       	sbiw	r26, 0x01	; 1
    32f4:	89 81       	ldd	r24, Y+1	; 0x01
    32f6:	82 83       	std	Z+2, r24	; 0x02
    32f8:	13 82       	std	Z+3, r1	; 0x03
    32fa:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
  }
  PRINTA("\n");
    32fe:	0f 90       	pop	r0
    3300:	0f 90       	pop	r0
    3302:	8d e7       	ldi	r24, 0x7D	; 125
    3304:	91 e0       	ldi	r25, 0x01	; 1
    3306:	ed b7       	in	r30, 0x3d	; 61
    3308:	fe b7       	in	r31, 0x3e	; 62
    330a:	92 83       	std	Z+2, r25	; 0x02
    330c:	81 83       	std	Z+1, r24	; 0x01
    330e:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
#endif

  /* Initialize stack protocols */
  queuebuf_init();
    3312:	0f 90       	pop	r0
    3314:	0f 90       	pop	r0
    3316:	0e 94 58 32 	call	0x64b0	; 0x64b0 <queuebuf_init>
  NETSTACK_RDC.init();
    331a:	e0 91 33 0e 	lds	r30, 0x0E33
    331e:	f0 91 34 0e 	lds	r31, 0x0E34
    3322:	09 95       	icall
  NETSTACK_MAC.init();
    3324:	e0 91 1a 0e 	lds	r30, 0x0E1A
    3328:	f0 91 1b 0e 	lds	r31, 0x0E1B
    332c:	09 95       	icall
  NETSTACK_NETWORK.init();
    332e:	e0 91 ef 0d 	lds	r30, 0x0DEF
    3332:	f0 91 f0 0d 	lds	r31, 0x0DF0
    3336:	09 95       	icall

#if ANNOUNCE_BOOT
  PRINTA("%s %s, channel %u , check rate %u Hz tx power %u\n",NETSTACK_MAC.name, NETSTACK_RDC.name, rf230_get_channel(),
    3338:	00 91 18 0e 	lds	r16, 0x0E18
    333c:	10 91 19 0e 	lds	r17, 0x0E19
    3340:	c0 90 31 0e 	lds	r12, 0x0E31
    3344:	d0 90 32 0e 	lds	r13, 0x0E32
    3348:	0e 94 86 20 	call	0x410c	; 0x410c <rf230_get_channel>
    334c:	b8 2e       	mov	r11, r24
    334e:	e0 90 3f 0e 	lds	r14, 0x0E3F
    3352:	f0 90 40 0e 	lds	r15, 0x0E40
    3356:	f7 01       	movw	r30, r14
    3358:	09 95       	icall
    335a:	00 97       	sbiw	r24, 0x00	; 0
    335c:	49 f0       	breq	.+18     	; 0x3370 <initialize+0x1d2>
    335e:	f7 01       	movw	r30, r14
    3360:	09 95       	icall
    3362:	bc 01       	movw	r22, r24
    3364:	80 e8       	ldi	r24, 0x80	; 128
    3366:	90 e0       	ldi	r25, 0x00	; 0
    3368:	0e 94 63 4a 	call	0x94c6	; 0x94c6 <__udivmodhi4>
    336c:	7b 01       	movw	r14, r22
    336e:	03 c0       	rjmp	.+6      	; 0x3376 <initialize+0x1d8>
    3370:	80 e8       	ldi	r24, 0x80	; 128
    3372:	e8 2e       	mov	r14, r24
    3374:	f1 2c       	mov	r15, r1
    3376:	0e 94 37 22 	call	0x446e	; 0x446e <rf230_get_txpower>
    337a:	2d b7       	in	r18, 0x3d	; 61
    337c:	3e b7       	in	r19, 0x3e	; 62
    337e:	2c 50       	subi	r18, 0x0C	; 12
    3380:	30 40       	sbci	r19, 0x00	; 0
    3382:	0f b6       	in	r0, 0x3f	; 63
    3384:	f8 94       	cli
    3386:	3e bf       	out	0x3e, r19	; 62
    3388:	0f be       	out	0x3f, r0	; 63
    338a:	2d bf       	out	0x3d, r18	; 61
    338c:	ed b7       	in	r30, 0x3d	; 61
    338e:	fe b7       	in	r31, 0x3e	; 62
    3390:	31 96       	adiw	r30, 0x01	; 1
    3392:	2b e4       	ldi	r18, 0x4B	; 75
    3394:	31 e0       	ldi	r19, 0x01	; 1
    3396:	ad b7       	in	r26, 0x3d	; 61
    3398:	be b7       	in	r27, 0x3e	; 62
    339a:	12 96       	adiw	r26, 0x02	; 2
    339c:	3c 93       	st	X, r19
    339e:	2e 93       	st	-X, r18
    33a0:	11 97       	sbiw	r26, 0x01	; 1
    33a2:	13 83       	std	Z+3, r17	; 0x03
    33a4:	02 83       	std	Z+2, r16	; 0x02
    33a6:	d5 82       	std	Z+5, r13	; 0x05
    33a8:	c4 82       	std	Z+4, r12	; 0x04
    33aa:	b6 82       	std	Z+6, r11	; 0x06
    33ac:	17 82       	std	Z+7, r1	; 0x07
    33ae:	f1 86       	std	Z+9, r15	; 0x09
    33b0:	e0 86       	std	Z+8, r14	; 0x08
    33b2:	82 87       	std	Z+10, r24	; 0x0a
    33b4:	13 86       	std	Z+11, r1	; 0x0b
    33b6:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
  PRINTA("Routing Enabled\n");
#endif

#endif /* ANNOUNCE_BOOT */

  process_start(&tcpip_process, NULL);
    33ba:	ed b7       	in	r30, 0x3d	; 61
    33bc:	fe b7       	in	r31, 0x3e	; 62
    33be:	3c 96       	adiw	r30, 0x0c	; 12
    33c0:	0f b6       	in	r0, 0x3f	; 63
    33c2:	f8 94       	cli
    33c4:	fe bf       	out	0x3e, r31	; 62
    33c6:	0f be       	out	0x3f, r0	; 63
    33c8:	ed bf       	out	0x3d, r30	; 61
    33ca:	86 e6       	ldi	r24, 0x66	; 102
    33cc:	9e e0       	ldi	r25, 0x0E	; 14
    33ce:	60 e0       	ldi	r22, 0x00	; 0
    33d0:	70 e0       	ldi	r23, 0x00	; 0
    33d2:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <process_start>
#ifdef RAVEN_LCD_INTERFACE
  process_start(&raven_lcd_process, NULL);
#endif

  /* Autostart other processes */
  autostart_start(autostart_processes);
    33d6:	8e e6       	ldi	r24, 0x6E	; 110
    33d8:	92 e0       	ldi	r25, 0x02	; 2
    33da:	0e 94 93 2c 	call	0x5926	; 0x5926 <autostart_start>
#elif COFFEE_FILES==4
   PRINTA(".%s online with dynamic %u KB program memory file system\n",buf,size>>10);
#endif /* COFFEE_FILES */
}
#else
   PRINTA("Online\n");
    33de:	00 d0       	rcall	.+0      	; 0x33e0 <initialize+0x242>
    33e0:	83 e4       	ldi	r24, 0x43	; 67
    33e2:	91 e0       	ldi	r25, 0x01	; 1
    33e4:	ad b7       	in	r26, 0x3d	; 61
    33e6:	be b7       	in	r27, 0x3e	; 62
    33e8:	12 96       	adiw	r26, 0x02	; 2
    33ea:	9c 93       	st	X, r25
    33ec:	8e 93       	st	-X, r24
    33ee:	11 97       	sbiw	r26, 0x01	; 1
    33f0:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
#if RF230BB_CONF_LEDONPORTE1
  /* NB: PORTE1 conflicts with UART0 */
  DDRE|=(1<<DDE1);  //set led pin to output (Micheal Hatrtman board)
  PORTE&=~(1<<PE1); //and low to turn led off
#endif
}
    33f4:	0f 90       	pop	r0
    33f6:	0f 90       	pop	r0
    33f8:	0f 90       	pop	r0
    33fa:	0f 90       	pop	r0
    33fc:	cf 91       	pop	r28
    33fe:	df 91       	pop	r29
    3400:	1f 91       	pop	r17
    3402:	0f 91       	pop	r16
    3404:	ff 90       	pop	r15
    3406:	ef 90       	pop	r14
    3408:	df 90       	pop	r13
    340a:	cf 90       	pop	r12
    340c:	bf 90       	pop	r11
    340e:	08 95       	ret

00003410 <main>:
/*-------------------------------------------------------------------------*/
/*------------------------- Main Scheduler loop----------------------------*/
/*-------------------------------------------------------------------------*/
int
main(void)
{
    3410:	af 92       	push	r10
    3412:	bf 92       	push	r11
    3414:	cf 92       	push	r12
    3416:	df 92       	push	r13
    3418:	ef 92       	push	r14
    341a:	ff 92       	push	r15
    341c:	0f 93       	push	r16
    341e:	1f 93       	push	r17
    3420:	cf 93       	push	r28
    3422:	df 93       	push	r29
  initialize();
    3424:	0e 94 cf 18 	call	0x319e	; 0x319e <initialize>
  if (clocktime!=clock_seconds()) {
     clocktime=clock_seconds();
#endif

#if STAMPS
if ((clocktime%STAMPS)==0) {
    3428:	9c e3       	ldi	r25, 0x3C	; 60
    342a:	a9 2e       	mov	r10, r25
    342c:	b1 2c       	mov	r11, r1
    342e:	c1 2c       	mov	r12, r1
    3430:	d1 2c       	mov	r13, r1
if ((clocktime%STACKMONITOR)==3) {
  extern uint16_t __bss_end;
  uint16_t p=(uint16_t)&__bss_end;
  do {
    if (*(uint16_t *)p != 0x4242) {
      PRINTF("Never-used stack > %d bytes\n",p-(uint16_t)&__bss_end);
    3432:	c6 e2       	ldi	r28, 0x26	; 38
    3434:	d1 e0       	ldi	r29, 0x01	; 1
main(void)
{
  initialize();

  while(1) {
    process_run();
    3436:	0e 94 25 15 	call	0x2a4a	; 0x2a4a <process_run>
    watchdog_periodic();
    343a:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <watchdog_periodic>

    /* Turn off LED after a while */
    if (ledtimer) {
    343e:	80 91 11 2e 	lds	r24, 0x2E11
    3442:	90 91 12 2e 	lds	r25, 0x2E12
    3446:	00 97       	sbiw	r24, 0x00	; 0
    3448:	29 f0       	breq	.+10     	; 0x3454 <main+0x44>
      if (--ledtimer==0) {
    344a:	01 97       	sbiw	r24, 0x01	; 1
    344c:	90 93 12 2e 	sts	0x2E12, r25
    3450:	80 93 11 2e 	sts	0x2E11, r24
 */
    if (rtimerflag) {
      rtimer_set(&rt, RTIMER_NOW()+ RTIMER_ARCH_SECOND*1UL, 1,(void *) rtimercycle, NULL);
      rtimerflag=0;
#else
  if (clocktime!=clock_seconds()) {
    3454:	e0 90 13 2e 	lds	r14, 0x2E13
    3458:	f0 90 14 2e 	lds	r15, 0x2E14
    345c:	00 91 15 2e 	lds	r16, 0x2E15
    3460:	10 91 16 2e 	lds	r17, 0x2E16
    3464:	0e 94 6d 1b 	call	0x36da	; 0x36da <clock_seconds>
    3468:	e6 16       	cp	r14, r22
    346a:	f7 06       	cpc	r15, r23
    346c:	08 07       	cpc	r16, r24
    346e:	19 07       	cpc	r17, r25
    3470:	11 f3       	breq	.-60     	; 0x3436 <main+0x26>
     clocktime=clock_seconds();
    3472:	0e 94 6d 1b 	call	0x36da	; 0x36da <clock_seconds>
    3476:	60 93 13 2e 	sts	0x2E13, r22
    347a:	70 93 14 2e 	sts	0x2E14, r23
    347e:	80 93 15 2e 	sts	0x2E15, r24
    3482:	90 93 16 2e 	sts	0x2E16, r25
#endif

#if STAMPS
if ((clocktime%STAMPS)==0) {
    3486:	a6 01       	movw	r20, r12
    3488:	95 01       	movw	r18, r10
    348a:	0e 94 8a 4a 	call	0x9514	; 0x9514 <__udivmodsi4>
    348e:	61 15       	cp	r22, r1
    3490:	71 05       	cpc	r23, r1
    3492:	81 05       	cpc	r24, r1
    3494:	91 05       	cpc	r25, r1
    3496:	11 f4       	brne	.+4      	; 0x349c <main+0x8c>
#if ENERGEST_CONF_ON
#include "lib/print-stats.h"
	print_stats();
    3498:	0e 94 bb 2e 	call	0x5d76	; 0x5d76 <print_stats>
  PRINTF("\n---------\n");
}
#endif

#if STACKMONITOR
if ((clocktime%STACKMONITOR)==3) {
    349c:	80 91 13 2e 	lds	r24, 0x2E13
    34a0:	90 91 14 2e 	lds	r25, 0x2E14
    34a4:	a0 91 15 2e 	lds	r26, 0x2E15
    34a8:	b0 91 16 2e 	lds	r27, 0x2E16
    34ac:	93 70       	andi	r25, 0x03	; 3
    34ae:	a0 70       	andi	r26, 0x00	; 0
    34b0:	b0 70       	andi	r27, 0x00	; 0
    34b2:	83 30       	cpi	r24, 0x03	; 3
    34b4:	91 05       	cpc	r25, r1
    34b6:	a1 05       	cpc	r26, r1
    34b8:	b1 05       	cpc	r27, r1
    34ba:	09 f0       	breq	.+2      	; 0x34be <main+0xae>
    34bc:	bc cf       	rjmp	.-136    	; 0x3436 <main+0x26>
  extern uint16_t __bss_end;
  uint16_t p=(uint16_t)&__bss_end;
    34be:	ea ec       	ldi	r30, 0xCA	; 202
    34c0:	f6 e3       	ldi	r31, 0x36	; 54
  do {
    if (*(uint16_t *)p != 0x4242) {
    34c2:	80 81       	ld	r24, Z
    34c4:	91 81       	ldd	r25, Z+1	; 0x01
    34c6:	22 e4       	ldi	r18, 0x42	; 66
    34c8:	82 34       	cpi	r24, 0x42	; 66
    34ca:	92 07       	cpc	r25, r18
    34cc:	a9 f0       	breq	.+42     	; 0x34f8 <main+0xe8>
      PRINTF("Never-used stack > %d bytes\n",p-(uint16_t)&__bss_end);
    34ce:	00 d0       	rcall	.+0      	; 0x34d0 <main+0xc0>
    34d0:	00 d0       	rcall	.+0      	; 0x34d2 <main+0xc2>
    34d2:	ad b7       	in	r26, 0x3d	; 61
    34d4:	be b7       	in	r27, 0x3e	; 62
    34d6:	12 96       	adiw	r26, 0x02	; 2
    34d8:	dc 93       	st	X, r29
    34da:	ce 93       	st	-X, r28
    34dc:	11 97       	sbiw	r26, 0x01	; 1
    34de:	ea 5c       	subi	r30, 0xCA	; 202
    34e0:	f6 43       	sbci	r31, 0x36	; 54
    34e2:	14 96       	adiw	r26, 0x04	; 4
    34e4:	fc 93       	st	X, r31
    34e6:	ee 93       	st	-X, r30
    34e8:	13 97       	sbiw	r26, 0x03	; 3
    34ea:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
      break;
    34ee:	0f 90       	pop	r0
    34f0:	0f 90       	pop	r0
    34f2:	0f 90       	pop	r0
    34f4:	0f 90       	pop	r0
    34f6:	9f cf       	rjmp	.-194    	; 0x3436 <main+0x26>
    }
    p+=10;
    34f8:	3a 96       	adiw	r30, 0x0a	; 10
  } while (p<RAMEND-10);
    34fa:	b1 e4       	ldi	r27, 0x41	; 65
    34fc:	e5 3f       	cpi	r30, 0xF5	; 245
    34fe:	fb 07       	cpc	r31, r27
    3500:	00 f3       	brcs	.-64     	; 0x34c2 <main+0xb2>
    3502:	99 cf       	rjmp	.-206    	; 0x3436 <main+0x26>

00003504 <log_message>:

/*---------------------------------------------------------------------------*/

void log_message(char *m1, char *m2)
{
  PRINTF("%s%s\n", m1, m2);
    3504:	00 d0       	rcall	.+0      	; 0x3506 <log_message+0x2>
    3506:	00 d0       	rcall	.+0      	; 0x3508 <log_message+0x4>
    3508:	00 d0       	rcall	.+0      	; 0x350a <log_message+0x6>
    350a:	ed b7       	in	r30, 0x3d	; 61
    350c:	fe b7       	in	r31, 0x3e	; 62
    350e:	31 96       	adiw	r30, 0x01	; 1
    3510:	20 e2       	ldi	r18, 0x20	; 32
    3512:	31 e0       	ldi	r19, 0x01	; 1
    3514:	ad b7       	in	r26, 0x3d	; 61
    3516:	be b7       	in	r27, 0x3e	; 62
    3518:	12 96       	adiw	r26, 0x02	; 2
    351a:	3c 93       	st	X, r19
    351c:	2e 93       	st	-X, r18
    351e:	11 97       	sbiw	r26, 0x01	; 1
    3520:	93 83       	std	Z+3, r25	; 0x03
    3522:	82 83       	std	Z+2, r24	; 0x02
    3524:	75 83       	std	Z+5, r23	; 0x05
    3526:	64 83       	std	Z+4, r22	; 0x04
    3528:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
    352c:	8d b7       	in	r24, 0x3d	; 61
    352e:	9e b7       	in	r25, 0x3e	; 62
    3530:	06 96       	adiw	r24, 0x06	; 6
    3532:	0f b6       	in	r0, 0x3f	; 63
    3534:	f8 94       	cli
    3536:	9e bf       	out	0x3e, r25	; 62
    3538:	0f be       	out	0x3f, r0	; 63
    353a:	8d bf       	out	0x3d, r24	; 61
}
    353c:	08 95       	ret

0000353e <params_get_channel>:
#if CONTIKI_CONF_RANDOM_MAC
static uint8_t randomeui64;
#endif

uint8_t
params_get_channel(void) {
    353e:	0f 93       	push	r16
    3540:	1f 93       	push	r17
    3542:	df 93       	push	r29
    3544:	cf 93       	push	r28
    3546:	cd b7       	in	r28, 0x3d	; 61
    3548:	de b7       	in	r29, 0x3e	; 62
    354a:	a2 97       	sbiw	r28, 0x22	; 34
    354c:	0f b6       	in	r0, 0x3f	; 63
    354e:	f8 94       	cli
    3550:	de bf       	out	0x3e, r29	; 62
    3552:	0f be       	out	0x3f, r0	; 63
    3554:	cd bf       	out	0x3d, r28	; 61
  uint8_t x[2];
  *(uint16_t *)x = eeprom_read_word ((uint16_t *)&eemem_channel);
    3556:	82 e2       	ldi	r24, 0x22	; 34
    3558:	90 e0       	ldi	r25, 0x00	; 0
    355a:	0e 94 a9 4e 	call	0x9d52	; 0x9d52 <__eerd_word_m128rfa1>
    355e:	89 83       	std	Y+1, r24	; 0x01
    3560:	9a 83       	std	Y+2, r25	; 0x02
/* Don't return an invalid channel number */
  if( (x[0]<11) || (x[0] > 26)) x[1]=x[0];
    3562:	98 2f       	mov	r25, r24
    3564:	9b 50       	subi	r25, 0x0B	; 11
    3566:	90 31       	cpi	r25, 0x10	; 16
    3568:	08 f0       	brcs	.+2      	; 0x356c <params_get_channel+0x2e>
    356a:	8a 83       	std	Y+2, r24	; 0x02
/* Do exclusive or test on the two values read */
  if((uint8_t)x[0]!=(uint8_t)~x[1]) {//~x[1] can promote comparison to 16 bit
    356c:	9a 81       	ldd	r25, Y+2	; 0x02
    356e:	90 95       	com	r25
    3570:	89 17       	cp	r24, r25
    3572:	09 f4       	brne	.+2      	; 0x3576 <params_get_channel+0x38>
    3574:	70 c0       	rjmp	.+224    	; 0x3656 <params_get_channel+0x118>
/* Verification fails, rewrite everything */
    uint8_t i,buffer[32];
    PRINTD("EEPROM is corrupt, rewriting with defaults.\n");
    3576:	00 d0       	rcall	.+0      	; 0x3578 <params_get_channel+0x3a>
    3578:	8b ee       	ldi	r24, 0xEB	; 235
    357a:	91 e0       	ldi	r25, 0x01	; 1
    357c:	ad b7       	in	r26, 0x3d	; 61
    357e:	be b7       	in	r27, 0x3e	; 62
    3580:	12 96       	adiw	r26, 0x02	; 2
    3582:	9c 93       	st	X, r25
    3584:	8e 93       	st	-X, r24
    3586:	11 97       	sbiw	r26, 0x01	; 1
    3588:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
    358c:	8e 01       	movw	r16, r28
    358e:	0d 5f       	subi	r16, 0xFD	; 253
    3590:	1f 4f       	sbci	r17, 0xFF	; 255
    3592:	0f 90       	pop	r0
    3594:	0f 90       	pop	r0
    3596:	d8 01       	movw	r26, r16
    3598:	80 e0       	ldi	r24, 0x00	; 0
    359a:	90 e0       	ldi	r25, 0x00	; 0
#if CONTIKI_CONF_RANDOM_MAC
    PRINTD("Generating random EUI64 MAC\n");
    generate_new_eui64(&buffer);
    randomeui64=1;
#else
    for (i=0;i<sizeof(default_mac_address);i++) buffer[i] = pgm_read_byte_near(default_mac_address+i);
    359c:	fc 01       	movw	r30, r24
    359e:	e5 53       	subi	r30, 0x35	; 53
    35a0:	fe 4f       	sbci	r31, 0xFE	; 254
    35a2:	e4 91       	lpm	r30, Z+
    35a4:	ed 93       	st	X+, r30
    35a6:	01 96       	adiw	r24, 0x01	; 1
    35a8:	88 30       	cpi	r24, 0x08	; 8
    35aa:	91 05       	cpc	r25, r1
    35ac:	b9 f7       	brne	.-18     	; 0x359c <params_get_channel+0x5e>
#endif
/* eeprom_write_block should not be interrupted */
    cli();
    35ae:	f8 94       	cli
    eeprom_write_block(&buffer,  &eemem_mac_address, sizeof(eemem_mac_address));
    35b0:	ce 01       	movw	r24, r28
    35b2:	03 96       	adiw	r24, 0x03	; 3
    35b4:	60 e0       	ldi	r22, 0x00	; 0
    35b6:	70 e0       	ldi	r23, 0x00	; 0
    35b8:	48 e0       	ldi	r20, 0x08	; 8
    35ba:	50 e0       	ldi	r21, 0x00	; 0
    35bc:	0e 94 af 4e 	call	0x9d5e	; 0x9d5e <__eewr_block_m128rfa1>
    35c0:	d8 01       	movw	r26, r16
    35c2:	80 e0       	ldi	r24, 0x00	; 0
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    for (i=0;i<sizeof(default_server_name);i++) buffer[i] = pgm_read_byte_near(default_server_name+i);
    35c6:	fc 01       	movw	r30, r24
    35c8:	ed 52       	subi	r30, 0x2D	; 45
    35ca:	fe 4f       	sbci	r31, 0xFE	; 254
    35cc:	e4 91       	lpm	r30, Z+
    35ce:	ed 93       	st	X+, r30
    35d0:	01 96       	adiw	r24, 0x01	; 1
    35d2:	8e 30       	cpi	r24, 0x0E	; 14
    35d4:	91 05       	cpc	r25, r1
    35d6:	b9 f7       	brne	.-18     	; 0x35c6 <params_get_channel+0x88>
    eeprom_write_block(&buffer,  &eemem_server_name, sizeof(eemem_server_name));
    35d8:	ce 01       	movw	r24, r28
    35da:	03 96       	adiw	r24, 0x03	; 3
    35dc:	68 e0       	ldi	r22, 0x08	; 8
    35de:	70 e0       	ldi	r23, 0x00	; 0
    35e0:	4e e0       	ldi	r20, 0x0E	; 14
    35e2:	50 e0       	ldi	r21, 0x00	; 0
    35e4:	0e 94 af 4e 	call	0x9d5e	; 0x9d5e <__eewr_block_m128rfa1>
    35e8:	80 e0       	ldi	r24, 0x00	; 0
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    for (i=0;i<sizeof(default_domain_name);i++) buffer[i] = pgm_read_byte_near(default_domain_name+i);
    35ec:	fc 01       	movw	r30, r24
    35ee:	ef 51       	subi	r30, 0x1F	; 31
    35f0:	fe 4f       	sbci	r31, 0xFE	; 254
    35f2:	e4 91       	lpm	r30, Z+
    35f4:	d8 01       	movw	r26, r16
    35f6:	ed 93       	st	X+, r30
    35f8:	8d 01       	movw	r16, r26
    35fa:	01 96       	adiw	r24, 0x01	; 1
    35fc:	8a 30       	cpi	r24, 0x0A	; 10
    35fe:	91 05       	cpc	r25, r1
    3600:	a9 f7       	brne	.-22     	; 0x35ec <params_get_channel+0xae>
    eeprom_write_block(&buffer,  &eemem_domain_name, sizeof(eemem_domain_name));
    3602:	ce 01       	movw	r24, r28
    3604:	03 96       	adiw	r24, 0x03	; 3
    3606:	66 e1       	ldi	r22, 0x16	; 22
    3608:	70 e0       	ldi	r23, 0x00	; 0
    360a:	4a e0       	ldi	r20, 0x0A	; 10
    360c:	50 e0       	ldi	r21, 0x00	; 0
    360e:	0e 94 af 4e 	call	0x9d5e	; 0x9d5e <__eewr_block_m128rfa1>
    eeprom_write_word(&eemem_panid  , PARAMS_PANID);
    3612:	84 e2       	ldi	r24, 0x24	; 36
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	6d ec       	ldi	r22, 0xCD	; 205
    3618:	7b ea       	ldi	r23, 0xAB	; 171
    361a:	0e 94 c7 4e 	call	0x9d8e	; 0x9d8e <__eewr_word_m128rfa1>
    eeprom_write_word(&eemem_panaddr, PARAMS_PANADDR);
    361e:	86 e2       	ldi	r24, 0x26	; 38
    3620:	90 e0       	ldi	r25, 0x00	; 0
    3622:	60 e0       	ldi	r22, 0x00	; 0
    3624:	70 e0       	ldi	r23, 0x00	; 0
    3626:	0e 94 c7 4e 	call	0x9d8e	; 0x9d8e <__eewr_word_m128rfa1>
    eeprom_write_byte(&eemem_txpower, PARAMS_TXPOWER);
    362a:	88 e2       	ldi	r24, 0x28	; 40
    362c:	90 e0       	ldi	r25, 0x00	; 0
    362e:	60 e0       	ldi	r22, 0x00	; 0
    3630:	0e 94 b9 4e 	call	0x9d72	; 0x9d72 <__eewr_byte_m128rfa1>
    eeprom_write_word(&eemem_nodeid, PARAMS_NODEID);
    3634:	80 e2       	ldi	r24, 0x20	; 32
    3636:	90 e0       	ldi	r25, 0x00	; 0
    3638:	60 e0       	ldi	r22, 0x00	; 0
    363a:	70 e0       	ldi	r23, 0x00	; 0
    363c:	0e 94 c7 4e 	call	0x9d8e	; 0x9d8e <__eewr_word_m128rfa1>
    x[0] = PARAMS_CHANNEL;
    3640:	8a e1       	ldi	r24, 0x1A	; 26
    3642:	89 83       	std	Y+1, r24	; 0x01
    x[1]= ~x[0];
    3644:	85 ee       	ldi	r24, 0xE5	; 229
    3646:	8a 83       	std	Y+2, r24	; 0x02
    eeprom_write_word((uint16_t *)&eemem_channel, *(uint16_t *)x);
    3648:	69 81       	ldd	r22, Y+1	; 0x01
    364a:	7a 81       	ldd	r23, Y+2	; 0x02
    364c:	82 e2       	ldi	r24, 0x22	; 34
    364e:	90 e0       	ldi	r25, 0x00	; 0
    3650:	0e 94 c7 4e 	call	0x9d8e	; 0x9d8e <__eewr_word_m128rfa1>
    sei();
    3654:	78 94       	sei
  }
/* Always returns a valid channel */
  return x[0];
}
    3656:	89 81       	ldd	r24, Y+1	; 0x01
    3658:	a2 96       	adiw	r28, 0x22	; 34
    365a:	0f b6       	in	r0, 0x3f	; 63
    365c:	f8 94       	cli
    365e:	de bf       	out	0x3e, r29	; 62
    3660:	0f be       	out	0x3f, r0	; 63
    3662:	cd bf       	out	0x3d, r28	; 61
    3664:	cf 91       	pop	r28
    3666:	df 91       	pop	r29
    3668:	1f 91       	pop	r17
    366a:	0f 91       	pop	r16
    366c:	08 95       	ret

0000366e <params_get_eui64>:
uint8_t
params_get_eui64(uint8_t *eui64) {
  cli();
    366e:	f8 94       	cli
  eeprom_read_block ((void *)eui64, &eemem_mac_address, sizeof(rimeaddr_t));
    3670:	60 e0       	ldi	r22, 0x00	; 0
    3672:	70 e0       	ldi	r23, 0x00	; 0
    3674:	42 e0       	ldi	r20, 0x02	; 2
    3676:	50 e0       	ldi	r21, 0x00	; 0
    3678:	0e 94 91 4e 	call	0x9d22	; 0x9d22 <__eerd_block_m128rfa1>
  sei();
    367c:	78 94       	sei
#if CONTIKI_CONF_RANDOM_MAC
  return randomeui64;
#else
  return 0;
#endif
}
    367e:	80 e0       	ldi	r24, 0x00	; 0
    3680:	08 95       	ret

00003682 <params_get_panid>:
uint16_t
params_get_panid(void) {
  return eeprom_read_word(&eemem_panid);
    3682:	84 e2       	ldi	r24, 0x24	; 36
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	0e 94 a9 4e 	call	0x9d52	; 0x9d52 <__eerd_word_m128rfa1>
}
    368a:	08 95       	ret

0000368c <params_get_panaddr>:
uint16_t
params_get_panaddr(void) {
  return eeprom_read_word (&eemem_panaddr);
    368c:	86 e2       	ldi	r24, 0x26	; 38
    368e:	90 e0       	ldi	r25, 0x00	; 0
    3690:	0e 94 a9 4e 	call	0x9d52	; 0x9d52 <__eerd_word_m128rfa1>
}
    3694:	08 95       	ret

00003696 <params_get_txpower>:
uint8_t
params_get_txpower(void)
{
  return eeprom_read_byte(&eemem_txpower);
    3696:	88 e2       	ldi	r24, 0x28	; 40
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	0e 94 a1 4e 	call	0x9d42	; 0x9d42 <__eerd_byte_m128rfa1>
}
    369e:	08 95       	ret

000036a0 <clock_init>:
 * Start the clock by enabling the timer comparison interrupts. 
 */
void
clock_init(void)
{
  cli ();
    36a0:	f8 94       	cli
  OCRSetup();
    36a2:	10 92 b6 00 	sts	0x00B6, r1
    36a6:	16 bc       	out	0x26, r1	; 38
    36a8:	83 ef       	ldi	r24, 0xF3	; 243
    36aa:	87 bd       	out	0x27, r24	; 39
    36ac:	82 e0       	ldi	r24, 0x02	; 2
    36ae:	84 bd       	out	0x24, r24	; 36
    36b0:	94 e0       	ldi	r25, 0x04	; 4
    36b2:	95 bd       	out	0x25, r25	; 37
    36b4:	95 b3       	in	r25, 0x15	; 21
    36b6:	95 bb       	out	0x15, r25	; 21
    36b8:	80 93 6e 00 	sts	0x006E, r24
  sei ();
    36bc:	78 94       	sei
}
    36be:	08 95       	ret

000036c0 <clock_time>:
clock_time_t
clock_time(void)
{
  clock_time_t tmp;
  do {
    tmp = count;
    36c0:	20 91 fb 25 	lds	r18, 0x25FB
    36c4:	30 91 fc 25 	lds	r19, 0x25FC
  } while(tmp != count);
    36c8:	80 91 fb 25 	lds	r24, 0x25FB
    36cc:	90 91 fc 25 	lds	r25, 0x25FC
    36d0:	28 17       	cp	r18, r24
    36d2:	39 07       	cpc	r19, r25
    36d4:	a9 f7       	brne	.-22     	; 0x36c0 <clock_time>
  return tmp;
}
    36d6:	c9 01       	movw	r24, r18
    36d8:	08 95       	ret

000036da <clock_seconds>:
unsigned long
clock_seconds(void)
{
  unsigned long tmp;
  do {
    tmp = seconds;
    36da:	20 91 1f 2e 	lds	r18, 0x2E1F
    36de:	30 91 20 2e 	lds	r19, 0x2E20
    36e2:	40 91 21 2e 	lds	r20, 0x2E21
    36e6:	50 91 22 2e 	lds	r21, 0x2E22
  } while(tmp != seconds);
    36ea:	80 91 1f 2e 	lds	r24, 0x2E1F
    36ee:	90 91 20 2e 	lds	r25, 0x2E20
    36f2:	a0 91 21 2e 	lds	r26, 0x2E21
    36f6:	b0 91 22 2e 	lds	r27, 0x2E22
    36fa:	28 17       	cp	r18, r24
    36fc:	39 07       	cpc	r19, r25
    36fe:	4a 07       	cpc	r20, r26
    3700:	5b 07       	cpc	r21, r27
    3702:	59 f7       	brne	.-42     	; 0x36da <clock_seconds>
  return tmp;
}
    3704:	b9 01       	movw	r22, r18
    3706:	ca 01       	movw	r24, r20
    3708:	08 95       	ret

0000370a <clock_set_seconds>:
 * Set seconds, e.g. to a standard epoch for an absolute date/time.
 */
void
clock_set_seconds(unsigned long sec)
{
  seconds = sec;
    370a:	60 93 1f 2e 	sts	0x2E1F, r22
    370e:	70 93 20 2e 	sts	0x2E20, r23
    3712:	80 93 21 2e 	sts	0x2E21, r24
    3716:	90 93 22 2e 	sts	0x2E22, r25
}
    371a:	08 95       	ret

0000371c <clock_wait>:
/**
 * Wait for a number of clock ticks.
 */
void
clock_wait(clock_time_t t)
{
    371c:	cf 93       	push	r28
    371e:	df 93       	push	r29
    3720:	ec 01       	movw	r28, r24
  clock_time_t endticks = clock_time() + t;
    3722:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    3726:	c8 0f       	add	r28, r24
    3728:	d9 1f       	adc	r29, r25
  if (sizeof(clock_time_t) == 1) {
    while ((signed char )(clock_time() - endticks) < 0) {;}
  } else if (sizeof(clock_time_t) == 2) {
    while ((signed short)(clock_time() - endticks) < 0) {;}
    372a:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    372e:	8c 1b       	sub	r24, r28
    3730:	9d 0b       	sbc	r25, r29
    3732:	97 fd       	sbrc	r25, 7
    3734:	fa cf       	rjmp	.-12     	; 0x372a <clock_wait+0xe>
  } else {
    while ((signed long )(clock_time() - endticks) < 0) {;}
  }
}
    3736:	df 91       	pop	r29
    3738:	cf 91       	pop	r28
    373a:	08 95       	ret

0000373c <clock_delay_usec>:
#elif F_CPU >= 12000000UL
  if(howlong<2) return;
  howlong-=(uint16_t) (3*12000000/F_CPU);
  my_delay_loop_2((howlong*(uint16_t)(F_CPU/3250000)));
#elif F_CPU >= 8000000UL
  if(howlong<4) return;
    373c:	84 30       	cpi	r24, 0x04	; 4
    373e:	91 05       	cpc	r25, r1
    3740:	48 f0       	brcs	.+18     	; 0x3754 <clock_delay_usec+0x18>
  howlong-=(uint16_t) (3*8000000/F_CPU);
    3742:	03 97       	sbiw	r24, 0x03	; 3
  my_delay_loop_2((howlong*(uint16_t)(F_CPU/2000000))/2);
    3744:	88 0f       	add	r24, r24
    3746:	99 1f       	adc	r25, r25
    3748:	88 0f       	add	r24, r24
    374a:	99 1f       	adc	r25, r25
    374c:	96 95       	lsr	r25
    374e:	87 95       	ror	r24
 */
static inline void my_delay_loop_2(uint16_t __count) __attribute__((always_inline));
void
my_delay_loop_2(uint16_t __count)
{
  __asm__ volatile (
    3750:	01 97       	sbiw	r24, 0x01	; 1
    3752:	f1 f7       	brne	.-4      	; 0x3750 <clock_delay_usec+0x14>
    3754:	08 95       	ret

00003756 <clock_delay_msec>:
 * Platforms are not required to implement this call.
 * \note This will break for CPUs clocked above 260 MHz.
 */
void
clock_delay_msec(uint16_t howlong)
{
    3756:	cf 93       	push	r28
    3758:	df 93       	push	r29
    375a:	ec 01       	movw	r28, r24

#if F_CPU>=16000000
  while(howlong--) clock_delay_usec(1000);
#elif F_CPU>=8000000
  uint16_t i=996;
    375c:	84 ee       	ldi	r24, 0xE4	; 228
    375e:	93 e0       	ldi	r25, 0x03	; 3
  while(howlong--) {clock_delay_usec(i);i=999;}
    3760:	05 c0       	rjmp	.+10     	; 0x376c <clock_delay_msec+0x16>
    3762:	0e 94 9e 1b 	call	0x373c	; 0x373c <clock_delay_usec>
    3766:	21 97       	sbiw	r28, 0x01	; 1
    3768:	87 ee       	ldi	r24, 0xE7	; 231
    376a:	93 e0       	ldi	r25, 0x03	; 3
    376c:	20 97       	sbiw	r28, 0x00	; 0
    376e:	c9 f7       	brne	.-14     	; 0x3762 <clock_delay_msec+0xc>
  while(howlong--) {clock_delay_usec(i);i=999;}
#else
  uint16_t i=983;
  while(howlong--) {clock_delay_usec(i);i=999;}
#endif
}
    3770:	df 91       	pop	r29
    3772:	cf 91       	pop	r28
    3774:	08 95       	ret

00003776 <clock_adjust_ticks>:
 * clock_seconds will increment if necessary to reflect the tick addition.
  * Leap ticks or seconds can (rarely) be introduced if the ISR is not blocked.
 */
void
clock_adjust_ticks(clock_time_t howmany)
{
    3776:	0f 93       	push	r16
    3778:	1f 93       	push	r17
  uint8_t sreg = SREG;cli();
    377a:	1f b7       	in	r17, 0x3f	; 63
    377c:	f8 94       	cli
  count  += howmany;
    377e:	20 91 fb 25 	lds	r18, 0x25FB
    3782:	30 91 fc 25 	lds	r19, 0x25FC
    3786:	28 0f       	add	r18, r24
    3788:	39 1f       	adc	r19, r25
    378a:	30 93 fc 25 	sts	0x25FC, r19
    378e:	20 93 fb 25 	sts	0x25FB, r18
#if TWO_COUNTERS
  howmany+= scount;
    3792:	20 91 fd 25 	lds	r18, 0x25FD
    3796:	fc 01       	movw	r30, r24
    3798:	e2 0f       	add	r30, r18
    379a:	f1 1d       	adc	r31, r1
  while(howmany >= CLOCK_SECOND) {
    howmany -= CLOCK_SECOND;
    seconds++;
    sleepseconds++;
#if RADIOSTATS
    if (RF230_receive_on) radioontime += 1;
    379c:	00 91 c3 2f 	lds	r16, 0x2FC3
    37a0:	60 91 1b 2e 	lds	r22, 0x2E1B
    37a4:	70 91 1c 2e 	lds	r23, 0x2E1C
    37a8:	80 91 1d 2e 	lds	r24, 0x2E1D
    37ac:	90 91 1e 2e 	lds	r25, 0x2E1E
clock_adjust_ticks(clock_time_t howmany)
{
  uint8_t sreg = SREG;cli();
  count  += howmany;
#if TWO_COUNTERS
  howmany+= scount;
    37b0:	df 01       	movw	r26, r30
#endif
  while(howmany >= CLOCK_SECOND) {
    37b2:	2c c0       	rjmp	.+88     	; 0x380c <clock_adjust_ticks+0x96>
    howmany -= CLOCK_SECOND;
    37b4:	a0 58       	subi	r26, 0x80	; 128
    37b6:	b0 40       	sbci	r27, 0x00	; 0
    seconds++;
    37b8:	20 91 1f 2e 	lds	r18, 0x2E1F
    37bc:	30 91 20 2e 	lds	r19, 0x2E20
    37c0:	40 91 21 2e 	lds	r20, 0x2E21
    37c4:	50 91 22 2e 	lds	r21, 0x2E22
    37c8:	2f 5f       	subi	r18, 0xFF	; 255
    37ca:	3f 4f       	sbci	r19, 0xFF	; 255
    37cc:	4f 4f       	sbci	r20, 0xFF	; 255
    37ce:	5f 4f       	sbci	r21, 0xFF	; 255
    37d0:	20 93 1f 2e 	sts	0x2E1F, r18
    37d4:	30 93 20 2e 	sts	0x2E20, r19
    37d8:	40 93 21 2e 	sts	0x2E21, r20
    37dc:	50 93 22 2e 	sts	0x2E22, r21
    sleepseconds++;
#if RADIOSTATS
    if (RF230_receive_on) radioontime += 1;
    37e0:	00 23       	and	r16, r16
    37e2:	a1 f0       	breq	.+40     	; 0x380c <clock_adjust_ticks+0x96>
    37e4:	20 91 17 2e 	lds	r18, 0x2E17
    37e8:	30 91 18 2e 	lds	r19, 0x2E18
    37ec:	40 91 19 2e 	lds	r20, 0x2E19
    37f0:	50 91 1a 2e 	lds	r21, 0x2E1A
    37f4:	2f 5f       	subi	r18, 0xFF	; 255
    37f6:	3f 4f       	sbci	r19, 0xFF	; 255
    37f8:	4f 4f       	sbci	r20, 0xFF	; 255
    37fa:	5f 4f       	sbci	r21, 0xFF	; 255
    37fc:	20 93 17 2e 	sts	0x2E17, r18
    3800:	30 93 18 2e 	sts	0x2E18, r19
    3804:	40 93 19 2e 	sts	0x2E19, r20
    3808:	50 93 1a 2e 	sts	0x2E1A, r21
  uint8_t sreg = SREG;cli();
  count  += howmany;
#if TWO_COUNTERS
  howmany+= scount;
#endif
  while(howmany >= CLOCK_SECOND) {
    380c:	a0 38       	cpi	r26, 0x80	; 128
    380e:	b1 05       	cpc	r27, r1
    3810:	88 f6       	brcc	.-94     	; 0x37b4 <clock_adjust_ticks+0x3e>
 * Typically used to add ticks after an MCU sleep
 * clock_seconds will increment if necessary to reflect the tick addition.
  * Leap ticks or seconds can (rarely) be introduced if the ISR is not blocked.
 */
void
clock_adjust_ticks(clock_time_t howmany)
    3812:	9f 01       	movw	r18, r30
    3814:	22 0f       	add	r18, r18
    3816:	23 2f       	mov	r18, r19
    3818:	22 1f       	adc	r18, r18
    381a:	33 0b       	sbc	r19, r19
    381c:	31 95       	neg	r19
    381e:	40 e0       	ldi	r20, 0x00	; 0
    3820:	50 e0       	ldi	r21, 0x00	; 0
  uint8_t sreg = SREG;cli();
  count  += howmany;
#if TWO_COUNTERS
  howmany+= scount;
#endif
  while(howmany >= CLOCK_SECOND) {
    3822:	26 0f       	add	r18, r22
    3824:	37 1f       	adc	r19, r23
    3826:	48 1f       	adc	r20, r24
    3828:	59 1f       	adc	r21, r25
    382a:	20 93 1b 2e 	sts	0x2E1B, r18
    382e:	30 93 1c 2e 	sts	0x2E1C, r19
    3832:	40 93 1d 2e 	sts	0x2E1D, r20
    3836:	50 93 1e 2e 	sts	0x2E1E, r21
#if RADIOSTATS
    if (RF230_receive_on) radioontime += 1;
#endif
  }
#if TWO_COUNTERS
  scount = howmany;
    383a:	ef 77       	andi	r30, 0x7F	; 127
    383c:	f0 70       	andi	r31, 0x00	; 0
    383e:	e0 93 fd 25 	sts	0x25FD, r30
#endif
  SREG=sreg;
    3842:	1f bf       	out	0x3f, r17	; 63
}
    3844:	1f 91       	pop	r17
    3846:	0f 91       	pop	r16
    3848:	08 95       	ret

0000384a <__vector_21>:
 *  clock-avr.h for the particular MCU.
 */
void AVR_OUTPUT_COMPARE_INT(void);
#else
ISR(AVR_OUTPUT_COMPARE_INT)
{
    384a:	1f 92       	push	r1
    384c:	0f 92       	push	r0
    384e:	0f b6       	in	r0, 0x3f	; 63
    3850:	0f 92       	push	r0
    3852:	0b b6       	in	r0, 0x3b	; 59
    3854:	0f 92       	push	r0
    3856:	11 24       	eor	r1, r1
    3858:	2f 93       	push	r18
    385a:	3f 93       	push	r19
    385c:	4f 93       	push	r20
    385e:	5f 93       	push	r21
    3860:	6f 93       	push	r22
    3862:	7f 93       	push	r23
    3864:	8f 93       	push	r24
    3866:	9f 93       	push	r25
    3868:	af 93       	push	r26
    386a:	bf 93       	push	r27
    386c:	ef 93       	push	r30
    386e:	ff 93       	push	r31
    count++;
    3870:	80 91 fb 25 	lds	r24, 0x25FB
    3874:	90 91 fc 25 	lds	r25, 0x25FC
    3878:	01 96       	adiw	r24, 0x01	; 1
    387a:	90 93 fc 25 	sts	0x25FC, r25
    387e:	80 93 fb 25 	sts	0x25FB, r24
#if TWO_COUNTERS
  if(++scount >= CLOCK_SECOND) {
    3882:	80 91 fd 25 	lds	r24, 0x25FD
    3886:	8f 5f       	subi	r24, 0xFF	; 255
    3888:	80 93 fd 25 	sts	0x25FD, r24
    388c:	80 91 fd 25 	lds	r24, 0x25FD
    3890:	87 ff       	sbrs	r24, 7
    3892:	15 c0       	rjmp	.+42     	; 0x38be <__vector_21+0x74>
    scount = 0;
    3894:	10 92 fd 25 	sts	0x25FD, r1
#else
  if(count%CLOCK_SECOND==0) {
#endif
    seconds++;
    3898:	80 91 1f 2e 	lds	r24, 0x2E1F
    389c:	90 91 20 2e 	lds	r25, 0x2E20
    38a0:	a0 91 21 2e 	lds	r26, 0x2E21
    38a4:	b0 91 22 2e 	lds	r27, 0x2E22
    38a8:	01 96       	adiw	r24, 0x01	; 1
    38aa:	a1 1d       	adc	r26, r1
    38ac:	b1 1d       	adc	r27, r1
    38ae:	80 93 1f 2e 	sts	0x2E1F, r24
    38b2:	90 93 20 2e 	sts	0x2E20, r25
    38b6:	a0 93 21 2e 	sts	0x2E21, r26
    38ba:	b0 93 22 2e 	sts	0x2E22, r27

  }

#if RADIOSTATS
   /* Sample radio on time. Less accurate than ENERGEST but a smaller footprint */
  if (RF230_receive_on) {
    38be:	80 91 c3 2f 	lds	r24, 0x2FC3
    38c2:	88 23       	and	r24, r24
    38c4:	f1 f0       	breq	.+60     	; 0x3902 <__vector_21+0xb8>
    if (++rcount >= CLOCK_SECOND) {
    38c6:	80 91 fe 25 	lds	r24, 0x25FE
    38ca:	8f 5f       	subi	r24, 0xFF	; 255
    38cc:	80 93 fe 25 	sts	0x25FE, r24
    38d0:	80 91 fe 25 	lds	r24, 0x25FE
    38d4:	87 ff       	sbrs	r24, 7
    38d6:	15 c0       	rjmp	.+42     	; 0x3902 <__vector_21+0xb8>
      rcount=0;
    38d8:	10 92 fe 25 	sts	0x25FE, r1
      radioontime++;
    38dc:	80 91 17 2e 	lds	r24, 0x2E17
    38e0:	90 91 18 2e 	lds	r25, 0x2E18
    38e4:	a0 91 19 2e 	lds	r26, 0x2E19
    38e8:	b0 91 1a 2e 	lds	r27, 0x2E1A
    38ec:	01 96       	adiw	r24, 0x01	; 1
    38ee:	a1 1d       	adc	r26, r1
    38f0:	b1 1d       	adc	r27, r1
    38f2:	80 93 17 2e 	sts	0x2E17, r24
    38f6:	90 93 18 2e 	sts	0x2E18, r25
    38fa:	a0 93 19 2e 	sts	0x2E19, r26
    38fe:	b0 93 1a 2e 	sts	0x2E1A, r27
}
#endif

#if 1
/*  gcc will save all registers on the stack if an external routine is called */
  if(etimer_pending()) {
    3902:	0e 94 34 17 	call	0x2e68	; 0x2e68 <etimer_pending>
    3906:	00 97       	sbiw	r24, 0x00	; 0
    3908:	11 f0       	breq	.+4      	; 0x390e <__vector_21+0xc4>
    etimer_request_poll();
    390a:	0e 94 34 16 	call	0x2c68	; 0x2c68 <etimer_request_poll>
      etimer_process.needspoll = 1;
      poll_requested = 1;
    }
  }
#endif
}
    390e:	ff 91       	pop	r31
    3910:	ef 91       	pop	r30
    3912:	bf 91       	pop	r27
    3914:	af 91       	pop	r26
    3916:	9f 91       	pop	r25
    3918:	8f 91       	pop	r24
    391a:	7f 91       	pop	r23
    391c:	6f 91       	pop	r22
    391e:	5f 91       	pop	r21
    3920:	4f 91       	pop	r20
    3922:	3f 91       	pop	r19
    3924:	2f 91       	pop	r18
    3926:	0f 90       	pop	r0
    3928:	0b be       	out	0x3b, r0	; 59
    392a:	0f 90       	pop	r0
    392c:	0f be       	out	0x3f, r0	; 63
    392e:	0f 90       	pop	r0
    3930:	1f 90       	pop	r1
    3932:	18 95       	reti

00003934 <__vector_25>:
#endif

#if NUMPORTS > 0
int (* input_handler_0)(unsigned char);
ISR(D_USART0_RX_vect)
{
    3934:	1f 92       	push	r1
    3936:	0f 92       	push	r0
    3938:	0f b6       	in	r0, 0x3f	; 63
    393a:	0f 92       	push	r0
    393c:	0b b6       	in	r0, 0x3b	; 59
    393e:	0f 92       	push	r0
    3940:	11 24       	eor	r1, r1
    3942:	2f 93       	push	r18
    3944:	3f 93       	push	r19
    3946:	4f 93       	push	r20
    3948:	5f 93       	push	r21
    394a:	6f 93       	push	r22
    394c:	7f 93       	push	r23
    394e:	8f 93       	push	r24
    3950:	9f 93       	push	r25
    3952:	af 93       	push	r26
    3954:	bf 93       	push	r27
    3956:	ef 93       	push	r30
    3958:	ff 93       	push	r31
  unsigned char c;
  c = D_UDR0;
    395a:	80 91 c6 00 	lds	r24, 0x00C6
  if (input_handler_0 != NULL) input_handler_0(c);
    395e:	e0 91 25 2e 	lds	r30, 0x2E25
    3962:	f0 91 26 2e 	lds	r31, 0x2E26
    3966:	30 97       	sbiw	r30, 0x00	; 0
    3968:	09 f0       	breq	.+2      	; 0x396c <__vector_25+0x38>
    396a:	09 95       	icall
}
    396c:	ff 91       	pop	r31
    396e:	ef 91       	pop	r30
    3970:	bf 91       	pop	r27
    3972:	af 91       	pop	r26
    3974:	9f 91       	pop	r25
    3976:	8f 91       	pop	r24
    3978:	7f 91       	pop	r23
    397a:	6f 91       	pop	r22
    397c:	5f 91       	pop	r21
    397e:	4f 91       	pop	r20
    3980:	3f 91       	pop	r19
    3982:	2f 91       	pop	r18
    3984:	0f 90       	pop	r0
    3986:	0b be       	out	0x3b, r0	; 59
    3988:	0f 90       	pop	r0
    398a:	0f be       	out	0x3f, r0	; 63
    398c:	0f 90       	pop	r0
    398e:	1f 90       	pop	r1
    3990:	18 95       	reti

00003992 <__vector_36>:
#endif

#if NUMPORTS > 1
int (* input_handler_1)(unsigned char);
ISR(D_USART1_RX_vect)
{
    3992:	1f 92       	push	r1
    3994:	0f 92       	push	r0
    3996:	0f b6       	in	r0, 0x3f	; 63
    3998:	0f 92       	push	r0
    399a:	0b b6       	in	r0, 0x3b	; 59
    399c:	0f 92       	push	r0
    399e:	11 24       	eor	r1, r1
    39a0:	2f 93       	push	r18
    39a2:	3f 93       	push	r19
    39a4:	4f 93       	push	r20
    39a6:	5f 93       	push	r21
    39a8:	6f 93       	push	r22
    39aa:	7f 93       	push	r23
    39ac:	8f 93       	push	r24
    39ae:	9f 93       	push	r25
    39b0:	af 93       	push	r26
    39b2:	bf 93       	push	r27
    39b4:	ef 93       	push	r30
    39b6:	ff 93       	push	r31
  unsigned char c;
  c = D_UDR1;
    39b8:	80 91 ce 00 	lds	r24, 0x00CE
  if (input_handler_1 != NULL) input_handler_1(c);
    39bc:	e0 91 23 2e 	lds	r30, 0x2E23
    39c0:	f0 91 24 2e 	lds	r31, 0x2E24
    39c4:	30 97       	sbiw	r30, 0x00	; 0
    39c6:	09 f0       	breq	.+2      	; 0x39ca <__vector_36+0x38>
    39c8:	09 95       	icall
}
    39ca:	ff 91       	pop	r31
    39cc:	ef 91       	pop	r30
    39ce:	bf 91       	pop	r27
    39d0:	af 91       	pop	r26
    39d2:	9f 91       	pop	r25
    39d4:	8f 91       	pop	r24
    39d6:	7f 91       	pop	r23
    39d8:	6f 91       	pop	r22
    39da:	5f 91       	pop	r21
    39dc:	4f 91       	pop	r20
    39de:	3f 91       	pop	r19
    39e0:	2f 91       	pop	r18
    39e2:	0f 90       	pop	r0
    39e4:	0b be       	out	0x3b, r0	; 59
    39e6:	0f 90       	pop	r0
    39e8:	0f be       	out	0x3f, r0	; 63
    39ea:	0f 90       	pop	r0
    39ec:	1f 90       	pop	r1
    39ee:	18 95       	reti

000039f0 <rs232_init>:
/*---------------------------------------------------------------------------*/
void
rs232_init (uint8_t port, uint8_t bd, uint8_t ffmt)
{
#if NUMPORTS > 0
 if (port == 0) {
    39f0:	88 23       	and	r24, r24
    39f2:	71 f4       	brne	.+28     	; 0x3a10 <rs232_init+0x20>
   D_UBRR0H = (uint8_t)(bd>>8);
    39f4:	10 92 c5 00 	sts	0x00C5, r1
   D_UBRR0L = (uint8_t)bd;
    39f8:	60 93 c4 00 	sts	0x00C4, r22
#if RS232_TX_INTERRUPTS
   txwait_0 = 0;
   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#else
   D_UCSR0B =  USART_INTERRUPT_RX_COMPLETE | \
    39fc:	88 e9       	ldi	r24, 0x98	; 152
    39fe:	80 93 c1 00 	sts	0x00C1, r24
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#endif
   D_UCSR0C = USART_UCSRC_SEL | ffmt;
    3a02:	40 93 c2 00 	sts	0x00C2, r20
   input_handler_0 = NULL;
    3a06:	10 92 26 2e 	sts	0x2E26, r1
    3a0a:	10 92 25 2e 	sts	0x2E25, r1
    3a0e:	08 95       	ret

#if NUMPORTS > 1
 } else if (port == 1) {
    3a10:	81 30       	cpi	r24, 0x01	; 1
    3a12:	69 f4       	brne	.+26     	; 0x3a2e <rs232_init+0x3e>
   D_UBRR1H = (uint8_t)(bd>>8);
    3a14:	10 92 cd 00 	sts	0x00CD, r1
   D_UBRR1L = (uint8_t)bd;
    3a18:	60 93 cc 00 	sts	0x00CC, r22
#if RS232_TX_INTERRUPTS
   txwait_1 = 0;
   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | USART_INTERRUPT_TX_COMPLETE | \
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#else
   D_UCSR1B =  USART_INTERRUPT_RX_COMPLETE | \
    3a1c:	88 e9       	ldi	r24, 0x98	; 152
    3a1e:	80 93 c9 00 	sts	0x00C9, r24
               USART_RECEIVER_ENABLE | USART_TRANSMITTER_ENABLE;
#endif
   D_UCSR1C = USART_UCSRC_SEL | ffmt;
    3a22:	40 93 ca 00 	sts	0x00CA, r20
   input_handler_1 = NULL;
    3a26:	10 92 24 2e 	sts	0x2E24, r1
    3a2a:	10 92 23 2e 	sts	0x2E23, r1
    3a2e:	08 95       	ret

00003a30 <rs232_send>:
  }
#endif
#else /* RS232_TX_INTERRUPTS */
  /* Block until tx ready and output character */
#if NUMPORTS > 0
  if (port == 0 ) {
    3a30:	88 23       	and	r24, r24
    3a32:	39 f4       	brne	.+14     	; 0x3a42 <rs232_send+0x12>
    while (!(D_UCSR0A & D_UDRE0M));
    3a34:	80 91 c0 00 	lds	r24, 0x00C0
    3a38:	85 ff       	sbrs	r24, 5
    3a3a:	fc cf       	rjmp	.-8      	; 0x3a34 <rs232_send+0x4>
    D_UDR0 = c;
    3a3c:	60 93 c6 00 	sts	0x00C6, r22
    3a40:	08 95       	ret
#if NUMPORTS > 1
  } else if (port == 1) {
    3a42:	81 30       	cpi	r24, 0x01	; 1
    3a44:	31 f4       	brne	.+12     	; 0x3a52 <rs232_send+0x22>
    while (!(D_UCSR1A & D_UDRE1M));
    3a46:	80 91 c8 00 	lds	r24, 0x00C8
    3a4a:	85 ff       	sbrs	r24, 5
    3a4c:	fc cf       	rjmp	.-8      	; 0x3a46 <rs232_send+0x16>
    D_UDR1 = c;
    3a4e:	60 93 ce 00 	sts	0x00CE, r22
    3a52:	08 95       	ret

00003a54 <rs232_stdout_putchar>:
static FILE rs232_stdout = FDEV_SETUP_STREAM(rs232_stdout_putchar,
					     NULL,
					     _FDEV_SETUP_WRITE);

int rs232_stdout_putchar(char c, FILE *stream)
{
    3a54:	1f 93       	push	r17
    3a56:	18 2f       	mov	r17, r24
#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
  if(c=='\n') rs232_send(stdout_rs232_port, '\r');
    3a58:	8a 30       	cpi	r24, 0x0A	; 10
    3a5a:	31 f4       	brne	.+12     	; 0x3a68 <rs232_stdout_putchar+0x14>
    3a5c:	80 91 ff 25 	lds	r24, 0x25FF
    3a60:	6d e0       	ldi	r22, 0x0D	; 13
    3a62:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>
    3a66:	02 c0       	rjmp	.+4      	; 0x3a6c <rs232_stdout_putchar+0x18>
  if(c!='\r') rs232_send (stdout_rs232_port, c);
    3a68:	8d 30       	cpi	r24, 0x0D	; 13
    3a6a:	29 f0       	breq	.+10     	; 0x3a76 <rs232_stdout_putchar+0x22>
    3a6c:	80 91 ff 25 	lds	r24, 0x25FF
    3a70:	61 2f       	mov	r22, r17
    3a72:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>
#else
  rs232_send (stdout_rs232_port, c);
#endif
  return 0;
}
    3a76:	80 e0       	ldi	r24, 0x00	; 0
    3a78:	90 e0       	ldi	r25, 0x00	; 0
    3a7a:	1f 91       	pop	r17
    3a7c:	08 95       	ret

00003a7e <rs232_set_input>:
/*---------------------------------------------------------------------------*/
void
rs232_set_input(uint8_t port, int (*f)(unsigned char))
{
#if NUMPORTS > 0
  if (port == 0) {
    3a7e:	88 23       	and	r24, r24
    3a80:	29 f4       	brne	.+10     	; 0x3a8c <rs232_set_input+0xe>
    input_handler_0 = f;
    3a82:	70 93 26 2e 	sts	0x2E26, r23
    3a86:	60 93 25 2e 	sts	0x2E25, r22
    3a8a:	08 95       	ret
#if NUMPORTS > 1
  } else if (port == 1) {
    3a8c:	81 30       	cpi	r24, 0x01	; 1
    3a8e:	21 f4       	brne	.+8      	; 0x3a98 <rs232_set_input+0x1a>
    input_handler_1 = f;
    3a90:	70 93 24 2e 	sts	0x2E24, r23
    3a94:	60 93 23 2e 	sts	0x2E23, r22
    3a98:	08 95       	ret

00003a9a <rs232_print>:
}

/*---------------------------------------------------------------------------*/
void
rs232_print(uint8_t port, char *buf)
{
    3a9a:	ef 92       	push	r14
    3a9c:	ff 92       	push	r15
    3a9e:	1f 93       	push	r17
    3aa0:	cf 93       	push	r28
    3aa2:	df 93       	push	r29
    3aa4:	18 2f       	mov	r17, r24
    3aa6:	e6 2e       	mov	r14, r22
    3aa8:	e7 01       	movw	r28, r14
    3aaa:	7e 01       	movw	r14, r28
    3aac:	f7 2e       	mov	r15, r23
    3aae:	e7 01       	movw	r28, r14
  while(*buf) {
    3ab0:	0c c0       	rjmp	.+24     	; 0x3aca <rs232_print+0x30>
#if ADD_CARRIAGE_RETURN_AFTER_NEWLINE
    if(*buf=='\n') rs232_send(port, '\r');
    3ab2:	8a 30       	cpi	r24, 0x0A	; 10
    3ab4:	21 f4       	brne	.+8      	; 0x3abe <rs232_print+0x24>
    3ab6:	81 2f       	mov	r24, r17
    3ab8:	6d e0       	ldi	r22, 0x0D	; 13
    3aba:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>
	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
    3abe:	69 91       	ld	r22, Y+
    3ac0:	6d 30       	cpi	r22, 0x0D	; 13
    3ac2:	19 f0       	breq	.+6      	; 0x3aca <rs232_print+0x30>
    3ac4:	81 2f       	mov	r24, r17
    3ac6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>

/*---------------------------------------------------------------------------*/
void
rs232_print(uint8_t port, char *buf)
{
  while(*buf) {
    3aca:	88 81       	ld	r24, Y
    3acc:	88 23       	and	r24, r24
    3ace:	89 f7       	brne	.-30     	; 0x3ab2 <rs232_print+0x18>
	if(*buf=='\r') buf++; else rs232_send(port, *buf++);
#else
    rs232_send(port, *buf++);
#endif
  }
}
    3ad0:	df 91       	pop	r29
    3ad2:	cf 91       	pop	r28
    3ad4:	1f 91       	pop	r17
    3ad6:	ff 90       	pop	r15
    3ad8:	ef 90       	pop	r14
    3ada:	08 95       	ret

00003adc <slip_arch_writeb>:
}
#endif
/*---------------------------------------------------------------------------*/
void
slip_arch_writeb(unsigned char c)
{
    3adc:	68 2f       	mov	r22, r24
  rs232_send(SLIP_PORT, c);
    3ade:	80 e0       	ldi	r24, 0x00	; 0
    3ae0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <rs232_send>
}
    3ae4:	08 95       	ret

00003ae6 <rs232_redirect_stdout>:
#endif
  return 0;
}
/*---------------------------------------------------------------------------*/
void rs232_redirect_stdout (uint8_t port) {
  stdout_rs232_port = port;
    3ae6:	80 93 ff 25 	sts	0x25FF, r24
  stdout = &rs232_stdout;
    3aea:	8c e9       	ldi	r24, 0x9C	; 156
    3aec:	9d e0       	ldi	r25, 0x0D	; 13
    3aee:	90 93 c7 36 	sts	0x36C7, r25
    3af2:	80 93 c6 36 	sts	0x36C6, r24
}
    3af6:	08 95       	ret

00003af8 <watchdog_init>:
watchdog_init(void)
{
/*  Clear startup bit and disable the wdt, whether or not it will be used.
    Random code may have caused the last reset.
 */
	MCUSR&=~(1<<WDRF);
    3af8:	84 b7       	in	r24, 0x34	; 52
    3afa:	87 7f       	andi	r24, 0xF7	; 247
    3afc:	84 bf       	out	0x34, r24	; 52
    wdt_disable();
    3afe:	88 e1       	ldi	r24, 0x18	; 24
    3b00:	0f b6       	in	r0, 0x3f	; 63
    3b02:	f8 94       	cli
    3b04:	80 93 60 00 	sts	0x0060, r24
    3b08:	10 92 60 00 	sts	0x0060, r1
    3b0c:	0f be       	out	0x3f, r0	; 63
#if WATCHDOG_CONF_BALANCE && WATCHDOG_CONF_TIMEOUT >= 0
	stopped = 1;
#endif
}
    3b0e:	08 95       	ret

00003b10 <watchdog_start>:
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	stopped--;
	if(!stopped)
#endif
		wdt_enable(WATCHDOG_CONF_TIMEOUT);
    3b10:	2f e0       	ldi	r18, 0x0F	; 15
    3b12:	88 e1       	ldi	r24, 0x18	; 24
    3b14:	90 e0       	ldi	r25, 0x00	; 0
    3b16:	0f b6       	in	r0, 0x3f	; 63
    3b18:	f8 94       	cli
    3b1a:	a8 95       	wdr
    3b1c:	80 93 60 00 	sts	0x0060, r24
    3b20:	0f be       	out	0x3f, r0	; 63
    3b22:	20 93 60 00 	sts	0x0060, r18
#endif  
}
    3b26:	08 95       	ret

00003b28 <watchdog_periodic>:
{
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	if(!stopped)
#endif
		wdt_reset();
    3b28:	a8 95       	wdr
#endif
}
    3b2a:	08 95       	ret

00003b2c <watchdog_stop>:
{
#if WATCHDOG_CONF_TIMEOUT >= 0
#if WATCHDOG_CONF_BALANCE
	stopped++;
#endif
	wdt_disable();
    3b2c:	88 e1       	ldi	r24, 0x18	; 24
    3b2e:	0f b6       	in	r0, 0x3f	; 63
    3b30:	f8 94       	cli
    3b32:	80 93 60 00 	sts	0x0060, r24
    3b36:	10 92 60 00 	sts	0x0060, r1
    3b3a:	0f be       	out	0x3f, r0	; 63
#endif
}
    3b3c:	08 95       	ret

00003b3e <watchdog_reboot>:
/*---------------------------------------------------------------------------*/
void
watchdog_reboot(void)
{
	cli();
    3b3e:	f8 94       	cli
	wdt_enable(WDTO_15MS); //wd on,250ms 
    3b40:	28 e0       	ldi	r18, 0x08	; 8
    3b42:	88 e1       	ldi	r24, 0x18	; 24
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	0f b6       	in	r0, 0x3f	; 63
    3b48:	f8 94       	cli
    3b4a:	a8 95       	wdr
    3b4c:	80 93 60 00 	sts	0x0060, r24
    3b50:	0f be       	out	0x3f, r0	; 63
    3b52:	20 93 60 00 	sts	0x0060, r18
    3b56:	ff cf       	rjmp	.-2      	; 0x3b56 <watchdog_reboot+0x18>

00003b58 <flushrx>:


static void
flushrx(void)
{
  rxframe[rxframe_head].length=0;
    3b58:	80 91 37 2e 	lds	r24, 0x2E37
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
    3b5e:	fc 01       	movw	r30, r24
    3b60:	ee 0f       	add	r30, r30
    3b62:	ff 1f       	adc	r31, r31
    3b64:	96 95       	lsr	r25
    3b66:	98 2f       	mov	r25, r24
    3b68:	88 27       	eor	r24, r24
    3b6a:	97 95       	ror	r25
    3b6c:	87 95       	ror	r24
    3b6e:	e8 0f       	add	r30, r24
    3b70:	f9 1f       	adc	r31, r25
    3b72:	e8 5c       	subi	r30, 0xC8	; 200
    3b74:	f1 4d       	sbci	r31, 0xD1	; 209
    3b76:	10 82       	st	Z, r1
}
    3b78:	08 95       	ret

00003b7a <rf230_pending_packet>:
rf230_pending_packet(void)
{
#if RF230_INSERTACK
    if(ack_pending == 1) return 1;
#endif
  return rf230_pending;
    3b7a:	80 91 2e 2e 	lds	r24, 0x2E2E
}
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	08 95       	ret

00003b82 <rf230_receiving_packet>:
/*---------------------------------------------------------------------------*/
int
rf230_receiving_packet(void)
{
  uint8_t radio_state;
  if (hal_get_slptr()) {
    3b82:	80 91 39 01 	lds	r24, 0x0139
    3b86:	81 fd       	sbrc	r24, 1
    3b88:	0c c0       	rjmp	.+24     	; 0x3ba2 <rf230_receiving_packet+0x20>
    DEBUGFLOW('=');
  } else {  
    radio_state = hal_subregister_read(SR_TRX_STATUS);
    3b8a:	81 e4       	ldi	r24, 0x41	; 65
    3b8c:	91 e0       	ldi	r25, 0x01	; 1
    3b8e:	6f e1       	ldi	r22, 0x1F	; 31
    3b90:	40 e0       	ldi	r20, 0x00	; 0
    3b92:	0e 94 0b 24 	call	0x4816	; 0x4816 <hal_subregister_read>
    if ((radio_state==BUSY_RX) || (radio_state==BUSY_RX_AACK)) {
    3b96:	81 30       	cpi	r24, 0x01	; 1
    3b98:	39 f0       	breq	.+14     	; 0x3ba8 <rf230_receiving_packet+0x26>
	 return 0;
   }
}
/*---------------------------------------------------------------------------*/
int
rf230_receiving_packet(void)
    3b9a:	21 e0       	ldi	r18, 0x01	; 1
    3b9c:	30 e0       	ldi	r19, 0x00	; 0
    3b9e:	81 31       	cpi	r24, 0x11	; 17
    3ba0:	29 f0       	breq	.+10     	; 0x3bac <rf230_receiving_packet+0x2a>
//      DEBUGFLOW('8');
//	  rf230_pending=1;
      return 1;
    }
  }
  return 0;
    3ba2:	20 e0       	ldi	r18, 0x00	; 0
    3ba4:	30 e0       	ldi	r19, 0x00	; 0
    3ba6:	02 c0       	rjmp	.+4      	; 0x3bac <rf230_receiving_packet+0x2a>
  } else {  
    radio_state = hal_subregister_read(SR_TRX_STATUS);
    if ((radio_state==BUSY_RX) || (radio_state==BUSY_RX_AACK)) {
//      DEBUGFLOW('8');
//	  rf230_pending=1;
      return 1;
    3ba8:	21 e0       	ldi	r18, 0x01	; 1
    3baa:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 0;
}
    3bac:	c9 01       	movw	r24, r18
    3bae:	08 95       	ret

00003bb0 <rf230_isidle>:
/*---------------------------------------------------------------------------*/
static char
rf230_isidle(void)
{
  uint8_t radio_state;
  if (hal_get_slptr()) {
    3bb0:	80 91 39 01 	lds	r24, 0x0139
    3bb4:	81 fd       	sbrc	r24, 1
    3bb6:	12 c0       	rjmp	.+36     	; 0x3bdc <rf230_isidle+0x2c>
    DEBUGFLOW(']');
	return 1;
  } else {
  radio_state = hal_subregister_read(SR_TRX_STATUS);
    3bb8:	81 e4       	ldi	r24, 0x41	; 65
    3bba:	91 e0       	ldi	r25, 0x01	; 1
    3bbc:	6f e1       	ldi	r22, 0x1F	; 31
    3bbe:	40 e0       	ldi	r20, 0x00	; 0
    3bc0:	0e 94 0b 24 	call	0x4816	; 0x4816 <hal_subregister_read>
    3bc4:	98 2f       	mov	r25, r24
  if (radio_state != BUSY_TX_ARET &&
    3bc6:	81 51       	subi	r24, 0x11	; 17
    3bc8:	82 30       	cpi	r24, 0x02	; 2
    3bca:	50 f0       	brcs	.+20     	; 0x3be0 <rf230_isidle+0x30>
      radio_state != BUSY_RX_AACK &&
    3bcc:	9f 31       	cpi	r25, 0x1F	; 31
    3bce:	41 f0       	breq	.+16     	; 0x3be0 <rf230_isidle+0x30>
      radio_state != STATE_TRANSITION &&
    3bd0:	91 30       	cpi	r25, 0x01	; 1
    3bd2:	41 f0       	breq	.+16     	; 0x3be4 <rf230_isidle+0x34>
    hal_subregister_write(SR_TRX_CMD, CMD_FORCE_TRX_OFF);
    delay_us(TIME_CMD_FORCE_TRX_OFF);
}
/*---------------------------------------------------------------------------*/
static char
rf230_isidle(void)
    3bd4:	81 e0       	ldi	r24, 0x01	; 1
    3bd6:	92 30       	cpi	r25, 0x02	; 2
    3bd8:	31 f4       	brne	.+12     	; 0x3be6 <rf230_isidle+0x36>
    3bda:	02 c0       	rjmp	.+4      	; 0x3be0 <rf230_isidle+0x30>
{
  uint8_t radio_state;
  if (hal_get_slptr()) {
    DEBUGFLOW(']');
	return 1;
    3bdc:	81 e0       	ldi	r24, 0x01	; 1
    3bde:	08 95       	ret
      radio_state != BUSY_RX && 
      radio_state != BUSY_TX) {
    return(1);
  } else {
//    printf(".%u",radio_state);
    return(0);
    3be0:	80 e0       	ldi	r24, 0x00	; 0
    3be2:	08 95       	ret
    3be4:	80 e0       	ldi	r24, 0x00	; 0
  }
  }
}
    3be6:	08 95       	ret

00003be8 <rf230_waitidle>:
  
static void
rf230_waitidle(void)
{
    3be8:	cf 93       	push	r28
    3bea:	df 93       	push	r29
    3bec:	c0 e1       	ldi	r28, 0x10	; 16
    3bee:	d7 e2       	ldi	r29, 0x27	; 39
int i;
  for (i=0;i<10000;i++) {  //to avoid potential hangs
 // while (1) {
    if (rf230_isidle()) break;
    3bf0:	0e 94 d8 1d 	call	0x3bb0	; 0x3bb0 <rf230_isidle>
    3bf4:	88 23       	and	r24, r24
    3bf6:	11 f4       	brne	.+4      	; 0x3bfc <rf230_waitidle+0x14>
    3bf8:	21 97       	sbiw	r28, 0x01	; 1
  
static void
rf230_waitidle(void)
{
int i;
  for (i=0;i<10000;i++) {  //to avoid potential hangs
    3bfa:	d1 f7       	brne	.-12     	; 0x3bf0 <rf230_waitidle+0x8>
 // while (1) {
    if (rf230_isidle()) break;
  }
  if (i>=10000) {DEBUGFLOW('H');DEBUGFLOW('R');}
}
    3bfc:	df 91       	pop	r29
    3bfe:	cf 91       	pop	r28
    3c00:	08 95       	ret

00003c02 <radio_reset_state_machine>:
 *          its states, except for the SLEEP state.
 */
static void
radio_reset_state_machine(void)
{
    if (hal_get_slptr()) DEBUGFLOW('"');
    3c02:	e9 e3       	ldi	r30, 0x39	; 57
    3c04:	f1 e0       	ldi	r31, 0x01	; 1
    3c06:	80 81       	ld	r24, Z
    hal_set_slptr_low();
    3c08:	80 81       	ld	r24, Z
    3c0a:	8d 7f       	andi	r24, 0xFD	; 253
    3c0c:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c0e:	8d e0       	ldi	r24, 0x0D	; 13
    3c10:	90 e0       	ldi	r25, 0x00	; 0
    3c12:	01 97       	sbiw	r24, 0x01	; 1
    3c14:	f1 f7       	brne	.-4      	; 0x3c12 <radio_reset_state_machine+0x10>
    delay_us(TIME_NOCLK_TO_WAKE);
    hal_subregister_write(SR_TRX_CMD, CMD_FORCE_TRX_OFF);
    3c16:	82 e4       	ldi	r24, 0x42	; 66
    3c18:	91 e0       	ldi	r25, 0x01	; 1
    3c1a:	6f e1       	ldi	r22, 0x1F	; 31
    3c1c:	40 e0       	ldi	r20, 0x00	; 0
    3c1e:	23 e0       	ldi	r18, 0x03	; 3
    3c20:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
    3c24:	83 e0       	ldi	r24, 0x03	; 3
    3c26:	90 e0       	ldi	r25, 0x00	; 0
    3c28:	01 97       	sbiw	r24, 0x01	; 1
    3c2a:	f1 f7       	brne	.-4      	; 0x3c28 <radio_reset_state_machine+0x26>
    delay_us(TIME_CMD_FORCE_TRX_OFF);
}
    3c2c:	08 95       	ret

00003c2e <off>:
#ifdef RF230BB_HOOK_RADIO_OFF
  RF230BB_HOOK_RADIO_OFF();
#endif

  /* Wait for any transmission to end */
  rf230_waitidle(); 
    3c2e:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <rf230_waitidle>
#if RADIOALWAYSON
/* Do not transmit autoacks when stack thinks radio is off */
  radio_set_trx_state(RX_ON);
#else 
  /* Force the device into TRX_OFF. */   
  radio_reset_state_machine();
    3c32:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <radio_reset_state_machine>
#if RADIOSLEEPSWHENOFF
  /* Sleep Radio */
  hal_set_slptr_high();
    3c36:	80 91 39 01 	lds	r24, 0x0139
    3c3a:	82 60       	ori	r24, 0x02	; 2
    3c3c:	80 93 39 01 	sts	0x0139, r24
  ENERGEST_OFF(ENERGEST_TYPE_LED_RED);
    3c40:	80 91 45 30 	lds	r24, 0x3045
    3c44:	88 23       	and	r24, r24
    3c46:	e9 f1       	breq	.+122    	; 0x3cc2 <off+0x94>
    3c48:	80 91 94 00 	lds	r24, 0x0094
    3c4c:	90 91 95 00 	lds	r25, 0x0095
    3c50:	20 91 56 30 	lds	r18, 0x3056
    3c54:	30 91 57 30 	lds	r19, 0x3057
    3c58:	82 17       	cp	r24, r18
    3c5a:	93 07       	cpc	r25, r19
    3c5c:	a0 f4       	brcc	.+40     	; 0x3c86 <off+0x58>
    3c5e:	80 91 22 30 	lds	r24, 0x3022
    3c62:	90 91 23 30 	lds	r25, 0x3023
    3c66:	a0 91 24 30 	lds	r26, 0x3024
    3c6a:	b0 91 25 30 	lds	r27, 0x3025
    3c6e:	8c 57       	subi	r24, 0x7C	; 124
    3c70:	91 4e       	sbci	r25, 0xE1	; 225
    3c72:	af 4f       	sbci	r26, 0xFF	; 255
    3c74:	bf 4f       	sbci	r27, 0xFF	; 255
    3c76:	80 93 22 30 	sts	0x3022, r24
    3c7a:	90 93 23 30 	sts	0x3023, r25
    3c7e:	a0 93 24 30 	sts	0x3024, r26
    3c82:	b0 93 25 30 	sts	0x3025, r27
    3c86:	80 91 94 00 	lds	r24, 0x0094
    3c8a:	90 91 95 00 	lds	r25, 0x0095
    3c8e:	82 1b       	sub	r24, r18
    3c90:	93 0b       	sbc	r25, r19
    3c92:	a0 e0       	ldi	r26, 0x00	; 0
    3c94:	b0 e0       	ldi	r27, 0x00	; 0
    3c96:	20 91 22 30 	lds	r18, 0x3022
    3c9a:	30 91 23 30 	lds	r19, 0x3023
    3c9e:	40 91 24 30 	lds	r20, 0x3024
    3ca2:	50 91 25 30 	lds	r21, 0x3025
    3ca6:	82 0f       	add	r24, r18
    3ca8:	93 1f       	adc	r25, r19
    3caa:	a4 1f       	adc	r26, r20
    3cac:	b5 1f       	adc	r27, r21
    3cae:	80 93 22 30 	sts	0x3022, r24
    3cb2:	90 93 23 30 	sts	0x3023, r25
    3cb6:	a0 93 24 30 	sts	0x3024, r26
    3cba:	b0 93 25 30 	sts	0x3025, r27
    3cbe:	10 92 45 30 	sts	0x3045, r1
#endif
#endif /* RADIOALWAYSON */

   RF230_receive_on = 0;
    3cc2:	10 92 c3 2f 	sts	0x2FC3, r1
   ENERGEST_OFF(ENERGEST_TYPE_LISTEN);
    3cc6:	80 91 47 30 	lds	r24, 0x3047
    3cca:	88 23       	and	r24, r24
    3ccc:	e9 f1       	breq	.+122    	; 0x3d48 <off+0x11a>
    3cce:	80 91 94 00 	lds	r24, 0x0094
    3cd2:	90 91 95 00 	lds	r25, 0x0095
    3cd6:	20 91 5a 30 	lds	r18, 0x305A
    3cda:	30 91 5b 30 	lds	r19, 0x305B
    3cde:	82 17       	cp	r24, r18
    3ce0:	93 07       	cpc	r25, r19
    3ce2:	a0 f4       	brcc	.+40     	; 0x3d0c <off+0xde>
    3ce4:	80 91 2a 30 	lds	r24, 0x302A
    3ce8:	90 91 2b 30 	lds	r25, 0x302B
    3cec:	a0 91 2c 30 	lds	r26, 0x302C
    3cf0:	b0 91 2d 30 	lds	r27, 0x302D
    3cf4:	8c 57       	subi	r24, 0x7C	; 124
    3cf6:	91 4e       	sbci	r25, 0xE1	; 225
    3cf8:	af 4f       	sbci	r26, 0xFF	; 255
    3cfa:	bf 4f       	sbci	r27, 0xFF	; 255
    3cfc:	80 93 2a 30 	sts	0x302A, r24
    3d00:	90 93 2b 30 	sts	0x302B, r25
    3d04:	a0 93 2c 30 	sts	0x302C, r26
    3d08:	b0 93 2d 30 	sts	0x302D, r27
    3d0c:	80 91 94 00 	lds	r24, 0x0094
    3d10:	90 91 95 00 	lds	r25, 0x0095
    3d14:	82 1b       	sub	r24, r18
    3d16:	93 0b       	sbc	r25, r19
    3d18:	a0 e0       	ldi	r26, 0x00	; 0
    3d1a:	b0 e0       	ldi	r27, 0x00	; 0
    3d1c:	20 91 2a 30 	lds	r18, 0x302A
    3d20:	30 91 2b 30 	lds	r19, 0x302B
    3d24:	40 91 2c 30 	lds	r20, 0x302C
    3d28:	50 91 2d 30 	lds	r21, 0x302D
    3d2c:	82 0f       	add	r24, r18
    3d2e:	93 1f       	adc	r25, r19
    3d30:	a4 1f       	adc	r26, r20
    3d32:	b5 1f       	adc	r27, r21
    3d34:	80 93 2a 30 	sts	0x302A, r24
    3d38:	90 93 2b 30 	sts	0x302B, r25
    3d3c:	a0 93 2c 30 	sts	0x302C, r26
    3d40:	b0 93 2d 30 	sts	0x302D, r27
    3d44:	10 92 47 30 	sts	0x3047, r1
    3d48:	08 95       	ret

00003d4a <rf230_off>:
/*---------------------------------------------------------------------------*/
int
rf230_off(void)
{
  /* Don't do anything if we are already turned off. */
  if(RF230_receive_on == 0) {
    3d4a:	80 91 c3 2f 	lds	r24, 0x2FC3
    3d4e:	88 23       	and	r24, r24
    3d50:	21 f0       	breq	.+8      	; 0x3d5a <rf230_off+0x10>

  /* If we are currently receiving a packet, we still call off(),
     as that routine waits until Rx is complete (packet uploaded in ISR
     so no worries about losing it). If using RX_AACK_MODE, chances are
     the packet is not for us and will be discarded. */
  if (!rf230_isidle()) {
    3d52:	0e 94 d8 1d 	call	0x3bb0	; 0x3bb0 <rf230_isidle>
    PRINTF("rf230_off: busy receiving\r\n");
    //return 1;
  }

  off();
    3d56:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <off>
  return 0;
}
    3d5a:	80 e0       	ldi	r24, 0x00	; 0
    3d5c:	90 e0       	ldi	r25, 0x00	; 0
    3d5e:	08 95       	ret

00003d60 <set_txpower>:
set_txpower(uint8_t power)
{
  if (power > TX_PWR_17_2DBM){
    power=TX_PWR_17_2DBM;
  }
  if (hal_get_slptr()) {
    3d60:	90 91 39 01 	lds	r25, 0x0139
    3d64:	91 fd       	sbrc	r25, 1
    3d66:	0a c0       	rjmp	.+20     	; 0x3d7c <set_txpower+0x1c>
    DEBUGFLOW('f');
    PRINTF("rf230_set_txpower:Sleeping");  //happens with cxmac
  } else {
    DEBUGFLOW('g');
    hal_subregister_write(SR_TX_PWR, power);
    3d68:	28 2f       	mov	r18, r24
    3d6a:	80 31       	cpi	r24, 0x10	; 16
    3d6c:	08 f0       	brcs	.+2      	; 0x3d70 <set_txpower+0x10>
    3d6e:	2f e0       	ldi	r18, 0x0F	; 15
    3d70:	85 e4       	ldi	r24, 0x45	; 69
    3d72:	91 e0       	ldi	r25, 0x01	; 1
    3d74:	6f e0       	ldi	r22, 0x0F	; 15
    3d76:	40 e0       	ldi	r20, 0x00	; 0
    3d78:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
    3d7c:	08 95       	ret

00003d7e <rf230_prepare>:
  return tx_result;
}
/*---------------------------------------------------------------------------*/
static int
rf230_prepare(const void *payload, unsigned short payload_len)
{
    3d7e:	b8 2f       	mov	r27, r24
    3d80:	a9 2f       	mov	r26, r25
    3d82:	f6 2f       	mov	r31, r22
    3d84:	e7 2f       	mov	r30, r23
  DEBUGFLOW('p');

//  PRINTF("rf230: sending %d bytes\n", payload_len);
//  PRINTSHORT("s%d ",payload_len);

  RIMESTATS_ADD(tx);
    3d86:	20 91 c6 2f 	lds	r18, 0x2FC6
    3d8a:	30 91 c7 2f 	lds	r19, 0x2FC7
    3d8e:	40 91 c8 2f 	lds	r20, 0x2FC8
    3d92:	50 91 c9 2f 	lds	r21, 0x2FC9
    3d96:	2f 5f       	subi	r18, 0xFF	; 255
    3d98:	3f 4f       	sbci	r19, 0xFF	; 255
    3d9a:	4f 4f       	sbci	r20, 0xFF	; 255
    3d9c:	5f 4f       	sbci	r21, 0xFF	; 255
    3d9e:	20 93 c6 2f 	sts	0x2FC6, r18
    3da2:	30 93 c7 2f 	sts	0x2FC7, r19
    3da6:	40 93 c8 2f 	sts	0x2FC8, r20
    3daa:	50 93 c9 2f 	sts	0x2FC9, r21
#if RF230_CONF_CHECKSUM
  checksum = crc16_data(payload, payload_len, 0);
#endif
 
  /* Copy payload to RAM buffer */
  total_len = payload_len + AUX_LEN;
    3dae:	86 2f       	mov	r24, r22
    3db0:	8e 5f       	subi	r24, 0xFE	; 254
  if (total_len > RF230_MAX_TX_FRAME_LENGTH){
    3db2:	87 ff       	sbrs	r24, 7
    3db4:	0c c0       	rjmp	.+24     	; 0x3dce <rf230_prepare+0x50>
#if RADIOSTATS
    RF230_sendfail++;
    3db6:	80 91 c0 2f 	lds	r24, 0x2FC0
    3dba:	90 91 c1 2f 	lds	r25, 0x2FC1
    3dbe:	01 96       	adiw	r24, 0x01	; 1
    3dc0:	90 93 c1 2f 	sts	0x2FC1, r25
    3dc4:	80 93 c0 2f 	sts	0x2FC0, r24
#endif
    PRINTF("rf230_prepare: packet too large (%d, max: %d)\n",total_len,RF230_MAX_TX_FRAME_LENGTH);
    ret = -1;
    3dc8:	2f ef       	ldi	r18, 0xFF	; 255
    3dca:	3f ef       	ldi	r19, 0xFF	; 255
    goto bail;
    3dcc:	0b c0       	rjmp	.+22     	; 0x3de4 <rf230_prepare+0x66>
  }
  pbuf=&buffer[0];
  memcpy(pbuf,payload,payload_len);
    3dce:	20 e0       	ldi	r18, 0x00	; 0
    3dd0:	36 e2       	ldi	r19, 0x26	; 38
    3dd2:	c9 01       	movw	r24, r18
    3dd4:	6b 2f       	mov	r22, r27
    3dd6:	7a 2f       	mov	r23, r26
    3dd8:	4f 2f       	mov	r20, r31
    3dda:	5e 2f       	mov	r21, r30
    3ddc:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
}
/*---------------------------------------------------------------------------*/
static int
rf230_prepare(const void *payload, unsigned short payload_len)
{
  int ret = 0;
    3de0:	20 e0       	ldi	r18, 0x00	; 0
    3de2:	30 e0       	ldi	r19, 0x00	; 0
#endif
  

bail:
  return ret;
}
    3de4:	c9 01       	movw	r24, r18
    3de6:	08 95       	ret

00003de8 <radio_get_trx_state>:
 */
//static uint8_t
uint8_t
radio_get_trx_state(void)
{
    return hal_subregister_read(SR_TRX_STATUS);
    3de8:	81 e4       	ldi	r24, 0x41	; 65
    3dea:	91 e0       	ldi	r25, 0x01	; 1
    3dec:	6f e1       	ldi	r22, 0x1F	; 31
    3dee:	40 e0       	ldi	r20, 0x00	; 0
    3df0:	0e 94 0b 24 	call	0x4816	; 0x4816 <hal_subregister_read>
}
    3df4:	08 95       	ret

00003df6 <radio_set_trx_state>:
 *  \retval    RADIO_TIMED_OUT        The state transition could not be completed
 *                                  within resonable time.
 */
static radio_status_t
radio_set_trx_state(uint8_t new_state)
{
    3df6:	0f 93       	push	r16
    3df8:	1f 93       	push	r17
    3dfa:	18 2f       	mov	r17, r24
    uint8_t original_state;

    /*Check function paramter and current state of the radio transceiver.*/
    if (!((new_state == TRX_OFF)    ||
    3dfc:	88 30       	cpi	r24, 0x08	; 8
    3dfe:	49 f0       	breq	.+18     	; 0x3e12 <radio_set_trx_state+0x1c>
    3e00:	86 30       	cpi	r24, 0x06	; 6
    3e02:	39 f0       	breq	.+14     	; 0x3e12 <radio_set_trx_state+0x1c>
          (new_state == RX_ON)      ||
    3e04:	89 30       	cpi	r24, 0x09	; 9
    3e06:	29 f0       	breq	.+10     	; 0x3e12 <radio_set_trx_state+0x1c>
          (new_state == PLL_ON)     ||
    3e08:	86 31       	cpi	r24, 0x16	; 22
    3e0a:	19 f0       	breq	.+6      	; 0x3e12 <radio_set_trx_state+0x1c>
radio_set_trx_state(uint8_t new_state)
{
    uint8_t original_state;

    /*Check function paramter and current state of the radio transceiver.*/
    if (!((new_state == TRX_OFF)    ||
    3e0c:	89 31       	cpi	r24, 0x19	; 25
    3e0e:	09 f0       	breq	.+2      	; 0x3e12 <radio_set_trx_state+0x1c>
    3e10:	41 c0       	rjmp	.+130    	; 0x3e94 <radio_set_trx_state+0x9e>
          (new_state == RX_AACK_ON) ||
          (new_state == TX_ARET_ON))){
        return RADIO_INVALID_ARGUMENT;
    }

	if (hal_get_slptr()) {
    3e12:	80 91 39 01 	lds	r24, 0x0139
    3e16:	81 fd       	sbrc	r24, 1
    3e18:	40 c0       	rjmp	.+128    	; 0x3e9a <radio_set_trx_state+0xa4>
        return RADIO_WRONG_STATE;
    }

    /* Wait for radio to finish previous operation */
    rf230_waitidle();
    3e1a:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <rf230_waitidle>
 //   for(;;)
 //   {
        original_state = radio_get_trx_state();
    3e1e:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <radio_get_trx_state>
    3e22:	08 2f       	mov	r16, r24
  //          original_state != BUSY_RX && 
  //          original_state != BUSY_TX)
  //          break;
  //  }

    if (new_state == original_state){
    3e24:	18 17       	cp	r17, r24
    3e26:	09 f4       	brne	.+2      	; 0x3e2a <radio_set_trx_state+0x34>
    3e28:	3b c0       	rjmp	.+118    	; 0x3ea0 <radio_set_trx_state+0xaa>
    /* At this point it is clear that the requested new_state is: */
    /* TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON. */

    /* The radio transceiver can be in one of the following states: */
    /* TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON, TX_ARET_ON. */
    if(new_state == TRX_OFF){
    3e2a:	18 30       	cpi	r17, 0x08	; 8
    3e2c:	19 f4       	brne	.+6      	; 0x3e34 <radio_set_trx_state+0x3e>
        radio_reset_state_machine(); /* Go to TRX_OFF from any state. */
    3e2e:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <radio_reset_state_machine>
    3e32:	29 c0       	rjmp	.+82     	; 0x3e86 <radio_set_trx_state+0x90>
    } else {
        /* It is not allowed to go from RX_AACK_ON or TX_AACK_ON and directly to */
        /* TX_AACK_ON or RX_AACK_ON respectively. Need to go via RX_ON or PLL_ON. */
        if ((new_state == TX_ARET_ON) &&
    3e34:	19 31       	cpi	r17, 0x19	; 25
    3e36:	41 f4       	brne	.+16     	; 0x3e48 <radio_set_trx_state+0x52>
    3e38:	86 31       	cpi	r24, 0x16	; 22
    3e3a:	a9 f4       	brne	.+42     	; 0x3e66 <radio_set_trx_state+0x70>
            (original_state == RX_AACK_ON)){
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            /* The final state transition to TX_ARET_ON is handled after the if-else if. */
            hal_subregister_write(SR_TRX_CMD, PLL_ON);
    3e3c:	82 e4       	ldi	r24, 0x42	; 66
    3e3e:	91 e0       	ldi	r25, 0x01	; 1
    3e40:	6f e1       	ldi	r22, 0x1F	; 31
    3e42:	40 e0       	ldi	r20, 0x00	; 0
    3e44:	29 e0       	ldi	r18, 0x09	; 9
    3e46:	09 c0       	rjmp	.+18     	; 0x3e5a <radio_set_trx_state+0x64>
            delay_us(TIME_STATE_TRANSITION_PLL_ACTIVE);
        } else if ((new_state == RX_AACK_ON) &&
    3e48:	16 31       	cpi	r17, 0x16	; 22
    3e4a:	69 f4       	brne	.+26     	; 0x3e66 <radio_set_trx_state+0x70>
    3e4c:	89 31       	cpi	r24, 0x19	; 25
    3e4e:	59 f4       	brne	.+22     	; 0x3e66 <radio_set_trx_state+0x70>
                 (original_state == TX_ARET_ON)){
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            /* The final state transition to RX_AACK_ON is handled after the if-else if. */
            hal_subregister_write(SR_TRX_CMD, RX_ON);
    3e50:	82 e4       	ldi	r24, 0x42	; 66
    3e52:	91 e0       	ldi	r25, 0x01	; 1
    3e54:	6f e1       	ldi	r22, 0x1F	; 31
    3e56:	40 e0       	ldi	r20, 0x00	; 0
    3e58:	26 e0       	ldi	r18, 0x06	; 6
    3e5a:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
    3e5e:	e3 e0       	ldi	r30, 0x03	; 3
    3e60:	f0 e0       	ldi	r31, 0x00	; 0
    3e62:	31 97       	sbiw	r30, 0x01	; 1
    3e64:	f1 f7       	brne	.-4      	; 0x3e62 <radio_set_trx_state+0x6c>
            delay_us(TIME_STATE_TRANSITION_PLL_ACTIVE);
        }

        /* Any other state transition can be done directly. */
        hal_subregister_write(SR_TRX_CMD, new_state);
    3e66:	82 e4       	ldi	r24, 0x42	; 66
    3e68:	91 e0       	ldi	r25, 0x01	; 1
    3e6a:	6f e1       	ldi	r22, 0x1F	; 31
    3e6c:	40 e0       	ldi	r20, 0x00	; 0
    3e6e:	21 2f       	mov	r18, r17
    3e70:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>

        /* When the PLL is active most states can be reached in 1us. However, from */
        /* TRX_OFF the PLL needs time to activate. */
        if (original_state == TRX_OFF){
    3e74:	08 30       	cpi	r16, 0x08	; 8
    3e76:	19 f4       	brne	.+6      	; 0x3e7e <radio_set_trx_state+0x88>
    3e78:	e9 e6       	ldi	r30, 0x69	; 105
    3e7a:	f1 e0       	ldi	r31, 0x01	; 1
    3e7c:	02 c0       	rjmp	.+4      	; 0x3e82 <radio_set_trx_state+0x8c>
    3e7e:	e3 e0       	ldi	r30, 0x03	; 3
    3e80:	f0 e0       	ldi	r31, 0x00	; 0
    3e82:	31 97       	sbiw	r30, 0x01	; 1
    3e84:	f1 f7       	brne	.-4      	; 0x3e82 <radio_set_trx_state+0x8c>
    } /*  end: if(new_state == TRX_OFF) ... */

    /*Verify state transition.*/
    radio_status_t set_state_status = RADIO_TIMED_OUT;

    if (radio_get_trx_state() == new_state){
    3e86:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <radio_get_trx_state>
    3e8a:	81 17       	cp	r24, r17
    3e8c:	49 f0       	breq	.+18     	; 0x3ea0 <radio_set_trx_state+0xaa>
            delay_us(TIME_STATE_TRANSITION_PLL_ACTIVE);
        }
    } /*  end: if(new_state == TRX_OFF) ... */

    /*Verify state transition.*/
    radio_status_t set_state_status = RADIO_TIMED_OUT;
    3e8e:	23 e4       	ldi	r18, 0x43	; 67
    3e90:	30 e0       	ldi	r19, 0x00	; 0
    3e92:	08 c0       	rjmp	.+16     	; 0x3ea4 <radio_set_trx_state+0xae>
    if (!((new_state == TRX_OFF)    ||
          (new_state == RX_ON)      ||
          (new_state == PLL_ON)     ||
          (new_state == RX_AACK_ON) ||
          (new_state == TX_ARET_ON))){
        return RADIO_INVALID_ARGUMENT;
    3e94:	22 e4       	ldi	r18, 0x42	; 66
    3e96:	30 e0       	ldi	r19, 0x00	; 0
    3e98:	05 c0       	rjmp	.+10     	; 0x3ea4 <radio_set_trx_state+0xae>
    }

	if (hal_get_slptr()) {
        return RADIO_WRONG_STATE;
    3e9a:	24 e4       	ldi	r18, 0x44	; 68
    3e9c:	30 e0       	ldi	r19, 0x00	; 0
    3e9e:	02 c0       	rjmp	.+4      	; 0x3ea4 <radio_set_trx_state+0xae>

    /*Verify state transition.*/
    radio_status_t set_state_status = RADIO_TIMED_OUT;

    if (radio_get_trx_state() == new_state){
        set_state_status = RADIO_SUCCESS;
    3ea0:	20 e4       	ldi	r18, 0x40	; 64
    3ea2:	30 e0       	ldi	r19, 0x00	; 0
    }

    return set_state_status;
}
    3ea4:	c9 01       	movw	r24, r18
    3ea6:	1f 91       	pop	r17
    3ea8:	0f 91       	pop	r16
    3eaa:	08 95       	ret

00003eac <on>:
/*---------------------------------------------------------------------------*/
static void
on(void)
{
//   ENERGEST_OFF(ENERGEST_TYPE_LISTEN);//testing
  ENERGEST_ON(ENERGEST_TYPE_LISTEN);
    3eac:	80 91 94 00 	lds	r24, 0x0094
    3eb0:	90 91 95 00 	lds	r25, 0x0095
    3eb4:	90 93 5b 30 	sts	0x305B, r25
    3eb8:	80 93 5a 30 	sts	0x305A, r24
    3ebc:	21 e0       	ldi	r18, 0x01	; 1
    3ebe:	20 93 47 30 	sts	0x3047, r18
  RF230_receive_on = 1;
    3ec2:	20 93 c3 2f 	sts	0x2FC3, r18
#ifdef RF230BB_HOOK_RADIO_ON
  RF230BB_HOOK_RADIO_ON();
#endif

/* If radio is off (slptr high), turn it on */
  if (hal_get_slptr()) {
    3ec6:	80 91 39 01 	lds	r24, 0x0139
    3eca:	81 ff       	sbrs	r24, 1
    3ecc:	16 c0       	rjmp	.+44     	; 0x3efa <on+0x4e>
    ENERGEST_ON(ENERGEST_TYPE_LED_RED);
    3ece:	80 91 94 00 	lds	r24, 0x0094
    3ed2:	90 91 95 00 	lds	r25, 0x0095
    3ed6:	90 93 57 30 	sts	0x3057, r25
    3eda:	80 93 56 30 	sts	0x3056, r24
    3ede:	20 93 45 30 	sts	0x3045, r18
#if RF230BB_CONF_LEDONPORTE1
    PORTE|=(1<<PE1); //ledon
#endif
#if defined(__AVR_ATmega128RFA1__)
/* Use the poweron interrupt for delay */
    rf230_interruptwait=1;
    3ee2:	20 93 c2 2f 	sts	0x2FC2, r18
    sei();
    3ee6:	78 94       	sei
    hal_set_slptr_low();
    3ee8:	80 91 39 01 	lds	r24, 0x0139
    3eec:	8d 7f       	andi	r24, 0xFD	; 253
    3eee:	80 93 39 01 	sts	0x0139, r24
    while (rf230_interruptwait) {}
    3ef2:	80 91 c2 2f 	lds	r24, 0x2FC2
    3ef6:	88 23       	and	r24, r24
    3ef8:	e1 f7       	brne	.-8      	; 0x3ef2 <on+0x46>
#endif
  }

#if RF230_CONF_AUTOACK
 // radio_set_trx_state(is_promiscuous?RX_ON:RX_AACK_ON);
  radio_set_trx_state(RX_AACK_ON);
    3efa:	86 e1       	ldi	r24, 0x16	; 22
    3efc:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <radio_set_trx_state>
#else
  radio_set_trx_state(RX_ON);
#endif
  rf230_waitidle();
    3f00:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <rf230_waitidle>
}
    3f04:	08 95       	ret

00003f06 <rf230_on>:
}
/*---------------------------------------------------------------------------*/
int
rf230_on(void)
{
  if(RF230_receive_on) {
    3f06:	80 91 c3 2f 	lds	r24, 0x2FC3
    3f0a:	88 23       	and	r24, r24
    3f0c:	11 f4       	brne	.+4      	; 0x3f12 <rf230_on+0xc>
    DEBUGFLOW('q');
    return 1;
  }

  on();
    3f0e:	0e 94 56 1f 	call	0x3eac	; 0x3eac <on>
  return 1;
}
    3f12:	81 e0       	ldi	r24, 0x01	; 1
    3f14:	90 e0       	ldi	r25, 0x00	; 0
    3f16:	08 95       	ret

00003f18 <rf230_cca>:
}

/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
{
    3f18:	0f 93       	push	r16
    3f1a:	1f 93       	push	r17
  uint8_t cca=0;
  uint8_t radio_was_off = 0;

  /* Turn radio on if necessary. If radio is currently busy return busy channel */
  /* This may happen when testing radio duty cycling with RADIOALWAYSON */
  if(RF230_receive_on) {
    3f1c:	80 91 c3 2f 	lds	r24, 0x2FC3
    3f20:	88 23       	and	r24, r24
    3f22:	59 f0       	breq	.+22     	; 0x3f3a <rf230_cca+0x22>
    if (hal_get_slptr()) {  //should not be sleeping!
    3f24:	80 91 39 01 	lds	r24, 0x0139
    3f28:	81 fd       	sbrc	r24, 1
    3f2a:	74 c0       	rjmp	.+232    	; 0x4014 <rf230_cca+0xfc>
	  DEBUGFLOW('<');
	  goto busyexit;
	} else {
      if (!rf230_isidle()) {DEBUGFLOW('2');goto busyexit;}
    3f2c:	0e 94 d8 1d 	call	0x3bb0	; 0x3bb0 <rf230_isidle>
    3f30:	88 23       	and	r24, r24
    3f32:	09 f4       	brne	.+2      	; 0x3f36 <rf230_cca+0x1e>
    3f34:	6f c0       	rjmp	.+222    	; 0x4014 <rf230_cca+0xfc>
/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
{
  uint8_t cca=0;
  uint8_t radio_was_off = 0;
    3f36:	00 e0       	ldi	r16, 0x00	; 0
    3f38:	03 c0       	rjmp	.+6      	; 0x3f40 <rf230_cca+0x28>
	} else {
      if (!rf230_isidle()) {DEBUGFLOW('2');goto busyexit;}
	}
  } else {
    radio_was_off = 1;
    rf230_on();
    3f3a:	0e 94 83 1f 	call	0x3f06	; 0x3f06 <rf230_on>
	  goto busyexit;
	} else {
      if (!rf230_isidle()) {DEBUGFLOW('2');goto busyexit;}
	}
  } else {
    radio_was_off = 1;
    3f3e:	01 e0       	ldi	r16, 0x01	; 1
    rf230_on();
  }

  ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW);
    3f40:	80 91 94 00 	lds	r24, 0x0094
    3f44:	90 91 95 00 	lds	r25, 0x0095
    3f48:	90 93 55 30 	sts	0x3055, r25
    3f4c:	80 93 54 30 	sts	0x3054, r24
    3f50:	11 e0       	ldi	r17, 0x01	; 1
    3f52:	10 93 44 30 	sts	0x3044, r17

  /* Start the CCA, wait till done, return result */
  /* Note reading the TRX_STATUS register clears both CCA_STATUS and CCA_DONE bits */
#if defined(__AVR_ATmega128RFA1__)
#if 1  //interrupt method
    sei();
    3f56:	78 94       	sei
//rf230_waitidle();
//TODO:disable reception for version bug
  radio_set_trx_state(RX_ON);
    3f58:	86 e0       	ldi	r24, 0x06	; 6
    3f5a:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <radio_set_trx_state>
//  rf230_waitidle();
    rf230_ccawait=1;
    3f5e:	10 93 2f 2e 	sts	0x2E2F, r17
//CCA_REQUEST is supposed to trigger the interrupt but it doesn't
//  hal_subregister_write(SR_CCA_REQUEST,1);
    hal_register_write(PHY_ED_LEVEL,0);
    3f62:	10 92 47 01 	sts	0x0147, r1
//  delay_us(TIME_CCA);
//  if (hal_register_read(RG_PHY_ED_LEVEL)<(91-77)) cca=0xff;
    while (rf230_ccawait) {}
    3f66:	80 91 2f 2e 	lds	r24, 0x2E2F
    3f6a:	88 23       	and	r24, r24
    3f6c:	e1 f7       	brne	.-8      	; 0x3f66 <rf230_cca+0x4e>
#ifdef RF230_CONF_CCA_THRES
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91+RF230_CONF_CCA_THRES) cca=0xff;
#else
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91-77)) cca=0xff;
    3f6e:	80 91 47 01 	lds	r24, 0x0147
    3f72:	8e 30       	cpi	r24, 0x0E	; 14
    3f74:	10 f0       	brcs	.+4      	; 0x3f7a <rf230_cca+0x62>

/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
{
  uint8_t cca=0;
    3f76:	10 e0       	ldi	r17, 0x00	; 0
    3f78:	01 c0       	rjmp	.+2      	; 0x3f7c <rf230_cca+0x64>
//  if (hal_register_read(RG_PHY_ED_LEVEL)<(91-77)) cca=0xff;
    while (rf230_ccawait) {}
#ifdef RF230_CONF_CCA_THRES
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91+RF230_CONF_CCA_THRES) cca=0xff;
#else
    if (hal_register_read(RG_PHY_ED_LEVEL)<(91-77)) cca=0xff;
    3f7a:	1f ef       	ldi	r17, 0xFF	; 255
#endif
//TODO:see if the status register works!
//   cca=hal_register_read(RG_TRX_STATUS);
#if RF230_CONF_AUTOACK
  radio_set_trx_state(RX_AACK_ON);
    3f7c:	86 e1       	ldi	r24, 0x16	; 22
    3f7e:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <radio_set_trx_state>
    cca=hal_register_read(RG_TRX_STATUS);
  }
  SREG=saved_sreg;
}
#endif
  ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW); 
    3f82:	80 91 44 30 	lds	r24, 0x3044
    3f86:	88 23       	and	r24, r24
    3f88:	e9 f1       	breq	.+122    	; 0x4004 <rf230_cca+0xec>
    3f8a:	80 91 94 00 	lds	r24, 0x0094
    3f8e:	90 91 95 00 	lds	r25, 0x0095
    3f92:	20 91 54 30 	lds	r18, 0x3054
    3f96:	30 91 55 30 	lds	r19, 0x3055
    3f9a:	82 17       	cp	r24, r18
    3f9c:	93 07       	cpc	r25, r19
    3f9e:	a0 f4       	brcc	.+40     	; 0x3fc8 <rf230_cca+0xb0>
    3fa0:	80 91 1e 30 	lds	r24, 0x301E
    3fa4:	90 91 1f 30 	lds	r25, 0x301F
    3fa8:	a0 91 20 30 	lds	r26, 0x3020
    3fac:	b0 91 21 30 	lds	r27, 0x3021
    3fb0:	8c 57       	subi	r24, 0x7C	; 124
    3fb2:	91 4e       	sbci	r25, 0xE1	; 225
    3fb4:	af 4f       	sbci	r26, 0xFF	; 255
    3fb6:	bf 4f       	sbci	r27, 0xFF	; 255
    3fb8:	80 93 1e 30 	sts	0x301E, r24
    3fbc:	90 93 1f 30 	sts	0x301F, r25
    3fc0:	a0 93 20 30 	sts	0x3020, r26
    3fc4:	b0 93 21 30 	sts	0x3021, r27
    3fc8:	80 91 94 00 	lds	r24, 0x0094
    3fcc:	90 91 95 00 	lds	r25, 0x0095
    3fd0:	82 1b       	sub	r24, r18
    3fd2:	93 0b       	sbc	r25, r19
    3fd4:	a0 e0       	ldi	r26, 0x00	; 0
    3fd6:	b0 e0       	ldi	r27, 0x00	; 0
    3fd8:	20 91 1e 30 	lds	r18, 0x301E
    3fdc:	30 91 1f 30 	lds	r19, 0x301F
    3fe0:	40 91 20 30 	lds	r20, 0x3020
    3fe4:	50 91 21 30 	lds	r21, 0x3021
    3fe8:	82 0f       	add	r24, r18
    3fea:	93 1f       	adc	r25, r19
    3fec:	a4 1f       	adc	r26, r20
    3fee:	b5 1f       	adc	r27, r21
    3ff0:	80 93 1e 30 	sts	0x301E, r24
    3ff4:	90 93 1f 30 	sts	0x301F, r25
    3ff8:	a0 93 20 30 	sts	0x3020, r26
    3ffc:	b0 93 21 30 	sts	0x3021, r27
    4000:	10 92 44 30 	sts	0x3044, r1
  if(radio_was_off) {
    4004:	00 23       	and	r16, r16
    4006:	11 f0       	breq	.+4      	; 0x400c <rf230_cca+0xf4>
    rf230_off();
    4008:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <rf230_off>
  return rssi;
}

/*---------------------------------------------------------------------------*/
static int
rf230_cca(void)
    400c:	21 e0       	ldi	r18, 0x01	; 1
    400e:	30 e0       	ldi	r19, 0x00	; 0
    4010:	16 fd       	sbrc	r17, 6
    4012:	02 c0       	rjmp	.+4      	; 0x4018 <rf230_cca+0x100>
//   DEBUGFLOW('5');
	 return 1;
   } else {
//  DEBUGFLOW('6');
 busyexit:
	 return 0;
    4014:	20 e0       	ldi	r18, 0x00	; 0
    4016:	30 e0       	ldi	r19, 0x00	; 0
   }
}
    4018:	c9 01       	movw	r24, r18
    401a:	1f 91       	pop	r17
    401c:	0f 91       	pop	r16
    401e:	08 95       	ret

00004020 <rf230_set_promiscuous_mode>:
}

void
rf230_set_promiscuous_mode(bool isPromiscuous) {
#if RF230_CONF_AUTOACK
    is_promiscuous = isPromiscuous;
    4020:	80 93 82 26 	sts	0x2682, r24
/* TODO: Figure out when to pass promisc state to 802.15.4 */
//    radio_set_trx_state(is_promiscuous?RX_ON:RX_AACK_ON);
#endif
}
    4024:	08 95       	ret

00004026 <rf230_is_ready_to_send>:

bool
rf230_is_ready_to_send() {
	switch(radio_get_trx_state()) {
    4026:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <radio_get_trx_state>
    402a:	82 50       	subi	r24, 0x02	; 2
    402c:	81 31       	cpi	r24, 0x11	; 17
    402e:	30 f4       	brcc	.+12     	; 0x403c <rf230_is_ready_to_send+0x16>
    4030:	e8 2f       	mov	r30, r24
    4032:	f0 e0       	ldi	r31, 0x00	; 0
    4034:	eb 52       	subi	r30, 0x2B	; 43
    4036:	f2 4f       	sbci	r31, 0xF2	; 242
    4038:	80 81       	ld	r24, Z
    403a:	08 95       	ret
    403c:	81 e0       	ldi	r24, 0x01	; 1
		case BUSY_TX_ARET:
			return false;
	}
	
	return true;
}
    403e:	08 95       	ret

00004040 <rf230_setpendingbit>:
    DEBUGFLOW('g');
    hal_subregister_write(SR_TX_PWR, power);
  }
}
void rf230_setpendingbit(uint8_t value)
{
    4040:	28 2f       	mov	r18, r24
  hal_subregister_write(SR_AACK_SET_PD, value);
    4042:	8e e6       	ldi	r24, 0x6E	; 110
    4044:	91 e0       	ldi	r25, 0x01	; 1
    4046:	60 e2       	ldi	r22, 0x20	; 32
    4048:	45 e0       	ldi	r20, 0x05	; 5
    404a:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
}
    404e:	08 95       	ret

00004050 <rf230_warm_reset>:
#warning Manipulating PORTB pins for RF230 Sneezer mode!
  PORTB &= ~(1<<7);
  DDRB  &= ~(1<<7);
#endif
  
  hal_register_write(RG_IRQ_MASK, RF230_SUPPORTED_INTERRUPT_MASK);
    4050:	8f ef       	ldi	r24, 0xFF	; 255
    4052:	80 93 4e 01 	sts	0x014E, r24

  /* Set up number of automatic retries 0-15 (0 implies PLL_ON sends instead of the extended TX_ARET mode */
  hal_subregister_write(SR_MAX_FRAME_RETRIES, RF230_CONF_AUTORETRIES );
    4056:	8c e6       	ldi	r24, 0x6C	; 108
    4058:	91 e0       	ldi	r25, 0x01	; 1
    405a:	60 ef       	ldi	r22, 0xF0	; 240
    405c:	44 e0       	ldi	r20, 0x04	; 4
    405e:	22 e0       	ldi	r18, 0x02	; 2
    4060:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
 
 /* Set up carrier sense/clear channel assesment parameters for extended operating mode */
  hal_subregister_write(SR_MAX_CSMA_RETRIES, 5 );//highest allowed retries
    4064:	8c e6       	ldi	r24, 0x6C	; 108
    4066:	91 e0       	ldi	r25, 0x01	; 1
    4068:	6e e0       	ldi	r22, 0x0E	; 14
    406a:	41 e0       	ldi	r20, 0x01	; 1
    406c:	25 e0       	ldi	r18, 0x05	; 5
    406e:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
  hal_register_write(RG_CSMA_BE, 0x80);       //min backoff exponent 0, max 8 (highest allowed)
    4072:	80 e8       	ldi	r24, 0x80	; 128
    4074:	80 93 6f 01 	sts	0x016F, r24
  hal_register_write(RG_CSMA_SEED_0,hal_register_read(RG_PHY_RSSI) );//upper two RSSI reg bits RND_VALUE are random in rf231
    4078:	80 91 46 01 	lds	r24, 0x0146
    407c:	80 93 6d 01 	sts	0x016D, r24

  /* Use automatic CRC unless manual is specified */
#if RF230_CONF_CHECKSUM
  hal_subregister_write(SR_TX_AUTO_CRC_ON, 0);
#else
  hal_subregister_write(SR_TX_AUTO_CRC_ON, 1);
    4080:	84 e4       	ldi	r24, 0x44	; 68
    4082:	91 e0       	ldi	r25, 0x01	; 1
    4084:	60 e2       	ldi	r22, 0x20	; 32
    4086:	45 e0       	ldi	r20, 0x05	; 5
    4088:	21 e0       	ldi	r18, 0x01	; 1
    408a:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>

/* Limit tx power for testing miniature Raven mesh */
#ifdef RF230_MAX_TX_POWER
  set_txpower(RF230_MAX_TX_POWER);  //0=3dbm 15=-17.2dbm
#endif
}
    408e:	08 95       	ret

00004090 <rf230_init>:
}
#endif
/*---------------------------------------------------------------------------*/
int
rf230_init(void)
{
    4090:	cf 93       	push	r28
    4092:	df 93       	push	r29
    4094:	cd ef       	ldi	r28, 0xFD	; 253
    4096:	d3 e0       	ldi	r29, 0x03	; 3
    4098:	ce 01       	movw	r24, r28
    409a:	01 97       	sbiw	r24, 0x01	; 1
    409c:	f1 f7       	brne	.-4      	; 0x409a <rf230_init+0xa>
  uint8_t i;
  DEBUGFLOW('i');
  /* Wait in case VCC just applied */
  delay_us(TIME_TO_ENTER_P_ON);
  /* Initialize Hardware Abstraction Layer */
  hal_init();
    409e:	0e 94 01 24 	call	0x4802	; 0x4802 <hal_init>
 // printf_P(PSTR("\nBefore calibration OSCCAL=%x\n"),OSCCAL);
 // calibrate_rc_osc_32k();
 // printf_P(PSTR("After calibration OSCCAL=%x\n"),OSCCAL); 

  /* Set receive buffers empty and point to the first */
  for (i=0;i<RF230_CONF_RX_BUFFERS;i++) rxframe[i].length=0;
    40a2:	10 92 38 2e 	sts	0x2E38, r1
    40a6:	10 92 ba 2e 	sts	0x2EBA, r1
    40aa:	10 92 3c 2f 	sts	0x2F3C, r1
  rxframe_head=0;rxframe_tail=0;
    40ae:	10 92 37 2e 	sts	0x2E37, r1
    40b2:	10 92 36 2e 	sts	0x2E36, r1
  
  /* Do full rf230 Reset */
  hal_set_rst_low();
    40b6:	e9 e3       	ldi	r30, 0x39	; 57
    40b8:	f1 e0       	ldi	r31, 0x01	; 1
    40ba:	80 81       	ld	r24, Z
    40bc:	8e 7f       	andi	r24, 0xFE	; 254
    40be:	80 83       	st	Z, r24
  hal_set_slptr_low();
    40c0:	80 81       	ld	r24, Z
    40c2:	8d 7f       	andi	r24, 0xFD	; 253
    40c4:	80 83       	st	Z, r24
    40c6:	81 ec       	ldi	r24, 0xC1	; 193
    40c8:	9d e0       	ldi	r25, 0x0D	; 13
    40ca:	01 97       	sbiw	r24, 0x01	; 1
    40cc:	f1 f7       	brne	.-4      	; 0x40ca <rf230_init+0x3a>
   */
  delay_us(2*TIME_SLEEP_TO_TRX_OFF);
#else
  delay_us(TIME_RESET);
#endif
  hal_set_rst_high();
    40ce:	80 81       	ld	r24, Z
    40d0:	81 60       	ori	r24, 0x01	; 1
    40d2:	80 83       	st	Z, r24

  /* Force transition to TRX_OFF */
  hal_subregister_write(SR_TRX_CMD, CMD_FORCE_TRX_OFF);
    40d4:	82 e4       	ldi	r24, 0x42	; 66
    40d6:	91 e0       	ldi	r25, 0x01	; 1
    40d8:	6f e1       	ldi	r22, 0x1F	; 31
    40da:	40 e0       	ldi	r20, 0x00	; 0
    40dc:	23 e0       	ldi	r18, 0x03	; 3
    40de:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
    40e2:	21 97       	sbiw	r28, 0x01	; 1
    40e4:	f1 f7       	brne	.-4      	; 0x40e2 <rf230_init+0x52>
  delay_us(TIME_P_ON_TO_TRX_OFF);
  
  /* Verify that it is a supported version */
  /* Note gcc optimizes this away if DEBUG is not set! */
  //ATMEGA128RFA1 - version 4, ID 31
  uint8_t tvers = hal_register_read(RG_VERSION_NUM);
    40e6:	80 91 5d 01 	lds	r24, 0x015D
  uint8_t tmanu = hal_register_read(RG_MAN_ID_0);
    40ea:	80 91 5e 01 	lds	r24, 0x015E
  if (tmanu != SUPPORTED_MANUFACTURER_ID) 
    PRINTF("rf230: Unsupported manufacturer ID %u\n",tmanu);

  PRINTF("rf230: Version %u, ID %u\n",tvers,tmanu);
  
  rf230_warm_reset();
    40ee:	0e 94 28 20 	call	0x4050	; 0x4050 <rf230_warm_reset>
 
 /* Start the packet receive process */
  process_start(&rf230_process, NULL);
    40f2:	87 eb       	ldi	r24, 0xB7	; 183
    40f4:	9d e0       	ldi	r25, 0x0D	; 13
    40f6:	60 e0       	ldi	r22, 0x00	; 0
    40f8:	70 e0       	ldi	r23, 0x00	; 0
    40fa:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <process_start>
 
 /* Leave radio in on state (?)*/
  on();
    40fe:	0e 94 56 1f 	call	0x3eac	; 0x3eac <on>

  return 1;
}
    4102:	81 e0       	ldi	r24, 0x01	; 1
    4104:	90 e0       	ldi	r25, 0x00	; 0
    4106:	df 91       	pop	r29
    4108:	cf 91       	pop	r28
    410a:	08 95       	ret

0000410c <rf230_get_channel>:
rf230_get_channel(void)
{
//jackdaw reads zero channel, raven reads correct channel?
//return hal_subregister_read(SR_CHANNEL);
  return channel;
}
    410c:	80 91 81 26 	lds	r24, 0x2681
    4110:	08 95       	ret

00004112 <rf230_set_channel>:
/*---------------------------------------------------------------------------*/
void
rf230_set_channel(uint8_t c)
{
    4112:	df 93       	push	r29
    4114:	cf 93       	push	r28
    4116:	0f 92       	push	r0
    4118:	cd b7       	in	r28, 0x3d	; 61
    411a:	de b7       	in	r29, 0x3e	; 62
 /* Wait for any transmission to end. */
  PRINTF("rf230: Set Channel %u\n",c);
  rf230_waitidle();
    411c:	89 83       	std	Y+1, r24	; 0x01
    411e:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <rf230_waitidle>
  channel=c;
    4122:	29 81       	ldd	r18, Y+1	; 0x01
    4124:	20 93 81 26 	sts	0x2681, r18
  hal_subregister_write(SR_CHANNEL, c);
    4128:	88 e4       	ldi	r24, 0x48	; 72
    412a:	91 e0       	ldi	r25, 0x01	; 1
    412c:	6f e1       	ldi	r22, 0x1F	; 31
    412e:	40 e0       	ldi	r20, 0x00	; 0
    4130:	0e 94 15 24 	call	0x482a	; 0x482a <hal_subregister_write>
}
    4134:	0f 90       	pop	r0
    4136:	cf 91       	pop	r28
    4138:	df 91       	pop	r29
    413a:	08 95       	ret

0000413c <rf230_listen_channel>:
void
rf230_listen_channel(uint8_t c)
{
 /* Same as set channel but forces RX_ON state for sniffer or energy scan */
//  PRINTF("rf230: Listen Channel %u\n",c);
  rf230_set_channel(c);
    413c:	0e 94 89 20 	call	0x4112	; 0x4112 <rf230_set_channel>
  radio_set_trx_state(RX_ON);
    4140:	86 e0       	ldi	r24, 0x06	; 6
    4142:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <radio_set_trx_state>
}
    4146:	08 95       	ret

00004148 <rf230_set_pan_addr>:
{
  PRINTF("rf230: PAN=%x Short Addr=%x\n",pan,addr);
  
  uint8_t abyte;
  abyte = pan & 0xFF;
  hal_register_write(RG_PAN_ID_0,abyte);
    4148:	80 93 62 01 	sts	0x0162, r24
  abyte = (pan >> 8*1) & 0xFF;
  hal_register_write(RG_PAN_ID_1, abyte);
    414c:	90 93 63 01 	sts	0x0163, r25

  abyte = addr & 0xFF;
  hal_register_write(RG_SHORT_ADDR_0, abyte);
    4150:	60 93 60 01 	sts	0x0160, r22
  abyte = (addr >> 8*1) & 0xFF;
  hal_register_write(RG_SHORT_ADDR_1, abyte);  
    4154:	70 93 61 01 	sts	0x0161, r23

  if (ieee_addr != NULL) {
    4158:	41 15       	cp	r20, r1
    415a:	51 05       	cpc	r21, r1
    415c:	31 f1       	breq	.+76     	; 0x41aa <rf230_set_pan_addr+0x62>
    PRINTF("MAC=%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_7, *ieee_addr++);
    415e:	fa 01       	movw	r30, r20
    4160:	81 91       	ld	r24, Z+
    4162:	80 93 6b 01 	sts	0x016B, r24
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_6, *ieee_addr++);
    4166:	da 01       	movw	r26, r20
    4168:	11 96       	adiw	r26, 0x01	; 1
    416a:	8c 91       	ld	r24, X
    416c:	80 93 6a 01 	sts	0x016A, r24
    4170:	df 01       	movw	r26, r30
    4172:	11 96       	adiw	r26, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_5, *ieee_addr++);
    4174:	81 81       	ldd	r24, Z+1	; 0x01
    4176:	80 93 69 01 	sts	0x0169, r24
    417a:	fd 01       	movw	r30, r26
    417c:	31 96       	adiw	r30, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_4, *ieee_addr++);
    417e:	11 96       	adiw	r26, 0x01	; 1
    4180:	8c 91       	ld	r24, X
    4182:	80 93 68 01 	sts	0x0168, r24
    4186:	df 01       	movw	r26, r30
    4188:	11 96       	adiw	r26, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_3, *ieee_addr++);
    418a:	81 81       	ldd	r24, Z+1	; 0x01
    418c:	80 93 67 01 	sts	0x0167, r24
    4190:	fd 01       	movw	r30, r26
    4192:	31 96       	adiw	r30, 0x01	; 1
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_2, *ieee_addr++);
    4194:	11 96       	adiw	r26, 0x01	; 1
    4196:	8c 91       	ld	r24, X
    4198:	11 97       	sbiw	r26, 0x01	; 1
    419a:	80 93 66 01 	sts	0x0166, r24
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_1, *ieee_addr++);
    419e:	81 81       	ldd	r24, Z+1	; 0x01
    41a0:	80 93 65 01 	sts	0x0165, r24
    PRINTF(":%x",*ieee_addr);
    hal_register_write(RG_IEEE_ADDR_0, *ieee_addr);
    41a4:	82 81       	ldd	r24, Z+2	; 0x02
    41a6:	80 93 64 01 	sts	0x0164, r24
    41aa:	08 95       	ret

000041ac <rf230_interrupt>:
#if RF230_CONF_TIMESTAMPS
  interrupt_time = timesynch_time();
  interrupt_time_set = 1;
#endif /* RF230_CONF_TIMESTAMPS */

  process_poll(&rf230_process);
    41ac:	87 eb       	ldi	r24, 0xB7	; 183
    41ae:	9d e0       	ldi	r25, 0x0D	; 13
    41b0:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <process_poll>
#if RF230_TIMETABLE_PROFILING
  timetable_clear(&rf230_timetable);
  TIMETABLE_TIMESTAMP(rf230_timetable, "interrupt");
#endif /* RF230_TIMETABLE_PROFILING */

  rf230_pending = 1;
    41b4:	81 e0       	ldi	r24, 0x01	; 1
    41b6:	80 93 2e 2e 	sts	0x2E2E, r24
  
#if RADIOSTATS //TODO:This will double count buffered packets
  RF230_receivepackets++;
    41ba:	80 91 30 2e 	lds	r24, 0x2E30
    41be:	90 91 31 2e 	lds	r25, 0x2E31
    41c2:	01 96       	adiw	r24, 0x01	; 1
    41c4:	90 93 31 2e 	sts	0x2E31, r25
    41c8:	80 93 30 2e 	sts	0x2E30, r24
#endif
  RIMESTATS_ADD(llrx);
    41cc:	80 91 0a 30 	lds	r24, 0x300A
    41d0:	90 91 0b 30 	lds	r25, 0x300B
    41d4:	a0 91 0c 30 	lds	r26, 0x300C
    41d8:	b0 91 0d 30 	lds	r27, 0x300D
    41dc:	01 96       	adiw	r24, 0x01	; 1
    41de:	a1 1d       	adc	r26, r1
    41e0:	b1 1d       	adc	r27, r1
    41e2:	80 93 0a 30 	sts	0x300A, r24
    41e6:	90 93 0b 30 	sts	0x300B, r25
    41ea:	a0 93 0c 30 	sts	0x300C, r26
    41ee:	b0 93 0d 30 	sts	0x300D, r27
  DEBUGFLOW('-');
  rxframe[rxframe_head].length=0;
}
#endif
  return 1;
}
    41f2:	81 e0       	ldi	r24, 0x01	; 1
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	08 95       	ret

000041f8 <rf230_read>:
 * As a result, PRINTF cannot be used in here.
 */
/*---------------------------------------------------------------------------*/
static int
rf230_read(void *buf, unsigned short bufsize)
{
    41f8:	ef 92       	push	r14
    41fa:	ff 92       	push	r15
    41fc:	cf 93       	push	r28
    41fe:	df 93       	push	r29
    return bufsize;
 }
#endif

  /* The length includes the twp-byte checksum but not the LQI byte */
  len=rxframe[rxframe_head].length;
    4200:	50 91 37 2e 	lds	r21, 0x2E37
    4204:	25 2f       	mov	r18, r21
    4206:	30 e0       	ldi	r19, 0x00	; 0
    4208:	f9 01       	movw	r30, r18
    420a:	ee 0f       	add	r30, r30
    420c:	ff 1f       	adc	r31, r31
    420e:	36 95       	lsr	r19
    4210:	32 2f       	mov	r19, r18
    4212:	22 27       	eor	r18, r18
    4214:	37 95       	ror	r19
    4216:	27 95       	ror	r18
    4218:	e2 0f       	add	r30, r18
    421a:	f3 1f       	adc	r31, r19
    421c:	e8 5c       	subi	r30, 0xC8	; 200
    421e:	f1 4d       	sbci	r31, 0xD1	; 209
    4220:	40 81       	ld	r20, Z
  if (len==0) {
    4222:	44 23       	and	r20, r20
    4224:	09 f4       	brne	.+2      	; 0x4228 <__stack+0x29>
    4226:	ce c0       	rjmp	.+412    	; 0x43c4 <__stack+0x1c5>
  }

#if RADIOALWAYSON
if (RF230_receive_on) {
#else
if (hal_get_slptr()) {
    4228:	20 91 39 01 	lds	r18, 0x0139
    422c:	21 fd       	sbrc	r18, 1
    422e:	ca c0       	rjmp	.+404    	; 0x43c4 <__stack+0x1c5>
  DEBUGFLOW('!');
  return 0;
}
if (!RF230_receive_on) {
    4230:	20 91 c3 2f 	lds	r18, 0x2FC3
    4234:	22 23       	and	r18, r18
    4236:	09 f4       	brne	.+2      	; 0x423a <__stack+0x3b>
    4238:	c5 c0       	rjmp	.+394    	; 0x43c4 <__stack+0x1c5>
    //PRINTF("\n");
  }
#endif

//if(len > RF230_MAX_PACKET_LEN) {
  if(len > RF230_MAX_TX_FRAME_LENGTH) {
    423a:	47 ff       	sbrs	r20, 7
    423c:	16 c0       	rjmp	.+44     	; 0x426a <__stack+0x6b>
    /* Oops, we must be out of sync. */
    DEBUGFLOW('u');
    flushrx();
    423e:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <flushrx>
    RIMESTATS_ADD(badsynch);
    4242:	80 91 f6 2f 	lds	r24, 0x2FF6
    4246:	90 91 f7 2f 	lds	r25, 0x2FF7
    424a:	a0 91 f8 2f 	lds	r26, 0x2FF8
    424e:	b0 91 f9 2f 	lds	r27, 0x2FF9
    4252:	01 96       	adiw	r24, 0x01	; 1
    4254:	a1 1d       	adc	r26, r1
    4256:	b1 1d       	adc	r27, r1
    4258:	80 93 f6 2f 	sts	0x2FF6, r24
    425c:	90 93 f7 2f 	sts	0x2FF7, r25
    4260:	a0 93 f8 2f 	sts	0x2FF8, r26
    4264:	b0 93 f9 2f 	sts	0x2FF9, r27
    4268:	ad c0       	rjmp	.+346    	; 0x43c4 <__stack+0x1c5>
    return 0;
  }

  if(len <= AUX_LEN) {
    426a:	43 30       	cpi	r20, 0x03	; 3
    426c:	b0 f4       	brcc	.+44     	; 0x429a <__stack+0x9b>
    DEBUGFLOW('s');
    //PRINTF("len <= AUX_LEN\n");
    flushrx();
    426e:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <flushrx>
    RIMESTATS_ADD(tooshort);
    4272:	80 91 f2 2f 	lds	r24, 0x2FF2
    4276:	90 91 f3 2f 	lds	r25, 0x2FF3
    427a:	a0 91 f4 2f 	lds	r26, 0x2FF4
    427e:	b0 91 f5 2f 	lds	r27, 0x2FF5
    4282:	01 96       	adiw	r24, 0x01	; 1
    4284:	a1 1d       	adc	r26, r1
    4286:	b1 1d       	adc	r27, r1
    4288:	80 93 f2 2f 	sts	0x2FF2, r24
    428c:	90 93 f3 2f 	sts	0x2FF3, r25
    4290:	a0 93 f4 2f 	sts	0x2FF4, r26
    4294:	b0 93 f5 2f 	sts	0x2FF5, r27
    4298:	95 c0       	rjmp	.+298    	; 0x43c4 <__stack+0x1c5>
    return 0;
  }

  if(len - AUX_LEN > bufsize) {
    429a:	c4 2f       	mov	r28, r20
    429c:	d0 e0       	ldi	r29, 0x00	; 0
    429e:	22 97       	sbiw	r28, 0x02	; 2
    42a0:	6c 17       	cp	r22, r28
    42a2:	7d 07       	cpc	r23, r29
    42a4:	b0 f4       	brcc	.+44     	; 0x42d2 <__stack+0xd3>
    DEBUGFLOW('v');
    //PRINTF("len - AUX_LEN > bufsize\n");
    flushrx();
    42a6:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <flushrx>
    RIMESTATS_ADD(toolong);
    42aa:	80 91 ee 2f 	lds	r24, 0x2FEE
    42ae:	90 91 ef 2f 	lds	r25, 0x2FEF
    42b2:	a0 91 f0 2f 	lds	r26, 0x2FF0
    42b6:	b0 91 f1 2f 	lds	r27, 0x2FF1
    42ba:	01 96       	adiw	r24, 0x01	; 1
    42bc:	a1 1d       	adc	r26, r1
    42be:	b1 1d       	adc	r27, r1
    42c0:	80 93 ee 2f 	sts	0x2FEE, r24
    42c4:	90 93 ef 2f 	sts	0x2FEF, r25
    42c8:	a0 93 f0 2f 	sts	0x2FF0, r26
    42cc:	b0 93 f1 2f 	sts	0x2FF1, r27
    42d0:	79 c0       	rjmp	.+242    	; 0x43c4 <__stack+0x1c5>
    return 0;
  }
 /* Transfer the frame, stripping the footer, but copying the checksum */
  framep=&(rxframe[rxframe_head].data[0]);
    42d2:	65 2f       	mov	r22, r21
    42d4:	70 e0       	ldi	r23, 0x00	; 0
    42d6:	9b 01       	movw	r18, r22
    42d8:	22 0f       	add	r18, r18
    42da:	33 1f       	adc	r19, r19
    42dc:	76 95       	lsr	r23
    42de:	76 2f       	mov	r23, r22
    42e0:	66 27       	eor	r22, r22
    42e2:	77 95       	ror	r23
    42e4:	67 95       	ror	r22
    42e6:	26 0f       	add	r18, r22
    42e8:	37 1f       	adc	r19, r23
    42ea:	27 5c       	subi	r18, 0xC7	; 199
    42ec:	31 4d       	sbci	r19, 0xD1	; 209
  memcpy(buf,framep,len-AUX_LEN+CHECKSUM_LEN);
    42ee:	b9 01       	movw	r22, r18
    42f0:	50 e0       	ldi	r21, 0x00	; 0
    42f2:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
  rf230_last_correlation = rxframe[rxframe_head].lqi;
    42f6:	20 91 37 2e 	lds	r18, 0x2E37
    42fa:	82 2f       	mov	r24, r18
    42fc:	90 e0       	ldi	r25, 0x00	; 0
    42fe:	fc 01       	movw	r30, r24
    4300:	ee 0f       	add	r30, r30
    4302:	ff 1f       	adc	r31, r31
    4304:	96 95       	lsr	r25
    4306:	98 2f       	mov	r25, r24
    4308:	88 27       	eor	r24, r24
    430a:	97 95       	ror	r25
    430c:	87 95       	ror	r24
    430e:	e8 0f       	add	r30, r24
    4310:	f9 1f       	adc	r31, r25
    4312:	e8 54       	subi	r30, 0x48	; 72
    4314:	f1 4d       	sbci	r31, 0xD1	; 209
    4316:	80 81       	ld	r24, Z
    4318:	80 93 27 2e 	sts	0x2E27, r24

  /* Clear the length field to allow buffering of the next packet */
  rxframe[rxframe_head].length=0;
    431c:	82 2f       	mov	r24, r18
    431e:	90 e0       	ldi	r25, 0x00	; 0
    4320:	fc 01       	movw	r30, r24
    4322:	ee 0f       	add	r30, r30
    4324:	ff 1f       	adc	r31, r31
    4326:	96 95       	lsr	r25
    4328:	98 2f       	mov	r25, r24
    432a:	88 27       	eor	r24, r24
    432c:	97 95       	ror	r25
    432e:	87 95       	ror	r24
    4330:	e8 0f       	add	r30, r24
    4332:	f9 1f       	adc	r31, r25
    4334:	e8 5c       	subi	r30, 0xC8	; 200
    4336:	f1 4d       	sbci	r31, 0xD1	; 209
    4338:	10 82       	st	Z, r1
  rxframe_head++;if (rxframe_head >= RF230_CONF_RX_BUFFERS) rxframe_head=0;
    433a:	2f 5f       	subi	r18, 0xFF	; 255
    433c:	20 93 37 2e 	sts	0x2E37, r18
    4340:	23 30       	cpi	r18, 0x03	; 3
    4342:	10 f0       	brcs	.+4      	; 0x4348 <__stack+0x149>
    4344:	10 92 37 2e 	sts	0x2E37, r1
  /* If another packet has been buffered, schedule another receive poll */
  if (rxframe[rxframe_head].length) rf230_interrupt();
    4348:	80 91 37 2e 	lds	r24, 0x2E37
    434c:	90 e0       	ldi	r25, 0x00	; 0
    434e:	fc 01       	movw	r30, r24
    4350:	ee 0f       	add	r30, r30
    4352:	ff 1f       	adc	r31, r31
    4354:	96 95       	lsr	r25
    4356:	98 2f       	mov	r25, r24
    4358:	88 27       	eor	r24, r24
    435a:	97 95       	ror	r25
    435c:	87 95       	ror	r24
    435e:	e8 0f       	add	r30, r24
    4360:	f9 1f       	adc	r31, r25
    4362:	e8 5c       	subi	r30, 0xC8	; 200
    4364:	f1 4d       	sbci	r31, 0xD1	; 209
    4366:	80 81       	ld	r24, Z
    4368:	88 23       	and	r24, r24
    436a:	11 f0       	breq	.+4      	; 0x4370 <__stack+0x171>
    436c:	0e 94 d6 20 	call	0x41ac	; 0x41ac <rf230_interrupt>
#if 0   //more general
    rf230_last_rssi = rf230_get_raw_rssi();
#else   //faster
#if RF230_CONF_AUTOACK
 //   rf230_last_rssi = hal_subregister_read(SR_ED_LEVEL);  //0-84 resolution 1 dB
    rf230_last_rssi = hal_register_read(RG_PHY_ED_LEVEL);  //0-84, resolution 1 dB
    4370:	60 91 47 01 	lds	r22, 0x0147
    4374:	60 93 28 2e 	sts	0x2E28, r22
//  rf230_last_rssi = 3*hal_subregister_read(SR_RSSI);    //0-28 resolution 3 dB
#endif
#endif /* speed vs. generality */

  /* Save the smallest rssi. The display routine can reset by setting it to zero */
  if ((rf230_smallest_rssi==0) || (rf230_last_rssi<rf230_smallest_rssi))
    4378:	80 91 2d 2e 	lds	r24, 0x2E2D
    437c:	88 23       	and	r24, r24
    437e:	11 f0       	breq	.+4      	; 0x4384 <__stack+0x185>
    4380:	68 17       	cp	r22, r24
    4382:	10 f4       	brcc	.+4      	; 0x4388 <__stack+0x189>
     rf230_smallest_rssi=rf230_last_rssi;
    4384:	60 93 2d 2e 	sts	0x2E2D, r22

 //   rf230_last_correlation = rxframe[rxframe_head].lqi;
    packetbuf_set_attr(PACKETBUF_ATTR_RSSI, rf230_last_rssi);
    4388:	84 e0       	ldi	r24, 0x04	; 4
    438a:	70 e0       	ldi	r23, 0x00	; 0
    438c:	0e 94 32 32 	call	0x6464	; 0x6464 <packetbuf_set_attr>
    packetbuf_set_attr(PACKETBUF_ATTR_LINK_QUALITY, rf230_last_correlation);
    4390:	60 91 27 2e 	lds	r22, 0x2E27
    4394:	83 e0       	ldi	r24, 0x03	; 3
    4396:	70 e0       	ldi	r23, 0x00	; 0
    4398:	0e 94 32 32 	call	0x6464	; 0x6464 <packetbuf_set_attr>

    RIMESTATS_ADD(rx);
    439c:	80 91 ca 2f 	lds	r24, 0x2FCA
    43a0:	90 91 cb 2f 	lds	r25, 0x2FCB
    43a4:	a0 91 cc 2f 	lds	r26, 0x2FCC
    43a8:	b0 91 cd 2f 	lds	r27, 0x2FCD
    43ac:	01 96       	adiw	r24, 0x01	; 1
    43ae:	a1 1d       	adc	r26, r1
    43b0:	b1 1d       	adc	r27, r1
    43b2:	80 93 ca 2f 	sts	0x2FCA, r24
    43b6:	90 93 cb 2f 	sts	0x2FCB, r25
    43ba:	a0 93 cc 2f 	sts	0x2FCC, r26
    43be:	b0 93 cd 2f 	sts	0x2FCD, r27
#ifdef RF230BB_HOOK_RX_PACKET
  RF230BB_HOOK_RX_PACKET(buf,len);
#endif

  /* Here return just the data length. The checksum is however still in the buffer for packet sniffing */
  return len - AUX_LEN;
    43c2:	02 c0       	rjmp	.+4      	; 0x43c8 <__stack+0x1c9>
  DEBUGFLOW('!');
  return 0;
}
if (!RF230_receive_on) {
  DEBUGFLOW('[');
  return 0;
    43c4:	c0 e0       	ldi	r28, 0x00	; 0
    43c6:	d0 e0       	ldi	r29, 0x00	; 0
} else {
   DEBUGFLOW('y');  //Stack thought radio was off
   return 0;
}
#endif
}
    43c8:	ce 01       	movw	r24, r28
    43ca:	df 91       	pop	r29
    43cc:	cf 91       	pop	r28
    43ce:	ff 90       	pop	r15
    43d0:	ef 90       	pop	r14
    43d2:	08 95       	ret

000043d4 <process_thread_rf230_process>:
#else
#define RF230PROCESSFLAG(arg)
#endif

PROCESS_THREAD(rf230_process, ev, data)
{
    43d4:	0f 93       	push	r16
    43d6:	1f 93       	push	r17
    43d8:	df 93       	push	r29
    43da:	cf 93       	push	r28
    43dc:	0f 92       	push	r0
    43de:	cd b7       	in	r28, 0x3d	; 61
    43e0:	de b7       	in	r29, 0x3e	; 62
    43e2:	8c 01       	movw	r16, r24
  int len;
  PROCESS_BEGIN();
    43e4:	fc 01       	movw	r30, r24
    43e6:	80 81       	ld	r24, Z
    43e8:	91 81       	ldd	r25, Z+1	; 0x01
    43ea:	00 97       	sbiw	r24, 0x00	; 0
    43ec:	29 f0       	breq	.+10     	; 0x43f8 <process_thread_rf230_process+0x24>
    43ee:	f5 e0       	ldi	r31, 0x05	; 5
    43f0:	81 31       	cpi	r24, 0x11	; 17
    43f2:	9f 07       	cpc	r25, r31
    43f4:	69 f5       	brne	.+90     	; 0x4450 <process_thread_rf230_process+0x7c>
    43f6:	06 c0       	rjmp	.+12     	; 0x4404 <process_thread_rf230_process+0x30>
  RF230PROCESSFLAG(99);

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
    43f8:	81 e1       	ldi	r24, 0x11	; 17
    43fa:	95 e0       	ldi	r25, 0x05	; 5
    43fc:	f8 01       	movw	r30, r16
    43fe:	91 83       	std	Z+1, r25	; 0x01
    4400:	80 83       	st	Z, r24
    4402:	2b c0       	rjmp	.+86     	; 0x445a <process_thread_rf230_process+0x86>
    4404:	62 38       	cpi	r22, 0x82	; 130
    4406:	49 f5       	brne	.+82     	; 0x445a <process_thread_rf230_process+0x86>
    RF230PROCESSFLAG(42);
#if RF230_TIMETABLE_PROFILING
    TIMETABLE_TIMESTAMP(rf230_timetable, "poll");
#endif /* RF230_TIMETABLE_PROFILING */

    rf230_pending = 0;
    4408:	10 92 2e 2e 	sts	0x2E2E, r1

    packetbuf_clear();
    440c:	0e 94 ac 31 	call	0x6358	; 0x6358 <packetbuf_clear>

    /* Turn off interrupts to avoid ISR writing to the same buffers we are reading. */
    HAL_ENTER_CRITICAL_REGION();
    4410:	8f b7       	in	r24, 0x3f	; 63
    4412:	89 83       	std	Y+1, r24	; 0x01
    4414:	f8 94       	cli

    len = rf230_read(packetbuf_dataptr(), PACKETBUF_SIZE);        
    4416:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    441a:	60 e8       	ldi	r22, 0x80	; 128
    441c:	70 e0       	ldi	r23, 0x00	; 0
    441e:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <rf230_read>

    /* Restore interrupts. */
    HAL_LEAVE_CRITICAL_REGION();
    4422:	29 81       	ldd	r18, Y+1	; 0x01
    4424:	2f bf       	out	0x3f, r18	; 63
    PRINTF("rf230_read: %u bytes lqi %u\n",len,rf230_last_correlation);

    RF230PROCESSFLAG(1);
    if(len > 0) {
    4426:	18 16       	cp	r1, r24
    4428:	19 06       	cpc	r1, r25
    442a:	44 f4       	brge	.+16     	; 0x443c <process_thread_rf230_process+0x68>
      packetbuf_set_datalen(len);
    442c:	0e 94 04 31 	call	0x6208	; 0x6208 <packetbuf_set_datalen>
      RF230PROCESSFLAG(2);
      NETSTACK_RDC.input();
    4430:	e0 91 39 0e 	lds	r30, 0x0E39
    4434:	f0 91 3a 0e 	lds	r31, 0x0E3A
    4438:	09 95       	icall
    443a:	de cf       	rjmp	.-68     	; 0x43f8 <process_thread_rf230_process+0x24>
                                           &rf230_timetable);
      timetable_clear(&rf230_timetable);
#endif /* RF230_TIMETABLE_PROFILING */
    } else {
#if RADIOSTATS
       RF230_receivefail++;
    443c:	80 91 2b 2e 	lds	r24, 0x2E2B
    4440:	90 91 2c 2e 	lds	r25, 0x2E2C
    4444:	01 96       	adiw	r24, 0x01	; 1
    4446:	90 93 2c 2e 	sts	0x2E2C, r25
    444a:	80 93 2b 2e 	sts	0x2E2B, r24
    444e:	d4 cf       	rjmp	.-88     	; 0x43f8 <process_thread_rf230_process+0x24>
#endif
    }
  }

  PROCESS_END();
    4450:	f8 01       	movw	r30, r16
    4452:	11 82       	std	Z+1, r1	; 0x01
    4454:	10 82       	st	Z, r1
    4456:	83 e0       	ldi	r24, 0x03	; 3
    4458:	01 c0       	rjmp	.+2      	; 0x445c <process_thread_rf230_process+0x88>
  int len;
  PROCESS_BEGIN();
  RF230PROCESSFLAG(99);

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
    445a:	81 e0       	ldi	r24, 0x01	; 1
#endif
    }
  }

  PROCESS_END();
}
    445c:	0f 90       	pop	r0
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	1f 91       	pop	r17
    4464:	0f 91       	pop	r16
    4466:	08 95       	ret

00004468 <rf230_set_txpower>:
}
/*---------------------------------------------------------------------------*/
void
rf230_set_txpower(uint8_t power)
{
  set_txpower(power);
    4468:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <set_txpower>
}
    446c:	08 95       	ret

0000446e <rf230_get_txpower>:
/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_txpower(void)
{
	uint8_t power = TX_PWR_UNDEFINED;
	if (hal_get_slptr()) {
    446e:	80 91 39 01 	lds	r24, 0x0139
    4472:	81 fd       	sbrc	r24, 1
    4474:	07 c0       	rjmp	.+14     	; 0x4484 <rf230_get_txpower+0x16>
		PRINTF("rf230_get_txpower:Sleeping");
	} else {
		power = hal_subregister_read(SR_TX_PWR);
    4476:	85 e4       	ldi	r24, 0x45	; 69
    4478:	91 e0       	ldi	r25, 0x01	; 1
    447a:	6f e0       	ldi	r22, 0x0F	; 15
    447c:	40 e0       	ldi	r20, 0x00	; 0
    447e:	0e 94 0b 24 	call	0x4816	; 0x4816 <hal_subregister_read>
    4482:	08 95       	ret
}
/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_txpower(void)
{
	uint8_t power = TX_PWR_UNDEFINED;
    4484:	80 e1       	ldi	r24, 0x10	; 16
		PRINTF("rf230_get_txpower:Sleeping");
	} else {
		power = hal_subregister_read(SR_TX_PWR);
	}
	return power;
}
    4486:	08 95       	ret

00004488 <rf230_transmit>:
/*---------------------------------------------------------------------------*/
static uint8_t buffer[RF230_MAX_TX_FRAME_LENGTH+AUX_LEN];

static int
rf230_transmit(unsigned short payload_len)
{
    4488:	df 92       	push	r13
    448a:	ef 92       	push	r14
    448c:	ff 92       	push	r15
    448e:	0f 93       	push	r16
    4490:	1f 93       	push	r17
    4492:	cf 93       	push	r28
    4494:	df 93       	push	r29
    4496:	d8 2e       	mov	r13, r24
  struct timestamp timestamp;
#endif /* RF230_CONF_TIMESTAMPS */

  /* If radio is sleeping we have to turn it on first */
  /* This automatically does the PLL calibrations */
  if (hal_get_slptr()) {
    4498:	80 91 39 01 	lds	r24, 0x0139
    449c:	81 ff       	sbrs	r24, 1
    449e:	1a c0       	rjmp	.+52     	; 0x44d4 <rf230_transmit+0x4c>
#if defined(__AVR_ATmega128RFA1__)
	ENERGEST_ON(ENERGEST_TYPE_LED_RED);
    44a0:	80 91 94 00 	lds	r24, 0x0094
    44a4:	90 91 95 00 	lds	r25, 0x0095
    44a8:	90 93 57 30 	sts	0x3057, r25
    44ac:	80 93 56 30 	sts	0x3056, r24
    44b0:	81 e0       	ldi	r24, 0x01	; 1
    44b2:	80 93 45 30 	sts	0x3045, r24
#if RF230BB_CONF_LEDONPORTE1
    PORTE|=(1<<PE1); //ledon
#endif
	rf230_interruptwait=1;
    44b6:	80 93 c2 2f 	sts	0x2FC2, r24
	hal_set_slptr_low();
    44ba:	80 91 39 01 	lds	r24, 0x0139
    44be:	8d 7f       	andi	r24, 0xFD	; 253
    44c0:	80 93 39 01 	sts	0x0139, r24
    44c4:	80 e1       	ldi	r24, 0x10	; 16
    44c6:	97 e2       	ldi	r25, 0x27	; 39
//	while (rf230_interruptwait) {}	
    {
      int i;
      for (i=0;i<10000;i++) {
        if (!rf230_interruptwait) break;
    44c8:	20 91 c2 2f 	lds	r18, 0x2FC2
    44cc:	22 23       	and	r18, r18
    44ce:	11 f0       	breq	.+4      	; 0x44d4 <rf230_transmit+0x4c>
    44d0:	01 97       	sbiw	r24, 0x01	; 1
	rf230_interruptwait=1;
	hal_set_slptr_low();
//	while (rf230_interruptwait) {}	
    {
      int i;
      for (i=0;i<10000;i++) {
    44d2:	d1 f7       	brne	.-12     	; 0x44c8 <rf230_transmit+0x40>
    }
#endif
  }
 
  /* Wait for any previous operation or state transition to finish */
  rf230_waitidle();
    44d4:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <rf230_waitidle>
  if(RF230_receive_on) {
    44d8:	80 91 c3 2f 	lds	r24, 0x2FC3
    44dc:	88 23       	and	r24, r24
    44de:	09 f4       	brne	.+2      	; 0x44e2 <rf230_transmit+0x5a>
    44e0:	41 c0       	rjmp	.+130    	; 0x4564 <rf230_transmit+0xdc>
    ENERGEST_OFF(ENERGEST_TYPE_LISTEN);
    44e2:	80 91 47 30 	lds	r24, 0x3047
    44e6:	88 23       	and	r24, r24
    44e8:	e9 f1       	breq	.+122    	; 0x4564 <rf230_transmit+0xdc>
    44ea:	20 91 94 00 	lds	r18, 0x0094
    44ee:	30 91 95 00 	lds	r19, 0x0095
    44f2:	80 91 5a 30 	lds	r24, 0x305A
    44f6:	90 91 5b 30 	lds	r25, 0x305B
    44fa:	28 17       	cp	r18, r24
    44fc:	39 07       	cpc	r19, r25
    44fe:	a0 f4       	brcc	.+40     	; 0x4528 <rf230_transmit+0xa0>
    4500:	20 91 2a 30 	lds	r18, 0x302A
    4504:	30 91 2b 30 	lds	r19, 0x302B
    4508:	40 91 2c 30 	lds	r20, 0x302C
    450c:	50 91 2d 30 	lds	r21, 0x302D
    4510:	2c 57       	subi	r18, 0x7C	; 124
    4512:	31 4e       	sbci	r19, 0xE1	; 225
    4514:	4f 4f       	sbci	r20, 0xFF	; 255
    4516:	5f 4f       	sbci	r21, 0xFF	; 255
    4518:	20 93 2a 30 	sts	0x302A, r18
    451c:	30 93 2b 30 	sts	0x302B, r19
    4520:	40 93 2c 30 	sts	0x302C, r20
    4524:	50 93 2d 30 	sts	0x302D, r21
    4528:	20 91 94 00 	lds	r18, 0x0094
    452c:	30 91 95 00 	lds	r19, 0x0095
    4530:	28 1b       	sub	r18, r24
    4532:	39 0b       	sbc	r19, r25
    4534:	40 e0       	ldi	r20, 0x00	; 0
    4536:	50 e0       	ldi	r21, 0x00	; 0
    4538:	e0 90 2a 30 	lds	r14, 0x302A
    453c:	f0 90 2b 30 	lds	r15, 0x302B
    4540:	00 91 2c 30 	lds	r16, 0x302C
    4544:	10 91 2d 30 	lds	r17, 0x302D
    4548:	2e 0d       	add	r18, r14
    454a:	3f 1d       	adc	r19, r15
    454c:	40 1f       	adc	r20, r16
    454e:	51 1f       	adc	r21, r17
    4550:	20 93 2a 30 	sts	0x302A, r18
    4554:	30 93 2b 30 	sts	0x302B, r19
    4558:	40 93 2c 30 	sts	0x302C, r20
    455c:	50 93 2d 30 	sts	0x302D, r21
    4560:	10 92 47 30 	sts	0x3047, r1
  }
  /* Prepare to transmit */
#if RF230_CONF_AUTORETRIES
  radio_set_trx_state(TX_ARET_ON);
    4564:	89 e1       	ldi	r24, 0x19	; 25
    4566:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <radio_set_trx_state>
  DEBUGFLOW('T');
#endif

  txpower = 0;
  
  if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    456a:	86 e0       	ldi	r24, 0x06	; 6
    456c:	0e 94 3d 32 	call	0x647a	; 0x647a <packetbuf_attr>
    4570:	00 97       	sbiw	r24, 0x00	; 0
    4572:	51 f0       	breq	.+20     	; 0x4588 <rf230_transmit+0x100>
    /* Remember the current transmission power */
    txpower = rf230_get_txpower();
    4574:	0e 94 37 22 	call	0x446e	; 0x446e <rf230_get_txpower>
    4578:	c8 2f       	mov	r28, r24
    /* Set the specified transmission power */
    set_txpower(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) - 1);
    457a:	86 e0       	ldi	r24, 0x06	; 6
    457c:	0e 94 3d 32 	call	0x647a	; 0x647a <packetbuf_attr>
    4580:	81 50       	subi	r24, 0x01	; 1
    4582:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <set_txpower>
    4586:	02 c0       	rjmp	.+4      	; 0x458c <rf230_transmit+0x104>
#else
  radio_set_trx_state(PLL_ON);
  DEBUGFLOW('T');
#endif

  txpower = 0;
    4588:	c0 e0       	ldi	r28, 0x00	; 0
    458a:	d0 e0       	ldi	r29, 0x00	; 0

#if RF230_CONF_TIMESTAMPS
  rtimer_clock_t txtime = timesynch_time();
#endif /* RF230_CONF_TIMESTAMPS */

  ENERGEST_ON(ENERGEST_TYPE_TRANSMIT);
    458c:	80 91 94 00 	lds	r24, 0x0094
    4590:	90 91 95 00 	lds	r25, 0x0095
    4594:	90 93 59 30 	sts	0x3059, r25
    4598:	80 93 58 30 	sts	0x3058, r24
    459c:	81 e0       	ldi	r24, 0x01	; 1
    459e:	80 93 46 30 	sts	0x3046, r24
  
#if defined(__AVR_ATmega128RFA1__)
/* No interrupts across frame download! */
  cli();
    45a2:	f8 94       	cli
/* slow down the transmit? */
 //   delay_us(500);
#endif
 /* Toggle the SLP_TR pin to initiate the frame transmission */
  hal_set_slptr_high();
    45a4:	80 91 39 01 	lds	r24, 0x0139
    45a8:	82 60       	ori	r24, 0x02	; 2
    45aa:	80 93 39 01 	sts	0x0139, r24
  hal_set_slptr_low();
    45ae:	80 91 39 01 	lds	r24, 0x0139
    45b2:	8d 7f       	andi	r24, 0xFD	; 253
    45b4:	80 93 39 01 	sts	0x0139, r24
    txpower = rf230_get_txpower();
    /* Set the specified transmission power */
    set_txpower(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) - 1);
  }

  total_len = payload_len + AUX_LEN;
    45b8:	6d 2d       	mov	r22, r13
    45ba:	6e 5f       	subi	r22, 0xFE	; 254
 //   delay_us(500);
#endif
 /* Toggle the SLP_TR pin to initiate the frame transmission */
  hal_set_slptr_high();
  hal_set_slptr_low();
  hal_frame_write(buffer, total_len);
    45bc:	80 e0       	ldi	r24, 0x00	; 0
    45be:	96 e2       	ldi	r25, 0x26	; 38
    45c0:	0e 94 53 24 	call	0x48a6	; 0x48a6 <hal_frame_write>
#if defined(__AVR_ATmega128RFA1__)
 sei();
    45c4:	78 94       	sei
    PRINTF("\n");
  }
#endif

#if RADIOSTATS
  RF230_sendpackets++;
    45c6:	80 91 be 2f 	lds	r24, 0x2FBE
    45ca:	90 91 bf 2f 	lds	r25, 0x2FBF
    45ce:	01 96       	adiw	r24, 0x01	; 1
    45d0:	90 93 bf 2f 	sts	0x2FBF, r25
    45d4:	80 93 be 2f 	sts	0x2FBE, r24
#endif
 
 /* We wait until transmission has ended so that we get an
     accurate measurement of the transmission time.*/
  rf230_waitidle();
    45d8:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <rf230_waitidle>

 /* Get the transmission result */  
#if RF230_CONF_AUTORETRIES
  tx_result = hal_subregister_read(SR_TRAC_STATUS);
    45dc:	82 e4       	ldi	r24, 0x42	; 66
    45de:	91 e0       	ldi	r25, 0x01	; 1
    45e0:	60 ee       	ldi	r22, 0xE0	; 224
    45e2:	45 e0       	ldi	r20, 0x05	; 5
    45e4:	0e 94 0b 24 	call	0x4816	; 0x4816 <hal_subregister_read>
    45e8:	18 2f       	mov	r17, r24
#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
  ENERGEST_OFF_LEVEL(ENERGEST_TYPE_TRANSMIT,rf230_get_txpower());
#endif

 /* Restore the transmission power */
 if(packetbuf_attr(PACKETBUF_ATTR_RADIO_TXPOWER) > 0) {
    45ea:	86 e0       	ldi	r24, 0x06	; 6
    45ec:	0e 94 3d 32 	call	0x647a	; 0x647a <packetbuf_attr>
    45f0:	00 97       	sbiw	r24, 0x00	; 0
    45f2:	19 f0       	breq	.+6      	; 0x45fa <rf230_transmit+0x172>
    set_txpower(txpower & 0xff);
    45f4:	8c 2f       	mov	r24, r28
    45f6:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <set_txpower>
    num_transmissions++;
  }

#endif /* RF230_CONF_TIMESTAMPS */

  ENERGEST_OFF(ENERGEST_TYPE_TRANSMIT);
    45fa:	80 91 46 30 	lds	r24, 0x3046
    45fe:	88 23       	and	r24, r24
    4600:	e9 f1       	breq	.+122    	; 0x467c <rf230_transmit+0x1f4>
    4602:	20 91 94 00 	lds	r18, 0x0094
    4606:	30 91 95 00 	lds	r19, 0x0095
    460a:	80 91 58 30 	lds	r24, 0x3058
    460e:	90 91 59 30 	lds	r25, 0x3059
    4612:	28 17       	cp	r18, r24
    4614:	39 07       	cpc	r19, r25
    4616:	a0 f4       	brcc	.+40     	; 0x4640 <rf230_transmit+0x1b8>
    4618:	20 91 26 30 	lds	r18, 0x3026
    461c:	30 91 27 30 	lds	r19, 0x3027
    4620:	40 91 28 30 	lds	r20, 0x3028
    4624:	50 91 29 30 	lds	r21, 0x3029
    4628:	2c 57       	subi	r18, 0x7C	; 124
    462a:	31 4e       	sbci	r19, 0xE1	; 225
    462c:	4f 4f       	sbci	r20, 0xFF	; 255
    462e:	5f 4f       	sbci	r21, 0xFF	; 255
    4630:	20 93 26 30 	sts	0x3026, r18
    4634:	30 93 27 30 	sts	0x3027, r19
    4638:	40 93 28 30 	sts	0x3028, r20
    463c:	50 93 29 30 	sts	0x3029, r21
    4640:	20 91 94 00 	lds	r18, 0x0094
    4644:	30 91 95 00 	lds	r19, 0x0095
    4648:	28 1b       	sub	r18, r24
    464a:	39 0b       	sbc	r19, r25
    464c:	40 e0       	ldi	r20, 0x00	; 0
    464e:	50 e0       	ldi	r21, 0x00	; 0
    4650:	60 91 26 30 	lds	r22, 0x3026
    4654:	70 91 27 30 	lds	r23, 0x3027
    4658:	80 91 28 30 	lds	r24, 0x3028
    465c:	90 91 29 30 	lds	r25, 0x3029
    4660:	26 0f       	add	r18, r22
    4662:	37 1f       	adc	r19, r23
    4664:	48 1f       	adc	r20, r24
    4666:	59 1f       	adc	r21, r25
    4668:	20 93 26 30 	sts	0x3026, r18
    466c:	30 93 27 30 	sts	0x3027, r19
    4670:	40 93 28 30 	sts	0x3028, r20
    4674:	50 93 29 30 	sts	0x3029, r21
    4678:	10 92 46 30 	sts	0x3046, r1
  if(RF230_receive_on) {
    467c:	80 91 c3 2f 	lds	r24, 0x2FC3
    4680:	88 23       	and	r24, r24
    4682:	71 f0       	breq	.+28     	; 0x46a0 <rf230_transmit+0x218>
    DEBUGFLOW('l');
    ENERGEST_ON(ENERGEST_TYPE_LISTEN);
    4684:	80 91 94 00 	lds	r24, 0x0094
    4688:	90 91 95 00 	lds	r25, 0x0095
    468c:	90 93 5b 30 	sts	0x305B, r25
    4690:	80 93 5a 30 	sts	0x305A, r24
    4694:	81 e0       	ldi	r24, 0x01	; 1
    4696:	80 93 47 30 	sts	0x3047, r24
    on();
    469a:	0e 94 56 1f 	call	0x3eac	; 0x3eac <on>
    469e:	02 c0       	rjmp	.+4      	; 0x46a4 <rf230_transmit+0x21c>
  } else {
#if RADIOALWAYSON
    /* Enable reception */
    on();
#else
    off();
    46a0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <off>

#if RF230_INSERTACK
   ack_pending = 0;
#endif

  if (tx_result==1) {        //success, data pending from addressee
    46a4:	11 30       	cpi	r17, 0x01	; 1
    46a6:	11 f0       	breq	.+4      	; 0x46ac <rf230_transmit+0x224>
    tx_result=RADIO_TX_OK;           //handle as ordinary success
  }

  if (tx_result==RADIO_TX_OK) {
    46a8:	11 23       	and	r17, r17
    46aa:	69 f5       	brne	.+90     	; 0x4706 <rf230_transmit+0x27e>
    RIMESTATS_ADD(lltx);
    46ac:	80 91 06 30 	lds	r24, 0x3006
    46b0:	90 91 07 30 	lds	r25, 0x3007
    46b4:	a0 91 08 30 	lds	r26, 0x3008
    46b8:	b0 91 09 30 	lds	r27, 0x3009
    46bc:	01 96       	adiw	r24, 0x01	; 1
    46be:	a1 1d       	adc	r26, r1
    46c0:	b1 1d       	adc	r27, r1
    46c2:	80 93 06 30 	sts	0x3006, r24
    46c6:	90 93 07 30 	sts	0x3007, r25
    46ca:	a0 93 08 30 	sts	0x3008, r26
    46ce:	b0 93 09 30 	sts	0x3009, r27
    if(packetbuf_attr(PACKETBUF_ATTR_RELIABLE))
    46d2:	8c e0       	ldi	r24, 0x0C	; 12
    46d4:	0e 94 3d 32 	call	0x647a	; 0x647a <packetbuf_attr>
    46d8:	00 97       	sbiw	r24, 0x00	; 0
    46da:	09 f4       	brne	.+2      	; 0x46de <rf230_transmit+0x256>
    46dc:	45 c0       	rjmp	.+138    	; 0x4768 <rf230_transmit+0x2e0>
      RIMESTATS_ADD(ackrx);		//ack was requested and received
    46de:	80 91 e2 2f 	lds	r24, 0x2FE2
    46e2:	90 91 e3 2f 	lds	r25, 0x2FE3
    46e6:	a0 91 e4 2f 	lds	r26, 0x2FE4
    46ea:	b0 91 e5 2f 	lds	r27, 0x2FE5
    46ee:	01 96       	adiw	r24, 0x01	; 1
    46f0:	a1 1d       	adc	r26, r1
    46f2:	b1 1d       	adc	r27, r1
    46f4:	80 93 e2 2f 	sts	0x2FE2, r24
    46f8:	90 93 e3 2f 	sts	0x2FE3, r25
    46fc:	a0 93 e4 2f 	sts	0x2FE4, r26
    4700:	b0 93 e5 2f 	sts	0x2FE5, r27
    4704:	31 c0       	rjmp	.+98     	; 0x4768 <rf230_transmit+0x2e0>
  /* Not PAN broadcast to FFFF, and ACK was requested and received */
  if (!((buffer[5]==0xff) && (buffer[6]==0xff)) && (buffer[0]&(1<<6)))
    ack_pending=1;
#endif

  } else if (tx_result==3) {        //CSMA channel access failure
    4706:	13 30       	cpi	r17, 0x03	; 3
    4708:	a9 f4       	brne	.+42     	; 0x4734 <rf230_transmit+0x2ac>
    DEBUGFLOW('m');
    RIMESTATS_ADD(contentiondrop);
    470a:	80 91 fe 2f 	lds	r24, 0x2FFE
    470e:	90 91 ff 2f 	lds	r25, 0x2FFF
    4712:	a0 91 00 30 	lds	r26, 0x3000
    4716:	b0 91 01 30 	lds	r27, 0x3001
    471a:	01 96       	adiw	r24, 0x01	; 1
    471c:	a1 1d       	adc	r26, r1
    471e:	b1 1d       	adc	r27, r1
    4720:	80 93 fe 2f 	sts	0x2FFE, r24
    4724:	90 93 ff 2f 	sts	0x2FFF, r25
    4728:	a0 93 00 30 	sts	0x3000, r26
    472c:	b0 93 01 30 	sts	0x3001, r27
    PRINTF("rf230_transmit: Transmission never started\n");
    tx_result = RADIO_TX_COLLISION;
    4730:	12 e0       	ldi	r17, 0x02	; 2
    4732:	1d c0       	rjmp	.+58     	; 0x476e <rf230_transmit+0x2e6>
  } else if (tx_result==5) {        //Expected ACK, none received
    4734:	15 30       	cpi	r17, 0x05	; 5
    4736:	a9 f4       	brne	.+42     	; 0x4762 <rf230_transmit+0x2da>
    DEBUGFLOW('n');
    tx_result = RADIO_TX_NOACK;
    PRINTF("rf230_transmit: ACK not received\n");
    RIMESTATS_ADD(badackrx);		//ack was requested but not received
    4738:	80 91 ea 2f 	lds	r24, 0x2FEA
    473c:	90 91 eb 2f 	lds	r25, 0x2FEB
    4740:	a0 91 ec 2f 	lds	r26, 0x2FEC
    4744:	b0 91 ed 2f 	lds	r27, 0x2FED
    4748:	01 96       	adiw	r24, 0x01	; 1
    474a:	a1 1d       	adc	r26, r1
    474c:	b1 1d       	adc	r27, r1
    474e:	80 93 ea 2f 	sts	0x2FEA, r24
    4752:	90 93 eb 2f 	sts	0x2FEB, r25
    4756:	a0 93 ec 2f 	sts	0x2FEC, r26
    475a:	b0 93 ed 2f 	sts	0x2FED, r27
    RIMESTATS_ADD(contentiondrop);
    PRINTF("rf230_transmit: Transmission never started\n");
    tx_result = RADIO_TX_COLLISION;
  } else if (tx_result==5) {        //Expected ACK, none received
    DEBUGFLOW('n');
    tx_result = RADIO_TX_NOACK;
    475e:	13 e0       	ldi	r17, 0x03	; 3
    4760:	06 c0       	rjmp	.+12     	; 0x476e <rf230_transmit+0x2e6>
    PRINTF("rf230_transmit: ACK not received\n");
    RIMESTATS_ADD(badackrx);		//ack was requested but not received
  } else if (tx_result==7) {        //Invalid (Can't happen since waited for idle above?)
    4762:	17 30       	cpi	r17, 0x07	; 7
    4764:	21 f4       	brne	.+8      	; 0x476e <rf230_transmit+0x2e6>
    4766:	02 c0       	rjmp	.+4      	; 0x476c <rf230_transmit+0x2e4>
    tx_result=RADIO_TX_OK;           //handle as ordinary success
  }

  if (tx_result==RADIO_TX_OK) {
    RIMESTATS_ADD(lltx);
    if(packetbuf_attr(PACKETBUF_ATTR_RELIABLE))
    4768:	10 e0       	ldi	r17, 0x00	; 0
    476a:	01 c0       	rjmp	.+2      	; 0x476e <rf230_transmit+0x2e6>
    tx_result = RADIO_TX_NOACK;
    PRINTF("rf230_transmit: ACK not received\n");
    RIMESTATS_ADD(badackrx);		//ack was requested but not received
  } else if (tx_result==7) {        //Invalid (Can't happen since waited for idle above?)
    DEBUGFLOW('o');
    tx_result = RADIO_TX_ERR;
    476c:	11 e0       	ldi	r17, 0x01	; 1
  }

  return tx_result;
}
    476e:	81 2f       	mov	r24, r17
    4770:	90 e0       	ldi	r25, 0x00	; 0
    4772:	df 91       	pop	r29
    4774:	cf 91       	pop	r28
    4776:	1f 91       	pop	r17
    4778:	0f 91       	pop	r16
    477a:	ff 90       	pop	r15
    477c:	ef 90       	pop	r14
    477e:	df 90       	pop	r13
    4780:	08 95       	ret

00004782 <rf230_send>:
  return ret;
}
/*---------------------------------------------------------------------------*/
static int
rf230_send(const void *payload, unsigned short payload_len)
{
    4782:	cf 93       	push	r28
    4784:	df 93       	push	r29
    4786:	eb 01       	movw	r28, r22
	if(!RF230BB_HOOK_IS_SEND_ENABLED()) {
		goto bail;
	}
#endif
	
	if((ret=rf230_prepare(payload, payload_len))) {
    4788:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <rf230_prepare>
    478c:	9c 01       	movw	r18, r24
    478e:	00 97       	sbiw	r24, 0x00	; 0
    4790:	31 f4       	brne	.+12     	; 0x479e <rf230_send+0x1c>
	    PRINTF("rf230_send: Unable to send, prep failed (%d)\n",ret);
		goto bail;
	}

	ret = rf230_transmit(payload_len);
    4792:	ce 01       	movw	r24, r28
    4794:	0e 94 44 22 	call	0x4488	; 0x4488 <rf230_transmit>
    4798:	9c 01       	movw	r18, r24
	
bail:
#if RADIOSTATS
    if (ret) RF230_sendfail++;
    479a:	00 97       	sbiw	r24, 0x00	; 0
    479c:	49 f0       	breq	.+18     	; 0x47b0 <rf230_send+0x2e>
    479e:	80 91 c0 2f 	lds	r24, 0x2FC0
    47a2:	90 91 c1 2f 	lds	r25, 0x2FC1
    47a6:	01 96       	adiw	r24, 0x01	; 1
    47a8:	90 93 c1 2f 	sts	0x2FC1, r25
    47ac:	80 93 c0 2f 	sts	0x2FC0, r24
#endif
	return ret;
}
    47b0:	c9 01       	movw	r24, r18
    47b2:	df 91       	pop	r29
    47b4:	cf 91       	pop	r28
    47b6:	08 95       	ret

000047b8 <rf230_get_raw_rssi>:
}

/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_raw_rssi(void)
{
    47b8:	0f 93       	push	r16
    47ba:	1f 93       	push	r17
  uint8_t rssi,state;
  bool radio_was_off = 0;

  /*The RSSI measurement should only be done in RX_ON or BUSY_RX.*/
  if(!RF230_receive_on) {
    47bc:	80 91 c3 2f 	lds	r24, 0x2FC3
    47c0:	88 23       	and	r24, r24
    47c2:	21 f4       	brne	.+8      	; 0x47cc <rf230_get_raw_rssi+0x14>
    radio_was_off = 1;
    rf230_on();
    47c4:	0e 94 83 1f 	call	0x3f06	; 0x3f06 <rf230_on>
  uint8_t rssi,state;
  bool radio_was_off = 0;

  /*The RSSI measurement should only be done in RX_ON or BUSY_RX.*/
  if(!RF230_receive_on) {
    radio_was_off = 1;
    47c8:	11 e0       	ldi	r17, 0x01	; 1
    47ca:	01 c0       	rjmp	.+2      	; 0x47ce <rf230_get_raw_rssi+0x16>
/*---------------------------------------------------------------------------*/
uint8_t
rf230_get_raw_rssi(void)
{
  uint8_t rssi,state;
  bool radio_was_off = 0;
    47cc:	10 e0       	ldi	r17, 0x00	; 0
    rf230_on();
  }

/* The energy detect register is used in extended mode (since RSSI will read 0) */
/* The rssi register is multiplied by 3 to a consistent value from either register */
  state=radio_get_trx_state();
    47ce:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <radio_get_trx_state>
  if ((state==RX_AACK_ON) || (state==BUSY_RX_AACK)) {
    47d2:	86 31       	cpi	r24, 0x16	; 22
    47d4:	11 f0       	breq	.+4      	; 0x47da <rf230_get_raw_rssi+0x22>
    47d6:	81 31       	cpi	r24, 0x11	; 17
    47d8:	19 f4       	brne	.+6      	; 0x47e0 <rf230_get_raw_rssi+0x28>
 //  rssi = hal_subregister_read(SR_ED_LEVEL);  //0-84, resolution 1 dB
     rssi = hal_register_read(RG_PHY_ED_LEVEL);  //0-84, resolution 1 dB
    47da:	00 91 47 01 	lds	r16, 0x0147
    47de:	09 c0       	rjmp	.+18     	; 0x47f2 <rf230_get_raw_rssi+0x3a>
#if 0   // 3-clock shift and add is faster on machines with no hardware multiply
/* avr-gcc may have an -Os bug that uses the general subroutine for multiplying by 3 */
     rssi = hal_subregister_read(SR_RSSI);      //0-28, resolution 3 dB
     rssi = (rssi << 1)  + rssi;                //*3
#else  // 1 or 2 clock multiply, or compiler with correct optimization
     rssi = 3 * hal_subregister_read(SR_RSSI);
    47e0:	86 e4       	ldi	r24, 0x46	; 70
    47e2:	91 e0       	ldi	r25, 0x01	; 1
    47e4:	6f e1       	ldi	r22, 0x1F	; 31
    47e6:	40 e0       	ldi	r20, 0x00	; 0
    47e8:	0e 94 0b 24 	call	0x4816	; 0x4816 <hal_subregister_read>
    47ec:	08 2f       	mov	r16, r24
    47ee:	00 0f       	add	r16, r16
    47f0:	08 0f       	add	r16, r24
#endif

  }

  if(radio_was_off) {
    47f2:	11 23       	and	r17, r17
    47f4:	11 f0       	breq	.+4      	; 0x47fa <rf230_get_raw_rssi+0x42>
    rf230_off();
    47f6:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <rf230_off>
  }
  return rssi;
}
    47fa:	80 2f       	mov	r24, r16
    47fc:	1f 91       	pop	r17
    47fe:	0f 91       	pop	r16
    4800:	08 95       	ret

00004802 <hal_init>:
#define HAL_TICK_UPCNT() (TCNT1)
void
hal_init(void)
{
    /*Reset variables used in file.*/
    hal_system_time = 0;
    4802:	10 92 84 26 	sts	0x2684, r1
    4806:	10 92 83 26 	sts	0x2683, r1
 //   TCCR1B = HAL_TCCR1B_CONFIG;       /* Set clock prescaler */
 //   TIFR1 |= (1 << ICF1);             /* Clear Input Capture Flag. */
 //   HAL_ENABLE_OVERFLOW_INTERRUPT(); /* Enable Timer1 overflow interrupt. */
    hal_enable_trx_interrupt();    /* Enable interrupts from the radio transceiver. */
    480a:	ef e6       	ldi	r30, 0x6F	; 111
    480c:	f0 e0       	ldi	r31, 0x00	; 0
    480e:	80 81       	ld	r24, Z
    4810:	80 62       	ori	r24, 0x20	; 32
    4812:	80 83       	st	Z, r24
}
    4814:	08 95       	ret

00004816 <hal_subregister_read>:
   
 */
uint8_t
hal_subregister_read(uint16_t address, uint8_t mask, uint8_t position)
{
    return (_SFR_MEM8(address)&mask)>>position;
    4816:	fc 01       	movw	r30, r24
    4818:	80 81       	ld	r24, Z
    481a:	86 23       	and	r24, r22
    481c:	90 e0       	ldi	r25, 0x00	; 0
    481e:	02 c0       	rjmp	.+4      	; 0x4824 <hal_subregister_read+0xe>
    4820:	95 95       	asr	r25
    4822:	87 95       	ror	r24
    4824:	4a 95       	dec	r20
    4826:	e2 f7       	brpl	.-8      	; 0x4820 <hal_subregister_read+0xa>
}
    4828:	08 95       	ret

0000482a <hal_subregister_write>:
void
hal_subregister_write(uint16_t address, uint8_t mask, uint8_t position,
                            uint8_t value)
{
 cli();
    482a:	f8 94       	cli
    uint8_t register_value = _SFR_MEM8(address);
    482c:	fc 01       	movw	r30, r24
    482e:	90 81       	ld	r25, Z
    register_value &= ~mask;
    4830:	86 2f       	mov	r24, r22
    4832:	80 95       	com	r24
    4834:	89 23       	and	r24, r25
    value <<= position;
    4836:	30 e0       	ldi	r19, 0x00	; 0
    4838:	02 c0       	rjmp	.+4      	; 0x483e <hal_subregister_write+0x14>
    483a:	22 0f       	add	r18, r18
    483c:	33 1f       	adc	r19, r19
    483e:	4a 95       	dec	r20
    4840:	e2 f7       	brpl	.-8      	; 0x483a <hal_subregister_write+0x10>
    value &= mask;
    4842:	26 23       	and	r18, r22
    value |= register_value;
    4844:	28 2b       	or	r18, r24
    _SFR_MEM8(address) = value;
    4846:	20 83       	st	Z, r18
 sei();
    4848:	78 94       	sei
}
    484a:	08 95       	ret

0000484c <hal_frame_read>:
    uint8_t frame_length,*rx_data,*rx_buffer;
 
    /* Get length from the TXT_RX_LENGTH register, not including LQI
     * Bypassing the length check can result in overrun if buffer is < 256 bytes.
     */
    frame_length = TST_RX_LENGTH;
    484c:	20 91 7b 01 	lds	r18, 0x017B
    if ( 0 || ((frame_length >= HAL_MIN_FRAME_LENGTH) && (frame_length <= HAL_MAX_FRAME_LENGTH))) {
    4850:	32 2f       	mov	r19, r18
    4852:	33 50       	subi	r19, 0x03	; 3
    4854:	3d 37       	cpi	r19, 0x7D	; 125
    4856:	e0 f4       	brcc	.+56     	; 0x4890 <hal_frame_read+0x44>
        rx_frame->length = frame_length;
    4858:	fc 01       	movw	r30, r24
    485a:	21 93       	st	Z+, r18
 *          are set to zero.
 *
 *  \param  rx_frame    Pointer to the data structure where the frame is stored.
 */
void
hal_frame_read(hal_rx_frame_t *rx_frame)
    485c:	21 50       	subi	r18, 0x01	; 1
    485e:	30 e0       	ldi	r19, 0x00	; 0
    4860:	a9 01       	movw	r20, r18
    4862:	4f 57       	subi	r20, 0x7F	; 127
    4864:	5e 4f       	sbci	r21, 0xFE	; 254
    frame_length = TST_RX_LENGTH;
    if ( 0 || ((frame_length >= HAL_MIN_FRAME_LENGTH) && (frame_length <= HAL_MAX_FRAME_LENGTH))) {
        rx_frame->length = frame_length;

        /* Start of buffer in I/O space, pointer to RAM buffer */
        rx_buffer=(uint8_t *)0x180;
    4866:	a0 e8       	ldi	r26, 0x80	; 128
    4868:	b1 e0       	ldi	r27, 0x01	; 1
        rx_data = (rx_frame->data);

        do{
            *rx_data++ = _SFR_MEM8(rx_buffer++);
    486a:	6d 91       	ld	r22, X+
    486c:	61 93       	st	Z+, r22
        } while (--frame_length > 0);
    486e:	a4 17       	cp	r26, r20
    4870:	b5 07       	cpc	r27, r21
    4872:	d9 f7       	brne	.-10     	; 0x486a <hal_frame_read+0x1e>

        /*Read LQI value for this frame.*/
        rx_frame->lqi = *rx_buffer;
    4874:	fc 01       	movw	r30, r24
    4876:	e0 58       	subi	r30, 0x80	; 128
    4878:	ff 4f       	sbci	r31, 0xFF	; 255
    487a:	2f 57       	subi	r18, 0x7F	; 127
    487c:	3e 4f       	sbci	r19, 0xFE	; 254
    487e:	d9 01       	movw	r26, r18
    4880:	2c 91       	ld	r18, X
    4882:	20 83       	st	Z, r18
#endif /* defined(__AVR_ATmega128RFA1__) */

        /* If crc was calculated set crc field in hal_rx_frame_t accordingly.
         * Else show the crc has passed the hardware check.
         */
        rx_frame->crc   = true;
    4884:	8f 57       	subi	r24, 0x7F	; 127
    4886:	9f 4f       	sbci	r25, 0xFF	; 255
    4888:	21 e0       	ldi	r18, 0x01	; 1
    488a:	fc 01       	movw	r30, r24
    488c:	20 83       	st	Z, r18
    488e:	08 95       	ret

    } else {
        /* Length test failed */
        rx_frame->length = 0;
    4890:	dc 01       	movw	r26, r24
    4892:	1c 92       	st	X, r1
        rx_frame->lqi    = 0;
    4894:	fc 01       	movw	r30, r24
    4896:	e0 58       	subi	r30, 0x80	; 128
    4898:	ff 4f       	sbci	r31, 0xFF	; 255
    489a:	10 82       	st	Z, r1
        rx_frame->crc    = false;
    489c:	8f 57       	subi	r24, 0x7F	; 127
    489e:	9f 4f       	sbci	r25, 0xFF	; 255
    48a0:	fc 01       	movw	r30, r24
    48a2:	10 82       	st	Z, r1
    48a4:	08 95       	ret

000048a6 <hal_frame_write>:
 *  \param  write_buffer    Pointer to data that is to be written to frame buffer.
 *  \param  length          Length of data. The maximum length is 127 bytes.
 */
void
hal_frame_write(uint8_t *write_buffer, uint8_t length)
{
    48a6:	fc 01       	movw	r30, r24
    tx_buffer=(uint8_t *)0x180;  //start of fifo in i/o space
    /* Write frame length, including the two byte checksum */
    /* The top bit of the length field shall be set to 0 for IEEE 802.15.4 compliant frames */
    /* It should already be clear, so bypassing the masking is sanity check of the uip stack */
//  length &= 0x7f;
    _SFR_MEM8(tx_buffer++) = length;
    48a8:	60 93 80 01 	sts	0x0180, r22
 *
 *  \param  write_buffer    Pointer to data that is to be written to frame buffer.
 *  \param  length          Length of data. The maximum length is 127 bytes.
 */
void
hal_frame_write(uint8_t *write_buffer, uint8_t length)
    48ac:	01 96       	adiw	r24, 0x01	; 1
    48ae:	63 50       	subi	r22, 0x03	; 3
    48b0:	86 0f       	add	r24, r22
    48b2:	91 1d       	adc	r25, r1
    tx_buffer=(uint8_t *)0x180;  //start of fifo in i/o space
    /* Write frame length, including the two byte checksum */
    /* The top bit of the length field shall be set to 0 for IEEE 802.15.4 compliant frames */
    /* It should already be clear, so bypassing the masking is sanity check of the uip stack */
//  length &= 0x7f;
    _SFR_MEM8(tx_buffer++) = length;
    48b4:	a1 e8       	ldi	r26, 0x81	; 129
    48b6:	b1 e0       	ldi	r27, 0x01	; 1
     * since they will be overwritten.
     */
#if !RF230_CONF_CHECKSUM
    length -= 2;
#endif
    do  _SFR_MEM8(tx_buffer++)= *write_buffer++; while (--length);
    48b8:	21 91       	ld	r18, Z+
    48ba:	2d 93       	st	X+, r18
    48bc:	e8 17       	cp	r30, r24
    48be:	f9 07       	cpc	r31, r25
    48c0:	d9 f7       	brne	.-10     	; 0x48b8 <hal_frame_write+0x12>
#endif
    do HAL_SPI_TRANSFER(*write_buffer++); while (--length);

    HAL_SPI_TRANSFER_CLOSE();
#endif /* defined(__AVR_ATmega128RFA1__) */
}
    48c2:	08 95       	ret

000048c4 <__vector_60>:
/* The atmega128rfa1 has individual interrupts for the integrated radio'
 * Whichever are enabled by the RF230 driver must be present even if not used!
 */
/* Received packet interrupt */
ISR(TRX24_RX_END_vect)
{
    48c4:	1f 92       	push	r1
    48c6:	0f 92       	push	r0
    48c8:	0f b6       	in	r0, 0x3f	; 63
    48ca:	0f 92       	push	r0
    48cc:	0b b6       	in	r0, 0x3b	; 59
    48ce:	0f 92       	push	r0
    48d0:	11 24       	eor	r1, r1
    48d2:	2f 93       	push	r18
    48d4:	3f 93       	push	r19
    48d6:	4f 93       	push	r20
    48d8:	5f 93       	push	r21
    48da:	6f 93       	push	r22
    48dc:	7f 93       	push	r23
    48de:	8f 93       	push	r24
    48e0:	9f 93       	push	r25
    48e2:	af 93       	push	r26
    48e4:	bf 93       	push	r27
    48e6:	ef 93       	push	r30
    48e8:	ff 93       	push	r31
/* Get the rssi from ED if extended mode */
#if RF230_CONF_AUTOACK
	rf230_last_rssi=hal_register_read(RG_PHY_ED_LEVEL);
    48ea:	80 91 47 01 	lds	r24, 0x0147
    48ee:	80 93 28 2e 	sts	0x2E28, r24
	if (rf230_last_rssi >= RF230_MIN_RX_POWER) {
#else
	if (1) {
#endif
//		DEBUGFLOW('2');
		hal_frame_read(&rxframe[rxframe_tail]);
    48f2:	20 91 36 2e 	lds	r18, 0x2E36
    48f6:	30 e0       	ldi	r19, 0x00	; 0
    48f8:	c9 01       	movw	r24, r18
    48fa:	88 0f       	add	r24, r24
    48fc:	99 1f       	adc	r25, r25
    48fe:	36 95       	lsr	r19
    4900:	32 2f       	mov	r19, r18
    4902:	22 27       	eor	r18, r18
    4904:	37 95       	ror	r19
    4906:	27 95       	ror	r18
    4908:	82 0f       	add	r24, r18
    490a:	93 1f       	adc	r25, r19
    490c:	88 5c       	subi	r24, 0xC8	; 200
    490e:	91 4d       	sbci	r25, 0xD1	; 209
    4910:	0e 94 26 24 	call	0x484c	; 0x484c <hal_frame_read>
		rxframe_tail++;if (rxframe_tail >= RF230_CONF_RX_BUFFERS) rxframe_tail=0;
    4914:	80 91 36 2e 	lds	r24, 0x2E36
    4918:	8f 5f       	subi	r24, 0xFF	; 255
    491a:	80 93 36 2e 	sts	0x2E36, r24
    491e:	83 30       	cpi	r24, 0x03	; 3
    4920:	10 f0       	brcs	.+4      	; 0x4926 <__vector_60+0x62>
    4922:	10 92 36 2e 	sts	0x2E36, r1
		rf230_interrupt();
    4926:	0e 94 d6 20 	call	0x41ac	; 0x41ac <rf230_interrupt>
	}
}
    492a:	ff 91       	pop	r31
    492c:	ef 91       	pop	r30
    492e:	bf 91       	pop	r27
    4930:	af 91       	pop	r26
    4932:	9f 91       	pop	r25
    4934:	8f 91       	pop	r24
    4936:	7f 91       	pop	r23
    4938:	6f 91       	pop	r22
    493a:	5f 91       	pop	r21
    493c:	4f 91       	pop	r20
    493e:	3f 91       	pop	r19
    4940:	2f 91       	pop	r18
    4942:	0f 90       	pop	r0
    4944:	0b be       	out	0x3b, r0	; 59
    4946:	0f 90       	pop	r0
    4948:	0f be       	out	0x3f, r0	; 63
    494a:	0f 90       	pop	r0
    494c:	1f 90       	pop	r1
    494e:	18 95       	reti

00004950 <__vector_59>:
/* Preamble detected, starting frame reception */
ISR(TRX24_RX_START_vect)
{
    4950:	1f 92       	push	r1
    4952:	0f 92       	push	r0
    4954:	0f b6       	in	r0, 0x3f	; 63
    4956:	0f 92       	push	r0
    4958:	11 24       	eor	r1, r1
/* Save RSSI for this packet if not in extended mode, scaling to 1dB resolution */
#if !RF230_CONF_AUTOACK
    rf230_last_rssi = 3 * hal_subregister_read(SR_RSSI);
#endif

}
    495a:	0f 90       	pop	r0
    495c:	0f be       	out	0x3f, r0	; 63
    495e:	0f 90       	pop	r0
    4960:	1f 90       	pop	r1
    4962:	18 95       	reti

00004964 <__vector_57>:

/* PLL has locked, either from a transition out of TRX_OFF or a channel change while on */
ISR(TRX24_PLL_LOCK_vect)
{
    4964:	1f 92       	push	r1
    4966:	0f 92       	push	r0
    4968:	0f b6       	in	r0, 0x3f	; 63
    496a:	0f 92       	push	r0
    496c:	11 24       	eor	r1, r1
//	DEBUGFLOW('4');
}
    496e:	0f 90       	pop	r0
    4970:	0f be       	out	0x3f, r0	; 63
    4972:	0f 90       	pop	r0
    4974:	1f 90       	pop	r1
    4976:	18 95       	reti

00004978 <__vector_58>:

/* PLL has unexpectedly unlocked */
ISR(TRX24_PLL_UNLOCK_vect)
{
    4978:	1f 92       	push	r1
    497a:	0f 92       	push	r0
    497c:	0f b6       	in	r0, 0x3f	; 63
    497e:	0f 92       	push	r0
    4980:	11 24       	eor	r1, r1
	DEBUGFLOW('5');
}
    4982:	0f 90       	pop	r0
    4984:	0f be       	out	0x3f, r0	; 63
    4986:	0f 90       	pop	r0
    4988:	1f 90       	pop	r1
    498a:	18 95       	reti

0000498c <__vector_64>:
/* Flag is set by the following interrupts */
extern volatile uint8_t rf230_interruptwait,rf230_ccawait;

/* Wake has finished */
ISR(TRX24_AWAKE_vect)
{
    498c:	1f 92       	push	r1
    498e:	0f 92       	push	r0
    4990:	0f b6       	in	r0, 0x3f	; 63
    4992:	0f 92       	push	r0
    4994:	11 24       	eor	r1, r1
//	DEBUGFLOW('6');
	rf230_interruptwait=0;
    4996:	10 92 c2 2f 	sts	0x2FC2, r1
}
    499a:	0f 90       	pop	r0
    499c:	0f be       	out	0x3f, r0	; 63
    499e:	0f 90       	pop	r0
    49a0:	1f 90       	pop	r1
    49a2:	18 95       	reti

000049a4 <__vector_63>:

/* Transmission has ended */
ISR(TRX24_TX_END_vect)
{
    49a4:	1f 92       	push	r1
    49a6:	0f 92       	push	r0
    49a8:	0f b6       	in	r0, 0x3f	; 63
    49aa:	0f 92       	push	r0
    49ac:	11 24       	eor	r1, r1
//	DEBUGFLOW('7');
	rf230_interruptwait=0;
    49ae:	10 92 c2 2f 	sts	0x2FC2, r1
}
    49b2:	0f 90       	pop	r0
    49b4:	0f be       	out	0x3f, r0	; 63
    49b6:	0f 90       	pop	r0
    49b8:	1f 90       	pop	r1
    49ba:	18 95       	reti

000049bc <__vector_62>:

/* Frame address has matched ours */
extern volatile uint8_t rf230_pending;
ISR(TRX24_XAH_AMI_vect)
{
    49bc:	1f 92       	push	r1
    49be:	0f 92       	push	r0
    49c0:	0f b6       	in	r0, 0x3f	; 63
    49c2:	0f 92       	push	r0
    49c4:	11 24       	eor	r1, r1
    49c6:	8f 93       	push	r24
//	DEBUGFLOW('8');
	rf230_pending=1;
    49c8:	81 e0       	ldi	r24, 0x01	; 1
    49ca:	80 93 2e 2e 	sts	0x2E2E, r24
}
    49ce:	8f 91       	pop	r24
    49d0:	0f 90       	pop	r0
    49d2:	0f be       	out	0x3f, r0	; 63
    49d4:	0f 90       	pop	r0
    49d6:	1f 90       	pop	r1
    49d8:	18 95       	reti

000049da <__vector_61>:

/* CCAED measurement has completed */
ISR(TRX24_CCA_ED_DONE_vect)
{
    49da:	1f 92       	push	r1
    49dc:	0f 92       	push	r0
    49de:	0f b6       	in	r0, 0x3f	; 63
    49e0:	0f 92       	push	r0
    49e2:	11 24       	eor	r1, r1
	DEBUGFLOW('4');
	rf230_ccawait=0;
    49e4:	10 92 2f 2e 	sts	0x2E2F, r1
}
    49e8:	0f 90       	pop	r0
    49ea:	0f be       	out	0x3f, r0	; 63
    49ec:	0f 90       	pop	r0
    49ee:	1f 90       	pop	r1
    49f0:	18 95       	reti

000049f2 <__vector_20>:
 * This is the interrupt service routine for timer1 overflow.
 */
void TIMER1_OVF_vect(void);
#else  /* !DOXYGEN */
HAL_TIME_ISR()
{
    49f2:	1f 92       	push	r1
    49f4:	0f 92       	push	r0
    49f6:	0f b6       	in	r0, 0x3f	; 63
    49f8:	0f 92       	push	r0
    49fa:	11 24       	eor	r1, r1
    49fc:	8f 93       	push	r24
    49fe:	9f 93       	push	r25
    hal_system_time++;
    4a00:	80 91 83 26 	lds	r24, 0x2683
    4a04:	90 91 84 26 	lds	r25, 0x2684
    4a08:	01 96       	adiw	r24, 0x01	; 1
    4a0a:	90 93 84 26 	sts	0x2684, r25
    4a0e:	80 93 83 26 	sts	0x2683, r24
}
    4a12:	9f 91       	pop	r25
    4a14:	8f 91       	pop	r24
    4a16:	0f 90       	pop	r0
    4a18:	0f be       	out	0x3f, r0	; 63
    4a1a:	0f 90       	pop	r0
    4a1c:	1f 90       	pop	r1
    4a1e:	18 95       	reti

00004a20 <rimeaddr_copy>:


/*---------------------------------------------------------------------------*/
void
rimeaddr_copy(rimeaddr_t *dest, const rimeaddr_t *src)
{
    4a20:	fc 01       	movw	r30, r24
    4a22:	db 01       	movw	r26, r22
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    dest->u8[i] = src->u8[i];
    4a24:	8c 91       	ld	r24, X
    4a26:	80 83       	st	Z, r24
    4a28:	11 96       	adiw	r26, 0x01	; 1
    4a2a:	8c 91       	ld	r24, X
    4a2c:	11 97       	sbiw	r26, 0x01	; 1
    4a2e:	81 83       	std	Z+1, r24	; 0x01
  }
}
    4a30:	08 95       	ret

00004a32 <rimeaddr_cmp>:
/*---------------------------------------------------------------------------*/
int
rimeaddr_cmp(const rimeaddr_t *addr1, const rimeaddr_t *addr2)
{
    4a32:	fc 01       	movw	r30, r24
    4a34:	db 01       	movw	r26, r22
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    if(addr1->u8[i] != addr2->u8[i]) {
    4a36:	90 81       	ld	r25, Z
    4a38:	8c 91       	ld	r24, X
    4a3a:	98 17       	cp	r25, r24
    4a3c:	41 f4       	brne	.+16     	; 0x4a4e <rimeaddr_cmp+0x1c>
      return 0;
    4a3e:	21 e0       	ldi	r18, 0x01	; 1
    4a40:	30 e0       	ldi	r19, 0x00	; 0
    4a42:	91 81       	ldd	r25, Z+1	; 0x01
    4a44:	11 96       	adiw	r26, 0x01	; 1
    4a46:	8c 91       	ld	r24, X
    4a48:	11 97       	sbiw	r26, 0x01	; 1
    4a4a:	98 17       	cp	r25, r24
    4a4c:	11 f0       	breq	.+4      	; 0x4a52 <rimeaddr_cmp+0x20>
    4a4e:	20 e0       	ldi	r18, 0x00	; 0
    4a50:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  return 1;
}
    4a52:	c9 01       	movw	r24, r18
    4a54:	08 95       	ret

00004a56 <rimeaddr_set_node_addr>:
/*---------------------------------------------------------------------------*/
void
rimeaddr_set_node_addr(rimeaddr_t *t)
{
    4a56:	fc 01       	movw	r30, r24
void
rimeaddr_copy(rimeaddr_t *dest, const rimeaddr_t *src)
{
  uint8_t i;
  for(i = 0; i < RIMEADDR_SIZE; i++) {
    dest->u8[i] = src->u8[i];
    4a58:	80 81       	ld	r24, Z
    4a5a:	80 93 c4 2f 	sts	0x2FC4, r24
    4a5e:	81 81       	ldd	r24, Z+1	; 0x01
    4a60:	80 93 c5 2f 	sts	0x2FC5, r24
/*---------------------------------------------------------------------------*/
void
rimeaddr_set_node_addr(rimeaddr_t *t)
{
  rimeaddr_copy(&rimeaddr_node_addr, t);
}
    4a64:	08 95       	ret

00004a66 <input>:
  list_remove(sniffers, s);
}
/*---------------------------------------------------------------------------*/
static void
input(void)
{
    4a66:	0f 93       	push	r16
    4a68:	1f 93       	push	r17
    4a6a:	cf 93       	push	r28
    4a6c:	df 93       	push	r29
  struct rime_sniffer *s;
  struct channel *c;

  RIMESTATS_ADD(rx);
    4a6e:	80 91 ca 2f 	lds	r24, 0x2FCA
    4a72:	90 91 cb 2f 	lds	r25, 0x2FCB
    4a76:	a0 91 cc 2f 	lds	r26, 0x2FCC
    4a7a:	b0 91 cd 2f 	lds	r27, 0x2FCD
    4a7e:	01 96       	adiw	r24, 0x01	; 1
    4a80:	a1 1d       	adc	r26, r1
    4a82:	b1 1d       	adc	r27, r1
    4a84:	80 93 ca 2f 	sts	0x2FCA, r24
    4a88:	90 93 cb 2f 	sts	0x2FCB, r25
    4a8c:	a0 93 cc 2f 	sts	0x2FCC, r26
    4a90:	b0 93 cd 2f 	sts	0x2FCD, r27
  c = chameleon_parse();
    4a94:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <chameleon_parse>
    4a98:	ec 01       	movw	r28, r24
  
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4a9a:	85 e8       	ldi	r24, 0x85	; 133
    4a9c:	96 e2       	ldi	r25, 0x26	; 38
    4a9e:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    4aa2:	0b c0       	rjmp	.+22     	; 0x4aba <input+0x54>
    if(s->input_callback != NULL) {
    4aa4:	d8 01       	movw	r26, r16
    4aa6:	12 96       	adiw	r26, 0x02	; 2
    4aa8:	ed 91       	ld	r30, X+
    4aaa:	fc 91       	ld	r31, X
    4aac:	13 97       	sbiw	r26, 0x03	; 3
    4aae:	30 97       	sbiw	r30, 0x00	; 0
    4ab0:	09 f0       	breq	.+2      	; 0x4ab4 <input+0x4e>
      s->input_callback();
    4ab2:	09 95       	icall
  struct channel *c;

  RIMESTATS_ADD(rx);
  c = chameleon_parse();
  
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4ab4:	c8 01       	movw	r24, r16
    4ab6:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <list_item_next>
    4aba:	08 2f       	mov	r16, r24
    4abc:	19 2f       	mov	r17, r25
    4abe:	01 15       	cp	r16, r1
    4ac0:	11 05       	cpc	r17, r1
    4ac2:	81 f7       	brne	.-32     	; 0x4aa4 <input+0x3e>
    if(s->input_callback != NULL) {
      s->input_callback();
    }
  }
  
  if(c != NULL) {
    4ac4:	20 97       	sbiw	r28, 0x00	; 0
    4ac6:	19 f0       	breq	.+6      	; 0x4ace <input+0x68>
    abc_input(c);
    4ac8:	ce 01       	movw	r24, r28
    4aca:	0e 94 44 28 	call	0x5088	; 0x5088 <abc_input>
  }
}
    4ace:	df 91       	pop	r29
    4ad0:	cf 91       	pop	r28
    4ad2:	1f 91       	pop	r17
    4ad4:	0f 91       	pop	r16
    4ad6:	08 95       	ret

00004ad8 <init>:
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  queuebuf_init();
    4ad8:	0e 94 58 32 	call	0x64b0	; 0x64b0 <queuebuf_init>
  packetbuf_clear();
    4adc:	0e 94 ac 31 	call	0x6358	; 0x6358 <packetbuf_clear>
  announcement_init();
    4ae0:	0e 94 e8 25 	call	0x4bd0	; 0x4bd0 <announcement_init>

  chameleon_init();
    4ae4:	0e 94 58 28 	call	0x50b0	; 0x50b0 <chameleon_init>
   * either be configurable, or derived from some MAC layer property
   * (duty cycle, sleep time, or something similar). But this is OK
   * for now, and should at least get us started with experimenting
   * with announcements.
   */
  broadcast_announcement_init(BROADCAST_ANNOUNCEMENT_CHANNEL,
    4ae8:	82 e0       	ldi	r24, 0x02	; 2
    4aea:	90 e0       	ldi	r25, 0x00	; 0
    4aec:	60 e0       	ldi	r22, 0x00	; 0
    4aee:	72 e0       	ldi	r23, 0x02	; 2
    4af0:	40 e0       	ldi	r20, 0x00	; 0
    4af2:	5e e1       	ldi	r21, 0x1E	; 30
    4af4:	2f ef       	ldi	r18, 0xFF	; 255
    4af6:	31 e0       	ldi	r19, 0x01	; 1
    4af8:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <broadcast_announcement_init>
                              BROADCAST_ANNOUNCEMENT_BUMP_TIME,
                              BROADCAST_ANNOUNCEMENT_MIN_TIME,
                              BROADCAST_ANNOUNCEMENT_MAX_TIME);
}
    4afc:	08 95       	ret

00004afe <packet_sent>:
/*---------------------------------------------------------------------------*/
static void
packet_sent(void *ptr, int status, int num_tx)
{
    4afe:	cf 92       	push	r12
    4b00:	df 92       	push	r13
    4b02:	ef 92       	push	r14
    4b04:	ff 92       	push	r15
    4b06:	0f 93       	push	r16
    4b08:	1f 93       	push	r17
    4b0a:	cf 93       	push	r28
    4b0c:	df 93       	push	r29
    4b0e:	6c 01       	movw	r12, r24
    4b10:	eb 01       	movw	r28, r22
    4b12:	8a 01       	movw	r16, r20
  default:
    PRINTF("rime: error %d after %d tx\n", status, num_tx);
  }

  /* Call sniffers, pass along the MAC status code. */
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4b14:	85 e8       	ldi	r24, 0x85	; 133
    4b16:	96 e2       	ldi	r25, 0x26	; 38
    4b18:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    4b1c:	0c c0       	rjmp	.+24     	; 0x4b36 <packet_sent+0x38>
    if(s->output_callback != NULL) {
    4b1e:	d7 01       	movw	r26, r14
    4b20:	14 96       	adiw	r26, 0x04	; 4
    4b22:	ed 91       	ld	r30, X+
    4b24:	fc 91       	ld	r31, X
    4b26:	15 97       	sbiw	r26, 0x05	; 5
    4b28:	30 97       	sbiw	r30, 0x00	; 0
    4b2a:	11 f0       	breq	.+4      	; 0x4b30 <packet_sent+0x32>
      s->output_callback(status);
    4b2c:	ce 01       	movw	r24, r28
    4b2e:	09 95       	icall
  default:
    PRINTF("rime: error %d after %d tx\n", status, num_tx);
  }

  /* Call sniffers, pass along the MAC status code. */
  for(s = list_head(sniffers); s != NULL; s = list_item_next(s)) {
    4b30:	c7 01       	movw	r24, r14
    4b32:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <list_item_next>
    4b36:	e8 2e       	mov	r14, r24
    4b38:	f9 2e       	mov	r15, r25
    4b3a:	e1 14       	cp	r14, r1
    4b3c:	f1 04       	cpc	r15, r1
    4b3e:	79 f7       	brne	.-34     	; 0x4b1e <packet_sent+0x20>
    if(s->output_callback != NULL) {
      s->output_callback(status);
    }
  }

  abc_sent(c, status, num_tx);
    4b40:	c6 01       	movw	r24, r12
    4b42:	be 01       	movw	r22, r28
    4b44:	a8 01       	movw	r20, r16
    4b46:	0e 94 4c 28 	call	0x5098	; 0x5098 <abc_sent>
}
    4b4a:	df 91       	pop	r29
    4b4c:	cf 91       	pop	r28
    4b4e:	1f 91       	pop	r17
    4b50:	0f 91       	pop	r16
    4b52:	ff 90       	pop	r15
    4b54:	ef 90       	pop	r14
    4b56:	df 90       	pop	r13
    4b58:	cf 90       	pop	r12
    4b5a:	08 95       	ret

00004b5c <rime_sniffer_add>:
LIST(sniffers);

/*---------------------------------------------------------------------------*/
void
rime_sniffer_add(struct rime_sniffer *s)
{
    4b5c:	bc 01       	movw	r22, r24
  list_add(sniffers, s);
    4b5e:	85 e8       	ldi	r24, 0x85	; 133
    4b60:	96 e2       	ldi	r25, 0x26	; 38
    4b62:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <list_add>
}
    4b66:	08 95       	ret

00004b68 <rime_sniffer_remove>:
/*---------------------------------------------------------------------------*/
void
rime_sniffer_remove(struct rime_sniffer *s)
{
    4b68:	bc 01       	movw	r22, r24
  list_remove(sniffers, s);
    4b6a:	85 e8       	ldi	r24, 0x85	; 133
    4b6c:	96 e2       	ldi	r25, 0x26	; 38
    4b6e:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
}
    4b72:	08 95       	ret

00004b74 <rime_output>:
  abc_sent(c, status, num_tx);
}
/*---------------------------------------------------------------------------*/
int
rime_output(struct channel *c)
{
    4b74:	cf 93       	push	r28
    4b76:	df 93       	push	r29
    4b78:	ec 01       	movw	r28, r24
  RIMESTATS_ADD(tx);
    4b7a:	80 91 c6 2f 	lds	r24, 0x2FC6
    4b7e:	90 91 c7 2f 	lds	r25, 0x2FC7
    4b82:	a0 91 c8 2f 	lds	r26, 0x2FC8
    4b86:	b0 91 c9 2f 	lds	r27, 0x2FC9
    4b8a:	01 96       	adiw	r24, 0x01	; 1
    4b8c:	a1 1d       	adc	r26, r1
    4b8e:	b1 1d       	adc	r27, r1
    4b90:	80 93 c6 2f 	sts	0x2FC6, r24
    4b94:	90 93 c7 2f 	sts	0x2FC7, r25
    4b98:	a0 93 c8 2f 	sts	0x2FC8, r26
    4b9c:	b0 93 c9 2f 	sts	0x2FC9, r27
  if(chameleon_create(c)) {
    4ba0:	ce 01       	movw	r24, r28
    4ba2:	0e 94 72 28 	call	0x50e4	; 0x50e4 <chameleon_create>
    4ba6:	00 97       	sbiw	r24, 0x00	; 0
    4ba8:	69 f0       	breq	.+26     	; 0x4bc4 <rime_output+0x50>
    packetbuf_compact();
    4baa:	0e 94 26 31 	call	0x624c	; 0x624c <packetbuf_compact>

    NETSTACK_MAC.send(packet_sent, c);
    4bae:	e0 91 1c 0e 	lds	r30, 0x0E1C
    4bb2:	f0 91 1d 0e 	lds	r31, 0x0E1D
    4bb6:	8f e7       	ldi	r24, 0x7F	; 127
    4bb8:	95 e2       	ldi	r25, 0x25	; 37
    4bba:	be 01       	movw	r22, r28
    4bbc:	09 95       	icall
    return 1;
    4bbe:	21 e0       	ldi	r18, 0x01	; 1
    4bc0:	30 e0       	ldi	r19, 0x00	; 0
    4bc2:	02 c0       	rjmp	.+4      	; 0x4bc8 <rime_output+0x54>
  }
  return 0;
    4bc4:	20 e0       	ldi	r18, 0x00	; 0
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
}
    4bc8:	c9 01       	movw	r24, r18
    4bca:	df 91       	pop	r29
    4bcc:	cf 91       	pop	r28
    4bce:	08 95       	ret

00004bd0 <announcement_init>:

/*---------------------------------------------------------------------------*/
void
announcement_init(void)
{
  list_init(announcements);
    4bd0:	87 e8       	ldi	r24, 0x87	; 135
    4bd2:	96 e2       	ldi	r25, 0x26	; 38
    4bd4:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <list_init>
}
    4bd8:	08 95       	ret

00004bda <announcement_register>:
/*---------------------------------------------------------------------------*/
void
announcement_register(struct announcement *a, uint16_t id,
		      announcement_callback_t callback)
{
    4bda:	0f 93       	push	r16
    4bdc:	cf 93       	push	r28
    4bde:	df 93       	push	r29
    4be0:	ec 01       	movw	r28, r24
  a->id = id;
    4be2:	7b 83       	std	Y+3, r23	; 0x03
    4be4:	6a 83       	std	Y+2, r22	; 0x02
  a->has_value = 0;
    4be6:	18 86       	std	Y+8, r1	; 0x08
  a->callback = callback;
    4be8:	5f 83       	std	Y+7, r21	; 0x07
    4bea:	4e 83       	std	Y+6, r20	; 0x06
  list_add(announcements, a);
    4bec:	87 e8       	ldi	r24, 0x87	; 135
    4bee:	96 e2       	ldi	r25, 0x26	; 38
    4bf0:	be 01       	movw	r22, r28
    4bf2:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <list_add>
  if(observer_callback) {
    4bf6:	e0 91 89 26 	lds	r30, 0x2689
    4bfa:	f0 91 8a 26 	lds	r31, 0x268A
    4bfe:	30 97       	sbiw	r30, 0x00	; 0
    4c00:	49 f0       	breq	.+18     	; 0x4c14 <announcement_register+0x3a>
    observer_callback(a->id, a->has_value,
    4c02:	4c 81       	ldd	r20, Y+4	; 0x04
    4c04:	5d 81       	ldd	r21, Y+5	; 0x05
    4c06:	8a 81       	ldd	r24, Y+2	; 0x02
    4c08:	9b 81       	ldd	r25, Y+3	; 0x03
    4c0a:	68 85       	ldd	r22, Y+8	; 0x08
    4c0c:	20 e0       	ldi	r18, 0x00	; 0
    4c0e:	30 e0       	ldi	r19, 0x00	; 0
    4c10:	01 e0       	ldi	r16, 0x01	; 1
    4c12:	09 95       	icall
                      a->value, 0, ANNOUNCEMENT_BUMP);
  }
}
    4c14:	df 91       	pop	r29
    4c16:	cf 91       	pop	r28
    4c18:	0f 91       	pop	r16
    4c1a:	08 95       	ret

00004c1c <announcement_remove>:
/*---------------------------------------------------------------------------*/
void
announcement_remove(struct announcement *a)
{
    4c1c:	bc 01       	movw	r22, r24
  list_remove(announcements, a);
    4c1e:	87 e8       	ldi	r24, 0x87	; 135
    4c20:	96 e2       	ldi	r25, 0x26	; 38
    4c22:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
}
    4c26:	08 95       	ret

00004c28 <announcement_remove_value>:
/*---------------------------------------------------------------------------*/
void
announcement_remove_value(struct announcement *a)
{
    4c28:	0f 93       	push	r16
    4c2a:	dc 01       	movw	r26, r24
  a->has_value = 0;
    4c2c:	18 96       	adiw	r26, 0x08	; 8
    4c2e:	1c 92       	st	X, r1
    4c30:	18 97       	sbiw	r26, 0x08	; 8
  if(observer_callback) {
    4c32:	e0 91 89 26 	lds	r30, 0x2689
    4c36:	f0 91 8a 26 	lds	r31, 0x268A
    4c3a:	30 97       	sbiw	r30, 0x00	; 0
    4c3c:	59 f0       	breq	.+22     	; 0x4c54 <announcement_remove_value+0x2c>
    observer_callback(a->id, 0, 0, 0, ANNOUNCEMENT_NOBUMP);
    4c3e:	12 96       	adiw	r26, 0x02	; 2
    4c40:	8d 91       	ld	r24, X+
    4c42:	9c 91       	ld	r25, X
    4c44:	13 97       	sbiw	r26, 0x03	; 3
    4c46:	60 e0       	ldi	r22, 0x00	; 0
    4c48:	40 e0       	ldi	r20, 0x00	; 0
    4c4a:	50 e0       	ldi	r21, 0x00	; 0
    4c4c:	20 e0       	ldi	r18, 0x00	; 0
    4c4e:	30 e0       	ldi	r19, 0x00	; 0
    4c50:	00 e0       	ldi	r16, 0x00	; 0
    4c52:	09 95       	icall
  }

}
    4c54:	0f 91       	pop	r16
    4c56:	08 95       	ret

00004c58 <announcement_set_value>:
/*---------------------------------------------------------------------------*/
void
announcement_set_value(struct announcement *a, uint16_t value)
{
    4c58:	0f 93       	push	r16
    4c5a:	dc 01       	movw	r26, r24
    4c5c:	ab 01       	movw	r20, r22
  uint16_t oldvalue = a->value;
    4c5e:	14 96       	adiw	r26, 0x04	; 4
    4c60:	2d 91       	ld	r18, X+
    4c62:	3c 91       	ld	r19, X
    4c64:	15 97       	sbiw	r26, 0x05	; 5

  a->has_value = 1;
    4c66:	81 e0       	ldi	r24, 0x01	; 1
    4c68:	18 96       	adiw	r26, 0x08	; 8
    4c6a:	8c 93       	st	X, r24
    4c6c:	18 97       	sbiw	r26, 0x08	; 8
  a->value = value;
    4c6e:	15 96       	adiw	r26, 0x05	; 5
    4c70:	7c 93       	st	X, r23
    4c72:	6e 93       	st	-X, r22
    4c74:	14 97       	sbiw	r26, 0x04	; 4
  if(observer_callback) {
    4c76:	e0 91 89 26 	lds	r30, 0x2689
    4c7a:	f0 91 8a 26 	lds	r31, 0x268A
    4c7e:	30 97       	sbiw	r30, 0x00	; 0
    4c80:	39 f0       	breq	.+14     	; 0x4c90 <announcement_set_value+0x38>
    observer_callback(a->id, a->has_value,
    4c82:	12 96       	adiw	r26, 0x02	; 2
    4c84:	8d 91       	ld	r24, X+
    4c86:	9c 91       	ld	r25, X
    4c88:	13 97       	sbiw	r26, 0x03	; 3
    4c8a:	61 e0       	ldi	r22, 0x01	; 1
    4c8c:	00 e0       	ldi	r16, 0x00	; 0
    4c8e:	09 95       	icall
                      value, oldvalue, ANNOUNCEMENT_NOBUMP);
  }
}
    4c90:	0f 91       	pop	r16
    4c92:	08 95       	ret

00004c94 <announcement_bump>:
/*---------------------------------------------------------------------------*/
void
announcement_bump(struct announcement *a)
{
    4c94:	0f 93       	push	r16
    4c96:	dc 01       	movw	r26, r24
  if(observer_callback) {
    4c98:	e0 91 89 26 	lds	r30, 0x2689
    4c9c:	f0 91 8a 26 	lds	r31, 0x268A
    4ca0:	30 97       	sbiw	r30, 0x00	; 0
    4ca2:	69 f0       	breq	.+26     	; 0x4cbe <announcement_bump+0x2a>
    observer_callback(a->id, a->has_value,
    4ca4:	14 96       	adiw	r26, 0x04	; 4
    4ca6:	2d 91       	ld	r18, X+
    4ca8:	3c 91       	ld	r19, X
    4caa:	15 97       	sbiw	r26, 0x05	; 5
    4cac:	12 96       	adiw	r26, 0x02	; 2
    4cae:	8d 91       	ld	r24, X+
    4cb0:	9c 91       	ld	r25, X
    4cb2:	13 97       	sbiw	r26, 0x03	; 3
    4cb4:	18 96       	adiw	r26, 0x08	; 8
    4cb6:	6c 91       	ld	r22, X
    4cb8:	a9 01       	movw	r20, r18
    4cba:	01 e0       	ldi	r16, 0x01	; 1
    4cbc:	09 95       	icall
                      a->value, a->value, ANNOUNCEMENT_BUMP);
  }
}
    4cbe:	0f 91       	pop	r16
    4cc0:	08 95       	ret

00004cc2 <announcement_listen>:
/*---------------------------------------------------------------------------*/
void
announcement_listen(int time)
{
  if(listen_callback) {
    4cc2:	e0 91 8b 26 	lds	r30, 0x268B
    4cc6:	f0 91 8c 26 	lds	r31, 0x268C
    4cca:	30 97       	sbiw	r30, 0x00	; 0
    4ccc:	09 f0       	breq	.+2      	; 0x4cd0 <announcement_listen+0xe>
    listen_callback(time);
    4cce:	09 95       	icall
    4cd0:	08 95       	ret

00004cd2 <announcement_register_listen_callback>:
}
/*---------------------------------------------------------------------------*/
void
announcement_register_listen_callback(void (*callback)(int time))
{
  listen_callback = callback;
    4cd2:	90 93 8c 26 	sts	0x268C, r25
    4cd6:	80 93 8b 26 	sts	0x268B, r24
}
    4cda:	08 95       	ret

00004cdc <announcement_register_observer_callback>:
/*---------------------------------------------------------------------------*/
void
announcement_register_observer_callback(announcement_observer callback)
{
  observer_callback = callback;
    4cdc:	90 93 8a 26 	sts	0x268A, r25
    4ce0:	80 93 89 26 	sts	0x2689, r24
}
    4ce4:	08 95       	ret

00004ce6 <announcement_list>:
/*---------------------------------------------------------------------------*/
struct announcement *
announcement_list(void)
{
  return list_head(announcements);
    4ce6:	87 e8       	ldi	r24, 0x87	; 135
    4ce8:	96 e2       	ldi	r25, 0x26	; 38
    4cea:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
}
    4cee:	08 95       	ret

00004cf0 <announcement_heard>:
/*---------------------------------------------------------------------------*/
void
announcement_heard(const rimeaddr_t *from, uint16_t id, uint16_t value)
{
    4cf0:	ef 92       	push	r14
    4cf2:	ff 92       	push	r15
    4cf4:	0f 93       	push	r16
    4cf6:	1f 93       	push	r17
    4cf8:	cf 93       	push	r28
    4cfa:	df 93       	push	r29
    4cfc:	8c 01       	movw	r16, r24
    4cfe:	eb 01       	movw	r28, r22
    4d00:	7a 01       	movw	r14, r20
  struct announcement *a;
  for(a = list_head(announcements); a != NULL; a = list_item_next(a)) {
    4d02:	87 e8       	ldi	r24, 0x87	; 135
    4d04:	96 e2       	ldi	r25, 0x26	; 38
    4d06:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    4d0a:	15 c0       	rjmp	.+42     	; 0x4d36 <announcement_heard+0x46>
    if(a->id == id) {
    4d0c:	dc 01       	movw	r26, r24
    4d0e:	12 96       	adiw	r26, 0x02	; 2
    4d10:	2d 91       	ld	r18, X+
    4d12:	3c 91       	ld	r19, X
    4d14:	13 97       	sbiw	r26, 0x03	; 3
    4d16:	2c 17       	cp	r18, r28
    4d18:	3d 07       	cpc	r19, r29
    4d1a:	59 f4       	brne	.+22     	; 0x4d32 <announcement_heard+0x42>
      if(a->callback != NULL) {
    4d1c:	16 96       	adiw	r26, 0x06	; 6
    4d1e:	ed 91       	ld	r30, X+
    4d20:	fc 91       	ld	r31, X
    4d22:	17 97       	sbiw	r26, 0x07	; 7
    4d24:	30 97       	sbiw	r30, 0x00	; 0
    4d26:	61 f0       	breq	.+24     	; 0x4d40 <announcement_heard+0x50>
	a->callback(a, from, id, value);
    4d28:	b8 01       	movw	r22, r16
    4d2a:	ae 01       	movw	r20, r28
    4d2c:	97 01       	movw	r18, r14
    4d2e:	09 95       	icall
    4d30:	07 c0       	rjmp	.+14     	; 0x4d40 <announcement_heard+0x50>
/*---------------------------------------------------------------------------*/
void
announcement_heard(const rimeaddr_t *from, uint16_t id, uint16_t value)
{
  struct announcement *a;
  for(a = list_head(announcements); a != NULL; a = list_item_next(a)) {
    4d32:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <list_item_next>
    4d36:	28 2f       	mov	r18, r24
    4d38:	39 2f       	mov	r19, r25
    4d3a:	c9 01       	movw	r24, r18
    4d3c:	00 97       	sbiw	r24, 0x00	; 0
    4d3e:	31 f7       	brne	.-52     	; 0x4d0c <announcement_heard+0x1c>
	a->callback(a, from, id, value);
      }
      return;
    }
  }
}
    4d40:	df 91       	pop	r29
    4d42:	cf 91       	pop	r28
    4d44:	1f 91       	pop	r17
    4d46:	0f 91       	pop	r16
    4d48:	ff 90       	pop	r15
    4d4a:	ef 90       	pop	r14
    4d4c:	08 95       	ret

00004d4e <adv_packet_sent>:
}
/*---------------------------------------------------------------------------*/
static void
adv_packet_sent(struct broadcast_conn *bc, int status, int num_tx)
{
}
    4d4e:	08 95       	ret

00004d50 <adv_packet_received>:
	 c.val);
}
/*---------------------------------------------------------------------------*/
static void
adv_packet_received(struct broadcast_conn *ibc, const rimeaddr_t *from)
{
    4d50:	af 92       	push	r10
    4d52:	bf 92       	push	r11
    4d54:	cf 92       	push	r12
    4d56:	df 92       	push	r13
    4d58:	ef 92       	push	r14
    4d5a:	ff 92       	push	r15
    4d5c:	0f 93       	push	r16
    4d5e:	1f 93       	push	r17
    4d60:	df 93       	push	r29
    4d62:	cf 93       	push	r28
    4d64:	00 d0       	rcall	.+0      	; 0x4d66 <adv_packet_received+0x16>
    4d66:	cd b7       	in	r28, 0x3d	; 61
    4d68:	de b7       	in	r29, 0x3e	; 62
    4d6a:	5b 01       	movw	r10, r22
  struct announcement_msg adata;
  struct announcement_data data;
  uint8_t *ptr;
  int i;

  ptr = packetbuf_dataptr();
    4d6c:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    4d70:	8c 01       	movw	r16, r24

  /* Copy number of announcements */
  memcpy(&adata, ptr, sizeof(struct announcement_msg));
    4d72:	fc 01       	movw	r30, r24
    4d74:	e0 80       	ld	r14, Z
    4d76:	f1 80       	ldd	r15, Z+1	; 0x01
    4d78:	fa 82       	std	Y+2, r15	; 0x02
    4d7a:	e9 82       	std	Y+1, r14	; 0x01
  PRINTF("%d.%d: adv_packet_received from %d.%d with %d announcements\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	 from->u8[0], from->u8[1], adata.num);

  if(ANNOUNCEMENT_MSG_HEADERLEN + adata.num * sizeof(struct announcement_data) > packetbuf_datalen()) {
    4d7c:	0e 94 5b 31 	call	0x62b6	; 0x62b6 <packetbuf_datalen>
    4d80:	97 01       	movw	r18, r14
    4d82:	22 0f       	add	r18, r18
    4d84:	33 1f       	adc	r19, r19
    4d86:	22 0f       	add	r18, r18
    4d88:	33 1f       	adc	r19, r19
    4d8a:	2e 5f       	subi	r18, 0xFE	; 254
    4d8c:	3f 4f       	sbci	r19, 0xFF	; 255
    4d8e:	82 17       	cp	r24, r18
    4d90:	93 07       	cpc	r25, r19
    4d92:	98 f0       	brcs	.+38     	; 0x4dba <adv_packet_received+0x6a>
    PRINTF("adata.num way out there: %d\n", adata.num);
    return;
  }

  ptr += ANNOUNCEMENT_MSG_HEADERLEN;
  for(i = 0; i < adata.num; ++i) {
    4d94:	cc 24       	eor	r12, r12
    4d96:	dd 24       	eor	r13, r13
    4d98:	0d c0       	rjmp	.+26     	; 0x4db4 <adv_packet_received+0x64>
    /* Copy announcements */
    memcpy(&data, ptr, sizeof(struct announcement_data));
    announcement_heard(from, data.id, data.value);
    4d9a:	f8 01       	movw	r30, r16
    4d9c:	62 81       	ldd	r22, Z+2	; 0x02
    4d9e:	73 81       	ldd	r23, Z+3	; 0x03
    4da0:	44 81       	ldd	r20, Z+4	; 0x04
    4da2:	55 81       	ldd	r21, Z+5	; 0x05
    4da4:	c5 01       	movw	r24, r10
    4da6:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <announcement_heard>
    PRINTF("adata.num way out there: %d\n", adata.num);
    return;
  }

  ptr += ANNOUNCEMENT_MSG_HEADERLEN;
  for(i = 0; i < adata.num; ++i) {
    4daa:	08 94       	sec
    4dac:	c1 1c       	adc	r12, r1
    4dae:	d1 1c       	adc	r13, r1
    4db0:	0c 5f       	subi	r16, 0xFC	; 252
    4db2:	1f 4f       	sbci	r17, 0xFF	; 255
    4db4:	ce 14       	cp	r12, r14
    4db6:	df 04       	cpc	r13, r15
    4db8:	80 f3       	brcs	.-32     	; 0x4d9a <adv_packet_received+0x4a>
    /* Copy announcements */
    memcpy(&data, ptr, sizeof(struct announcement_data));
    announcement_heard(from, data.id, data.value);
    ptr += sizeof(struct announcement_data);
  }
}
    4dba:	0f 90       	pop	r0
    4dbc:	0f 90       	pop	r0
    4dbe:	cf 91       	pop	r28
    4dc0:	df 91       	pop	r29
    4dc2:	1f 91       	pop	r17
    4dc4:	0f 91       	pop	r16
    4dc6:	ff 90       	pop	r15
    4dc8:	ef 90       	pop	r14
    4dca:	df 90       	pop	r13
    4dcc:	cf 90       	pop	r12
    4dce:	bf 90       	pop	r11
    4dd0:	af 90       	pop	r10
    4dd2:	08 95       	ret

00004dd4 <set_timers>:
/*---------------------------------------------------------------------------*/
static void send_timer(void *ptr);

static void
set_timers(void)
{
    4dd4:	cf 93       	push	r28
    4dd6:	df 93       	push	r29
  ctimer_set(&c.interval_timer, c.current_interval, send_timer, NULL);
    4dd8:	c8 ea       	ldi	r28, 0xA8	; 168
    4dda:	d6 e2       	ldi	r29, 0x26	; 38
    4ddc:	60 91 be 26 	lds	r22, 0x26BE
    4de0:	70 91 bf 26 	lds	r23, 0x26BF
    4de4:	ce 01       	movw	r24, r28
    4de6:	4c e1       	ldi	r20, 0x1C	; 28
    4de8:	57 e2       	ldi	r21, 0x27	; 39
    4dea:	20 e0       	ldi	r18, 0x00	; 0
    4dec:	30 e0       	ldi	r19, 0x00	; 0
    4dee:	0e 94 f7 17 	call	0x2fee	; 0x2fee <ctimer_set>
  ctimer_set(&c.send_timer, random_rand() % c.current_interval,
    4df2:	0e 94 7d 30 	call	0x60fa	; 0x60fa <random_rand>
    4df6:	60 91 be 26 	lds	r22, 0x26BE
    4dfa:	70 91 bf 26 	lds	r23, 0x26BF
    4dfe:	0e 94 63 4a 	call	0x94c6	; 0x94c6 <__udivmodhi4>
    4e02:	bc 01       	movw	r22, r24
    4e04:	ce 01       	movw	r24, r28
    4e06:	40 97       	sbiw	r24, 0x10	; 16
    4e08:	41 e3       	ldi	r20, 0x31	; 49
    4e0a:	57 e2       	ldi	r21, 0x27	; 39
    4e0c:	20 e0       	ldi	r18, 0x00	; 0
    4e0e:	30 e0       	ldi	r19, 0x00	; 0
    4e10:	0e 94 f7 17 	call	0x2fee	; 0x2fee <ctimer_set>
             send_adv, NULL);
}
    4e14:	df 91       	pop	r29
    4e16:	cf 91       	pop	r28
    4e18:	08 95       	ret

00004e1a <new_announcement>:
}
/*---------------------------------------------------------------------------*/
static void
new_announcement(uint16_t id, uint8_t has_value,
                 uint16_t newval, uint16_t oldval, uint8_t bump)
{
    4e1a:	0f 93       	push	r16
  if(bump == ANNOUNCEMENT_BUMP) {
    4e1c:	01 30       	cpi	r16, 0x01	; 1
    4e1e:	51 f4       	brne	.+20     	; 0x4e34 <new_announcement+0x1a>
    c.current_interval = c.initial_interval;
    4e20:	80 91 b8 26 	lds	r24, 0x26B8
    4e24:	90 91 b9 26 	lds	r25, 0x26B9
    4e28:	90 93 bf 26 	sts	0x26BF, r25
    4e2c:	80 93 be 26 	sts	0x26BE, r24
    set_timers();
    4e30:	0e 94 ea 26 	call	0x4dd4	; 0x4dd4 <set_timers>
    /*  } else if(newval != oldval) {
    c.current_interval = c.min_interval;
    set_timers();*/
  }
}
    4e34:	0f 91       	pop	r16
    4e36:	08 95       	ret

00004e38 <send_timer>:
static void
send_timer(void *ptr)
{
  clock_time_t interval;

  interval = c.current_interval * 2;
    4e38:	80 91 be 26 	lds	r24, 0x26BE
    4e3c:	90 91 bf 26 	lds	r25, 0x26BF

  if(interval > c.max_interval) {
    interval = c.max_interval;
  }

  c.current_interval = interval;
    4e40:	20 91 bc 26 	lds	r18, 0x26BC
    4e44:	30 91 bd 26 	lds	r19, 0x26BD
    4e48:	88 0f       	add	r24, r24
    4e4a:	99 1f       	adc	r25, r25
    4e4c:	28 17       	cp	r18, r24
    4e4e:	39 07       	cpc	r19, r25
    4e50:	08 f4       	brcc	.+2      	; 0x4e54 <send_timer+0x1c>
    4e52:	c9 01       	movw	r24, r18
    4e54:	90 93 bf 26 	sts	0x26BF, r25
    4e58:	80 93 be 26 	sts	0x26BE, r24

  /*  printf("current_interval %lu\n", (long unsigned int) interval);*/

  set_timers();
    4e5c:	0e 94 ea 26 	call	0x4dd4	; 0x4dd4 <set_timers>
}
    4e60:	08 95       	ret

00004e62 <send_adv>:
#define MIN(a, b) ((a)<(b)?(a):(b))

/*---------------------------------------------------------------------------*/
static void
send_adv(void *ptr)
{
    4e62:	ef 92       	push	r14
    4e64:	ff 92       	push	r15
    4e66:	cf 93       	push	r28
    4e68:	df 93       	push	r29
  struct announcement_msg *adata;
  struct announcement *a;

  packetbuf_clear();
    4e6a:	0e 94 ac 31 	call	0x6358	; 0x6358 <packetbuf_clear>
  adata = packetbuf_dataptr();
    4e6e:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    4e72:	e8 2e       	mov	r14, r24
    4e74:	e7 01       	movw	r28, r14
    4e76:	7e 01       	movw	r14, r28
    4e78:	f9 2e       	mov	r15, r25
    4e7a:	e7 01       	movw	r28, r14
  adata->num = 0;
    4e7c:	19 82       	std	Y+1, r1	; 0x01
    4e7e:	18 82       	st	Y, r1
  for(a = announcement_list(); a != NULL && a->has_value; a = list_item_next(a)) {
    4e80:	0e 94 73 26 	call	0x4ce6	; 0x4ce6 <announcement_list>
    4e84:	26 c0       	rjmp	.+76     	; 0x4ed2 <send_adv+0x70>
    adata->data[adata->num].id = a->id;
    4e86:	28 81       	ld	r18, Y
    4e88:	39 81       	ldd	r19, Y+1	; 0x01
    4e8a:	f9 01       	movw	r30, r18
    4e8c:	ee 0f       	add	r30, r30
    4e8e:	ff 1f       	adc	r31, r31
    4e90:	ee 0f       	add	r30, r30
    4e92:	ff 1f       	adc	r31, r31
    4e94:	ec 0f       	add	r30, r28
    4e96:	fd 1f       	adc	r31, r29
    4e98:	dc 01       	movw	r26, r24
    4e9a:	12 96       	adiw	r26, 0x02	; 2
    4e9c:	4d 91       	ld	r20, X+
    4e9e:	5c 91       	ld	r21, X
    4ea0:	13 97       	sbiw	r26, 0x03	; 3
    4ea2:	53 83       	std	Z+3, r21	; 0x03
    4ea4:	42 83       	std	Z+2, r20	; 0x02
    adata->data[adata->num].value = a->value;
    4ea6:	2f 5f       	subi	r18, 0xFF	; 255
    4ea8:	3f 4f       	sbci	r19, 0xFF	; 255
    4eaa:	f9 01       	movw	r30, r18
    4eac:	ee 0f       	add	r30, r30
    4eae:	ff 1f       	adc	r31, r31
    4eb0:	ee 0f       	add	r30, r30
    4eb2:	ff 1f       	adc	r31, r31
    4eb4:	ec 0f       	add	r30, r28
    4eb6:	fd 1f       	adc	r31, r29
    4eb8:	14 96       	adiw	r26, 0x04	; 4
    4eba:	4d 91       	ld	r20, X+
    4ebc:	5c 91       	ld	r21, X
    4ebe:	15 97       	sbiw	r26, 0x05	; 5
    4ec0:	51 83       	std	Z+1, r21	; 0x01
    4ec2:	40 83       	st	Z, r20
    adata->num++;
    4ec4:	39 83       	std	Y+1, r19	; 0x01
    4ec6:	28 83       	st	Y, r18
  struct announcement *a;

  packetbuf_clear();
  adata = packetbuf_dataptr();
  adata->num = 0;
  for(a = announcement_list(); a != NULL && a->has_value; a = list_item_next(a)) {
    4ec8:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <list_item_next>
    4ecc:	28 2f       	mov	r18, r24
    4ece:	39 2f       	mov	r19, r25
    4ed0:	c9 01       	movw	r24, r18
    4ed2:	00 97       	sbiw	r24, 0x00	; 0
    4ed4:	21 f0       	breq	.+8      	; 0x4ede <send_adv+0x7c>
    4ed6:	fc 01       	movw	r30, r24
    4ed8:	20 85       	ldd	r18, Z+8	; 0x08
    4eda:	22 23       	and	r18, r18
    4edc:	a1 f6       	brne	.-88     	; 0x4e86 <send_adv+0x24>
    adata->data[adata->num].value = a->value;
    adata->num++;
  }

  packetbuf_set_datalen(ANNOUNCEMENT_MSG_HEADERLEN +
		      sizeof(struct announcement_data) * adata->num);
    4ede:	88 81       	ld	r24, Y
    4ee0:	99 81       	ldd	r25, Y+1	; 0x01
    4ee2:	88 0f       	add	r24, r24
    4ee4:	99 1f       	adc	r25, r25
    4ee6:	88 0f       	add	r24, r24
    4ee8:	99 1f       	adc	r25, r25
    adata->data[adata->num].id = a->id;
    adata->data[adata->num].value = a->value;
    adata->num++;
  }

  packetbuf_set_datalen(ANNOUNCEMENT_MSG_HEADERLEN +
    4eea:	02 96       	adiw	r24, 0x02	; 2
    4eec:	0e 94 04 31 	call	0x6208	; 0x6208 <packetbuf_set_datalen>
		      sizeof(struct announcement_data) * adata->num);

  PRINTF("%d.%d: sending neighbor advertisement with %d announcements\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1], adata->num);

  if(adata->num > 0) {
    4ef0:	88 81       	ld	r24, Y
    4ef2:	99 81       	ldd	r25, Y+1	; 0x01
    4ef4:	00 97       	sbiw	r24, 0x00	; 0
    4ef6:	21 f0       	breq	.+8      	; 0x4f00 <send_adv+0x9e>
    /* Send the packet only if it contains more than zero announcements. */
    broadcast_send(&c.c);
    4ef8:	8d e8       	ldi	r24, 0x8D	; 141
    4efa:	96 e2       	ldi	r25, 0x26	; 38
    4efc:	0e 94 17 28 	call	0x502e	; 0x502e <broadcast_send>
  }
  PRINTF("%d.%d: sending neighbor advertisement with val %d\n",
	 rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	 c.val);
}
    4f00:	df 91       	pop	r29
    4f02:	cf 91       	pop	r28
    4f04:	ff 90       	pop	r15
    4f06:	ef 90       	pop	r14
    4f08:	08 95       	ret

00004f0a <broadcast_announcement_init>:
void
broadcast_announcement_init(uint16_t channel,
                            clock_time_t initial,
                            clock_time_t min,
                            clock_time_t max)
{
    4f0a:	ef 92       	push	r14
    4f0c:	ff 92       	push	r15
    4f0e:	0f 93       	push	r16
    4f10:	1f 93       	push	r17
    4f12:	cf 93       	push	r28
    4f14:	df 93       	push	r29
    4f16:	fc 01       	movw	r30, r24
    4f18:	8b 01       	movw	r16, r22
    4f1a:	7a 01       	movw	r14, r20
    4f1c:	e9 01       	movw	r28, r18
  broadcast_open(&c.c, channel, &broadcast_callbacks);
    4f1e:	8d e8       	ldi	r24, 0x8D	; 141
    4f20:	96 e2       	ldi	r25, 0x26	; 38
    4f22:	bf 01       	movw	r22, r30
    4f24:	43 ef       	ldi	r20, 0xF3	; 243
    4f26:	5d e0       	ldi	r21, 0x0D	; 13
    4f28:	0e 94 f9 27 	call	0x4ff2	; 0x4ff2 <broadcast_open>
  c.initial_interval = initial;
    4f2c:	10 93 b9 26 	sts	0x26B9, r17
    4f30:	00 93 b8 26 	sts	0x26B8, r16
  c.min_interval = min;
    4f34:	f0 92 bb 26 	sts	0x26BB, r15
    4f38:	e0 92 ba 26 	sts	0x26BA, r14
  c.max_interval = max;
    4f3c:	d0 93 bd 26 	sts	0x26BD, r29
    4f40:	c0 93 bc 26 	sts	0x26BC, r28

  announcement_register_observer_callback(new_announcement);
    4f44:	8d e0       	ldi	r24, 0x0D	; 13
    4f46:	97 e2       	ldi	r25, 0x27	; 39
    4f48:	0e 94 6e 26 	call	0x4cdc	; 0x4cdc <announcement_register_observer_callback>
}
    4f4c:	df 91       	pop	r29
    4f4e:	cf 91       	pop	r28
    4f50:	1f 91       	pop	r17
    4f52:	0f 91       	pop	r16
    4f54:	ff 90       	pop	r15
    4f56:	ef 90       	pop	r14
    4f58:	08 95       	ret

00004f5a <broadcast_announcement_stop>:
/*---------------------------------------------------------------------------*/
void
broadcast_announcement_stop(void)
{
    4f5a:	cf 93       	push	r28
    4f5c:	df 93       	push	r29
  ctimer_stop(&c.interval_timer);
    4f5e:	c8 ea       	ldi	r28, 0xA8	; 168
    4f60:	d6 e2       	ldi	r29, 0x26	; 38
    4f62:	ce 01       	movw	r24, r28
    4f64:	0e 94 7e 18 	call	0x30fc	; 0x30fc <ctimer_stop>
  ctimer_stop(&c.send_timer);
    4f68:	ce 01       	movw	r24, r28
    4f6a:	40 97       	sbiw	r24, 0x10	; 16
    4f6c:	0e 94 7e 18 	call	0x30fc	; 0x30fc <ctimer_stop>
  broadcast_close(&c.c);
    4f70:	ce 01       	movw	r24, r28
    4f72:	4b 97       	sbiw	r24, 0x1b	; 27
    4f74:	0e 94 14 28 	call	0x5028	; 0x5028 <broadcast_close>
}
    4f78:	df 91       	pop	r29
    4f7a:	cf 91       	pop	r28
    4f7c:	08 95       	ret

00004f7e <broadcast_announcement_beacon_interval>:
/*---------------------------------------------------------------------------*/
clock_time_t
broadcast_announcement_beacon_interval(void)
{
  return c.current_interval;
}
    4f7e:	80 91 be 26 	lds	r24, 0x26BE
    4f82:	90 91 bf 26 	lds	r25, 0x26BF
    4f86:	08 95       	ret

00004f88 <sent_by_abc>:
}
/*---------------------------------------------------------------------------*/
static void
sent_by_abc(struct abc_conn *bc, int status, int num_tx)
{
  struct broadcast_conn *c = (struct broadcast_conn *)bc;
    4f88:	dc 01       	movw	r26, r24
  PRINTF("%d.%d: sent to %d.%d status %d num_tx %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 packetbuf_addr(PACKETBUF_ADDR_SENDER)->u8[0],
         packetbuf_addr(PACKETBUF_ADDR_SENDER)->u8[1],
         status, num_tx);
  if(c->u->sent) {
    4f8a:	19 96       	adiw	r26, 0x09	; 9
    4f8c:	ed 91       	ld	r30, X+
    4f8e:	fc 91       	ld	r31, X
    4f90:	1a 97       	sbiw	r26, 0x0a	; 10
    4f92:	02 80       	ldd	r0, Z+2	; 0x02
    4f94:	f3 81       	ldd	r31, Z+3	; 0x03
    4f96:	e0 2d       	mov	r30, r0
    4f98:	30 97       	sbiw	r30, 0x00	; 0
    4f9a:	09 f0       	breq	.+2      	; 0x4f9e <sent_by_abc+0x16>
    c->u->sent(c, status, num_tx);
    4f9c:	09 95       	icall
    4f9e:	08 95       	ret

00004fa0 <recv_from_abc>:
#endif

/*---------------------------------------------------------------------------*/
static void
recv_from_abc(struct abc_conn *bc)
{
    4fa0:	ef 92       	push	r14
    4fa2:	ff 92       	push	r15
    4fa4:	0f 93       	push	r16
    4fa6:	1f 93       	push	r17
    4fa8:	df 93       	push	r29
    4faa:	cf 93       	push	r28
    4fac:	00 d0       	rcall	.+0      	; 0x4fae <recv_from_abc+0xe>
    4fae:	cd b7       	in	r28, 0x3d	; 61
    4fb0:	de b7       	in	r29, 0x3e	; 62
  rimeaddr_t sender;
  struct broadcast_conn *c = (struct broadcast_conn *)bc;
    4fb2:	8c 01       	movw	r16, r24

  rimeaddr_copy(&sender, packetbuf_addr(PACKETBUF_ADDR_SENDER));
    4fb4:	88 e1       	ldi	r24, 0x18	; 24
    4fb6:	0e 94 50 32 	call	0x64a0	; 0x64a0 <packetbuf_addr>
    4fba:	bc 01       	movw	r22, r24
    4fbc:	7e 01       	movw	r14, r28
    4fbe:	08 94       	sec
    4fc0:	e1 1c       	adc	r14, r1
    4fc2:	f1 1c       	adc	r15, r1
    4fc4:	c7 01       	movw	r24, r14
    4fc6:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
  
  PRINTF("%d.%d: broadcast: from %d.%d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 sender.u8[0], sender.u8[1]);
  c->u->recv(c, &sender);
    4fca:	d8 01       	movw	r26, r16
    4fcc:	19 96       	adiw	r26, 0x09	; 9
    4fce:	ed 91       	ld	r30, X+
    4fd0:	fc 91       	ld	r31, X
    4fd2:	1a 97       	sbiw	r26, 0x0a	; 10
    4fd4:	01 90       	ld	r0, Z+
    4fd6:	f0 81       	ld	r31, Z
    4fd8:	e0 2d       	mov	r30, r0
    4fda:	c8 01       	movw	r24, r16
    4fdc:	b7 01       	movw	r22, r14
    4fde:	09 95       	icall
}
    4fe0:	0f 90       	pop	r0
    4fe2:	0f 90       	pop	r0
    4fe4:	cf 91       	pop	r28
    4fe6:	df 91       	pop	r29
    4fe8:	1f 91       	pop	r17
    4fea:	0f 91       	pop	r16
    4fec:	ff 90       	pop	r15
    4fee:	ef 90       	pop	r14
    4ff0:	08 95       	ret

00004ff2 <broadcast_open>:
static const struct abc_callbacks broadcast = {recv_from_abc, sent_by_abc};
/*---------------------------------------------------------------------------*/
void
broadcast_open(struct broadcast_conn *c, uint16_t channel,
	  const struct broadcast_callbacks *u)
{
    4ff2:	ef 92       	push	r14
    4ff4:	ff 92       	push	r15
    4ff6:	0f 93       	push	r16
    4ff8:	1f 93       	push	r17
    4ffa:	cf 93       	push	r28
    4ffc:	df 93       	push	r29
    4ffe:	ec 01       	movw	r28, r24
    5000:	8b 01       	movw	r16, r22
    5002:	7a 01       	movw	r14, r20
  abc_open(&c->c, channel, &broadcast);
    5004:	47 ef       	ldi	r20, 0xF7	; 247
    5006:	5d e0       	ldi	r21, 0x0D	; 13
    5008:	0e 94 25 28 	call	0x504a	; 0x504a <abc_open>
  c->u = u;
    500c:	fa 86       	std	Y+10, r15	; 0x0a
    500e:	e9 86       	std	Y+9, r14	; 0x09
  channel_set_attributes(channel, attributes);
    5010:	c8 01       	movw	r24, r16
    5012:	6b ef       	ldi	r22, 0xFB	; 251
    5014:	7d e0       	ldi	r23, 0x0D	; 13
    5016:	0e 94 c1 28 	call	0x5182	; 0x5182 <channel_set_attributes>
}
    501a:	df 91       	pop	r29
    501c:	cf 91       	pop	r28
    501e:	1f 91       	pop	r17
    5020:	0f 91       	pop	r16
    5022:	ff 90       	pop	r15
    5024:	ef 90       	pop	r14
    5026:	08 95       	ret

00005028 <broadcast_close>:
/*---------------------------------------------------------------------------*/
void
broadcast_close(struct broadcast_conn *c)
{
  abc_close(&c->c);
    5028:	0e 94 3e 28 	call	0x507c	; 0x507c <abc_close>
}
    502c:	08 95       	ret

0000502e <broadcast_send>:
/*---------------------------------------------------------------------------*/
int
broadcast_send(struct broadcast_conn *c)
{
    502e:	cf 93       	push	r28
    5030:	df 93       	push	r29
    5032:	ec 01       	movw	r28, r24
  PRINTF("%d.%d: broadcast_send\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
  packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &rimeaddr_node_addr);
    5034:	88 e1       	ldi	r24, 0x18	; 24
    5036:	64 ec       	ldi	r22, 0xC4	; 196
    5038:	7f e2       	ldi	r23, 0x2F	; 47
    503a:	0e 94 46 32 	call	0x648c	; 0x648c <packetbuf_set_addr>
  return abc_send(&c->c);
    503e:	ce 01       	movw	r24, r28
    5040:	0e 94 41 28 	call	0x5082	; 0x5082 <abc_send>
}
    5044:	df 91       	pop	r29
    5046:	cf 91       	pop	r28
    5048:	08 95       	ret

0000504a <abc_open>:

/*---------------------------------------------------------------------------*/
void
abc_open(struct abc_conn *c, uint16_t channelno,
	  const struct abc_callbacks *callbacks)
{
    504a:	ef 92       	push	r14
    504c:	ff 92       	push	r15
    504e:	0f 93       	push	r16
    5050:	1f 93       	push	r17
    5052:	cf 93       	push	r28
    5054:	df 93       	push	r29
    5056:	ec 01       	movw	r28, r24
    5058:	8b 01       	movw	r16, r22
    505a:	7a 01       	movw	r14, r20
  channel_open(&c->channel, channelno);
    505c:	0e 94 9a 28 	call	0x5134	; 0x5134 <channel_open>
  c->u = callbacks;
    5060:	f8 86       	std	Y+8, r15	; 0x08
    5062:	ef 82       	std	Y+7, r14	; 0x07
  channel_set_attributes(channelno, attributes);
    5064:	c8 01       	movw	r24, r16
    5066:	6f ef       	ldi	r22, 0xFF	; 255
    5068:	7d e0       	ldi	r23, 0x0D	; 13
    506a:	0e 94 c1 28 	call	0x5182	; 0x5182 <channel_set_attributes>
}
    506e:	df 91       	pop	r29
    5070:	cf 91       	pop	r28
    5072:	1f 91       	pop	r17
    5074:	0f 91       	pop	r16
    5076:	ff 90       	pop	r15
    5078:	ef 90       	pop	r14
    507a:	08 95       	ret

0000507c <abc_close>:
/*---------------------------------------------------------------------------*/
void
abc_close(struct abc_conn *c)
{
  channel_close(&c->channel);
    507c:	0e 94 a3 28 	call	0x5146	; 0x5146 <channel_close>
}
    5080:	08 95       	ret

00005082 <abc_send>:
abc_send(struct abc_conn *c)
{
  PRINTF("%d.%d: abc: abc_send on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 c->channel.channelno);
  return rime_output(&c->channel);
    5082:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <rime_output>
}
    5086:	08 95       	ret

00005088 <abc_input>:
/*---------------------------------------------------------------------------*/
void
abc_input(struct channel *channel)
{
  struct abc_conn *c = (struct abc_conn *)channel;
    5088:	fc 01       	movw	r30, r24
  PRINTF("%d.%d: abc: abc_input_packet on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 channel->channelno);

  c->u->recv(c);
    508a:	a7 81       	ldd	r26, Z+7	; 0x07
    508c:	b0 85       	ldd	r27, Z+8	; 0x08
    508e:	2d 91       	ld	r18, X+
    5090:	3c 91       	ld	r19, X
    5092:	f9 01       	movw	r30, r18
    5094:	09 95       	icall
}
    5096:	08 95       	ret

00005098 <abc_sent>:
/*---------------------------------------------------------------------------*/
void
abc_sent(struct channel *channel, int status, int num_tx)
{
  struct abc_conn *c = (struct abc_conn *)channel;
    5098:	dc 01       	movw	r26, r24
  PRINTF("%d.%d: abc: abc_sent on channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 channel->channelno);

  if(c->u->sent) {
    509a:	17 96       	adiw	r26, 0x07	; 7
    509c:	ed 91       	ld	r30, X+
    509e:	fc 91       	ld	r31, X
    50a0:	18 97       	sbiw	r26, 0x08	; 8
    50a2:	02 80       	ldd	r0, Z+2	; 0x02
    50a4:	f3 81       	ldd	r31, Z+3	; 0x03
    50a6:	e0 2d       	mov	r30, r0
    50a8:	30 97       	sbiw	r30, 0x00	; 0
    50aa:	09 f0       	breq	.+2      	; 0x50ae <abc_sent+0x16>
    c->u->sent(c, status, num_tx);
    50ac:	09 95       	icall
    50ae:	08 95       	ret

000050b0 <chameleon_init>:

/*---------------------------------------------------------------------------*/
void
chameleon_init(void)
{
  channel_init();
    50b0:	0e 94 95 28 	call	0x512a	; 0x512a <channel_init>
}
    50b4:	08 95       	ret

000050b6 <chameleon_parse>:
}
#endif /* DEBUG */
/*---------------------------------------------------------------------------*/
struct channel *
chameleon_parse(void)
{
    50b6:	ef 92       	push	r14
    50b8:	ff 92       	push	r15
    50ba:	cf 93       	push	r28
    50bc:	df 93       	push	r29
  PRINTF("%d.%d: chameleon_input\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
#if DEBUG
  printhdr(packetbuf_dataptr(), packetbuf_datalen());
#endif /* DEBUG */
  c = CHAMELEON_MODULE.input();
    50be:	e0 91 01 0e 	lds	r30, 0x0E01
    50c2:	f0 91 02 0e 	lds	r31, 0x0E02
    50c6:	09 95       	icall
    50c8:	ec 01       	movw	r28, r24
  if(c != NULL) {
    50ca:	00 97       	sbiw	r24, 0x00	; 0
    50cc:	29 f0       	breq	.+10     	; 0x50d8 <chameleon_parse+0x22>
    PRINTF("%d.%d: chameleon_input channel %d\n",
           rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
           c->channelno);
    packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c->channelno);
    50ce:	6a 81       	ldd	r22, Y+2	; 0x02
    50d0:	7b 81       	ldd	r23, Y+3	; 0x03
    50d2:	81 e0       	ldi	r24, 0x01	; 1
    50d4:	0e 94 32 32 	call	0x6464	; 0x6464 <packetbuf_set_attr>
  } else {
    PRINTF("%d.%d: chameleon_input channel not found for incoming packet\n",
           rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1]);
  }
  return c;
}
    50d8:	ce 01       	movw	r24, r28
    50da:	df 91       	pop	r29
    50dc:	cf 91       	pop	r28
    50de:	ff 90       	pop	r15
    50e0:	ef 90       	pop	r14
    50e2:	08 95       	ret

000050e4 <chameleon_create>:
/*---------------------------------------------------------------------------*/
int
chameleon_create(struct channel *c)
{
    50e4:	0f 93       	push	r16
    50e6:	1f 93       	push	r17
    50e8:	cf 93       	push	r28
    50ea:	df 93       	push	r29
    50ec:	8c 01       	movw	r16, r24

  PRINTF("%d.%d: chameleon_output channel %d\n",
	 rimeaddr_node_addr.u8[0],rimeaddr_node_addr.u8[1],
	 c->channelno);

  ret = CHAMELEON_MODULE.output(c);
    50ee:	e0 91 03 0e 	lds	r30, 0x0E03
    50f2:	f0 91 04 0e 	lds	r31, 0x0E04
    50f6:	09 95       	icall
    50f8:	ec 01       	movw	r28, r24
  packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c->channelno);
    50fa:	f8 01       	movw	r30, r16
    50fc:	62 81       	ldd	r22, Z+2	; 0x02
    50fe:	73 81       	ldd	r23, Z+3	; 0x03
    5100:	81 e0       	ldi	r24, 0x01	; 1
    5102:	0e 94 32 32 	call	0x6464	; 0x6464 <packetbuf_set_attr>
#if DEBUG
  printhdr(packetbuf_hdrptr(), packetbuf_hdrlen());
#endif /* DEBUG */
  if(ret) {
    return 1;
    5106:	21 e0       	ldi	r18, 0x01	; 1
    5108:	30 e0       	ldi	r19, 0x00	; 0
    510a:	20 97       	sbiw	r28, 0x00	; 0
    510c:	11 f4       	brne	.+4      	; 0x5112 <chameleon_create+0x2e>
    510e:	20 e0       	ldi	r18, 0x00	; 0
    5110:	30 e0       	ldi	r19, 0x00	; 0
  }
  return 0;
}
    5112:	c9 01       	movw	r24, r18
    5114:	df 91       	pop	r29
    5116:	cf 91       	pop	r28
    5118:	1f 91       	pop	r17
    511a:	0f 91       	pop	r16
    511c:	08 95       	ret

0000511e <chameleon_hdrsize>:
/*---------------------------------------------------------------------------*/
int
chameleon_hdrsize(const struct packetbuf_attrlist attrlist[])
{
  return CHAMELEON_MODULE.hdrsize(attrlist);
    511e:	e0 91 05 0e 	lds	r30, 0x0E05
    5122:	f0 91 06 0e 	lds	r31, 0x0E06
    5126:	09 95       	icall
}
    5128:	08 95       	ret

0000512a <channel_init>:

/*---------------------------------------------------------------------------*/
void
channel_init(void)
{
  list_init(channel_list);
    512a:	82 ec       	ldi	r24, 0xC2	; 194
    512c:	96 e2       	ldi	r25, 0x26	; 38
    512e:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <list_init>
}
    5132:	08 95       	ret

00005134 <channel_open>:
  }
}
/*---------------------------------------------------------------------------*/
void
channel_open(struct channel *c, uint16_t channelno)
{
    5134:	fc 01       	movw	r30, r24
  c->channelno = channelno;
    5136:	73 83       	std	Z+3, r23	; 0x03
    5138:	62 83       	std	Z+2, r22	; 0x02
  list_add(channel_list, c);
    513a:	82 ec       	ldi	r24, 0xC2	; 194
    513c:	96 e2       	ldi	r25, 0x26	; 38
    513e:	bf 01       	movw	r22, r30
    5140:	0e 94 96 2d 	call	0x5b2c	; 0x5b2c <list_add>
}
    5144:	08 95       	ret

00005146 <channel_close>:
/*---------------------------------------------------------------------------*/
void
channel_close(struct channel *c)
{
    5146:	bc 01       	movw	r22, r24
  list_remove(channel_list, c);
    5148:	82 ec       	ldi	r24, 0xC2	; 194
    514a:	96 e2       	ldi	r25, 0x26	; 38
    514c:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>
}
    5150:	08 95       	ret

00005152 <channel_lookup>:
/*---------------------------------------------------------------------------*/
struct channel *
channel_lookup(uint16_t channelno)
{
    5152:	cf 93       	push	r28
    5154:	df 93       	push	r29
    5156:	ec 01       	movw	r28, r24
  struct channel *c;
  for(c = list_head(channel_list); c != NULL; c = list_item_next(c)) {
    5158:	82 ec       	ldi	r24, 0xC2	; 194
    515a:	96 e2       	ldi	r25, 0x26	; 38
    515c:	0e 94 0f 2d 	call	0x5a1e	; 0x5a1e <list_head>
    5160:	08 c0       	rjmp	.+16     	; 0x5172 <channel_lookup+0x20>
    if(c->channelno == channelno) {
    5162:	82 81       	ldd	r24, Z+2	; 0x02
    5164:	93 81       	ldd	r25, Z+3	; 0x03
    5166:	8c 17       	cp	r24, r28
    5168:	9d 07       	cpc	r25, r29
    516a:	39 f0       	breq	.+14     	; 0x517a <channel_lookup+0x28>
/*---------------------------------------------------------------------------*/
struct channel *
channel_lookup(uint16_t channelno)
{
  struct channel *c;
  for(c = list_head(channel_list); c != NULL; c = list_item_next(c)) {
    516c:	cf 01       	movw	r24, r30
    516e:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <list_item_next>
    5172:	e8 2f       	mov	r30, r24
    5174:	f9 2f       	mov	r31, r25
    5176:	30 97       	sbiw	r30, 0x00	; 0
    5178:	a1 f7       	brne	.-24     	; 0x5162 <channel_lookup+0x10>
    if(c->channelno == channelno) {
      return c;
    }
  }
  return NULL;
}
    517a:	cf 01       	movw	r24, r30
    517c:	df 91       	pop	r29
    517e:	cf 91       	pop	r28
    5180:	08 95       	ret

00005182 <channel_set_attributes>:
}
/*---------------------------------------------------------------------------*/
void
channel_set_attributes(uint16_t channelno,
		       const struct packetbuf_attrlist attrlist[])
{
    5182:	0f 93       	push	r16
    5184:	1f 93       	push	r17
    5186:	cf 93       	push	r28
    5188:	df 93       	push	r29
    518a:	8b 01       	movw	r16, r22
  struct channel *c;
  c = channel_lookup(channelno);
    518c:	0e 94 a9 28 	call	0x5152	; 0x5152 <channel_lookup>
    5190:	ec 01       	movw	r28, r24
  if(c != NULL) {
    5192:	00 97       	sbiw	r24, 0x00	; 0
    5194:	31 f0       	breq	.+12     	; 0x51a2 <channel_set_attributes+0x20>
    c->attrlist = attrlist;
    5196:	1d 83       	std	Y+5, r17	; 0x05
    5198:	0c 83       	std	Y+4, r16	; 0x04
    c->hdrsize = chameleon_hdrsize(attrlist);
    519a:	c8 01       	movw	r24, r16
    519c:	0e 94 8f 28 	call	0x511e	; 0x511e <chameleon_hdrsize>
    51a0:	8e 83       	std	Y+6, r24	; 0x06
  }
}
    51a2:	df 91       	pop	r29
    51a4:	cf 91       	pop	r28
    51a6:	1f 91       	pop	r17
    51a8:	0f 91       	pop	r16
    51aa:	08 95       	ret

000051ac <header_size>:
  }
}
/*---------------------------------------------------------------------------*/
static int
header_size(const struct packetbuf_attrlist *a)
{
    51ac:	fc 01       	movw	r30, r24
  int size, len;
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */
  
  size = 0;
    51ae:	20 e0       	ldi	r18, 0x00	; 0
    51b0:	30 e0       	ldi	r19, 0x00	; 0
  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {
    51b2:	04 c0       	rjmp	.+8      	; 0x51bc <header_size+0x10>
      continue;
    }
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    /*    PRINTF("chameleon header_size: header type %d len %d\n",
	   a->type, a->len);*/
    len = a->len;
    51b4:	81 81       	ldd	r24, Z+1	; 0x01
    /*    if(len < 8) {
      len = 8;
      }*/
    size += len;
    51b6:	28 0f       	add	r18, r24
    51b8:	31 1d       	adc	r19, r1
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */
  
  size = 0;
  for(; a->type != PACKETBUF_ATTR_NONE; ++a) {
    51ba:	32 96       	adiw	r30, 0x02	; 2
    51bc:	80 81       	ld	r24, Z
    51be:	88 23       	and	r24, r24
    51c0:	c9 f7       	brne	.-14     	; 0x51b4 <header_size+0x8>
      len = 8;
      }*/
    size += len;
  }
  return size;
}
    51c2:	c9 01       	movw	r24, r18
    51c4:	08 95       	ret

000051c6 <get_bits_in_byte>:
#endif

/*---------------------------------------------------------------------------*/
uint8_t CC_INLINE
get_bits_in_byte(uint8_t *from, int bitpos, int vallen)
{
    51c6:	fc 01       	movw	r30, r24
  uint16_t shifted_val;

  shifted_val = (from[0] << 8) | from[1];
    51c8:	81 81       	ldd	r24, Z+1	; 0x01
    51ca:	90 e0       	ldi	r25, 0x00	; 0
    51cc:	30 81       	ld	r19, Z
    51ce:	20 e0       	ldi	r18, 0x00	; 0
    51d0:	82 2b       	or	r24, r18
    51d2:	93 2b       	or	r25, r19
	from[0], from[1], shifted_val,
	(((shifted_val << bitpos) >> 8) & bitmask[vallen]) >> (8 - vallen),
	vallen
	);*/
  
  return (((shifted_val << bitpos) >> 8) & bitmask[vallen]) >> (8 - vallen);
    51d4:	02 c0       	rjmp	.+4      	; 0x51da <get_bits_in_byte+0x14>
    51d6:	88 0f       	add	r24, r24
    51d8:	99 1f       	adc	r25, r25
    51da:	6a 95       	dec	r22
    51dc:	e2 f7       	brpl	.-8      	; 0x51d6 <get_bits_in_byte+0x10>
    51de:	89 2f       	mov	r24, r25
    51e0:	99 27       	eor	r25, r25
    51e2:	fa 01       	movw	r30, r20
    51e4:	e9 5f       	subi	r30, 0xF9	; 249
    51e6:	f1 4f       	sbci	r31, 0xF1	; 241
    51e8:	20 81       	ld	r18, Z
    51ea:	30 e0       	ldi	r19, 0x00	; 0
    51ec:	82 23       	and	r24, r18
    51ee:	93 23       	and	r25, r19
    51f0:	28 e0       	ldi	r18, 0x08	; 8
    51f2:	30 e0       	ldi	r19, 0x00	; 0
    51f4:	24 1b       	sub	r18, r20
    51f6:	35 0b       	sbc	r19, r21
    51f8:	02 c0       	rjmp	.+4      	; 0x51fe <get_bits_in_byte+0x38>
    51fa:	96 95       	lsr	r25
    51fc:	87 95       	ror	r24
    51fe:	2a 95       	dec	r18
    5200:	e2 f7       	brpl	.-8      	; 0x51fa <get_bits_in_byte+0x34>
}
    5202:	08 95       	ret

00005204 <get_bits>:
/*---------------------------------------------------------------------------*/
void
get_bits(uint8_t *to, uint8_t *from, int bitpos, int vallen)
{
    5204:	6f 92       	push	r6
    5206:	7f 92       	push	r7
    5208:	8f 92       	push	r8
    520a:	9f 92       	push	r9
    520c:	af 92       	push	r10
    520e:	bf 92       	push	r11
    5210:	cf 92       	push	r12
    5212:	df 92       	push	r13
    5214:	ef 92       	push	r14
    5216:	ff 92       	push	r15
    5218:	0f 93       	push	r16
    521a:	1f 93       	push	r17
    521c:	cf 93       	push	r28
    521e:	df 93       	push	r29
    5220:	6c 01       	movw	r12, r24
    5222:	7b 01       	movw	r14, r22
    5224:	5a 01       	movw	r10, r20
    5226:	89 01       	movw	r16, r18
  int i, bits;
  
  
  if(vallen < 8) {
    5228:	28 30       	cpi	r18, 0x08	; 8
    522a:	31 05       	cpc	r19, r1
    522c:	44 f4       	brge	.+16     	; 0x523e <get_bits+0x3a>
    *to = get_bits_in_byte(from, bitpos, vallen);
    522e:	cb 01       	movw	r24, r22
    5230:	ba 01       	movw	r22, r20
    5232:	a9 01       	movw	r20, r18
    5234:	0e 94 e3 28 	call	0x51c6	; 0x51c6 <get_bits_in_byte>
    5238:	f6 01       	movw	r30, r12
    523a:	80 83       	st	Z, r24
    523c:	41 c0       	rjmp	.+130    	; 0x52c0 <get_bits+0xbc>
    523e:	39 01       	movw	r6, r18
    5240:	33 e0       	ldi	r19, 0x03	; 3
    5242:	75 94       	asr	r7
    5244:	67 94       	ror	r6
    5246:	3a 95       	dec	r19
    5248:	e1 f7       	brne	.-8      	; 0x5242 <get_bits+0x3e>
  } else {
    if(bitpos == 0) {
    524a:	41 15       	cp	r20, r1
    524c:	51 05       	cpc	r21, r1
    524e:	21 f0       	breq	.+8      	; 0x5258 <get_bits+0x54>
      bits = vallen & 7;
      if(bits) {
	to[i] = get_bits_in_byte(&from[i], 0, bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    5250:	4c 01       	movw	r8, r24
    5252:	c0 e0       	ldi	r28, 0x00	; 0
    5254:	d0 e0       	ldi	r29, 0x00	; 0
    5256:	16 c0       	rjmp	.+44     	; 0x5284 <get_bits+0x80>
  
  if(vallen < 8) {
    *to = get_bits_in_byte(from, bitpos, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5258:	db 01       	movw	r26, r22
    525a:	fc 01       	movw	r30, r24
    525c:	c0 e0       	ldi	r28, 0x00	; 0
    525e:	d0 e0       	ldi	r29, 0x00	; 0
	/*	PRINTF("get_bits i %d val 0x%02x\n",
		i, from[i]);*/
	to[i] = from[i];
    5260:	8d 91       	ld	r24, X+
    5262:	81 93       	st	Z+, r24
  
  if(vallen < 8) {
    *to = get_bits_in_byte(from, bitpos, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5264:	21 96       	adiw	r28, 0x01	; 1
    5266:	c6 15       	cp	r28, r6
    5268:	d7 05       	cpc	r29, r7
    526a:	d4 f3       	brlt	.-12     	; 0x5260 <get_bits+0x5c>
	/*	PRINTF("get_bits i %d val 0x%02x\n",
		i, from[i]);*/
	to[i] = from[i];
      }
      bits = vallen & 7;
    526c:	a8 01       	movw	r20, r16
    526e:	47 70       	andi	r20, 0x07	; 7
    5270:	50 70       	andi	r21, 0x00	; 0
      if(bits) {
    5272:	41 15       	cp	r20, r1
    5274:	51 05       	cpc	r21, r1
    5276:	21 f1       	breq	.+72     	; 0x52c0 <get_bits+0xbc>
	to[i] = get_bits_in_byte(&from[i], 0, bits);
    5278:	c7 01       	movw	r24, r14
    527a:	8c 0f       	add	r24, r28
    527c:	9d 1f       	adc	r25, r29
    527e:	60 e0       	ldi	r22, 0x00	; 0
    5280:	70 e0       	ldi	r23, 0x00	; 0
    5282:	19 c0       	rjmp	.+50     	; 0x52b6 <get_bits+0xb2>
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
	/*	PRINTF("get_bits i %d val 0x%02x bitpos %d\n",
		i, from[i], bitpos);*/
	to[i] = get_bits_in_byte(&from[i], bitpos, 8);
    5284:	c7 01       	movw	r24, r14
    5286:	8c 0f       	add	r24, r28
    5288:	9d 1f       	adc	r25, r29
    528a:	b5 01       	movw	r22, r10
    528c:	48 e0       	ldi	r20, 0x08	; 8
    528e:	50 e0       	ldi	r21, 0x00	; 0
    5290:	0e 94 e3 28 	call	0x51c6	; 0x51c6 <get_bits_in_byte>
    5294:	f4 01       	movw	r30, r8
    5296:	81 93       	st	Z+, r24
    5298:	4f 01       	movw	r8, r30
      bits = vallen & 7;
      if(bits) {
	to[i] = get_bits_in_byte(&from[i], 0, bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    529a:	21 96       	adiw	r28, 0x01	; 1
    529c:	c6 15       	cp	r28, r6
    529e:	d7 05       	cpc	r29, r7
    52a0:	8c f3       	brlt	.-30     	; 0x5284 <get_bits+0x80>
	/*	PRINTF("get_bits i %d val 0x%02x bitpos %d\n",
		i, from[i], bitpos);*/
	to[i] = get_bits_in_byte(&from[i], bitpos, 8);
      }
      bits = vallen & 7;
    52a2:	a8 01       	movw	r20, r16
    52a4:	47 70       	andi	r20, 0x07	; 7
    52a6:	50 70       	andi	r21, 0x00	; 0
      if(bits) {
    52a8:	41 15       	cp	r20, r1
    52aa:	51 05       	cpc	r21, r1
    52ac:	49 f0       	breq	.+18     	; 0x52c0 <get_bits+0xbc>
	to[i] = get_bits_in_byte(&from[i], bitpos, bits);
    52ae:	c7 01       	movw	r24, r14
    52b0:	8c 0f       	add	r24, r28
    52b2:	9d 1f       	adc	r25, r29
    52b4:	b5 01       	movw	r22, r10
    52b6:	0e 94 e3 28 	call	0x51c6	; 0x51c6 <get_bits_in_byte>
    52ba:	cc 0d       	add	r28, r12
    52bc:	dd 1d       	adc	r29, r13
    52be:	88 83       	st	Y, r24
      }
    }
  }
}
    52c0:	df 91       	pop	r29
    52c2:	cf 91       	pop	r28
    52c4:	1f 91       	pop	r17
    52c6:	0f 91       	pop	r16
    52c8:	ff 90       	pop	r15
    52ca:	ef 90       	pop	r14
    52cc:	df 90       	pop	r13
    52ce:	cf 90       	pop	r12
    52d0:	bf 90       	pop	r11
    52d2:	af 90       	pop	r10
    52d4:	9f 90       	pop	r9
    52d6:	8f 90       	pop	r8
    52d8:	7f 90       	pop	r7
    52da:	6f 90       	pop	r6
    52dc:	08 95       	ret

000052de <unpack_header>:
  return 1; /* Send out packet */
}
/*---------------------------------------------------------------------------*/
static struct channel *
unpack_header(void)
{
    52de:	4f 92       	push	r4
    52e0:	5f 92       	push	r5
    52e2:	6f 92       	push	r6
    52e4:	7f 92       	push	r7
    52e6:	8f 92       	push	r8
    52e8:	9f 92       	push	r9
    52ea:	af 92       	push	r10
    52ec:	bf 92       	push	r11
    52ee:	cf 92       	push	r12
    52f0:	df 92       	push	r13
    52f2:	ef 92       	push	r14
    52f4:	ff 92       	push	r15
    52f6:	0f 93       	push	r16
    52f8:	1f 93       	push	r17
    52fa:	df 93       	push	r29
    52fc:	cf 93       	push	r28
    52fe:	00 d0       	rcall	.+0      	; 0x5300 <unpack_header+0x22>
    5300:	00 d0       	rcall	.+0      	; 0x5302 <unpack_header+0x24>
    5302:	cd b7       	in	r28, 0x3d	; 61
    5304:	de b7       	in	r29, 0x3e	; 62
  struct channel *c;
  

  /* The packet has a header that tells us what channel the packet is
     for. */
  hdr = (struct bitopt_hdr *)packetbuf_dataptr();
    5306:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    530a:	e8 2e       	mov	r14, r24
    530c:	09 2f       	mov	r16, r25
  if(packetbuf_hdrreduce(sizeof(struct bitopt_hdr)) == 0) {
    530e:	82 e0       	ldi	r24, 0x02	; 2
    5310:	90 e0       	ldi	r25, 0x00	; 0
    5312:	0e 94 e5 30 	call	0x61ca	; 0x61ca <packetbuf_hdrreduce>
    5316:	00 97       	sbiw	r24, 0x00	; 0
    5318:	09 f4       	brne	.+2      	; 0x531c <unpack_header+0x3e>
    531a:	64 c0       	rjmp	.+200    	; 0x53e4 <unpack_header+0x106>
  struct channel *c;
  

  /* The packet has a header that tells us what channel the packet is
     for. */
  hdr = (struct bitopt_hdr *)packetbuf_dataptr();
    531c:	ee 2d       	mov	r30, r14
    531e:	f0 2f       	mov	r31, r16
  if(packetbuf_hdrreduce(sizeof(struct bitopt_hdr)) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  c = channel_lookup((hdr->channel[1] << 8) + hdr->channel[0]);
    5320:	91 81       	ldd	r25, Z+1	; 0x01
    5322:	80 e0       	ldi	r24, 0x00	; 0
    5324:	20 81       	ld	r18, Z
    5326:	82 0f       	add	r24, r18
    5328:	91 1d       	adc	r25, r1
    532a:	0e 94 a9 28 	call	0x5152	; 0x5152 <channel_lookup>
    532e:	7c 01       	movw	r14, r24
  if(c == NULL) {
    5330:	00 97       	sbiw	r24, 0x00	; 0
    5332:	09 f4       	brne	.+2      	; 0x5336 <unpack_header+0x58>
    5334:	59 c0       	rjmp	.+178    	; 0x53e8 <unpack_header+0x10a>
    PRINTF("chameleon-bitopt: input: channel %u not found\n",
           (hdr->channel[1] << 8) + hdr->channel[0]);
    return NULL;
  }

  hdrptr = packetbuf_dataptr();
    5336:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    533a:	3c 01       	movw	r6, r24
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
    533c:	f7 01       	movw	r30, r14
    533e:	46 81       	ldd	r20, Z+6	; 0x06
    5340:	24 2f       	mov	r18, r20
    5342:	30 e0       	ldi	r19, 0x00	; 0
    5344:	27 70       	andi	r18, 0x07	; 7
    5346:	30 70       	andi	r19, 0x00	; 0
    5348:	81 e0       	ldi	r24, 0x01	; 1
    534a:	90 e0       	ldi	r25, 0x00	; 0
    534c:	21 15       	cp	r18, r1
    534e:	31 05       	cpc	r19, r1
    5350:	11 f4       	brne	.+4      	; 0x5356 <unpack_header+0x78>
    5352:	80 e0       	ldi	r24, 0x00	; 0
    5354:	90 e0       	ldi	r25, 0x00	; 0
    5356:	46 95       	lsr	r20
    5358:	46 95       	lsr	r20
    535a:	46 95       	lsr	r20
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    535c:	84 0f       	add	r24, r20
    535e:	91 1d       	adc	r25, r1
    5360:	0e 94 e5 30 	call	0x61ca	; 0x61ca <packetbuf_hdrreduce>
    5364:	00 97       	sbiw	r24, 0x00	; 0
    5366:	f1 f1       	breq	.+124    	; 0x53e4 <unpack_header+0x106>
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    5368:	f7 01       	movw	r30, r14
    536a:	04 81       	ldd	r16, Z+4	; 0x04
    536c:	15 81       	ldd	r17, Z+5	; 0x05
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
    536e:	cc 24       	eor	r12, r12
    5370:	dd 24       	eor	r13, r13
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, addr.u8[0], addr.u8[1]);
      packetbuf_set_addr(a->type, &addr);
    } else {
      packetbuf_attr_t val = 0;
      get_bits((uint8_t *)&val, &hdrptr[byteptr], bitptr & 7, len);
    5372:	53 e0       	ldi	r21, 0x03	; 3
    5374:	45 2e       	mov	r4, r21
    5376:	51 2c       	mov	r5, r1
    5378:	4c 0e       	add	r4, r28
    537a:	5d 1e       	adc	r5, r29
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    byteptr = bitptr / 8;
    if(PACKETBUF_IS_ADDR(a->type)) {
      rimeaddr_t addr;
      get_bits((uint8_t *)&addr, &hdrptr[byteptr], bitptr & 7, len);
    537c:	4e 01       	movw	r8, r28
    537e:	08 94       	sec
    5380:	81 1c       	adc	r8, r1
    5382:	91 1c       	adc	r9, r1
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    5384:	2a c0       	rjmp	.+84     	; 0x53da <unpack_header+0xfc>
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    PRINTF("%d.%d: unpack_header type %d, len %d, bitptr %d\n",
	   rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    5386:	f8 01       	movw	r30, r16
    5388:	a1 80       	ldd	r10, Z+1	; 0x01
    538a:	bb 24       	eor	r11, r11
    byteptr = bitptr / 8;
    538c:	b6 01       	movw	r22, r12
    538e:	43 e0       	ldi	r20, 0x03	; 3
    5390:	75 95       	asr	r23
    5392:	67 95       	ror	r22
    5394:	4a 95       	dec	r20
    5396:	e1 f7       	brne	.-8      	; 0x5390 <unpack_header+0xb2>
    5398:	66 0d       	add	r22, r6
    539a:	77 1d       	adc	r23, r7
    539c:	a6 01       	movw	r20, r12
    539e:	47 70       	andi	r20, 0x07	; 7
    53a0:	50 70       	andi	r21, 0x00	; 0
    if(PACKETBUF_IS_ADDR(a->type)) {
    53a2:	88 31       	cpi	r24, 0x18	; 24
    53a4:	50 f0       	brcs	.+20     	; 0x53ba <unpack_header+0xdc>
      rimeaddr_t addr;
      get_bits((uint8_t *)&addr, &hdrptr[byteptr], bitptr & 7, len);
    53a6:	c4 01       	movw	r24, r8
    53a8:	95 01       	movw	r18, r10
    53aa:	0e 94 02 29 	call	0x5204	; 0x5204 <get_bits>
      PRINTF("%d.%d: unpack_header type %d, addr %d.%d\n",
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, addr.u8[0], addr.u8[1]);
      packetbuf_set_addr(a->type, &addr);
    53ae:	f8 01       	movw	r30, r16
    53b0:	80 81       	ld	r24, Z
    53b2:	b4 01       	movw	r22, r8
    53b4:	0e 94 46 32 	call	0x648c	; 0x648c <packetbuf_set_addr>
    53b8:	0c c0       	rjmp	.+24     	; 0x53d2 <unpack_header+0xf4>
    } else {
      packetbuf_attr_t val = 0;
    53ba:	1c 82       	std	Y+4, r1	; 0x04
    53bc:	1b 82       	std	Y+3, r1	; 0x03
      get_bits((uint8_t *)&val, &hdrptr[byteptr], bitptr & 7, len);
    53be:	c2 01       	movw	r24, r4
    53c0:	95 01       	movw	r18, r10
    53c2:	0e 94 02 29 	call	0x5204	; 0x5204 <get_bits>

      packetbuf_set_attr(a->type, val);
    53c6:	6b 81       	ldd	r22, Y+3	; 0x03
    53c8:	7c 81       	ldd	r23, Y+4	; 0x04
    53ca:	f8 01       	movw	r30, r16
    53cc:	80 81       	ld	r24, Z
    53ce:	0e 94 32 32 	call	0x6464	; 0x6464 <packetbuf_set_attr>
      PRINTF("%d.%d: unpack_header type %d, val %d\n",
	     rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	     a->type, val);
    }
    /*    byteptr += len / 8;*/
    bitptr += len;
    53d2:	ca 0c       	add	r12, r10
    53d4:	db 1c       	adc	r13, r11
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
  }
  byteptr = bitptr = 0;
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    53d6:	0e 5f       	subi	r16, 0xFE	; 254
    53d8:	1f 4f       	sbci	r17, 0xFF	; 255
    53da:	f8 01       	movw	r30, r16
    53dc:	80 81       	ld	r24, Z
    53de:	88 23       	and	r24, r24
    53e0:	91 f6       	brne	.-92     	; 0x5386 <unpack_header+0xa8>
    53e2:	02 c0       	rjmp	.+4      	; 0x53e8 <unpack_header+0x10a>

  hdrptr = packetbuf_dataptr();
  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdrreduce(hdrbytesize) == 0) {
    PRINTF("chameleon-bitopt: too short packet\n");
    return NULL;
    53e4:	ee 24       	eor	r14, r14
    53e6:	ff 24       	eor	r15, r15
    }
    /*    byteptr += len / 8;*/
    bitptr += len;
  }
  return c;
}
    53e8:	c7 01       	movw	r24, r14
    53ea:	0f 90       	pop	r0
    53ec:	0f 90       	pop	r0
    53ee:	0f 90       	pop	r0
    53f0:	0f 90       	pop	r0
    53f2:	cf 91       	pop	r28
    53f4:	df 91       	pop	r29
    53f6:	1f 91       	pop	r17
    53f8:	0f 91       	pop	r16
    53fa:	ff 90       	pop	r15
    53fc:	ef 90       	pop	r14
    53fe:	df 90       	pop	r13
    5400:	cf 90       	pop	r12
    5402:	bf 90       	pop	r11
    5404:	af 90       	pop	r10
    5406:	9f 90       	pop	r9
    5408:	8f 90       	pop	r8
    540a:	7f 90       	pop	r7
    540c:	6f 90       	pop	r6
    540e:	5f 90       	pop	r5
    5410:	4f 90       	pop	r4
    5412:	08 95       	ret

00005414 <set_bits_in_byte>:
  return size;
}
/*---------------------------------------------------------------------------*/
void CC_INLINE
set_bits_in_byte(uint8_t *target, int bitpos, uint8_t val, int vallen)
{
    5414:	fc 01       	movw	r30, r24
  unsigned short shifted_val;
  shifted_val = val << (8 - bitpos + 8 - vallen);
    5416:	50 e0       	ldi	r21, 0x00	; 0
    5418:	80 e1       	ldi	r24, 0x10	; 16
    541a:	90 e0       	ldi	r25, 0x00	; 0
    541c:	86 1b       	sub	r24, r22
    541e:	97 0b       	sbc	r25, r23
    5420:	82 1b       	sub	r24, r18
    5422:	93 0b       	sbc	r25, r19
    5424:	02 c0       	rjmp	.+4      	; 0x542a <set_bits_in_byte+0x16>
    5426:	44 0f       	add	r20, r20
    5428:	55 1f       	adc	r21, r21
    542a:	8a 95       	dec	r24
    542c:	e2 f7       	brpl	.-8      	; 0x5426 <set_bits_in_byte+0x12>
  /*  printf("set_bits_in_byte before target[0] 0x%02x target[1] 0x%02x shifted_val 0x%04x val 0x%02x vallen %d\n",
      target[0], target[1], shifted_val, val, vallen);*/
  target[0] |= shifted_val >> 8;
    542e:	80 81       	ld	r24, Z
    5430:	85 2b       	or	r24, r21
    5432:	80 83       	st	Z, r24
  target[1] |= shifted_val & 0xff;
    5434:	81 81       	ldd	r24, Z+1	; 0x01
    5436:	84 2b       	or	r24, r20
    5438:	81 83       	std	Z+1, r24	; 0x01
}
    543a:	08 95       	ret

0000543c <set_bits>:
/*---------------------------------------------------------------------------*/
void
set_bits(uint8_t *ptr, int bitpos, uint8_t *val, int vallen)
{
    543c:	6f 92       	push	r6
    543e:	7f 92       	push	r7
    5440:	8f 92       	push	r8
    5442:	9f 92       	push	r9
    5444:	af 92       	push	r10
    5446:	bf 92       	push	r11
    5448:	cf 92       	push	r12
    544a:	df 92       	push	r13
    544c:	ef 92       	push	r14
    544e:	ff 92       	push	r15
    5450:	0f 93       	push	r16
    5452:	1f 93       	push	r17
    5454:	cf 93       	push	r28
    5456:	df 93       	push	r29
    5458:	8c 01       	movw	r16, r24
    545a:	5b 01       	movw	r10, r22
    545c:	6a 01       	movw	r12, r20
    545e:	79 01       	movw	r14, r18
  int i, bits;

  /*  PRINTF("set_bits %p bitpos %d, val %p len %d\n",
      ptr, bitpos, val, vallen);*/

  if(vallen < 8) {
    5460:	28 30       	cpi	r18, 0x08	; 8
    5462:	31 05       	cpc	r19, r1
    5464:	24 f4       	brge	.+8      	; 0x546e <set_bits+0x32>
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
    5466:	c8 01       	movw	r24, r16
    5468:	fa 01       	movw	r30, r20
    546a:	40 81       	ld	r20, Z
    546c:	56 c0       	rjmp	.+172    	; 0x551a <set_bits+0xde>
    546e:	39 01       	movw	r6, r18
    5470:	63 e0       	ldi	r22, 0x03	; 3
    5472:	75 94       	asr	r7
    5474:	67 94       	ror	r6
    5476:	6a 95       	dec	r22
    5478:	e1 f7       	brne	.-8      	; 0x5472 <set_bits+0x36>
  } else {
    if(bitpos == 0) {
    547a:	a1 14       	cp	r10, r1
    547c:	b1 04       	cpc	r11, r1
    547e:	21 f0       	breq	.+8      	; 0x5488 <set_bits+0x4c>
      bits = vallen & 7;
      if(bits) {
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    5480:	4a 01       	movw	r8, r20
    5482:	c0 e0       	ldi	r28, 0x00	; 0
    5484:	d0 e0       	ldi	r29, 0x00	; 0
    5486:	21 c0       	rjmp	.+66     	; 0x54ca <set_bits+0x8e>

  if(vallen < 8) {
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5488:	da 01       	movw	r26, r20
    548a:	f8 01       	movw	r30, r16
    548c:	80 e0       	ldi	r24, 0x00	; 0
    548e:	90 e0       	ldi	r25, 0x00	; 0
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	ptr[i] = val[i];
    5490:	2d 91       	ld	r18, X+
    5492:	21 93       	st	Z+, r18

  if(vallen < 8) {
    set_bits_in_byte(ptr, bitpos, *val /*>> (8 - vallen)*/, vallen);
  } else {
    if(bitpos == 0) {
      for(i = 0; i < vallen / 8; ++i) {
    5494:	01 96       	adiw	r24, 0x01	; 1
    5496:	86 15       	cp	r24, r6
    5498:	97 05       	cpc	r25, r7
    549a:	d4 f3       	brlt	.-12     	; 0x5490 <set_bits+0x54>
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	ptr[i] = val[i];
      }
      bits = vallen & 7;
    549c:	97 01       	movw	r18, r14
    549e:	27 70       	andi	r18, 0x07	; 7
    54a0:	30 70       	andi	r19, 0x00	; 0
      if(bits) {
    54a2:	21 15       	cp	r18, r1
    54a4:	31 05       	cpc	r19, r1
    54a6:	d9 f1       	breq	.+118    	; 0x551e <set_bits+0xe2>
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
    54a8:	f6 01       	movw	r30, r12
    54aa:	e8 0f       	add	r30, r24
    54ac:	f9 1f       	adc	r31, r25
    54ae:	40 81       	ld	r20, Z
    54b0:	50 e0       	ldi	r21, 0x00	; 0
    54b2:	68 e0       	ldi	r22, 0x08	; 8
    54b4:	70 e0       	ldi	r23, 0x00	; 0
    54b6:	62 1b       	sub	r22, r18
    54b8:	73 0b       	sbc	r23, r19
    54ba:	02 c0       	rjmp	.+4      	; 0x54c0 <set_bits+0x84>
    54bc:	55 95       	asr	r21
    54be:	47 95       	ror	r20
    54c0:	6a 95       	dec	r22
    54c2:	e2 f7       	brpl	.-8      	; 0x54bc <set_bits+0x80>
    54c4:	80 0f       	add	r24, r16
    54c6:	91 1f       	adc	r25, r17
    54c8:	26 c0       	rjmp	.+76     	; 0x5516 <set_bits+0xda>
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	set_bits_in_byte(&ptr[i], bitpos, val[i], 8);
    54ca:	f4 01       	movw	r30, r8
    54cc:	41 91       	ld	r20, Z+
    54ce:	4f 01       	movw	r8, r30
    54d0:	c8 01       	movw	r24, r16
    54d2:	8c 0f       	add	r24, r28
    54d4:	9d 1f       	adc	r25, r29
    54d6:	b5 01       	movw	r22, r10
    54d8:	28 e0       	ldi	r18, 0x08	; 8
    54da:	30 e0       	ldi	r19, 0x00	; 0
    54dc:	0e 94 0a 2a 	call	0x5414	; 0x5414 <set_bits_in_byte>
      bits = vallen & 7;
      if(bits) {
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits), bits);
      }
    } else {
      for(i = 0; i < vallen / 8; ++i) {
    54e0:	21 96       	adiw	r28, 0x01	; 1
    54e2:	c6 15       	cp	r28, r6
    54e4:	d7 05       	cpc	r29, r7
    54e6:	8c f3       	brlt	.-30     	; 0x54ca <set_bits+0x8e>
	/*      PRINTF("set_bits i %d val %d\n",
		i, val[i]);*/
	set_bits_in_byte(&ptr[i], bitpos, val[i], 8);
      }
      bits = vallen & 7;
    54e8:	97 01       	movw	r18, r14
    54ea:	27 70       	andi	r18, 0x07	; 7
    54ec:	30 70       	andi	r19, 0x00	; 0
      if(bits) {
    54ee:	21 15       	cp	r18, r1
    54f0:	31 05       	cpc	r19, r1
    54f2:	a9 f0       	breq	.+42     	; 0x551e <set_bits+0xe2>
	set_bits_in_byte(&ptr[i], 0, val[i] >> (8 - bits + bitpos), bits);
    54f4:	f6 01       	movw	r30, r12
    54f6:	ec 0f       	add	r30, r28
    54f8:	fd 1f       	adc	r31, r29
    54fa:	40 81       	ld	r20, Z
    54fc:	50 e0       	ldi	r21, 0x00	; 0
    54fe:	c5 01       	movw	r24, r10
    5500:	08 96       	adiw	r24, 0x08	; 8
    5502:	82 1b       	sub	r24, r18
    5504:	93 0b       	sbc	r25, r19
    5506:	02 c0       	rjmp	.+4      	; 0x550c <set_bits+0xd0>
    5508:	55 95       	asr	r21
    550a:	47 95       	ror	r20
    550c:	8a 95       	dec	r24
    550e:	e2 f7       	brpl	.-8      	; 0x5508 <set_bits+0xcc>
    5510:	c8 01       	movw	r24, r16
    5512:	8c 0f       	add	r24, r28
    5514:	9d 1f       	adc	r25, r29
    5516:	60 e0       	ldi	r22, 0x00	; 0
    5518:	70 e0       	ldi	r23, 0x00	; 0
    551a:	0e 94 0a 2a 	call	0x5414	; 0x5414 <set_bits_in_byte>
      }
    }
  }
}
    551e:	df 91       	pop	r29
    5520:	cf 91       	pop	r28
    5522:	1f 91       	pop	r17
    5524:	0f 91       	pop	r16
    5526:	ff 90       	pop	r15
    5528:	ef 90       	pop	r14
    552a:	df 90       	pop	r13
    552c:	cf 90       	pop	r12
    552e:	bf 90       	pop	r11
    5530:	af 90       	pop	r10
    5532:	9f 90       	pop	r9
    5534:	8f 90       	pop	r8
    5536:	7f 90       	pop	r7
    5538:	6f 90       	pop	r6
    553a:	08 95       	ret

0000553c <pack_header>:
}
#endif
/*---------------------------------------------------------------------------*/
static int
pack_header(struct channel *c)
{
    553c:	4f 92       	push	r4
    553e:	5f 92       	push	r5
    5540:	6f 92       	push	r6
    5542:	7f 92       	push	r7
    5544:	8f 92       	push	r8
    5546:	9f 92       	push	r9
    5548:	af 92       	push	r10
    554a:	bf 92       	push	r11
    554c:	cf 92       	push	r12
    554e:	df 92       	push	r13
    5550:	ef 92       	push	r14
    5552:	ff 92       	push	r15
    5554:	0f 93       	push	r16
    5556:	1f 93       	push	r17
    5558:	df 93       	push	r29
    555a:	cf 93       	push	r28
    555c:	00 d0       	rcall	.+0      	; 0x555e <pack_header+0x22>
    555e:	cd b7       	in	r28, 0x3d	; 61
    5560:	de b7       	in	r29, 0x3e	; 62
    5562:	8c 01       	movw	r16, r24
  struct bitopt_hdr *hdr;
  
  /* Compute the total size of the final header by summing the size of
     all attributes that are used on this channel. */

  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
    5564:	dc 01       	movw	r26, r24
    5566:	16 96       	adiw	r26, 0x06	; 6
    5568:	4c 91       	ld	r20, X
    556a:	16 97       	sbiw	r26, 0x06	; 6
    556c:	84 2f       	mov	r24, r20
    556e:	90 e0       	ldi	r25, 0x00	; 0
    5570:	87 70       	andi	r24, 0x07	; 7
    5572:	90 70       	andi	r25, 0x00	; 0
    5574:	21 e0       	ldi	r18, 0x01	; 1
    5576:	30 e0       	ldi	r19, 0x00	; 0
    5578:	00 97       	sbiw	r24, 0x00	; 0
    557a:	11 f4       	brne	.+4      	; 0x5580 <pack_header+0x44>
    557c:	20 e0       	ldi	r18, 0x00	; 0
    557e:	30 e0       	ldi	r19, 0x00	; 0
    5580:	46 95       	lsr	r20
    5582:	46 95       	lsr	r20
    5584:	46 95       	lsr	r20
    5586:	79 01       	movw	r14, r18
    5588:	e4 0e       	add	r14, r20
    558a:	f1 1c       	adc	r15, r1
  if(packetbuf_hdralloc(hdrbytesize + sizeof(struct bitopt_hdr)) == 0) {
    558c:	c7 01       	movw	r24, r14
    558e:	02 96       	adiw	r24, 0x02	; 2
    5590:	0e 94 71 31 	call	0x62e2	; 0x62e2 <packetbuf_hdralloc>
    5594:	00 97       	sbiw	r24, 0x00	; 0
    5596:	09 f4       	brne	.+2      	; 0x559a <pack_header+0x5e>
    5598:	53 c0       	rjmp	.+166    	; 0x5640 <pack_header+0x104>
    PRINTF("chameleon-bitopt: insufficient space for headers\n");
    return 0;
  }
  hdr = (struct bitopt_hdr *)packetbuf_hdrptr();
    559a:	0e 94 11 31 	call	0x6222	; 0x6222 <packetbuf_hdrptr>
    559e:	fc 01       	movw	r30, r24
  hdr->channel[0] = c->channelno & 0xff;
    55a0:	d8 01       	movw	r26, r16
    55a2:	12 96       	adiw	r26, 0x02	; 2
    55a4:	8c 91       	ld	r24, X
    55a6:	12 97       	sbiw	r26, 0x02	; 2
    55a8:	80 83       	st	Z, r24
  hdr->channel[1] = (c->channelno >> 8) & 0xff;
    55aa:	13 96       	adiw	r26, 0x03	; 3
    55ac:	8c 91       	ld	r24, X
    55ae:	81 83       	std	Z+1, r24	; 0x01

  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
    55b0:	0e 94 11 31 	call	0x6222	; 0x6222 <packetbuf_hdrptr>
    55b4:	f2 e0       	ldi	r31, 0x02	; 2
    55b6:	6f 2e       	mov	r6, r31
    55b8:	71 2c       	mov	r7, r1
    55ba:	68 0e       	add	r6, r24
    55bc:	79 1e       	adc	r7, r25
  memset(hdrptr, 0, hdrbytesize);
    55be:	c3 01       	movw	r24, r6
    55c0:	60 e0       	ldi	r22, 0x00	; 0
    55c2:	70 e0       	ldi	r23, 0x00	; 0
    55c4:	a7 01       	movw	r20, r14
    55c6:	0e 94 57 4b 	call	0x96ae	; 0x96ae <memset>
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    55ca:	f8 01       	movw	r30, r16
    55cc:	c4 80       	ldd	r12, Z+4	; 0x04
    55ce:	d5 80       	ldd	r13, Z+5	; 0x05
  hdr->channel[1] = (c->channelno >> 8) & 0xff;

  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
    55d0:	00 e0       	ldi	r16, 0x00	; 0
    55d2:	10 e0       	ldi	r17, 0x00	; 0
	    ((uint8_t *)packetbuf_addr(a->type))[0],
	    ((uint8_t *)packetbuf_addr(a->type))[1]);
    } else {
      packetbuf_attr_t val;
      val = packetbuf_attr(a->type);
      set_bits(&hdrptr[byteptr], bitptr & 7,
    55d4:	2e 01       	movw	r4, r28
    55d6:	08 94       	sec
    55d8:	41 1c       	adc	r4, r1
    55da:	51 1c       	adc	r5, r1
  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    55dc:	2a c0       	rjmp	.+84     	; 0x5632 <pack_header+0xf6>
#endif /* CHAMELEON_WITH_MAC_LINK_ADDRESSES */
    PRINTF("%d.%d: pack_header type %d, len %d, bitptr %d, ",
	   rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    55de:	d6 01       	movw	r26, r12
    55e0:	11 96       	adiw	r26, 0x01	; 1
    55e2:	8c 90       	ld	r8, X
    55e4:	11 97       	sbiw	r26, 0x01	; 1
    55e6:	99 24       	eor	r9, r9
    byteptr = bitptr / 8;
    55e8:	78 01       	movw	r14, r16
    55ea:	e3 e0       	ldi	r30, 0x03	; 3
    55ec:	f5 94       	asr	r15
    55ee:	e7 94       	ror	r14
    55f0:	ea 95       	dec	r30
    55f2:	e1 f7       	brne	.-8      	; 0x55ec <pack_header+0xb0>
    55f4:	e6 0c       	add	r14, r6
    55f6:	f7 1c       	adc	r15, r7
    55f8:	77 e0       	ldi	r23, 0x07	; 7
    55fa:	a7 2e       	mov	r10, r23
    55fc:	b1 2c       	mov	r11, r1
    55fe:	a0 22       	and	r10, r16
    5600:	b1 22       	and	r11, r17
    if(PACKETBUF_IS_ADDR(a->type)) {
    5602:	88 31       	cpi	r24, 0x18	; 24
    5604:	30 f0       	brcs	.+12     	; 0x5612 <pack_header+0xd6>
      set_bits(&hdrptr[byteptr], bitptr & 7,
	       (uint8_t *)packetbuf_addr(a->type), len);
    5606:	0e 94 50 32 	call	0x64a0	; 0x64a0 <packetbuf_addr>
    560a:	ac 01       	movw	r20, r24
	   a->type, a->len, bitptr);
    /*    len = (a->len & 0xf8) + ((a->len & 7) ? 8: 0);*/
    len = a->len;
    byteptr = bitptr / 8;
    if(PACKETBUF_IS_ADDR(a->type)) {
      set_bits(&hdrptr[byteptr], bitptr & 7,
    560c:	c7 01       	movw	r24, r14
    560e:	b5 01       	movw	r22, r10
    5610:	07 c0       	rjmp	.+14     	; 0x5620 <pack_header+0xe4>
	    /*	    rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],*/
	    ((uint8_t *)packetbuf_addr(a->type))[0],
	    ((uint8_t *)packetbuf_addr(a->type))[1]);
    } else {
      packetbuf_attr_t val;
      val = packetbuf_attr(a->type);
    5612:	0e 94 3d 32 	call	0x647a	; 0x647a <packetbuf_attr>
    5616:	9a 83       	std	Y+2, r25	; 0x02
    5618:	89 83       	std	Y+1, r24	; 0x01
      set_bits(&hdrptr[byteptr], bitptr & 7,
    561a:	c7 01       	movw	r24, r14
    561c:	b5 01       	movw	r22, r10
    561e:	a2 01       	movw	r20, r4
    5620:	94 01       	movw	r18, r8
    5622:	0e 94 1e 2a 	call	0x543c	; 0x543c <set_bits>
      PRINTF("value %d\n",
	    /*rimeaddr_node_addr.u8[0], rimeaddr_node_addr.u8[1],*/
	    val);
    }
    /*    printhdr(hdrptr, hdrbytesize);*/
    bitptr += len;
    5626:	08 0d       	add	r16, r8
    5628:	19 1d       	adc	r17, r9
  hdrptr = ((uint8_t *)packetbuf_hdrptr()) + sizeof(struct bitopt_hdr);
  memset(hdrptr, 0, hdrbytesize);
  
  byteptr = bitptr = 0;
  
  for(a = c->attrlist; a->type != PACKETBUF_ATTR_NONE; ++a) {
    562a:	e2 e0       	ldi	r30, 0x02	; 2
    562c:	f0 e0       	ldi	r31, 0x00	; 0
    562e:	ce 0e       	add	r12, r30
    5630:	df 1e       	adc	r13, r31
    5632:	d6 01       	movw	r26, r12
    5634:	8c 91       	ld	r24, X
    5636:	88 23       	and	r24, r24
    5638:	91 f6       	brne	.-92     	; 0x55de <pack_header+0xa2>
    /*    printhdr(hdrptr, hdrbytesize);*/
    bitptr += len;
  }
  /*  printhdr(hdrptr, hdrbytesize);*/

  return 1; /* Send out packet */
    563a:	21 e0       	ldi	r18, 0x01	; 1
    563c:	30 e0       	ldi	r19, 0x00	; 0
    563e:	02 c0       	rjmp	.+4      	; 0x5644 <pack_header+0x108>
     all attributes that are used on this channel. */

  hdrbytesize = c->hdrsize / 8 + ((c->hdrsize & 7) == 0? 0: 1);
  if(packetbuf_hdralloc(hdrbytesize + sizeof(struct bitopt_hdr)) == 0) {
    PRINTF("chameleon-bitopt: insufficient space for headers\n");
    return 0;
    5640:	20 e0       	ldi	r18, 0x00	; 0
    5642:	30 e0       	ldi	r19, 0x00	; 0
    bitptr += len;
  }
  /*  printhdr(hdrptr, hdrbytesize);*/

  return 1; /* Send out packet */
}
    5644:	c9 01       	movw	r24, r18
    5646:	0f 90       	pop	r0
    5648:	0f 90       	pop	r0
    564a:	cf 91       	pop	r28
    564c:	df 91       	pop	r29
    564e:	1f 91       	pop	r17
    5650:	0f 91       	pop	r16
    5652:	ff 90       	pop	r15
    5654:	ef 90       	pop	r14
    5656:	df 90       	pop	r13
    5658:	cf 90       	pop	r12
    565a:	bf 90       	pop	r11
    565c:	af 90       	pop	r10
    565e:	9f 90       	pop	r9
    5660:	8f 90       	pop	r8
    5662:	7f 90       	pop	r7
    5664:	6f 90       	pop	r6
    5666:	5f 90       	pop	r5
    5668:	4f 90       	pop	r4
    566a:	08 95       	ret

0000566c <send_packet>:

/*---------------------------------------------------------------------------*/
static void
send_packet(mac_callback_t sent, void *ptr)
{
  NETSTACK_RDC.send(sent, ptr);
    566c:	e0 91 35 0e 	lds	r30, 0x0E35
    5670:	f0 91 36 0e 	lds	r31, 0x0E36
    5674:	09 95       	icall
}
    5676:	08 95       	ret

00005678 <packet_input>:
/*---------------------------------------------------------------------------*/
static void
packet_input(void)
{
  NETSTACK_NETWORK.input();
    5678:	e0 91 f1 0d 	lds	r30, 0x0DF1
    567c:	f0 91 f2 0d 	lds	r31, 0x0DF2
    5680:	09 95       	icall
}
    5682:	08 95       	ret

00005684 <on>:
/*---------------------------------------------------------------------------*/
static int
on(void)
{
  return NETSTACK_RDC.on();
    5684:	e0 91 3b 0e 	lds	r30, 0x0E3B
    5688:	f0 91 3c 0e 	lds	r31, 0x0E3C
    568c:	09 95       	icall
}
    568e:	08 95       	ret

00005690 <off>:
/*---------------------------------------------------------------------------*/
static int
off(int keep_radio_on)
{
  return NETSTACK_RDC.off(keep_radio_on);
    5690:	e0 91 3d 0e 	lds	r30, 0x0E3D
    5694:	f0 91 3e 0e 	lds	r31, 0x0E3E
    5698:	09 95       	icall
}
    569a:	08 95       	ret

0000569c <channel_check_interval>:
/*---------------------------------------------------------------------------*/
static unsigned short
channel_check_interval(void)
{
  return 0;
}
    569c:	80 e0       	ldi	r24, 0x00	; 0
    569e:	90 e0       	ldi	r25, 0x00	; 0
    56a0:	08 95       	ret

000056a2 <init>:
/*---------------------------------------------------------------------------*/
static void
init(void)
{
}
    56a2:	08 95       	ret

000056a4 <on>:
}
/*---------------------------------------------------------------------------*/
static int
on(void)
{
  return NETSTACK_RADIO.on();
    56a4:	e0 91 d1 0d 	lds	r30, 0x0DD1
    56a8:	f0 91 d2 0d 	lds	r31, 0x0DD2
    56ac:	09 95       	icall
}
    56ae:	08 95       	ret

000056b0 <off>:
/*---------------------------------------------------------------------------*/
static int
off(int keep_radio_on)
{
  if(keep_radio_on) {
    56b0:	00 97       	sbiw	r24, 0x00	; 0
    56b2:	31 f0       	breq	.+12     	; 0x56c0 <off+0x10>
    return NETSTACK_RADIO.on();
    56b4:	e0 91 d1 0d 	lds	r30, 0x0DD1
    56b8:	f0 91 d2 0d 	lds	r31, 0x0DD2
    56bc:	09 95       	icall
    56be:	08 95       	ret
  } else {
    return NETSTACK_RADIO.off();
    56c0:	e0 91 d3 0d 	lds	r30, 0x0DD3
    56c4:	f0 91 d4 0d 	lds	r31, 0x0DD4
    56c8:	09 95       	icall
  }
}
    56ca:	08 95       	ret

000056cc <channel_check_interval>:
/*---------------------------------------------------------------------------*/
static unsigned short
channel_check_interval(void)
{
  return 0;
}
    56cc:	80 e0       	ldi	r24, 0x00	; 0
    56ce:	90 e0       	ldi	r25, 0x00	; 0
    56d0:	08 95       	ret

000056d2 <input_packet>:
  }
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
{
    56d2:	0f 93       	push	r16
    56d4:	1f 93       	push	r17
    56d6:	df 93       	push	r29
    56d8:	cf 93       	push	r28
    56da:	cd b7       	in	r28, 0x3d	; 61
    56dc:	de b7       	in	r29, 0x3e	; 62
    56de:	e0 97       	sbiw	r28, 0x30	; 48
    56e0:	0f b6       	in	r0, 0x3f	; 63
    56e2:	f8 94       	cli
    56e4:	de bf       	out	0x3e, r29	; 62
    56e6:	0f be       	out	0x3f, r0	; 63
    56e8:	cd bf       	out	0x3d, r28	; 61
  frame802154_t frame;
  int len;

  len = packetbuf_datalen();
    56ea:	0e 94 5b 31 	call	0x62b6	; 0x62b6 <packetbuf_datalen>
    56ee:	8c 01       	movw	r16, r24

  if(frame802154_parse(packetbuf_dataptr(), len, &frame) &&
    56f0:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    56f4:	60 2f       	mov	r22, r16
    56f6:	ae 01       	movw	r20, r28
    56f8:	4f 5f       	subi	r20, 0xFF	; 255
    56fa:	5f 4f       	sbci	r21, 0xFF	; 255
    56fc:	0e 94 f1 38 	call	0x71e2	; 0x71e2 <frame802154_parse>
    5700:	88 23       	and	r24, r24
    5702:	09 f4       	brne	.+2      	; 0x5706 <input_packet+0x34>
    5704:	45 c0       	rjmp	.+138    	; 0x5790 <input_packet+0xbe>
     packetbuf_hdrreduce(len - frame.payload_len)) {
    5706:	88 a9       	ldd	r24, Y+48	; 0x30
    5708:	98 01       	movw	r18, r16
    570a:	28 1b       	sub	r18, r24
    570c:	31 09       	sbc	r19, r1
    570e:	c9 01       	movw	r24, r18
    5710:	0e 94 e5 30 	call	0x61ca	; 0x61ca <packetbuf_hdrreduce>
  frame802154_t frame;
  int len;

  len = packetbuf_datalen();

  if(frame802154_parse(packetbuf_dataptr(), len, &frame) &&
    5714:	00 97       	sbiw	r24, 0x00	; 0
    5716:	e1 f1       	breq	.+120    	; 0x5790 <input_packet+0xbe>
     packetbuf_hdrreduce(len - frame.payload_len)) {
    if(frame.fcf.dest_addr_mode) {
    5718:	2e 81       	ldd	r18, Y+6	; 0x06
    571a:	22 23       	and	r18, r18
    571c:	71 f1       	breq	.+92     	; 0x577a <input_packet+0xa8>
      if(frame.dest_pid != mac_src_pan_id &&
    571e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5720:	9b 85       	ldd	r25, Y+11	; 0x0b
    5722:	3b ea       	ldi	r19, 0xAB	; 171
    5724:	8d 3c       	cpi	r24, 0xCD	; 205
    5726:	93 07       	cpc	r25, r19
    5728:	21 f0       	breq	.+8      	; 0x5732 <input_packet+0x60>
    572a:	3f ef       	ldi	r19, 0xFF	; 255
    572c:	8f 3f       	cpi	r24, 0xFF	; 255
    572e:	93 07       	cpc	r25, r19
    5730:	79 f5       	brne	.+94     	; 0x5790 <input_packet+0xbe>

/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
    5732:	22 30       	cpi	r18, 0x02	; 2
    5734:	41 f0       	breq	.+16     	; 0x5746 <input_packet+0x74>
    5736:	88 e0       	ldi	r24, 0x08	; 8
    5738:	90 e0       	ldi	r25, 0x00	; 0
    573a:	07 c0       	rjmp	.+14     	; 0x574a <input_packet+0x78>
  while(i-- > 0) {
    573c:	01 97       	sbiw	r24, 0x01	; 1
    if(addr[i] != 0xff) {
    573e:	22 91       	ld	r18, -Z
    5740:	2f 3f       	cpi	r18, 0xFF	; 255
    5742:	41 f0       	breq	.+16     	; 0x5754 <input_packet+0x82>
    5744:	0b c0       	rjmp	.+22     	; 0x575c <input_packet+0x8a>

/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
    5746:	82 e0       	ldi	r24, 0x02	; 2
    5748:	90 e0       	ldi	r25, 0x00	; 0
    send_packet(sent, ptr);
  }
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
    574a:	fe 01       	movw	r30, r28
    574c:	e8 0f       	add	r30, r24
    574e:	f9 1f       	adc	r31, r25
    5750:	3c 96       	adiw	r30, 0x0c	; 12
    5752:	f4 cf       	rjmp	.-24     	; 0x573c <input_packet+0x6a>
/*---------------------------------------------------------------------------*/
static int
is_broadcast_addr(uint8_t mode, uint8_t *addr)
{
  int i = mode == FRAME802154_SHORTADDRMODE ? 2 : 8;
  while(i-- > 0) {
    5754:	18 16       	cp	r1, r24
    5756:	19 06       	cpc	r1, r25
    5758:	8c f3       	brlt	.-30     	; 0x573c <input_packet+0x6a>
    575a:	0f c0       	rjmp	.+30     	; 0x577a <input_packet+0xa8>
        /* Not broadcast or for our PAN */
        PRINTF("6MAC: for another pan %u\n", frame.dest_pid);
        return;
      }
      if(!is_broadcast_addr(frame.fcf.dest_addr_mode, frame.dest_addr)) {
        packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, (rimeaddr_t *)&frame.dest_addr);
    575c:	89 e1       	ldi	r24, 0x19	; 25
    575e:	be 01       	movw	r22, r28
    5760:	64 5f       	subi	r22, 0xF4	; 244
    5762:	7f 4f       	sbci	r23, 0xFF	; 255
    5764:	0e 94 46 32 	call	0x648c	; 0x648c <packetbuf_set_addr>
        if(!rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
    5768:	89 e1       	ldi	r24, 0x19	; 25
    576a:	0e 94 50 32 	call	0x64a0	; 0x64a0 <packetbuf_addr>
    576e:	64 ec       	ldi	r22, 0xC4	; 196
    5770:	7f e2       	ldi	r23, 0x2F	; 47
    5772:	0e 94 19 25 	call	0x4a32	; 0x4a32 <rimeaddr_cmp>
    5776:	00 97       	sbiw	r24, 0x00	; 0
    5778:	59 f0       	breq	.+22     	; 0x5790 <input_packet+0xbe>
          PRINTF("6MAC: not for us\n");
          return;
        }
      }
    }
    packetbuf_set_addr(PACKETBUF_ADDR_SENDER, (rimeaddr_t *)&frame.src_addr);
    577a:	88 e1       	ldi	r24, 0x18	; 24
    577c:	be 01       	movw	r22, r28
    577e:	6a 5e       	subi	r22, 0xEA	; 234
    5780:	7f 4f       	sbci	r23, 0xFF	; 255
    5782:	0e 94 46 32 	call	0x648c	; 0x648c <packetbuf_set_addr>

    PRINTF("6MAC-IN: %2X", frame.fcf.frame_type);
    PRINTADDR(packetbuf_addr(PACKETBUF_ADDR_SENDER));
    PRINTADDR(packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    PRINTF("%u\n", packetbuf_datalen());
    NETSTACK_MAC.input();
    5786:	e0 91 1e 0e 	lds	r30, 0x0E1E
    578a:	f0 91 1f 0e 	lds	r31, 0x0E1F
    578e:	09 95       	icall
  } else {
    PRINTF("6MAC: failed to parse hdr\n");
  }
}
    5790:	e0 96       	adiw	r28, 0x30	; 48
    5792:	0f b6       	in	r0, 0x3f	; 63
    5794:	f8 94       	cli
    5796:	de bf       	out	0x3e, r29	; 62
    5798:	0f be       	out	0x3f, r0	; 63
    579a:	cd bf       	out	0x3d, r28	; 61
    579c:	cf 91       	pop	r28
    579e:	df 91       	pop	r29
    57a0:	1f 91       	pop	r17
    57a2:	0f 91       	pop	r16
    57a4:	08 95       	ret

000057a6 <send_packet>:
  return 1;
}
/*---------------------------------------------------------------------------*/
static void
send_packet(mac_callback_t sent, void *ptr)
{
    57a6:	af 92       	push	r10
    57a8:	bf 92       	push	r11
    57aa:	cf 92       	push	r12
    57ac:	df 92       	push	r13
    57ae:	ef 92       	push	r14
    57b0:	ff 92       	push	r15
    57b2:	0f 93       	push	r16
    57b4:	1f 93       	push	r17
    57b6:	df 93       	push	r29
    57b8:	cf 93       	push	r28
    57ba:	cd b7       	in	r28, 0x3d	; 61
    57bc:	de b7       	in	r29, 0x3e	; 62
    57be:	e0 97       	sbiw	r28, 0x30	; 48
    57c0:	0f b6       	in	r0, 0x3f	; 63
    57c2:	f8 94       	cli
    57c4:	de bf       	out	0x3e, r29	; 62
    57c6:	0f be       	out	0x3f, r0	; 63
    57c8:	cd bf       	out	0x3d, r28	; 61
    57ca:	6c 01       	movw	r12, r24
    57cc:	8b 01       	movw	r16, r22
  frame802154_t params;
  uint8_t len;

  /* init to zeros */
  memset(&params, 0, sizeof(params));
    57ce:	fe 01       	movw	r30, r28
    57d0:	31 96       	adiw	r30, 0x01	; 1
    57d2:	80 e3       	ldi	r24, 0x30	; 48
    57d4:	df 01       	movw	r26, r30
    57d6:	1d 92       	st	X+, r1
    57d8:	8a 95       	dec	r24
    57da:	e9 f7       	brne	.-6      	; 0x57d6 <send_packet+0x30>

  /* Build the FCF. */
  params.fcf.frame_type = FRAME802154_DATAFRAME;
    57dc:	81 e0       	ldi	r24, 0x01	; 1
    57de:	89 83       	std	Y+1, r24	; 0x01
  params.fcf.security_enabled = 0;
  params.fcf.frame_pending = 0;
  params.fcf.ack_required = packetbuf_attr(PACKETBUF_ATTR_RELIABLE);
    57e0:	8c e0       	ldi	r24, 0x0C	; 12
    57e2:	0e 94 3d 32 	call	0x647a	; 0x647a <packetbuf_attr>
    57e6:	8c 83       	std	Y+4, r24	; 0x04
  params.fcf.panid_compression = 0;
    57e8:	1d 82       	std	Y+5, r1	; 0x05

  /* Insert IEEE 802.15.4 (2003) version bit. */
  params.fcf.frame_version = FRAME802154_IEEE802154_2003;
    57ea:	1f 82       	std	Y+7, r1	; 0x07

  /* Increment and set the data sequence number. */
  params.seq = mac_dsn++;
    57ec:	80 91 c4 26 	lds	r24, 0x26C4
    57f0:	89 87       	std	Y+9, r24	; 0x09
    57f2:	8f 5f       	subi	r24, 0xFF	; 255
    57f4:	80 93 c4 26 	sts	0x26C4, r24
  /* Complete the addressing fields. */
  /**
     \todo For phase 1 the addresses are all long. We'll need a mechanism
     in the rime attributes to tell the mac to use long or short for phase 2.
  */
  params.fcf.src_addr_mode = FRAME802154_LONGADDRMODE;
    57f8:	83 e0       	ldi	r24, 0x03	; 3
    57fa:	e8 2e       	mov	r14, r24
    57fc:	e8 86       	std	Y+8, r14	; 0x08
  params.dest_pid = mac_dst_pan_id;
    57fe:	8d ec       	ldi	r24, 0xCD	; 205
    5800:	9b ea       	ldi	r25, 0xAB	; 171
    5802:	9b 87       	std	Y+11, r25	; 0x0b
    5804:	8a 87       	std	Y+10, r24	; 0x0a

  /*
   *  If the output address is NULL in the Rime buf, then it is broadcast
   *  on the 802.15.4 network.
   */
  if(rimeaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER), &rimeaddr_null)) {
    5806:	89 e1       	ldi	r24, 0x19	; 25
    5808:	0e 94 50 32 	call	0x64a0	; 0x64a0 <packetbuf_addr>
    580c:	66 ee       	ldi	r22, 0xE6	; 230
    580e:	7d e0       	ldi	r23, 0x0D	; 13
    5810:	0e 94 19 25 	call	0x4a32	; 0x4a32 <rimeaddr_cmp>
    5814:	00 97       	sbiw	r24, 0x00	; 0
    5816:	31 f0       	breq	.+12     	; 0x5824 <send_packet+0x7e>
    /* Broadcast requires short address mode. */
    params.fcf.dest_addr_mode = FRAME802154_SHORTADDRMODE;
    5818:	82 e0       	ldi	r24, 0x02	; 2
    581a:	8e 83       	std	Y+6, r24	; 0x06
    params.dest_addr[0] = 0xFF;
    581c:	8f ef       	ldi	r24, 0xFF	; 255
    581e:	8c 87       	std	Y+12, r24	; 0x0c
    params.dest_addr[1] = 0xFF;
    5820:	8d 87       	std	Y+13, r24	; 0x0d
    5822:	09 c0       	rjmp	.+18     	; 0x5836 <send_packet+0x90>

  } else {
    rimeaddr_copy((rimeaddr_t *)&params.dest_addr,
    5824:	89 e1       	ldi	r24, 0x19	; 25
    5826:	0e 94 50 32 	call	0x64a0	; 0x64a0 <packetbuf_addr>
    582a:	bc 01       	movw	r22, r24
    582c:	ce 01       	movw	r24, r28
    582e:	0c 96       	adiw	r24, 0x0c	; 12
    5830:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
                  packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
    params.fcf.dest_addr_mode = FRAME802154_LONGADDRMODE;
    5834:	ee 82       	std	Y+6, r14	; 0x06
  }

  /* Set the source PAN ID to the global variable. */
  params.src_pid = mac_src_pan_id;
    5836:	8d ec       	ldi	r24, 0xCD	; 205
    5838:	9b ea       	ldi	r25, 0xAB	; 171
    583a:	9d 8b       	std	Y+21, r25	; 0x15
    583c:	8c 8b       	std	Y+20, r24	; 0x14

  /*
   * Set up the source address using only the long address mode for
   * phase 1.
   */
  rimeaddr_copy((rimeaddr_t *)&params.src_addr, &rimeaddr_node_addr);
    583e:	ce 01       	movw	r24, r28
    5840:	46 96       	adiw	r24, 0x16	; 22
    5842:	64 ec       	ldi	r22, 0xC4	; 196
    5844:	7f e2       	ldi	r23, 0x2F	; 47
    5846:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>

  params.payload = packetbuf_dataptr();
    584a:	0e 94 09 31 	call	0x6212	; 0x6212 <packetbuf_dataptr>
    584e:	9f a7       	std	Y+47, r25	; 0x2f
    5850:	8e a7       	std	Y+46, r24	; 0x2e
  params.payload_len = packetbuf_datalen();
    5852:	0e 94 5b 31 	call	0x62b6	; 0x62b6 <packetbuf_datalen>
    5856:	88 ab       	std	Y+48, r24	; 0x30
  len = frame802154_hdrlen(&params);
    5858:	7e 01       	movw	r14, r28
    585a:	08 94       	sec
    585c:	e1 1c       	adc	r14, r1
    585e:	f1 1c       	adc	r15, r1
    5860:	c7 01       	movw	r24, r14
    5862:	0e 94 e8 37 	call	0x6fd0	; 0x6fd0 <frame802154_hdrlen>
    5866:	a8 2e       	mov	r10, r24
  if(packetbuf_hdralloc(len)) {
    5868:	90 e0       	ldi	r25, 0x00	; 0
    586a:	0e 94 71 31 	call	0x62e2	; 0x62e2 <packetbuf_hdralloc>
    586e:	00 97       	sbiw	r24, 0x00	; 0
    5870:	41 f1       	breq	.+80     	; 0x58c2 <send_packet+0x11c>
    int ret;
    frame802154_create(&params, packetbuf_hdrptr(), len);
    5872:	0e 94 11 31 	call	0x6222	; 0x6222 <packetbuf_hdrptr>
    5876:	bc 01       	movw	r22, r24
    5878:	c7 01       	movw	r24, r14
    587a:	4a 2d       	mov	r20, r10
    587c:	0e 94 06 38 	call	0x700c	; 0x700c <frame802154_create>

    PRINTF("6MAC-UT: %2X", params.fcf.frame_type);
    PRINTADDR(params.dest_addr.u8);
    PRINTF("%u %u (%u)\n", len, packetbuf_datalen(), packetbuf_totlen());

    ret = NETSTACK_RADIO.send(packetbuf_hdrptr(), packetbuf_totlen());
    5880:	a0 90 c7 0d 	lds	r10, 0x0DC7
    5884:	b0 90 c8 0d 	lds	r11, 0x0DC8
    5888:	0e 94 11 31 	call	0x6222	; 0x6222 <packetbuf_hdrptr>
    588c:	7c 01       	movw	r14, r24
    588e:	0e 94 65 31 	call	0x62ca	; 0x62ca <packetbuf_totlen>
    5892:	bc 01       	movw	r22, r24
    5894:	c7 01       	movw	r24, r14
    5896:	f5 01       	movw	r30, r10
    5898:	09 95       	icall
    if(sent) {
    589a:	c1 14       	cp	r12, r1
    589c:	d1 04       	cpc	r13, r1
    589e:	89 f0       	breq	.+34     	; 0x58c2 <send_packet+0x11c>
      switch(ret) {
    58a0:	00 97       	sbiw	r24, 0x00	; 0
    58a2:	21 f0       	breq	.+8      	; 0x58ac <send_packet+0x106>
    58a4:	81 30       	cpi	r24, 0x01	; 1
    58a6:	91 05       	cpc	r25, r1
    58a8:	61 f4       	brne	.+24     	; 0x58c2 <send_packet+0x11c>
    58aa:	04 c0       	rjmp	.+8      	; 0x58b4 <send_packet+0x10e>
      case RADIO_TX_OK:
        sent(ptr, MAC_TX_OK, 1);
    58ac:	c8 01       	movw	r24, r16
    58ae:	60 e0       	ldi	r22, 0x00	; 0
    58b0:	70 e0       	ldi	r23, 0x00	; 0
    58b2:	03 c0       	rjmp	.+6      	; 0x58ba <send_packet+0x114>
        break;
      case RADIO_TX_ERR:
        sent(ptr, MAC_TX_ERR, 1);
    58b4:	c8 01       	movw	r24, r16
    58b6:	64 e0       	ldi	r22, 0x04	; 4
    58b8:	70 e0       	ldi	r23, 0x00	; 0
    58ba:	41 e0       	ldi	r20, 0x01	; 1
    58bc:	50 e0       	ldi	r21, 0x00	; 0
    58be:	f6 01       	movw	r30, r12
    58c0:	09 95       	icall
      }
    }
  } else {
    PRINTF("6MAC-UT: too large header: %u\n", len);
  }
}
    58c2:	e0 96       	adiw	r28, 0x30	; 48
    58c4:	0f b6       	in	r0, 0x3f	; 63
    58c6:	f8 94       	cli
    58c8:	de bf       	out	0x3e, r29	; 62
    58ca:	0f be       	out	0x3f, r0	; 63
    58cc:	cd bf       	out	0x3d, r28	; 61
    58ce:	cf 91       	pop	r28
    58d0:	df 91       	pop	r29
    58d2:	1f 91       	pop	r17
    58d4:	0f 91       	pop	r16
    58d6:	ff 90       	pop	r15
    58d8:	ef 90       	pop	r14
    58da:	df 90       	pop	r13
    58dc:	cf 90       	pop	r12
    58de:	bf 90       	pop	r11
    58e0:	af 90       	pop	r10
    58e2:	08 95       	ret

000058e4 <init>:
}
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  mac_dsn = random_rand() % 256;
    58e4:	0e 94 7d 30 	call	0x60fa	; 0x60fa <random_rand>
    58e8:	80 93 c4 26 	sts	0x26C4, r24

  NETSTACK_RADIO.on();
    58ec:	e0 91 d1 0d 	lds	r30, 0x0DD1
    58f0:	f0 91 d2 0d 	lds	r31, 0x0DD2
    58f4:	09 95       	icall
}
    58f6:	08 95       	ret

000058f8 <send_list>:
  }
}
/*---------------------------------------------------------------------------*/
void
send_list(mac_callback_t sent, void *ptr, struct rdc_buf_list *buf_list)
{
    58f8:	0f 93       	push	r16
    58fa:	1f 93       	push	r17
    58fc:	cf 93       	push	r28
    58fe:	df 93       	push	r29
    5900:	8c 01       	movw	r16, r24
    5902:	eb 01       	movw	r28, r22
  if(buf_list != NULL) {
    5904:	41 15       	cp	r20, r1
    5906:	51 05       	cpc	r21, r1
    5908:	49 f0       	breq	.+18     	; 0x591c <send_list+0x24>
    queuebuf_to_packetbuf(buf_list->buf);
    590a:	fa 01       	movw	r30, r20
    590c:	82 81       	ldd	r24, Z+2	; 0x02
    590e:	93 81       	ldd	r25, Z+3	; 0x03
    5910:	0e 94 e1 32 	call	0x65c2	; 0x65c2 <queuebuf_to_packetbuf>
    send_packet(sent, ptr);
    5914:	c8 01       	movw	r24, r16
    5916:	be 01       	movw	r22, r28
    5918:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <send_packet>
  }
}
    591c:	df 91       	pop	r29
    591e:	cf 91       	pop	r28
    5920:	1f 91       	pop	r17
    5922:	0f 91       	pop	r16
    5924:	08 95       	ret

00005926 <autostart_start>:
#endif

/*---------------------------------------------------------------------------*/
void
autostart_start(struct process * const processes[])
{
    5926:	ef 92       	push	r14
    5928:	ff 92       	push	r15
    592a:	cf 93       	push	r28
    592c:	df 93       	push	r29
    592e:	e8 2e       	mov	r14, r24
    5930:	e7 01       	movw	r28, r14
    5932:	7e 01       	movw	r14, r28
    5934:	f9 2e       	mov	r15, r25
    5936:	e7 01       	movw	r28, r14
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5938:	04 c0       	rjmp	.+8      	; 0x5942 <autostart_start+0x1c>
    process_start(processes[i], NULL);
    593a:	60 e0       	ldi	r22, 0x00	; 0
    593c:	70 e0       	ldi	r23, 0x00	; 0
    593e:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <process_start>
void
autostart_start(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5942:	89 91       	ld	r24, Y+
    5944:	99 91       	ld	r25, Y+
    5946:	00 97       	sbiw	r24, 0x00	; 0
    5948:	c1 f7       	brne	.-16     	; 0x593a <autostart_start+0x14>
    process_start(processes[i], NULL);
    PRINTF("autostart_start: starting process '%s'\n", processes[i]->name);
  }
}
    594a:	df 91       	pop	r29
    594c:	cf 91       	pop	r28
    594e:	ff 90       	pop	r15
    5950:	ef 90       	pop	r14
    5952:	08 95       	ret

00005954 <autostart_exit>:
/*---------------------------------------------------------------------------*/
void
autostart_exit(struct process * const processes[])
{
    5954:	ef 92       	push	r14
    5956:	ff 92       	push	r15
    5958:	cf 93       	push	r28
    595a:	df 93       	push	r29
    595c:	e8 2e       	mov	r14, r24
    595e:	e7 01       	movw	r28, r14
    5960:	7e 01       	movw	r14, r28
    5962:	f9 2e       	mov	r15, r25
    5964:	e7 01       	movw	r28, r14
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    5966:	02 c0       	rjmp	.+4      	; 0x596c <autostart_exit+0x18>
    process_exit(processes[i]);
    5968:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <process_exit>
void
autostart_exit(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
    596c:	89 91       	ld	r24, Y+
    596e:	99 91       	ld	r25, Y+
    5970:	00 97       	sbiw	r24, 0x00	; 0
    5972:	d1 f7       	brne	.-12     	; 0x5968 <autostart_exit+0x14>
    process_exit(processes[i]);
    PRINTF("autostart_exit: stopping process '%s'\n", processes[i]->name);
  }
}
    5974:	df 91       	pop	r29
    5976:	cf 91       	pop	r28
    5978:	ff 90       	pop	r15
    597a:	ef 90       	pop	r14
    597c:	08 95       	ret

0000597e <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    597e:	cf 93       	push	r28
    5980:	df 93       	push	r29
    5982:	ec 01       	movw	r28, r24
  t->interval = interval;
    5984:	7b 83       	std	Y+3, r23	; 0x03
    5986:	6a 83       	std	Y+2, r22	; 0x02
  t->start = clock_time();
    5988:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    598c:	99 83       	std	Y+1, r25	; 0x01
    598e:	88 83       	st	Y, r24
}
    5990:	df 91       	pop	r29
    5992:	cf 91       	pop	r28
    5994:	08 95       	ret

00005996 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    5996:	fc 01       	movw	r30, r24
  t->start += t->interval;
    5998:	80 81       	ld	r24, Z
    599a:	91 81       	ldd	r25, Z+1	; 0x01
    599c:	22 81       	ldd	r18, Z+2	; 0x02
    599e:	33 81       	ldd	r19, Z+3	; 0x03
    59a0:	82 0f       	add	r24, r18
    59a2:	93 1f       	adc	r25, r19
    59a4:	91 83       	std	Z+1, r25	; 0x01
    59a6:	80 83       	st	Z, r24
}
    59a8:	08 95       	ret

000059aa <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    59aa:	cf 93       	push	r28
    59ac:	df 93       	push	r29
    59ae:	ec 01       	movw	r28, r24
  t->start = clock_time();
    59b0:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    59b4:	99 83       	std	Y+1, r25	; 0x01
    59b6:	88 83       	st	Y, r24
}
    59b8:	df 91       	pop	r29
    59ba:	cf 91       	pop	r28
    59bc:	08 95       	ret

000059be <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    59be:	cf 93       	push	r28
    59c0:	df 93       	push	r29
    59c2:	ec 01       	movw	r28, r24
  /* Note: Can not return diff >= t->interval so we add 1 to diff and return
     t->interval < diff - required to avoid an internal error in mspgcc. */
  clock_time_t diff = (clock_time() - t->start) + 1;
    59c4:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    59c8:	28 81       	ld	r18, Y
    59ca:	39 81       	ldd	r19, Y+1	; 0x01
    59cc:	82 1b       	sub	r24, r18
    59ce:	93 0b       	sbc	r25, r19
    59d0:	01 96       	adiw	r24, 0x01	; 1
  return t->interval < diff;
    59d2:	21 e0       	ldi	r18, 0x01	; 1
    59d4:	30 e0       	ldi	r19, 0x00	; 0
    59d6:	4a 81       	ldd	r20, Y+2	; 0x02
    59d8:	5b 81       	ldd	r21, Y+3	; 0x03
    59da:	48 17       	cp	r20, r24
    59dc:	59 07       	cpc	r21, r25
    59de:	10 f0       	brcs	.+4      	; 0x59e4 <timer_expired+0x26>
    59e0:	20 e0       	ldi	r18, 0x00	; 0
    59e2:	30 e0       	ldi	r19, 0x00	; 0

}
    59e4:	c9 01       	movw	r24, r18
    59e6:	df 91       	pop	r29
    59e8:	cf 91       	pop	r28
    59ea:	08 95       	ret

000059ec <timer_remaining>:
 * \return The time until the timer expires
 *
 */
clock_time_t
timer_remaining(struct timer *t)
{
    59ec:	ef 92       	push	r14
    59ee:	ff 92       	push	r15
    59f0:	cf 93       	push	r28
    59f2:	df 93       	push	r29
    59f4:	fc 01       	movw	r30, r24
  return t->start + t->interval - clock_time();
    59f6:	c2 81       	ldd	r28, Z+2	; 0x02
    59f8:	d3 81       	ldd	r29, Z+3	; 0x03
    59fa:	80 81       	ld	r24, Z
    59fc:	91 81       	ldd	r25, Z+1	; 0x01
    59fe:	c8 0f       	add	r28, r24
    5a00:	d9 1f       	adc	r29, r25
    5a02:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <clock_time>
    5a06:	c8 1b       	sub	r28, r24
    5a08:	d9 0b       	sbc	r29, r25
}
    5a0a:	ce 01       	movw	r24, r28
    5a0c:	df 91       	pop	r29
    5a0e:	cf 91       	pop	r28
    5a10:	ff 90       	pop	r15
    5a12:	ef 90       	pop	r14
    5a14:	08 95       	ret

00005a16 <list_init>:
 * \param list The list to be initialized.
 */
void
list_init(list_t list)
{
  *list = NULL;
    5a16:	fc 01       	movw	r30, r24
    5a18:	11 82       	std	Z+1, r1	; 0x01
    5a1a:	10 82       	st	Z, r1
}
    5a1c:	08 95       	ret

00005a1e <list_head>:
 *
 * \sa list_tail()
 */
void *
list_head(list_t list)
{
    5a1e:	fc 01       	movw	r30, r24
  return *list;
}
    5a20:	80 81       	ld	r24, Z
    5a22:	91 81       	ldd	r25, Z+1	; 0x01
    5a24:	08 95       	ret

00005a26 <list_copy>:
 * \param src The source list.
 */
void
list_copy(list_t dest, list_t src)
{
  *dest = *src;
    5a26:	fb 01       	movw	r30, r22
    5a28:	20 81       	ld	r18, Z
    5a2a:	31 81       	ldd	r19, Z+1	; 0x01
    5a2c:	fc 01       	movw	r30, r24
    5a2e:	31 83       	std	Z+1, r19	; 0x01
    5a30:	20 83       	st	Z, r18
}
    5a32:	08 95       	ret

00005a34 <list_tail>:
void *
list_tail(list_t list)
{
  struct list *l;
  
  if(*list == NULL) {
    5a34:	fc 01       	movw	r30, r24
    5a36:	20 81       	ld	r18, Z
    5a38:	31 81       	ldd	r19, Z+1	; 0x01
    5a3a:	21 15       	cp	r18, r1
    5a3c:	31 05       	cpc	r19, r1
    5a3e:	11 f4       	brne	.+4      	; 0x5a44 <list_tail+0x10>
    5a40:	07 c0       	rjmp	.+14     	; 0x5a50 <list_tail+0x1c>
    return NULL;
  }
  
  for(l = *list; l->next != NULL; l = l->next);
    5a42:	9c 01       	movw	r18, r24
    5a44:	f9 01       	movw	r30, r18
    5a46:	80 81       	ld	r24, Z
    5a48:	91 81       	ldd	r25, Z+1	; 0x01
    5a4a:	00 97       	sbiw	r24, 0x00	; 0
    5a4c:	d1 f7       	brne	.-12     	; 0x5a42 <list_tail+0xe>
    5a4e:	02 c0       	rjmp	.+4      	; 0x5a54 <list_tail+0x20>
list_tail(list_t list)
{
  struct list *l;
  
  if(*list == NULL) {
    return NULL;
    5a50:	20 e0       	ldi	r18, 0x00	; 0
    5a52:	30 e0       	ldi	r19, 0x00	; 0
  }
  
  for(l = *list; l->next != NULL; l = l->next);
  
  return l;
}
    5a54:	c9 01       	movw	r24, r18
    5a56:	08 95       	ret

00005a58 <list_chop>:
 * \return The removed object
 *
 */
void *
list_chop(list_t list)
{
    5a58:	cf 93       	push	r28
    5a5a:	df 93       	push	r29
    5a5c:	dc 01       	movw	r26, r24
  struct list *l, *r;
  
  if(*list == NULL) {
    5a5e:	2d 91       	ld	r18, X+
    5a60:	3c 91       	ld	r19, X
    5a62:	11 97       	sbiw	r26, 0x01	; 1
    5a64:	21 15       	cp	r18, r1
    5a66:	31 05       	cpc	r19, r1
    5a68:	a9 f0       	breq	.+42     	; 0x5a94 <list_chop+0x3c>
    return NULL;
  }
  if(((struct list *)*list)->next == NULL) {
    5a6a:	f9 01       	movw	r30, r18
    5a6c:	80 81       	ld	r24, Z
    5a6e:	91 81       	ldd	r25, Z+1	; 0x01
    5a70:	00 97       	sbiw	r24, 0x00	; 0
    5a72:	29 f4       	brne	.+10     	; 0x5a7e <list_chop+0x26>
    l = *list;
    *list = NULL;
    5a74:	11 96       	adiw	r26, 0x01	; 1
    5a76:	1c 92       	st	X, r1
    5a78:	1e 92       	st	-X, r1
    return l;
    5a7a:	0e c0       	rjmp	.+28     	; 0x5a98 <list_chop+0x40>
  }
  
  for(l = *list; l->next->next != NULL; l = l->next);
    5a7c:	f9 01       	movw	r30, r18
    5a7e:	20 81       	ld	r18, Z
    5a80:	31 81       	ldd	r19, Z+1	; 0x01
    5a82:	d9 01       	movw	r26, r18
    5a84:	8d 91       	ld	r24, X+
    5a86:	9c 91       	ld	r25, X
    5a88:	11 97       	sbiw	r26, 0x01	; 1
    5a8a:	00 97       	sbiw	r24, 0x00	; 0
    5a8c:	b9 f7       	brne	.-18     	; 0x5a7c <list_chop+0x24>

  r = l->next;
  l->next = NULL;
    5a8e:	11 82       	std	Z+1, r1	; 0x01
    5a90:	10 82       	st	Z, r1
  
  return r;
    5a92:	02 c0       	rjmp	.+4      	; 0x5a98 <list_chop+0x40>
list_chop(list_t list)
{
  struct list *l, *r;
  
  if(*list == NULL) {
    return NULL;
    5a94:	20 e0       	ldi	r18, 0x00	; 0
    5a96:	30 e0       	ldi	r19, 0x00	; 0

  r = l->next;
  l->next = NULL;
  
  return r;
}
    5a98:	c9 01       	movw	r24, r18
    5a9a:	df 91       	pop	r29
    5a9c:	cf 91       	pop	r28
    5a9e:	08 95       	ret

00005aa0 <list_pop>:
 * \return Pointer to the removed element of list.
 */
/*---------------------------------------------------------------------------*/
void *
list_pop(list_t list)
{
    5aa0:	dc 01       	movw	r26, r24
  struct list *l;
  l = *list;
    5aa2:	ed 91       	ld	r30, X+
    5aa4:	fc 91       	ld	r31, X
    5aa6:	11 97       	sbiw	r26, 0x01	; 1
  if(*list != NULL) {
    5aa8:	30 97       	sbiw	r30, 0x00	; 0
    5aaa:	29 f0       	breq	.+10     	; 0x5ab6 <list_pop+0x16>
    *list = ((struct list *)*list)->next;
    5aac:	80 81       	ld	r24, Z
    5aae:	91 81       	ldd	r25, Z+1	; 0x01
    5ab0:	11 96       	adiw	r26, 0x01	; 1
    5ab2:	9c 93       	st	X, r25
    5ab4:	8e 93       	st	-X, r24
  }

  return l;
}
    5ab6:	cf 01       	movw	r24, r30
    5ab8:	08 95       	ret

00005aba <list_remove>:
 *
 */
/*---------------------------------------------------------------------------*/
void
list_remove(list_t list, void *item)
{
    5aba:	cf 93       	push	r28
    5abc:	df 93       	push	r29
    5abe:	fc 01       	movw	r30, r24
  struct list *l, *r;
  
  if(*list == NULL) {
    5ac0:	a0 81       	ld	r26, Z
    5ac2:	b1 81       	ldd	r27, Z+1	; 0x01
    5ac4:	10 97       	sbiw	r26, 0x00	; 0
    5ac6:	d9 f0       	breq	.+54     	; 0x5afe <list_remove+0x44>
    return;
  }
  
  r = NULL;
    5ac8:	c0 e0       	ldi	r28, 0x00	; 0
    5aca:	d0 e0       	ldi	r29, 0x00	; 0
  for(l = *list; l != NULL; l = l->next) {
    5acc:	16 c0       	rjmp	.+44     	; 0x5afa <list_remove+0x40>
    if(l == item) {
    5ace:	a6 17       	cp	r26, r22
    5ad0:	b7 07       	cpc	r27, r23
    5ad2:	71 f4       	brne	.+28     	; 0x5af0 <list_remove+0x36>
    5ad4:	8d 91       	ld	r24, X+
    5ad6:	9c 91       	ld	r25, X
    5ad8:	11 97       	sbiw	r26, 0x01	; 1
      if(r == NULL) {
    5ada:	20 97       	sbiw	r28, 0x00	; 0
    5adc:	19 f4       	brne	.+6      	; 0x5ae4 <list_remove+0x2a>
	/* First on list */
	*list = l->next;
    5ade:	91 83       	std	Z+1, r25	; 0x01
    5ae0:	80 83       	st	Z, r24
    5ae2:	02 c0       	rjmp	.+4      	; 0x5ae8 <list_remove+0x2e>
      } else {
	/* Not first on list */
	r->next = l->next;
    5ae4:	99 83       	std	Y+1, r25	; 0x01
    5ae6:	88 83       	st	Y, r24
      }
      l->next = NULL;
    5ae8:	11 96       	adiw	r26, 0x01	; 1
    5aea:	1c 92       	st	X, r1
    5aec:	1e 92       	st	-X, r1
      return;
    5aee:	07 c0       	rjmp	.+14     	; 0x5afe <list_remove+0x44>
  if(*list == NULL) {
    return;
  }
  
  r = NULL;
  for(l = *list; l != NULL; l = l->next) {
    5af0:	ed 01       	movw	r28, r26
    5af2:	98 81       	ld	r25, Y
    5af4:	89 81       	ldd	r24, Y+1	; 0x01
    5af6:	a9 2f       	mov	r26, r25
    5af8:	b8 2f       	mov	r27, r24
    5afa:	10 97       	sbiw	r26, 0x00	; 0
    5afc:	41 f7       	brne	.-48     	; 0x5ace <list_remove+0x14>
      l->next = NULL;
      return;
    }
    r = l;
  }
}
    5afe:	df 91       	pop	r29
    5b00:	cf 91       	pop	r28
    5b02:	08 95       	ret

00005b04 <list_push>:
/**
 * Add an item to the start of the list.
 */
void
list_push(list_t list, void *item)
{
    5b04:	0f 93       	push	r16
    5b06:	1f 93       	push	r17
    5b08:	cf 93       	push	r28
    5b0a:	df 93       	push	r29
    5b0c:	8c 01       	movw	r16, r24
    5b0e:	eb 01       	movw	r28, r22
  /*  struct list *l;*/

  /* Make sure not to add the same element twice */
  list_remove(list, item);
    5b10:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>

  ((struct list *)item)->next = *list;
    5b14:	f8 01       	movw	r30, r16
    5b16:	80 81       	ld	r24, Z
    5b18:	91 81       	ldd	r25, Z+1	; 0x01
    5b1a:	99 83       	std	Y+1, r25	; 0x01
    5b1c:	88 83       	st	Y, r24
  *list = item;
    5b1e:	d1 83       	std	Z+1, r29	; 0x01
    5b20:	c0 83       	st	Z, r28
}
    5b22:	df 91       	pop	r29
    5b24:	cf 91       	pop	r28
    5b26:	1f 91       	pop	r17
    5b28:	0f 91       	pop	r16
    5b2a:	08 95       	ret

00005b2c <list_add>:
 * \sa list_push()
 *
 */
void
list_add(list_t list, void *item)
{
    5b2c:	ef 92       	push	r14
    5b2e:	ff 92       	push	r15
    5b30:	0f 93       	push	r16
    5b32:	1f 93       	push	r17
    5b34:	cf 93       	push	r28
    5b36:	df 93       	push	r29
    5b38:	ec 01       	movw	r28, r24
    5b3a:	7b 01       	movw	r14, r22
  struct list *l;

  /* Make sure not to add the same element twice */
  list_remove(list, item);
    5b3c:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <list_remove>

  ((struct list *)item)->next = NULL;
    5b40:	f7 01       	movw	r30, r14
    5b42:	11 82       	std	Z+1, r1	; 0x01
    5b44:	10 82       	st	Z, r1
  
  l = list_tail(list);
    5b46:	ce 01       	movw	r24, r28
    5b48:	0e 94 1a 2d 	call	0x5a34	; 0x5a34 <list_tail>
    5b4c:	fc 01       	movw	r30, r24

  if(l == NULL) {
    5b4e:	00 97       	sbiw	r24, 0x00	; 0
    5b50:	19 f4       	brne	.+6      	; 0x5b58 <list_add+0x2c>
    *list = item;
    5b52:	e8 82       	st	Y, r14
    5b54:	f9 82       	std	Y+1, r15	; 0x01
    5b56:	02 c0       	rjmp	.+4      	; 0x5b5c <list_add+0x30>
  } else {
    l->next = item;
    5b58:	f1 82       	std	Z+1, r15	; 0x01
    5b5a:	e0 82       	st	Z, r14
  }
}
    5b5c:	df 91       	pop	r29
    5b5e:	cf 91       	pop	r28
    5b60:	1f 91       	pop	r17
    5b62:	0f 91       	pop	r16
    5b64:	ff 90       	pop	r15
    5b66:	ef 90       	pop	r14
    5b68:	08 95       	ret

00005b6a <list_length>:
list_length(list_t list)
{
  struct list *l;
  int n = 0;

  for(l = *list; l != NULL; l = l->next) {
    5b6a:	dc 01       	movw	r26, r24
    5b6c:	ed 91       	ld	r30, X+
    5b6e:	fc 91       	ld	r31, X
    5b70:	11 97       	sbiw	r26, 0x01	; 1
/*---------------------------------------------------------------------------*/
int
list_length(list_t list)
{
  struct list *l;
  int n = 0;
    5b72:	20 e0       	ldi	r18, 0x00	; 0
    5b74:	30 e0       	ldi	r19, 0x00	; 0

  for(l = *list; l != NULL; l = l->next) {
    5b76:	05 c0       	rjmp	.+10     	; 0x5b82 <list_length+0x18>
    ++n;
    5b78:	2f 5f       	subi	r18, 0xFF	; 255
    5b7a:	3f 4f       	sbci	r19, 0xFF	; 255
list_length(list_t list)
{
  struct list *l;
  int n = 0;

  for(l = *list; l != NULL; l = l->next) {
    5b7c:	01 90       	ld	r0, Z+
    5b7e:	f0 81       	ld	r31, Z
    5b80:	e0 2d       	mov	r30, r0
    5b82:	30 97       	sbiw	r30, 0x00	; 0
    5b84:	c9 f7       	brne	.-14     	; 0x5b78 <list_length+0xe>
    ++n;
  }

  return n;
}
    5b86:	c9 01       	movw	r24, r18
    5b88:	08 95       	ret

00005b8a <list_insert>:
 *             start of the list.
 *
 */
void
list_insert(list_t list, void *previtem, void *newitem)
{
    5b8a:	fb 01       	movw	r30, r22
  if(previtem == NULL) {
    5b8c:	30 97       	sbiw	r30, 0x00	; 0
    5b8e:	21 f4       	brne	.+8      	; 0x5b98 <list_insert+0xe>
    list_push(list, newitem);
    5b90:	ba 01       	movw	r22, r20
    5b92:	0e 94 82 2d 	call	0x5b04	; 0x5b04 <list_push>
    5b96:	08 95       	ret
  } else {
  
    ((struct list *)newitem)->next = ((struct list *)previtem)->next;
    5b98:	da 01       	movw	r26, r20
    5b9a:	80 81       	ld	r24, Z
    5b9c:	91 81       	ldd	r25, Z+1	; 0x01
    5b9e:	11 96       	adiw	r26, 0x01	; 1
    5ba0:	9c 93       	st	X, r25
    5ba2:	8e 93       	st	-X, r24
    ((struct list *)previtem)->next = newitem;
    5ba4:	51 83       	std	Z+1, r21	; 0x01
    5ba6:	40 83       	st	Z, r20
    5ba8:	08 95       	ret

00005baa <list_item_next>:
 *             lists.
 */
void *
list_item_next(void *item)
{
  return item == NULL? NULL: ((struct list *)item)->next;
    5baa:	00 97       	sbiw	r24, 0x00	; 0
    5bac:	21 f0       	breq	.+8      	; 0x5bb6 <list_item_next+0xc>
    5bae:	fc 01       	movw	r30, r24
    5bb0:	20 81       	ld	r18, Z
    5bb2:	31 81       	ldd	r19, Z+1	; 0x01
    5bb4:	02 c0       	rjmp	.+4      	; 0x5bba <list_item_next+0x10>
    5bb6:	20 e0       	ldi	r18, 0x00	; 0
    5bb8:	30 e0       	ldi	r19, 0x00	; 0
}
    5bba:	c9 01       	movw	r24, r18
    5bbc:	08 95       	ret

00005bbe <energest_init>:
unsigned char energest_current_mode[ENERGEST_TYPE_MAX];

/*---------------------------------------------------------------------------*/
void
energest_init(void)
{
    5bbe:	cf 93       	push	r28
    5bc0:	df 93       	push	r29
    5bc2:	ec e4       	ldi	r30, 0x4C	; 76
    5bc4:	f0 e3       	ldi	r31, 0x30	; 48
    5bc6:	ce e0       	ldi	r28, 0x0E	; 14
    5bc8:	d0 e3       	ldi	r29, 0x30	; 48
    5bca:	a0 e4       	ldi	r26, 0x40	; 64
    5bcc:	b0 e3       	ldi	r27, 0x30	; 48
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; ++i) {
    energest_total_time[i].current = energest_current_time[i] = 0;
    5bce:	11 92       	st	Z+, r1
    5bd0:	11 92       	st	Z+, r1
    5bd2:	19 92       	st	Y+, r1
    5bd4:	19 92       	st	Y+, r1
    5bd6:	19 92       	st	Y+, r1
    5bd8:	19 92       	st	Y+, r1
    energest_current_mode[i] = 0;
    5bda:	1d 92       	st	X+, r1
/*---------------------------------------------------------------------------*/
void
energest_init(void)
{
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; ++i) {
    5bdc:	80 e3       	ldi	r24, 0x30	; 48
    5bde:	e4 36       	cpi	r30, 0x64	; 100
    5be0:	f8 07       	cpc	r31, r24
    5be2:	a9 f7       	brne	.-22     	; 0x5bce <energest_init+0x10>
#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
  for(i = 0; i < ENERGEST_CONF_LEVELDEVICE_LEVELS; ++i) {
    energest_leveldevice_current_leveltime[i].current = 0;
  }
#endif
}
    5be4:	df 91       	pop	r29
    5be6:	cf 91       	pop	r28
    5be8:	08 95       	ret

00005bea <energest_type_time>:
/*---------------------------------------------------------------------------*/
unsigned long
energest_type_time(int type)
{
    5bea:	0f 93       	push	r16
    5bec:	1f 93       	push	r17
    5bee:	cf 93       	push	r28
    5bf0:	df 93       	push	r29
    5bf2:	fc 01       	movw	r30, r24
  /* Note: does not support ENERGEST_CONF_LEVELDEVICE_LEVELS! */
#ifndef ENERGEST_CONF_LEVELDEVICE_LEVELS
  if(energest_current_mode[type]) {
    5bf4:	dc 01       	movw	r26, r24
    5bf6:	a0 5c       	subi	r26, 0xC0	; 192
    5bf8:	bf 4c       	sbci	r27, 0xCF	; 207
    5bfa:	8c 91       	ld	r24, X
    5bfc:	88 23       	and	r24, r24
    5bfe:	39 f1       	breq	.+78     	; 0x5c4e <energest_type_time+0x64>
    rtimer_clock_t now = RTIMER_NOW();
    5c00:	00 91 94 00 	lds	r16, 0x0094
    5c04:	10 91 95 00 	lds	r17, 0x0095
    energest_total_time[type].current += (rtimer_clock_t)
    5c08:	ef 01       	movw	r28, r30
    5c0a:	cc 0f       	add	r28, r28
    5c0c:	dd 1f       	adc	r29, r29
    5c0e:	cc 0f       	add	r28, r28
    5c10:	dd 1f       	adc	r29, r29
    5c12:	c2 5f       	subi	r28, 0xF2	; 242
    5c14:	df 4c       	sbci	r29, 0xCF	; 207
      (now - energest_current_time[type]);
    5c16:	df 01       	movw	r26, r30
    5c18:	aa 0f       	add	r26, r26
    5c1a:	bb 1f       	adc	r27, r27
    5c1c:	a4 5b       	subi	r26, 0xB4	; 180
    5c1e:	bf 4c       	sbci	r27, 0xCF	; 207
    5c20:	8d 91       	ld	r24, X+
    5c22:	9c 91       	ld	r25, X
    5c24:	11 97       	sbiw	r26, 0x01	; 1
    5c26:	98 01       	movw	r18, r16
    5c28:	28 1b       	sub	r18, r24
    5c2a:	39 0b       	sbc	r19, r25
{
  /* Note: does not support ENERGEST_CONF_LEVELDEVICE_LEVELS! */
#ifndef ENERGEST_CONF_LEVELDEVICE_LEVELS
  if(energest_current_mode[type]) {
    rtimer_clock_t now = RTIMER_NOW();
    energest_total_time[type].current += (rtimer_clock_t)
    5c2c:	40 e0       	ldi	r20, 0x00	; 0
    5c2e:	50 e0       	ldi	r21, 0x00	; 0
    5c30:	68 81       	ld	r22, Y
    5c32:	79 81       	ldd	r23, Y+1	; 0x01
    5c34:	8a 81       	ldd	r24, Y+2	; 0x02
    5c36:	9b 81       	ldd	r25, Y+3	; 0x03
    5c38:	26 0f       	add	r18, r22
    5c3a:	37 1f       	adc	r19, r23
    5c3c:	48 1f       	adc	r20, r24
    5c3e:	59 1f       	adc	r21, r25
    5c40:	28 83       	st	Y, r18
    5c42:	39 83       	std	Y+1, r19	; 0x01
    5c44:	4a 83       	std	Y+2, r20	; 0x02
    5c46:	5b 83       	std	Y+3, r21	; 0x03
      (now - energest_current_time[type]);
    energest_current_time[type] = now;
    5c48:	11 96       	adiw	r26, 0x01	; 1
    5c4a:	1c 93       	st	X, r17
    5c4c:	0e 93       	st	-X, r16
  }
#endif /* ENERGEST_CONF_LEVELDEVICE_LEVELS */
  return energest_total_time[type].current;
    5c4e:	ee 0f       	add	r30, r30
    5c50:	ff 1f       	adc	r31, r31
    5c52:	ee 0f       	add	r30, r30
    5c54:	ff 1f       	adc	r31, r31
    5c56:	e2 5f       	subi	r30, 0xF2	; 242
    5c58:	ff 4c       	sbci	r31, 0xCF	; 207
#ifndef ENERGEST_CONF_LEVELDEVICE_LEVELS
  if(energest_current_mode[type]) {
    rtimer_clock_t now = RTIMER_NOW();
    energest_total_time[type].current += (rtimer_clock_t)
      (now - energest_current_time[type]);
    energest_current_time[type] = now;
    5c5a:	60 81       	ld	r22, Z
    5c5c:	71 81       	ldd	r23, Z+1	; 0x01
  }
#endif /* ENERGEST_CONF_LEVELDEVICE_LEVELS */
  return energest_total_time[type].current;
}
    5c5e:	82 81       	ldd	r24, Z+2	; 0x02
    5c60:	93 81       	ldd	r25, Z+3	; 0x03
    5c62:	df 91       	pop	r29
    5c64:	cf 91       	pop	r28
    5c66:	1f 91       	pop	r17
    5c68:	0f 91       	pop	r16
    5c6a:	08 95       	ret

00005c6c <energest_leveldevice_leveltime>:
#ifdef ENERGEST_CONF_LEVELDEVICE_LEVELS
  return energest_leveldevice_current_leveltime[powerlevel].current;
#else
  return 0;
#endif
}
    5c6c:	60 e0       	ldi	r22, 0x00	; 0
    5c6e:	70 e0       	ldi	r23, 0x00	; 0
    5c70:	cb 01       	movw	r24, r22
    5c72:	08 95       	ret

00005c74 <energest_type_set>:
/*---------------------------------------------------------------------------*/
void
energest_type_set(int type, unsigned long val)
{
  energest_total_time[type].current = val;
    5c74:	fc 01       	movw	r30, r24
    5c76:	ee 0f       	add	r30, r30
    5c78:	ff 1f       	adc	r31, r31
    5c7a:	ee 0f       	add	r30, r30
    5c7c:	ff 1f       	adc	r31, r31
    5c7e:	e2 5f       	subi	r30, 0xF2	; 242
    5c80:	ff 4c       	sbci	r31, 0xCF	; 207
    5c82:	40 83       	st	Z, r20
    5c84:	51 83       	std	Z+1, r21	; 0x01
    5c86:	62 83       	std	Z+2, r22	; 0x02
    5c88:	73 83       	std	Z+3, r23	; 0x03
}
    5c8a:	08 95       	ret

00005c8c <energest_flush>:
/*---------------------------------------------------------------------------*/
/* Note: does not support ENERGEST_CONF_LEVELDEVICE_LEVELS! */
void
energest_flush(void)
{
    5c8c:	ef 92       	push	r14
    5c8e:	ff 92       	push	r15
    5c90:	0f 93       	push	r16
    5c92:	1f 93       	push	r17
    5c94:	cf 93       	push	r28
    5c96:	df 93       	push	r29
    5c98:	20 e4       	ldi	r18, 0x40	; 64
    5c9a:	30 e3       	ldi	r19, 0x30	; 48
    5c9c:	ce e0       	ldi	r28, 0x0E	; 14
    5c9e:	d0 e3       	ldi	r29, 0x30	; 48
    5ca0:	ec e4       	ldi	r30, 0x4C	; 76
    5ca2:	f0 e3       	ldi	r31, 0x30	; 48
  rtimer_clock_t now;
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; i++) {
    if(energest_current_mode[i]) {
    5ca4:	d9 01       	movw	r26, r18
    5ca6:	8d 91       	ld	r24, X+
    5ca8:	9d 01       	movw	r18, r26
    5caa:	88 23       	and	r24, r24
    5cac:	c9 f0       	breq	.+50     	; 0x5ce0 <energest_flush+0x54>
      now = RTIMER_NOW();
    5cae:	40 91 94 00 	lds	r20, 0x0094
    5cb2:	50 91 95 00 	lds	r21, 0x0095
      energest_total_time[i].current += (rtimer_clock_t)
	(now - energest_current_time[i]);
    5cb6:	80 81       	ld	r24, Z
    5cb8:	91 81       	ldd	r25, Z+1	; 0x01
    5cba:	7a 01       	movw	r14, r20
    5cbc:	e8 1a       	sub	r14, r24
    5cbe:	f9 0a       	sbc	r15, r25
  rtimer_clock_t now;
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; i++) {
    if(energest_current_mode[i]) {
      now = RTIMER_NOW();
      energest_total_time[i].current += (rtimer_clock_t)
    5cc0:	00 e0       	ldi	r16, 0x00	; 0
    5cc2:	10 e0       	ldi	r17, 0x00	; 0
    5cc4:	88 81       	ld	r24, Y
    5cc6:	99 81       	ldd	r25, Y+1	; 0x01
    5cc8:	aa 81       	ldd	r26, Y+2	; 0x02
    5cca:	bb 81       	ldd	r27, Y+3	; 0x03
    5ccc:	8e 0d       	add	r24, r14
    5cce:	9f 1d       	adc	r25, r15
    5cd0:	a0 1f       	adc	r26, r16
    5cd2:	b1 1f       	adc	r27, r17
    5cd4:	88 83       	st	Y, r24
    5cd6:	99 83       	std	Y+1, r25	; 0x01
    5cd8:	aa 83       	std	Y+2, r26	; 0x02
    5cda:	bb 83       	std	Y+3, r27	; 0x03
	(now - energest_current_time[i]);
      energest_current_time[i] = now;
    5cdc:	51 83       	std	Z+1, r21	; 0x01
    5cde:	40 83       	st	Z, r20
    5ce0:	24 96       	adiw	r28, 0x04	; 4
    5ce2:	32 96       	adiw	r30, 0x02	; 2
void
energest_flush(void)
{
  rtimer_clock_t now;
  int i;
  for(i = 0; i < ENERGEST_TYPE_MAX; i++) {
    5ce4:	b0 e3       	ldi	r27, 0x30	; 48
    5ce6:	2c 34       	cpi	r18, 0x4C	; 76
    5ce8:	3b 07       	cpc	r19, r27
    5cea:	e1 f6       	brne	.-72     	; 0x5ca4 <energest_flush+0x18>
      energest_total_time[i].current += (rtimer_clock_t)
	(now - energest_current_time[i]);
      energest_current_time[i] = now;
    }
  }
}
    5cec:	df 91       	pop	r29
    5cee:	cf 91       	pop	r28
    5cf0:	1f 91       	pop	r17
    5cf2:	0f 91       	pop	r16
    5cf4:	ff 90       	pop	r15
    5cf6:	ef 90       	pop	r14
    5cf8:	08 95       	ret

00005cfa <rtimer_init>:

/*---------------------------------------------------------------------------*/
void
rtimer_init(void)
{
  rtimer_arch_init();
    5cfa:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <rtimer_arch_init>
}
    5cfe:	08 95       	ret

00005d00 <rtimer_set>:
/*---------------------------------------------------------------------------*/
int
rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
	   rtimer_clock_t duration,
	   rtimer_callback_t func, void *ptr)
{
    5d00:	0f 93       	push	r16
    5d02:	1f 93       	push	r17
    5d04:	fc 01       	movw	r30, r24
    5d06:	cb 01       	movw	r24, r22
  int first = 0;

  PRINTF("rtimer_set time %d\n", time);

  if(next_rtimer == NULL) {
    5d08:	40 91 c5 26 	lds	r20, 0x26C5
    5d0c:	50 91 c6 26 	lds	r21, 0x26C6
    first = 1;
  }

  rtimer->func = func;
    5d10:	33 83       	std	Z+3, r19	; 0x03
    5d12:	22 83       	std	Z+2, r18	; 0x02
  rtimer->ptr = ptr;
    5d14:	15 83       	std	Z+5, r17	; 0x05
    5d16:	04 83       	std	Z+4, r16	; 0x04

  rtimer->time = time;
    5d18:	71 83       	std	Z+1, r23	; 0x01
    5d1a:	60 83       	st	Z, r22
  next_rtimer = rtimer;
    5d1c:	f0 93 c6 26 	sts	0x26C6, r31
    5d20:	e0 93 c5 26 	sts	0x26C5, r30

  if(first == 1) {
    5d24:	41 15       	cp	r20, r1
    5d26:	51 05       	cpc	r21, r1
    5d28:	11 f4       	brne	.+4      	; 0x5d2e <rtimer_set+0x2e>
    rtimer_arch_schedule(time);
    5d2a:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <rtimer_arch_schedule>
  }
  return RTIMER_OK;
}
    5d2e:	80 e0       	ldi	r24, 0x00	; 0
    5d30:	90 e0       	ldi	r25, 0x00	; 0
    5d32:	1f 91       	pop	r17
    5d34:	0f 91       	pop	r16
    5d36:	08 95       	ret

00005d38 <rtimer_run_next>:
/*---------------------------------------------------------------------------*/
void
rtimer_run_next(void)
{
  struct rtimer *t;
  if(next_rtimer == NULL) {
    5d38:	80 91 c5 26 	lds	r24, 0x26C5
    5d3c:	90 91 c6 26 	lds	r25, 0x26C6
    5d40:	00 97       	sbiw	r24, 0x00	; 0
    5d42:	c1 f0       	breq	.+48     	; 0x5d74 <rtimer_run_next+0x3c>
    return;
  }
  t = next_rtimer;
  next_rtimer = NULL;
    5d44:	10 92 c6 26 	sts	0x26C6, r1
    5d48:	10 92 c5 26 	sts	0x26C5, r1
  t->func(t, t->ptr);
    5d4c:	dc 01       	movw	r26, r24
    5d4e:	14 96       	adiw	r26, 0x04	; 4
    5d50:	6d 91       	ld	r22, X+
    5d52:	7c 91       	ld	r23, X
    5d54:	15 97       	sbiw	r26, 0x05	; 5
    5d56:	12 96       	adiw	r26, 0x02	; 2
    5d58:	ed 91       	ld	r30, X+
    5d5a:	fc 91       	ld	r31, X
    5d5c:	13 97       	sbiw	r26, 0x03	; 3
    5d5e:	09 95       	icall
  if(next_rtimer != NULL) {
    5d60:	e0 91 c5 26 	lds	r30, 0x26C5
    5d64:	f0 91 c6 26 	lds	r31, 0x26C6
    5d68:	30 97       	sbiw	r30, 0x00	; 0
    5d6a:	21 f0       	breq	.+8      	; 0x5d74 <rtimer_run_next+0x3c>
    rtimer_arch_schedule(next_rtimer->time);
    5d6c:	80 81       	ld	r24, Z
    5d6e:	91 81       	ldd	r25, Z+1	; 0x01
    5d70:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <rtimer_arch_schedule>
    5d74:	08 95       	ret

00005d76 <print_stats>:
#endif

/*---------------------------------------------------------------------------*/
void
print_stats(void)
{
    5d76:	0f 93       	push	r16
    5d78:	1f 93       	push	r17
  PRINTA("S %d.%d clock %lu tx %lu rx %lu rtx %lu rrx %lu rexmit %lu acktx %lu noacktx %lu ackrx %lu timedout %lu badackrx %lu toolong %lu tooshort %lu badsynch %lu badcrc %lu contentiondrop %lu sendingdrop %lu lltx %lu llrx %lu\n",
    5d7a:	00 91 c4 2f 	lds	r16, 0x2FC4
    5d7e:	10 91 c5 2f 	lds	r17, 0x2FC5
    5d82:	0e 94 6d 1b 	call	0x36da	; 0x36da <clock_seconds>
    5d86:	2d b7       	in	r18, 0x3d	; 61
    5d88:	3e b7       	in	r19, 0x3e	; 62
    5d8a:	22 55       	subi	r18, 0x52	; 82
    5d8c:	30 40       	sbci	r19, 0x00	; 0
    5d8e:	0f b6       	in	r0, 0x3f	; 63
    5d90:	f8 94       	cli
    5d92:	3e bf       	out	0x3e, r19	; 62
    5d94:	0f be       	out	0x3f, r0	; 63
    5d96:	2d bf       	out	0x3d, r18	; 61
    5d98:	ed b7       	in	r30, 0x3d	; 61
    5d9a:	fe b7       	in	r31, 0x3e	; 62
    5d9c:	31 96       	adiw	r30, 0x01	; 1
    5d9e:	27 e8       	ldi	r18, 0x87	; 135
    5da0:	32 e0       	ldi	r19, 0x02	; 2
    5da2:	ad b7       	in	r26, 0x3d	; 61
    5da4:	be b7       	in	r27, 0x3e	; 62
    5da6:	12 96       	adiw	r26, 0x02	; 2
    5da8:	3c 93       	st	X, r19
    5daa:	2e 93       	st	-X, r18
    5dac:	11 97       	sbiw	r26, 0x01	; 1
    5dae:	02 83       	std	Z+2, r16	; 0x02
    5db0:	13 82       	std	Z+3, r1	; 0x03
    5db2:	14 83       	std	Z+4, r17	; 0x04
    5db4:	15 82       	std	Z+5, r1	; 0x05
    5db6:	66 83       	std	Z+6, r22	; 0x06
    5db8:	77 83       	std	Z+7, r23	; 0x07
    5dba:	80 87       	std	Z+8, r24	; 0x08
    5dbc:	91 87       	std	Z+9, r25	; 0x09
    5dbe:	80 91 c6 2f 	lds	r24, 0x2FC6
    5dc2:	90 91 c7 2f 	lds	r25, 0x2FC7
    5dc6:	a0 91 c8 2f 	lds	r26, 0x2FC8
    5dca:	b0 91 c9 2f 	lds	r27, 0x2FC9
    5dce:	82 87       	std	Z+10, r24	; 0x0a
    5dd0:	93 87       	std	Z+11, r25	; 0x0b
    5dd2:	a4 87       	std	Z+12, r26	; 0x0c
    5dd4:	b5 87       	std	Z+13, r27	; 0x0d
    5dd6:	80 91 ca 2f 	lds	r24, 0x2FCA
    5dda:	90 91 cb 2f 	lds	r25, 0x2FCB
    5dde:	a0 91 cc 2f 	lds	r26, 0x2FCC
    5de2:	b0 91 cd 2f 	lds	r27, 0x2FCD
    5de6:	86 87       	std	Z+14, r24	; 0x0e
    5de8:	97 87       	std	Z+15, r25	; 0x0f
    5dea:	a0 8b       	std	Z+16, r26	; 0x10
    5dec:	b1 8b       	std	Z+17, r27	; 0x11
    5dee:	80 91 ce 2f 	lds	r24, 0x2FCE
    5df2:	90 91 cf 2f 	lds	r25, 0x2FCF
    5df6:	a0 91 d0 2f 	lds	r26, 0x2FD0
    5dfa:	b0 91 d1 2f 	lds	r27, 0x2FD1
    5dfe:	82 8b       	std	Z+18, r24	; 0x12
    5e00:	93 8b       	std	Z+19, r25	; 0x13
    5e02:	a4 8b       	std	Z+20, r26	; 0x14
    5e04:	b5 8b       	std	Z+21, r27	; 0x15
    5e06:	80 91 d2 2f 	lds	r24, 0x2FD2
    5e0a:	90 91 d3 2f 	lds	r25, 0x2FD3
    5e0e:	a0 91 d4 2f 	lds	r26, 0x2FD4
    5e12:	b0 91 d5 2f 	lds	r27, 0x2FD5
    5e16:	86 8b       	std	Z+22, r24	; 0x16
    5e18:	97 8b       	std	Z+23, r25	; 0x17
    5e1a:	a0 8f       	std	Z+24, r26	; 0x18
    5e1c:	b1 8f       	std	Z+25, r27	; 0x19
    5e1e:	80 91 d6 2f 	lds	r24, 0x2FD6
    5e22:	90 91 d7 2f 	lds	r25, 0x2FD7
    5e26:	a0 91 d8 2f 	lds	r26, 0x2FD8
    5e2a:	b0 91 d9 2f 	lds	r27, 0x2FD9
    5e2e:	82 8f       	std	Z+26, r24	; 0x1a
    5e30:	93 8f       	std	Z+27, r25	; 0x1b
    5e32:	a4 8f       	std	Z+28, r26	; 0x1c
    5e34:	b5 8f       	std	Z+29, r27	; 0x1d
    5e36:	80 91 da 2f 	lds	r24, 0x2FDA
    5e3a:	90 91 db 2f 	lds	r25, 0x2FDB
    5e3e:	a0 91 dc 2f 	lds	r26, 0x2FDC
    5e42:	b0 91 dd 2f 	lds	r27, 0x2FDD
    5e46:	86 8f       	std	Z+30, r24	; 0x1e
    5e48:	97 8f       	std	Z+31, r25	; 0x1f
    5e4a:	a0 a3       	std	Z+32, r26	; 0x20
    5e4c:	b1 a3       	std	Z+33, r27	; 0x21
    5e4e:	80 91 de 2f 	lds	r24, 0x2FDE
    5e52:	90 91 df 2f 	lds	r25, 0x2FDF
    5e56:	a0 91 e0 2f 	lds	r26, 0x2FE0
    5e5a:	b0 91 e1 2f 	lds	r27, 0x2FE1
    5e5e:	82 a3       	std	Z+34, r24	; 0x22
    5e60:	93 a3       	std	Z+35, r25	; 0x23
    5e62:	a4 a3       	std	Z+36, r26	; 0x24
    5e64:	b5 a3       	std	Z+37, r27	; 0x25
    5e66:	80 91 e2 2f 	lds	r24, 0x2FE2
    5e6a:	90 91 e3 2f 	lds	r25, 0x2FE3
    5e6e:	a0 91 e4 2f 	lds	r26, 0x2FE4
    5e72:	b0 91 e5 2f 	lds	r27, 0x2FE5
    5e76:	86 a3       	std	Z+38, r24	; 0x26
    5e78:	97 a3       	std	Z+39, r25	; 0x27
    5e7a:	a0 a7       	std	Z+40, r26	; 0x28
    5e7c:	b1 a7       	std	Z+41, r27	; 0x29
    5e7e:	80 91 e6 2f 	lds	r24, 0x2FE6
    5e82:	90 91 e7 2f 	lds	r25, 0x2FE7
    5e86:	a0 91 e8 2f 	lds	r26, 0x2FE8
    5e8a:	b0 91 e9 2f 	lds	r27, 0x2FE9
    5e8e:	82 a7       	std	Z+42, r24	; 0x2a
    5e90:	93 a7       	std	Z+43, r25	; 0x2b
    5e92:	a4 a7       	std	Z+44, r26	; 0x2c
    5e94:	b5 a7       	std	Z+45, r27	; 0x2d
    5e96:	80 91 ea 2f 	lds	r24, 0x2FEA
    5e9a:	90 91 eb 2f 	lds	r25, 0x2FEB
    5e9e:	a0 91 ec 2f 	lds	r26, 0x2FEC
    5ea2:	b0 91 ed 2f 	lds	r27, 0x2FED
    5ea6:	86 a7       	std	Z+46, r24	; 0x2e
    5ea8:	97 a7       	std	Z+47, r25	; 0x2f
    5eaa:	a0 ab       	std	Z+48, r26	; 0x30
    5eac:	b1 ab       	std	Z+49, r27	; 0x31
    5eae:	80 91 ee 2f 	lds	r24, 0x2FEE
    5eb2:	90 91 ef 2f 	lds	r25, 0x2FEF
    5eb6:	a0 91 f0 2f 	lds	r26, 0x2FF0
    5eba:	b0 91 f1 2f 	lds	r27, 0x2FF1
    5ebe:	82 ab       	std	Z+50, r24	; 0x32
    5ec0:	93 ab       	std	Z+51, r25	; 0x33
    5ec2:	a4 ab       	std	Z+52, r26	; 0x34
    5ec4:	b5 ab       	std	Z+53, r27	; 0x35
    5ec6:	80 91 f2 2f 	lds	r24, 0x2FF2
    5eca:	90 91 f3 2f 	lds	r25, 0x2FF3
    5ece:	a0 91 f4 2f 	lds	r26, 0x2FF4
    5ed2:	b0 91 f5 2f 	lds	r27, 0x2FF5
    5ed6:	86 ab       	std	Z+54, r24	; 0x36
    5ed8:	97 ab       	std	Z+55, r25	; 0x37
    5eda:	a0 af       	std	Z+56, r26	; 0x38
    5edc:	b1 af       	std	Z+57, r27	; 0x39
    5ede:	80 91 f6 2f 	lds	r24, 0x2FF6
    5ee2:	90 91 f7 2f 	lds	r25, 0x2FF7
    5ee6:	a0 91 f8 2f 	lds	r26, 0x2FF8
    5eea:	b0 91 f9 2f 	lds	r27, 0x2FF9
    5eee:	82 af       	std	Z+58, r24	; 0x3a
    5ef0:	93 af       	std	Z+59, r25	; 0x3b
    5ef2:	a4 af       	std	Z+60, r26	; 0x3c
    5ef4:	b5 af       	std	Z+61, r27	; 0x3d
    5ef6:	ed b7       	in	r30, 0x3d	; 61
    5ef8:	fe b7       	in	r31, 0x3e	; 62
    5efa:	ff 96       	adiw	r30, 0x3f	; 63
    5efc:	80 91 fa 2f 	lds	r24, 0x2FFA
    5f00:	90 91 fb 2f 	lds	r25, 0x2FFB
    5f04:	a0 91 fc 2f 	lds	r26, 0x2FFC
    5f08:	b0 91 fd 2f 	lds	r27, 0x2FFD
    5f0c:	80 83       	st	Z, r24
    5f0e:	91 83       	std	Z+1, r25	; 0x01
    5f10:	a2 83       	std	Z+2, r26	; 0x02
    5f12:	b3 83       	std	Z+3, r27	; 0x03
    5f14:	ed b7       	in	r30, 0x3d	; 61
    5f16:	fe b7       	in	r31, 0x3e	; 62
    5f18:	ed 5b       	subi	r30, 0xBD	; 189
    5f1a:	ff 4f       	sbci	r31, 0xFF	; 255
    5f1c:	80 91 fe 2f 	lds	r24, 0x2FFE
    5f20:	90 91 ff 2f 	lds	r25, 0x2FFF
    5f24:	a0 91 00 30 	lds	r26, 0x3000
    5f28:	b0 91 01 30 	lds	r27, 0x3001
    5f2c:	80 83       	st	Z, r24
    5f2e:	91 83       	std	Z+1, r25	; 0x01
    5f30:	a2 83       	std	Z+2, r26	; 0x02
    5f32:	b3 83       	std	Z+3, r27	; 0x03
    5f34:	ed b7       	in	r30, 0x3d	; 61
    5f36:	fe b7       	in	r31, 0x3e	; 62
    5f38:	e9 5b       	subi	r30, 0xB9	; 185
    5f3a:	ff 4f       	sbci	r31, 0xFF	; 255
    5f3c:	80 91 02 30 	lds	r24, 0x3002
    5f40:	90 91 03 30 	lds	r25, 0x3003
    5f44:	a0 91 04 30 	lds	r26, 0x3004
    5f48:	b0 91 05 30 	lds	r27, 0x3005
    5f4c:	80 83       	st	Z, r24
    5f4e:	91 83       	std	Z+1, r25	; 0x01
    5f50:	a2 83       	std	Z+2, r26	; 0x02
    5f52:	b3 83       	std	Z+3, r27	; 0x03
    5f54:	ed b7       	in	r30, 0x3d	; 61
    5f56:	fe b7       	in	r31, 0x3e	; 62
    5f58:	e5 5b       	subi	r30, 0xB5	; 181
    5f5a:	ff 4f       	sbci	r31, 0xFF	; 255
    5f5c:	80 91 06 30 	lds	r24, 0x3006
    5f60:	90 91 07 30 	lds	r25, 0x3007
    5f64:	a0 91 08 30 	lds	r26, 0x3008
    5f68:	b0 91 09 30 	lds	r27, 0x3009
    5f6c:	80 83       	st	Z, r24
    5f6e:	91 83       	std	Z+1, r25	; 0x01
    5f70:	a2 83       	std	Z+2, r26	; 0x02
    5f72:	b3 83       	std	Z+3, r27	; 0x03
    5f74:	ed b7       	in	r30, 0x3d	; 61
    5f76:	fe b7       	in	r31, 0x3e	; 62
    5f78:	e1 5b       	subi	r30, 0xB1	; 177
    5f7a:	ff 4f       	sbci	r31, 0xFF	; 255
    5f7c:	80 91 0a 30 	lds	r24, 0x300A
    5f80:	90 91 0b 30 	lds	r25, 0x300B
    5f84:	a0 91 0c 30 	lds	r26, 0x300C
    5f88:	b0 91 0d 30 	lds	r27, 0x300D
    5f8c:	80 83       	st	Z, r24
    5f8e:	91 83       	std	Z+1, r25	; 0x01
    5f90:	a2 83       	std	Z+2, r26	; 0x02
    5f92:	b3 83       	std	Z+3, r27	; 0x03
    5f94:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
	 rimestats.toolong, rimestats.tooshort,
	 rimestats.badsynch, rimestats.badcrc,
	 rimestats.contentiondrop, rimestats.sendingdrop,
	 rimestats.lltx, rimestats.llrx);
#if ENERGEST_CONF_ON
  PRINTA("E %d.%d clock %lu cpu %lu lpm %lu irq %lu gled %lu yled %lu rled %lu tx %lu listen %lu sensors %lu serial %lu\n",
    5f98:	00 91 c4 2f 	lds	r16, 0x2FC4
    5f9c:	10 91 c5 2f 	lds	r17, 0x2FC5
    5fa0:	2d b7       	in	r18, 0x3d	; 61
    5fa2:	3e b7       	in	r19, 0x3e	; 62
    5fa4:	2e 5a       	subi	r18, 0xAE	; 174
    5fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    5fa8:	0f b6       	in	r0, 0x3f	; 63
    5faa:	f8 94       	cli
    5fac:	3e bf       	out	0x3e, r19	; 62
    5fae:	0f be       	out	0x3f, r0	; 63
    5fb0:	2d bf       	out	0x3d, r18	; 61
    5fb2:	0e 94 6d 1b 	call	0x36da	; 0x36da <clock_seconds>
    5fb6:	ad b7       	in	r26, 0x3d	; 61
    5fb8:	be b7       	in	r27, 0x3e	; 62
    5fba:	d2 97       	sbiw	r26, 0x32	; 50
    5fbc:	0f b6       	in	r0, 0x3f	; 63
    5fbe:	f8 94       	cli
    5fc0:	be bf       	out	0x3e, r27	; 62
    5fc2:	0f be       	out	0x3f, r0	; 63
    5fc4:	ad bf       	out	0x3d, r26	; 61
    5fc6:	ed b7       	in	r30, 0x3d	; 61
    5fc8:	fe b7       	in	r31, 0x3e	; 62
    5fca:	31 96       	adiw	r30, 0x01	; 1
    5fcc:	28 e1       	ldi	r18, 0x18	; 24
    5fce:	32 e0       	ldi	r19, 0x02	; 2
    5fd0:	12 96       	adiw	r26, 0x02	; 2
    5fd2:	3c 93       	st	X, r19
    5fd4:	2e 93       	st	-X, r18
    5fd6:	11 97       	sbiw	r26, 0x01	; 1
    5fd8:	02 83       	std	Z+2, r16	; 0x02
    5fda:	13 82       	std	Z+3, r1	; 0x03
    5fdc:	14 83       	std	Z+4, r17	; 0x04
    5fde:	15 82       	std	Z+5, r1	; 0x05
    5fe0:	66 83       	std	Z+6, r22	; 0x06
    5fe2:	77 83       	std	Z+7, r23	; 0x07
    5fe4:	80 87       	std	Z+8, r24	; 0x08
    5fe6:	91 87       	std	Z+9, r25	; 0x09
    5fe8:	80 91 0e 30 	lds	r24, 0x300E
    5fec:	90 91 0f 30 	lds	r25, 0x300F
    5ff0:	a0 91 10 30 	lds	r26, 0x3010
    5ff4:	b0 91 11 30 	lds	r27, 0x3011
    5ff8:	82 87       	std	Z+10, r24	; 0x0a
    5ffa:	93 87       	std	Z+11, r25	; 0x0b
    5ffc:	a4 87       	std	Z+12, r26	; 0x0c
    5ffe:	b5 87       	std	Z+13, r27	; 0x0d
    6000:	80 91 12 30 	lds	r24, 0x3012
    6004:	90 91 13 30 	lds	r25, 0x3013
    6008:	a0 91 14 30 	lds	r26, 0x3014
    600c:	b0 91 15 30 	lds	r27, 0x3015
    6010:	86 87       	std	Z+14, r24	; 0x0e
    6012:	97 87       	std	Z+15, r25	; 0x0f
    6014:	a0 8b       	std	Z+16, r26	; 0x10
    6016:	b1 8b       	std	Z+17, r27	; 0x11
    6018:	80 91 16 30 	lds	r24, 0x3016
    601c:	90 91 17 30 	lds	r25, 0x3017
    6020:	a0 91 18 30 	lds	r26, 0x3018
    6024:	b0 91 19 30 	lds	r27, 0x3019
    6028:	82 8b       	std	Z+18, r24	; 0x12
    602a:	93 8b       	std	Z+19, r25	; 0x13
    602c:	a4 8b       	std	Z+20, r26	; 0x14
    602e:	b5 8b       	std	Z+21, r27	; 0x15
    6030:	80 91 1a 30 	lds	r24, 0x301A
    6034:	90 91 1b 30 	lds	r25, 0x301B
    6038:	a0 91 1c 30 	lds	r26, 0x301C
    603c:	b0 91 1d 30 	lds	r27, 0x301D
    6040:	86 8b       	std	Z+22, r24	; 0x16
    6042:	97 8b       	std	Z+23, r25	; 0x17
    6044:	a0 8f       	std	Z+24, r26	; 0x18
    6046:	b1 8f       	std	Z+25, r27	; 0x19
    6048:	80 91 1e 30 	lds	r24, 0x301E
    604c:	90 91 1f 30 	lds	r25, 0x301F
    6050:	a0 91 20 30 	lds	r26, 0x3020
    6054:	b0 91 21 30 	lds	r27, 0x3021
    6058:	82 8f       	std	Z+26, r24	; 0x1a
    605a:	93 8f       	std	Z+27, r25	; 0x1b
    605c:	a4 8f       	std	Z+28, r26	; 0x1c
    605e:	b5 8f       	std	Z+29, r27	; 0x1d
    6060:	80 91 22 30 	lds	r24, 0x3022
    6064:	90 91 23 30 	lds	r25, 0x3023
    6068:	a0 91 24 30 	lds	r26, 0x3024
    606c:	b0 91 25 30 	lds	r27, 0x3025
    6070:	86 8f       	std	Z+30, r24	; 0x1e
    6072:	97 8f       	std	Z+31, r25	; 0x1f
    6074:	a0 a3       	std	Z+32, r26	; 0x20
    6076:	b1 a3       	std	Z+33, r27	; 0x21
    6078:	80 91 26 30 	lds	r24, 0x3026
    607c:	90 91 27 30 	lds	r25, 0x3027
    6080:	a0 91 28 30 	lds	r26, 0x3028
    6084:	b0 91 29 30 	lds	r27, 0x3029
    6088:	82 a3       	std	Z+34, r24	; 0x22
    608a:	93 a3       	std	Z+35, r25	; 0x23
    608c:	a4 a3       	std	Z+36, r26	; 0x24
    608e:	b5 a3       	std	Z+37, r27	; 0x25
    6090:	80 91 2a 30 	lds	r24, 0x302A
    6094:	90 91 2b 30 	lds	r25, 0x302B
    6098:	a0 91 2c 30 	lds	r26, 0x302C
    609c:	b0 91 2d 30 	lds	r27, 0x302D
    60a0:	86 a3       	std	Z+38, r24	; 0x26
    60a2:	97 a3       	std	Z+39, r25	; 0x27
    60a4:	a0 a7       	std	Z+40, r26	; 0x28
    60a6:	b1 a7       	std	Z+41, r27	; 0x29
    60a8:	80 91 36 30 	lds	r24, 0x3036
    60ac:	90 91 37 30 	lds	r25, 0x3037
    60b0:	a0 91 38 30 	lds	r26, 0x3038
    60b4:	b0 91 39 30 	lds	r27, 0x3039
    60b8:	82 a7       	std	Z+42, r24	; 0x2a
    60ba:	93 a7       	std	Z+43, r25	; 0x2b
    60bc:	a4 a7       	std	Z+44, r26	; 0x2c
    60be:	b5 a7       	std	Z+45, r27	; 0x2d
    60c0:	80 91 3a 30 	lds	r24, 0x303A
    60c4:	90 91 3b 30 	lds	r25, 0x303B
    60c8:	a0 91 3c 30 	lds	r26, 0x303C
    60cc:	b0 91 3d 30 	lds	r27, 0x303D
    60d0:	86 a7       	std	Z+46, r24	; 0x2e
    60d2:	97 a7       	std	Z+47, r25	; 0x2f
    60d4:	a0 ab       	std	Z+48, r26	; 0x30
    60d6:	b1 ab       	std	Z+49, r27	; 0x31
    60d8:	0e 94 f3 4b 	call	0x97e6	; 0x97e6 <printf_P>
    60dc:	2d b7       	in	r18, 0x3d	; 61
    60de:	3e b7       	in	r19, 0x3e	; 62
    60e0:	2e 5c       	subi	r18, 0xCE	; 206
    60e2:	3f 4f       	sbci	r19, 0xFF	; 255
    60e4:	0f b6       	in	r0, 0x3f	; 63
    60e6:	f8 94       	cli
    60e8:	3e bf       	out	0x3e, r19	; 62
    60ea:	0f be       	out	0x3f, r0	; 63
    60ec:	2d bf       	out	0x3d, r18	; 61
	 energest_total_time[ENERGEST_TYPE_TRANSMIT].current,
	 energest_total_time[ENERGEST_TYPE_LISTEN].current,
	 energest_total_time[ENERGEST_TYPE_SENSORS].current,
	 energest_total_time[ENERGEST_TYPE_SERIAL].current);
#endif /* ENERGEST_CONF_ON */
}
    60ee:	1f 91       	pop	r17
    60f0:	0f 91       	pop	r16
    60f2:	08 95       	ret

000060f4 <random_init>:

/*---------------------------------------------------------------------------*/
void
random_init(unsigned short seed)
{
  srand(seed);
    60f4:	0e 94 36 4b 	call	0x966c	; 0x966c <srand>
}
    60f8:	08 95       	ret

000060fa <random_rand>:
random_rand(void)
{
/* In gcc int rand() uses RAND_MAX and long random() uses RANDOM_MAX=0x7FFFFFFF */
/* RAND_MAX varies depending on the architecture */

  return (unsigned short)rand();
    60fa:	0e 94 31 4b 	call	0x9662	; 0x9662 <rand>
}
    60fe:	08 95       	ret

00006100 <packetbuf_clear_hdr>:
}
/*---------------------------------------------------------------------------*/
void
packetbuf_clear_hdr(void)
{
  hdrptr = PACKETBUF_HDR_SIZE;
    6100:	80 e3       	ldi	r24, 0x30	; 48
    6102:	80 93 c7 26 	sts	0x26C7, r24
}
    6106:	08 95       	ret

00006108 <packetbuf_copyto_hdr>:
  }
}
/*---------------------------------------------------------------------------*/
int
packetbuf_copyto_hdr(uint8_t *to)
{
    6108:	ef 92       	push	r14
    610a:	ff 92       	push	r15
    610c:	cf 93       	push	r28
    610e:	df 93       	push	r29
      PRINTF("0x%02x, ", packetbuf[i]);
    }
    PRINTF("\n");
  }
#endif /* DEBUG_LEVEL */
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
    6110:	20 91 c7 26 	lds	r18, 0x26C7
    6114:	30 e0       	ldi	r19, 0x00	; 0
    6116:	c0 e3       	ldi	r28, 0x30	; 48
    6118:	d0 e0       	ldi	r29, 0x00	; 0
    611a:	c2 1b       	sub	r28, r18
    611c:	d3 0b       	sbc	r29, r19
    611e:	24 53       	subi	r18, 0x34	; 52
    6120:	39 4d       	sbci	r19, 0xD9	; 217
    6122:	b9 01       	movw	r22, r18
    6124:	ae 01       	movw	r20, r28
    6126:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
  return PACKETBUF_HDR_SIZE - hdrptr;
}
    612a:	ce 01       	movw	r24, r28
    612c:	df 91       	pop	r29
    612e:	cf 91       	pop	r28
    6130:	ff 90       	pop	r15
    6132:	ef 90       	pop	r14
    6134:	08 95       	ret

00006136 <packetbuf_copyto>:
/*---------------------------------------------------------------------------*/
int
packetbuf_copyto(void *to)
{
    6136:	af 92       	push	r10
    6138:	bf 92       	push	r11
    613a:	cf 92       	push	r12
    613c:	df 92       	push	r13
    613e:	ef 92       	push	r14
    6140:	ff 92       	push	r15
    6142:	0f 93       	push	r16
    6144:	1f 93       	push	r17
    6146:	cf 93       	push	r28
    6148:	df 93       	push	r29
    614a:	7c 01       	movw	r14, r24
      bufferptr += sprintf(bufferptr, "0x%02x, ", packetbufptr[i]);
    }
    PRINTF("packetbuf_write: data: %s\n", buffer);
  }
#endif /* DEBUG_LEVEL */
  if(PACKETBUF_HDR_SIZE - hdrptr + buflen > PACKETBUF_SIZE) {
    614c:	c0 90 c8 26 	lds	r12, 0x26C8
    6150:	d0 90 c9 26 	lds	r13, 0x26C9
    6154:	20 91 c7 26 	lds	r18, 0x26C7
    6158:	30 e0       	ldi	r19, 0x00	; 0
    615a:	86 01       	movw	r16, r12
    615c:	00 5d       	subi	r16, 0xD0	; 208
    615e:	1f 4f       	sbci	r17, 0xFF	; 255
    6160:	02 1b       	sub	r16, r18
    6162:	13 0b       	sbc	r17, r19
    6164:	01 38       	cpi	r16, 0x81	; 129
    6166:	11 05       	cpc	r17, r1
    6168:	e0 f4       	brcc	.+56     	; 0x61a2 <packetbuf_copyto+0x6c>
    /* Too large packet */
    return 0;
  }
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
    616a:	c0 e3       	ldi	r28, 0x30	; 48
    616c:	d0 e0       	ldi	r29, 0x00	; 0
    616e:	c2 1b       	sub	r28, r18
    6170:	d3 0b       	sbc	r29, r19
    6172:	24 53       	subi	r18, 0x34	; 52
    6174:	39 4d       	sbci	r19, 0xD9	; 217
    6176:	b9 01       	movw	r22, r18
    6178:	ae 01       	movw	r20, r28
    617a:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
  memcpy((uint8_t *)to + PACKETBUF_HDR_SIZE - hdrptr, packetbufptr + bufptr,
    617e:	ce 0d       	add	r28, r14
    6180:	df 1d       	adc	r29, r15
    6182:	20 91 ca 26 	lds	r18, 0x26CA
    6186:	30 91 cb 26 	lds	r19, 0x26CB
    618a:	80 91 7e 27 	lds	r24, 0x277E
    618e:	90 91 7f 27 	lds	r25, 0x277F
    6192:	28 0f       	add	r18, r24
    6194:	39 1f       	adc	r19, r25
    6196:	ce 01       	movw	r24, r28
    6198:	b9 01       	movw	r22, r18
    619a:	a6 01       	movw	r20, r12
    619c:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
	 buflen);
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
    61a0:	02 c0       	rjmp	.+4      	; 0x61a6 <packetbuf_copyto+0x70>
    PRINTF("packetbuf_write: data: %s\n", buffer);
  }
#endif /* DEBUG_LEVEL */
  if(PACKETBUF_HDR_SIZE - hdrptr + buflen > PACKETBUF_SIZE) {
    /* Too large packet */
    return 0;
    61a2:	00 e0       	ldi	r16, 0x00	; 0
    61a4:	10 e0       	ldi	r17, 0x00	; 0
  }
  memcpy(to, packetbuf + hdrptr, PACKETBUF_HDR_SIZE - hdrptr);
  memcpy((uint8_t *)to + PACKETBUF_HDR_SIZE - hdrptr, packetbufptr + bufptr,
	 buflen);
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
}
    61a6:	c8 01       	movw	r24, r16
    61a8:	df 91       	pop	r29
    61aa:	cf 91       	pop	r28
    61ac:	1f 91       	pop	r17
    61ae:	0f 91       	pop	r16
    61b0:	ff 90       	pop	r15
    61b2:	ef 90       	pop	r14
    61b4:	df 90       	pop	r13
    61b6:	cf 90       	pop	r12
    61b8:	bf 90       	pop	r11
    61ba:	af 90       	pop	r10
    61bc:	08 95       	ret

000061be <packetbuf_hdr_remove>:
}
/*---------------------------------------------------------------------------*/
void
packetbuf_hdr_remove(int size)
{
  hdrptr += size;
    61be:	90 91 c7 26 	lds	r25, 0x26C7
    61c2:	98 0f       	add	r25, r24
    61c4:	90 93 c7 26 	sts	0x26C7, r25
}
    61c8:	08 95       	ret

000061ca <packetbuf_hdrreduce>:
/*---------------------------------------------------------------------------*/
int
packetbuf_hdrreduce(int size)
{
  if(buflen < size) {
    61ca:	40 91 c8 26 	lds	r20, 0x26C8
    61ce:	50 91 c9 26 	lds	r21, 0x26C9
    61d2:	9c 01       	movw	r18, r24
    61d4:	48 17       	cp	r20, r24
    61d6:	59 07       	cpc	r21, r25
    61d8:	98 f0       	brcs	.+38     	; 0x6200 <packetbuf_hdrreduce+0x36>
    return 0;
  }

  bufptr += size;
    61da:	80 91 7e 27 	lds	r24, 0x277E
    61de:	90 91 7f 27 	lds	r25, 0x277F
    61e2:	82 0f       	add	r24, r18
    61e4:	93 1f       	adc	r25, r19
    61e6:	90 93 7f 27 	sts	0x277F, r25
    61ea:	80 93 7e 27 	sts	0x277E, r24
  buflen -= size;
    61ee:	42 1b       	sub	r20, r18
    61f0:	53 0b       	sbc	r21, r19
    61f2:	50 93 c9 26 	sts	0x26C9, r21
    61f6:	40 93 c8 26 	sts	0x26C8, r20
  return 1;
    61fa:	21 e0       	ldi	r18, 0x01	; 1
    61fc:	30 e0       	ldi	r19, 0x00	; 0
    61fe:	02 c0       	rjmp	.+4      	; 0x6204 <packetbuf_hdrreduce+0x3a>
/*---------------------------------------------------------------------------*/
int
packetbuf_hdrreduce(int size)
{
  if(buflen < size) {
    return 0;
    6200:	20 e0       	ldi	r18, 0x00	; 0
    6202:	30 e0       	ldi	r19, 0x00	; 0
  }

  bufptr += size;
  buflen -= size;
  return 1;
}
    6204:	c9 01       	movw	r24, r18
    6206:	08 95       	ret

00006208 <packetbuf_set_datalen>:
/*---------------------------------------------------------------------------*/
void
packetbuf_set_datalen(uint16_t len)
{
  PRINTF("packetbuf_set_len: len %d\n", len);
  buflen = len;
    6208:	90 93 c9 26 	sts	0x26C9, r25
    620c:	80 93 c8 26 	sts	0x26C8, r24
}
    6210:	08 95       	ret

00006212 <packetbuf_dataptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_dataptr(void)
{
  return (void *)(&packetbuf[bufptr + PACKETBUF_HDR_SIZE]);
    6212:	20 91 7e 27 	lds	r18, 0x277E
    6216:	30 91 7f 27 	lds	r19, 0x277F
    621a:	24 50       	subi	r18, 0x04	; 4
    621c:	39 4d       	sbci	r19, 0xD9	; 217
}
    621e:	c9 01       	movw	r24, r18
    6220:	08 95       	ret

00006222 <packetbuf_hdrptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_hdrptr(void)
{
  return (void *)(&packetbuf[hdrptr]);
    6222:	20 91 c7 26 	lds	r18, 0x26C7
    6226:	30 e0       	ldi	r19, 0x00	; 0
    6228:	24 53       	subi	r18, 0x34	; 52
    622a:	39 4d       	sbci	r19, 0xD9	; 217
}
    622c:	c9 01       	movw	r24, r18
    622e:	08 95       	ret

00006230 <packetbuf_is_reference>:
}
/*---------------------------------------------------------------------------*/
int
packetbuf_is_reference(void)
{
  return packetbufptr != &packetbuf[PACKETBUF_HDR_SIZE];
    6230:	21 e0       	ldi	r18, 0x01	; 1
    6232:	30 e0       	ldi	r19, 0x00	; 0
    6234:	80 91 ca 26 	lds	r24, 0x26CA
    6238:	90 91 cb 26 	lds	r25, 0x26CB
    623c:	46 e2       	ldi	r20, 0x26	; 38
    623e:	8c 3f       	cpi	r24, 0xFC	; 252
    6240:	94 07       	cpc	r25, r20
    6242:	11 f4       	brne	.+4      	; 0x6248 <packetbuf_is_reference+0x18>
    6244:	20 e0       	ldi	r18, 0x00	; 0
    6246:	30 e0       	ldi	r19, 0x00	; 0
}
    6248:	c9 01       	movw	r24, r18
    624a:	08 95       	ret

0000624c <packetbuf_compact>:
void
packetbuf_compact(void)
{
  int i, len;

  if(packetbuf_is_reference()) {
    624c:	0e 94 18 31 	call	0x6230	; 0x6230 <packetbuf_is_reference>
    6250:	00 97       	sbiw	r24, 0x00	; 0
    6252:	71 f0       	breq	.+28     	; 0x6270 <packetbuf_compact+0x24>
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
    6254:	2c ef       	ldi	r18, 0xFC	; 252
    6256:	36 e2       	ldi	r19, 0x26	; 38
    6258:	60 91 ca 26 	lds	r22, 0x26CA
    625c:	70 91 cb 26 	lds	r23, 0x26CB
    6260:	40 91 c8 26 	lds	r20, 0x26C8
    6264:	50 91 c9 26 	lds	r21, 0x26C9
    6268:	c9 01       	movw	r24, r18
    626a:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    626e:	08 95       	ret
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    6270:	a0 91 7e 27 	lds	r26, 0x277E
    6274:	b0 91 7f 27 	lds	r27, 0x277F
    6278:	10 97       	sbiw	r26, 0x00	; 0
    627a:	b9 f0       	breq	.+46     	; 0x62aa <packetbuf_compact+0x5e>
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    627c:	20 91 c8 26 	lds	r18, 0x26C8
    6280:	30 91 c9 26 	lds	r19, 0x26C9
    6284:	20 5d       	subi	r18, 0xD0	; 208
    6286:	3f 4f       	sbci	r19, 0xFF	; 255
  buflen = l;
  return l;
}
/*---------------------------------------------------------------------------*/
void
packetbuf_compact(void)
    6288:	a4 50       	subi	r26, 0x04	; 4
    628a:	b9 4d       	sbci	r27, 0xD9	; 217
    628c:	ec ef       	ldi	r30, 0xFC	; 252
    628e:	f6 e2       	ldi	r31, 0x26	; 38
  if(packetbuf_is_reference()) {
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    for(i = PACKETBUF_HDR_SIZE; i < len; i++) {
    6290:	80 e3       	ldi	r24, 0x30	; 48
    6292:	90 e0       	ldi	r25, 0x00	; 0
    6294:	03 c0       	rjmp	.+6      	; 0x629c <packetbuf_compact+0x50>
      packetbuf[i] = packetbuf[bufptr + i];
    6296:	4d 91       	ld	r20, X+
    6298:	41 93       	st	Z+, r20
  if(packetbuf_is_reference()) {
    memcpy(&packetbuf[PACKETBUF_HDR_SIZE], packetbuf_reference_ptr(),
	   packetbuf_datalen());
  } else if (bufptr > 0) {
    len = packetbuf_datalen() + PACKETBUF_HDR_SIZE;
    for(i = PACKETBUF_HDR_SIZE; i < len; i++) {
    629a:	01 96       	adiw	r24, 0x01	; 1
    629c:	82 17       	cp	r24, r18
    629e:	93 07       	cpc	r25, r19
    62a0:	d4 f3       	brlt	.-12     	; 0x6296 <packetbuf_compact+0x4a>
      packetbuf[i] = packetbuf[bufptr + i];
    }

    bufptr = 0;
    62a2:	10 92 7f 27 	sts	0x277F, r1
    62a6:	10 92 7e 27 	sts	0x277E, r1
    62aa:	08 95       	ret

000062ac <packetbuf_reference_ptr>:
/*---------------------------------------------------------------------------*/
void *
packetbuf_reference_ptr(void)
{
  return packetbufptr;
}
    62ac:	80 91 ca 26 	lds	r24, 0x26CA
    62b0:	90 91 cb 26 	lds	r25, 0x26CB
    62b4:	08 95       	ret

000062b6 <packetbuf_datalen>:
/*---------------------------------------------------------------------------*/
uint16_t
packetbuf_datalen(void)
{
  return buflen;
}
    62b6:	80 91 c8 26 	lds	r24, 0x26C8
    62ba:	90 91 c9 26 	lds	r25, 0x26C9
    62be:	08 95       	ret

000062c0 <packetbuf_hdrlen>:
/*---------------------------------------------------------------------------*/
uint8_t
packetbuf_hdrlen(void)
{
  return PACKETBUF_HDR_SIZE - hdrptr;
    62c0:	90 91 c7 26 	lds	r25, 0x26C7
}
    62c4:	80 e3       	ldi	r24, 0x30	; 48
    62c6:	89 1b       	sub	r24, r25
    62c8:	08 95       	ret

000062ca <packetbuf_totlen>:
}
/*---------------------------------------------------------------------------*/
uint8_t
packetbuf_hdrlen(void)
{
  return PACKETBUF_HDR_SIZE - hdrptr;
    62ca:	80 e3       	ldi	r24, 0x30	; 48
    62cc:	90 91 c7 26 	lds	r25, 0x26C7
    62d0:	89 1b       	sub	r24, r25
}
/*---------------------------------------------------------------------------*/
uint16_t
packetbuf_totlen(void)
{
  return packetbuf_hdrlen() + packetbuf_datalen();
    62d2:	20 91 c8 26 	lds	r18, 0x26C8
    62d6:	30 91 c9 26 	lds	r19, 0x26C9
    62da:	28 0f       	add	r18, r24
    62dc:	31 1d       	adc	r19, r1
}
    62de:	c9 01       	movw	r24, r18
    62e0:	08 95       	ret

000062e2 <packetbuf_hdralloc>:
  return PACKETBUF_HDR_SIZE - hdrptr + buflen;
}
/*---------------------------------------------------------------------------*/
int
packetbuf_hdralloc(int size)
{
    62e2:	1f 93       	push	r17
    62e4:	cf 93       	push	r28
    62e6:	df 93       	push	r29
    62e8:	ec 01       	movw	r28, r24
  if(hdrptr >= size && packetbuf_totlen() + size <= PACKETBUF_SIZE) {
    62ea:	10 91 c7 26 	lds	r17, 0x26C7
    62ee:	81 2f       	mov	r24, r17
    62f0:	90 e0       	ldi	r25, 0x00	; 0
    62f2:	8c 17       	cp	r24, r28
    62f4:	9d 07       	cpc	r25, r29
    62f6:	6c f0       	brlt	.+26     	; 0x6312 <packetbuf_hdralloc+0x30>
    62f8:	0e 94 65 31 	call	0x62ca	; 0x62ca <packetbuf_totlen>
    62fc:	8c 0f       	add	r24, r28
    62fe:	9d 1f       	adc	r25, r29
    6300:	81 38       	cpi	r24, 0x81	; 129
    6302:	91 05       	cpc	r25, r1
    6304:	30 f4       	brcc	.+12     	; 0x6312 <packetbuf_hdralloc+0x30>
    hdrptr -= size;
    6306:	1c 1b       	sub	r17, r28
    6308:	10 93 c7 26 	sts	0x26C7, r17
    return 1;
    630c:	21 e0       	ldi	r18, 0x01	; 1
    630e:	30 e0       	ldi	r19, 0x00	; 0
    6310:	02 c0       	rjmp	.+4      	; 0x6316 <packetbuf_hdralloc+0x34>
  }
  return 0;
    6312:	20 e0       	ldi	r18, 0x00	; 0
    6314:	30 e0       	ldi	r19, 0x00	; 0
}
    6316:	c9 01       	movw	r24, r18
    6318:	df 91       	pop	r29
    631a:	cf 91       	pop	r28
    631c:	1f 91       	pop	r17
    631e:	08 95       	ret

00006320 <packetbuf_attr_clear>:
  return packetbuf_hdrlen() + packetbuf_datalen();
}
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_clear(void)
{
    6320:	cf 93       	push	r28
    6322:	df 93       	push	r29
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    6324:	ec e6       	ldi	r30, 0x6C	; 108
    6326:	f0 e3       	ldi	r31, 0x30	; 48
    packetbuf_attrs[i].val = 0;
    6328:	11 92       	st	Z+, r1
    632a:	11 92       	st	Z+, r1
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_clear(void)
{
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    632c:	80 e3       	ldi	r24, 0x30	; 48
    632e:	ec 39       	cpi	r30, 0x9C	; 156
    6330:	f8 07       	cpc	r31, r24
    6332:	d1 f7       	brne	.-12     	; 0x6328 <packetbuf_attr_clear+0x8>
    6334:	c0 e0       	ldi	r28, 0x00	; 0
    6336:	d0 e0       	ldi	r29, 0x00	; 0
    packetbuf_attrs[i].val = 0;
  }
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    rimeaddr_copy(&packetbuf_addrs[i].addr, &rimeaddr_null);
    6338:	ce 01       	movw	r24, r28
    633a:	88 0f       	add	r24, r24
    633c:	99 1f       	adc	r25, r25
    633e:	8c 59       	subi	r24, 0x9C	; 156
    6340:	9f 4c       	sbci	r25, 0xCF	; 207
    6342:	66 ee       	ldi	r22, 0xE6	; 230
    6344:	7d e0       	ldi	r23, 0x0D	; 13
    6346:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
{
  int i;
  for(i = 0; i < PACKETBUF_NUM_ATTRS; ++i) {
    packetbuf_attrs[i].val = 0;
  }
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    634a:	21 96       	adiw	r28, 0x01	; 1
    634c:	c4 30       	cpi	r28, 0x04	; 4
    634e:	d1 05       	cpc	r29, r1
    6350:	99 f7       	brne	.-26     	; 0x6338 <packetbuf_attr_clear+0x18>
    rimeaddr_copy(&packetbuf_addrs[i].addr, &rimeaddr_null);
  }
}
    6352:	df 91       	pop	r29
    6354:	cf 91       	pop	r28
    6356:	08 95       	ret

00006358 <packetbuf_clear>:

/*---------------------------------------------------------------------------*/
void
packetbuf_clear(void)
{
  buflen = bufptr = 0;
    6358:	10 92 7f 27 	sts	0x277F, r1
    635c:	10 92 7e 27 	sts	0x277E, r1
    6360:	10 92 c9 26 	sts	0x26C9, r1
    6364:	10 92 c8 26 	sts	0x26C8, r1
  hdrptr = PACKETBUF_HDR_SIZE;
    6368:	80 e3       	ldi	r24, 0x30	; 48
    636a:	80 93 c7 26 	sts	0x26C7, r24

  packetbufptr = &packetbuf[PACKETBUF_HDR_SIZE];
    636e:	8c ef       	ldi	r24, 0xFC	; 252
    6370:	96 e2       	ldi	r25, 0x26	; 38
    6372:	90 93 cb 26 	sts	0x26CB, r25
    6376:	80 93 ca 26 	sts	0x26CA, r24
  packetbuf_attr_clear();
    637a:	0e 94 90 31 	call	0x6320	; 0x6320 <packetbuf_attr_clear>
}
    637e:	08 95       	ret

00006380 <packetbuf_reference>:
  return (void *)(&packetbuf[hdrptr]);
}
/*---------------------------------------------------------------------------*/
void
packetbuf_reference(void *ptr, uint16_t len)
{
    6380:	0f 93       	push	r16
    6382:	1f 93       	push	r17
    6384:	cf 93       	push	r28
    6386:	df 93       	push	r29
    6388:	ec 01       	movw	r28, r24
    638a:	8b 01       	movw	r16, r22
  packetbuf_clear();
    638c:	0e 94 ac 31 	call	0x6358	; 0x6358 <packetbuf_clear>
  packetbufptr = ptr;
    6390:	d0 93 cb 26 	sts	0x26CB, r29
    6394:	c0 93 ca 26 	sts	0x26CA, r28
  buflen = len;
    6398:	10 93 c9 26 	sts	0x26C9, r17
    639c:	00 93 c8 26 	sts	0x26C8, r16
}
    63a0:	df 91       	pop	r29
    63a2:	cf 91       	pop	r28
    63a4:	1f 91       	pop	r17
    63a6:	0f 91       	pop	r16
    63a8:	08 95       	ret

000063aa <packetbuf_copyfrom>:
  hdrptr = PACKETBUF_HDR_SIZE;
}
/*---------------------------------------------------------------------------*/
int
packetbuf_copyfrom(const void *from, uint16_t len)
{
    63aa:	cf 92       	push	r12
    63ac:	df 92       	push	r13
    63ae:	ef 92       	push	r14
    63b0:	ff 92       	push	r15
    63b2:	0f 93       	push	r16
    63b4:	1f 93       	push	r17
    63b6:	df 93       	push	r29
    63b8:	cf 93       	push	r28
    63ba:	00 d0       	rcall	.+0      	; 0x63bc <packetbuf_copyfrom+0x12>
    63bc:	cd b7       	in	r28, 0x3d	; 61
    63be:	de b7       	in	r29, 0x3e	; 62
    63c0:	8c 01       	movw	r16, r24
  uint16_t l;

  packetbuf_clear();
    63c2:	69 83       	std	Y+1, r22	; 0x01
    63c4:	7a 83       	std	Y+2, r23	; 0x02
    63c6:	0e 94 ac 31 	call	0x6358	; 0x6358 <packetbuf_clear>
  l = len > PACKETBUF_SIZE? PACKETBUF_SIZE: len;
    63ca:	69 81       	ldd	r22, Y+1	; 0x01
    63cc:	7a 81       	ldd	r23, Y+2	; 0x02
    63ce:	c6 2e       	mov	r12, r22
    63d0:	d7 2e       	mov	r13, r23
    63d2:	21 e8       	ldi	r18, 0x81	; 129
    63d4:	c2 16       	cp	r12, r18
    63d6:	d1 04       	cpc	r13, r1
    63d8:	18 f0       	brcs	.+6      	; 0x63e0 <packetbuf_copyfrom+0x36>
    63da:	30 e8       	ldi	r19, 0x80	; 128
    63dc:	c3 2e       	mov	r12, r19
    63de:	d1 2c       	mov	r13, r1
  memcpy(packetbufptr, from, l);
    63e0:	80 91 ca 26 	lds	r24, 0x26CA
    63e4:	90 91 cb 26 	lds	r25, 0x26CB
    63e8:	b8 01       	movw	r22, r16
    63ea:	a6 01       	movw	r20, r12
    63ec:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
  buflen = l;
    63f0:	d0 92 c9 26 	sts	0x26C9, r13
    63f4:	c0 92 c8 26 	sts	0x26C8, r12
  return l;
}
    63f8:	c6 01       	movw	r24, r12
    63fa:	0f 90       	pop	r0
    63fc:	0f 90       	pop	r0
    63fe:	cf 91       	pop	r28
    6400:	df 91       	pop	r29
    6402:	1f 91       	pop	r17
    6404:	0f 91       	pop	r16
    6406:	ff 90       	pop	r15
    6408:	ef 90       	pop	r14
    640a:	df 90       	pop	r13
    640c:	cf 90       	pop	r12
    640e:	08 95       	ret

00006410 <packetbuf_attr_copyto>:
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_copyto(struct packetbuf_attr *attrs,
		    struct packetbuf_addr *addrs)
{
  memcpy(attrs, packetbuf_attrs, sizeof(packetbuf_attrs));
    6410:	28 2f       	mov	r18, r24
    6412:	39 2f       	mov	r19, r25
    6414:	d9 01       	movw	r26, r18
    6416:	ec e6       	ldi	r30, 0x6C	; 108
    6418:	f0 e3       	ldi	r31, 0x30	; 48
    641a:	80 e3       	ldi	r24, 0x30	; 48
    641c:	01 90       	ld	r0, Z+
    641e:	0d 92       	st	X+, r0
    6420:	81 50       	subi	r24, 0x01	; 1
    6422:	e1 f7       	brne	.-8      	; 0x641c <packetbuf_attr_copyto+0xc>
  memcpy(addrs, packetbuf_addrs, sizeof(packetbuf_addrs));
    6424:	86 2f       	mov	r24, r22
    6426:	97 2f       	mov	r25, r23
    6428:	dc 01       	movw	r26, r24
    642a:	e4 e6       	ldi	r30, 0x64	; 100
    642c:	f0 e3       	ldi	r31, 0x30	; 48
    642e:	88 e0       	ldi	r24, 0x08	; 8
    6430:	01 90       	ld	r0, Z+
    6432:	0d 92       	st	X+, r0
    6434:	81 50       	subi	r24, 0x01	; 1
    6436:	e1 f7       	brne	.-8      	; 0x6430 <packetbuf_attr_copyto+0x20>
}
    6438:	08 95       	ret

0000643a <packetbuf_attr_copyfrom>:
/*---------------------------------------------------------------------------*/
void
packetbuf_attr_copyfrom(struct packetbuf_attr *attrs,
		      struct packetbuf_addr *addrs)
{
  memcpy(packetbuf_attrs, attrs, sizeof(packetbuf_attrs));
    643a:	ec e6       	ldi	r30, 0x6C	; 108
    643c:	f0 e3       	ldi	r31, 0x30	; 48
    643e:	28 2f       	mov	r18, r24
    6440:	39 2f       	mov	r19, r25
    6442:	d9 01       	movw	r26, r18
    6444:	80 e3       	ldi	r24, 0x30	; 48
    6446:	0d 90       	ld	r0, X+
    6448:	01 92       	st	Z+, r0
    644a:	81 50       	subi	r24, 0x01	; 1
    644c:	e1 f7       	brne	.-8      	; 0x6446 <packetbuf_attr_copyfrom+0xc>
  memcpy(packetbuf_addrs, addrs, sizeof(packetbuf_addrs));
    644e:	a4 e6       	ldi	r26, 0x64	; 100
    6450:	b0 e3       	ldi	r27, 0x30	; 48
    6452:	86 2f       	mov	r24, r22
    6454:	97 2f       	mov	r25, r23
    6456:	fc 01       	movw	r30, r24
    6458:	88 e0       	ldi	r24, 0x08	; 8
    645a:	01 90       	ld	r0, Z+
    645c:	0d 92       	st	X+, r0
    645e:	81 50       	subi	r24, 0x01	; 1
    6460:	e1 f7       	brne	.-8      	; 0x645a <packetbuf_attr_copyfrom+0x20>
}
    6462:	08 95       	ret

00006464 <packetbuf_set_attr>:
#if !PACKETBUF_CONF_ATTRS_INLINE
int
packetbuf_set_attr(uint8_t type, const packetbuf_attr_t val)
{
/*   packetbuf_attrs[type].type = type; */
  packetbuf_attrs[type].val = val;
    6464:	e8 2f       	mov	r30, r24
    6466:	f0 e0       	ldi	r31, 0x00	; 0
    6468:	ee 0f       	add	r30, r30
    646a:	ff 1f       	adc	r31, r31
    646c:	e4 59       	subi	r30, 0x94	; 148
    646e:	ff 4c       	sbci	r31, 0xCF	; 207
    6470:	71 83       	std	Z+1, r23	; 0x01
    6472:	60 83       	st	Z, r22
  return 1;
}
    6474:	81 e0       	ldi	r24, 0x01	; 1
    6476:	90 e0       	ldi	r25, 0x00	; 0
    6478:	08 95       	ret

0000647a <packetbuf_attr>:
/*---------------------------------------------------------------------------*/
packetbuf_attr_t
packetbuf_attr(uint8_t type)
{
  return packetbuf_attrs[type].val;
    647a:	e8 2f       	mov	r30, r24
    647c:	f0 e0       	ldi	r31, 0x00	; 0
    647e:	ee 0f       	add	r30, r30
    6480:	ff 1f       	adc	r31, r31
    6482:	e4 59       	subi	r30, 0x94	; 148
    6484:	ff 4c       	sbci	r31, 0xCF	; 207
}
    6486:	80 81       	ld	r24, Z
    6488:	91 81       	ldd	r25, Z+1	; 0x01
    648a:	08 95       	ret

0000648c <packetbuf_set_addr>:
/*---------------------------------------------------------------------------*/
int
packetbuf_set_addr(uint8_t type, const rimeaddr_t *addr)
{
/*   packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].type = type; */
  rimeaddr_copy(&packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr, addr);
    648c:	90 e0       	ldi	r25, 0x00	; 0
    648e:	88 0f       	add	r24, r24
    6490:	99 1f       	adc	r25, r25
    6492:	8c 5c       	subi	r24, 0xCC	; 204
    6494:	9f 4c       	sbci	r25, 0xCF	; 207
    6496:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
  return 1;
}
    649a:	81 e0       	ldi	r24, 0x01	; 1
    649c:	90 e0       	ldi	r25, 0x00	; 0
    649e:	08 95       	ret

000064a0 <packetbuf_addr>:
/*---------------------------------------------------------------------------*/
const rimeaddr_t *
packetbuf_addr(uint8_t type)
{
  return &packetbuf_addrs[type - PACKETBUF_ADDR_FIRST].addr;
    64a0:	28 2f       	mov	r18, r24
    64a2:	30 e0       	ldi	r19, 0x00	; 0
    64a4:	22 0f       	add	r18, r18
    64a6:	33 1f       	adc	r19, r19
    64a8:	2c 5c       	subi	r18, 0xCC	; 204
    64aa:	3f 4c       	sbci	r19, 0xCF	; 207
}
    64ac:	c9 01       	movw	r24, r18
    64ae:	08 95       	ret

000064b0 <queuebuf_init>:
  for(i=0; i<NQBUF_FILES; i++) {
    qbuf_files[i].renewable = 1;
    qbuf_renew_file(i);
  }
#endif
  memb_init(&buframmem);
    64b0:	81 e5       	ldi	r24, 0x51	; 81
    64b2:	9e e0       	ldi	r25, 0x0E	; 14
    64b4:	0e 94 b8 39 	call	0x7370	; 0x7370 <memb_init>
  memb_init(&bufmem);
    64b8:	81 e4       	ldi	r24, 0x41	; 65
    64ba:	9e e0       	ldi	r25, 0x0E	; 14
    64bc:	0e 94 b8 39 	call	0x7370	; 0x7370 <memb_init>
  memb_init(&refbufmem);
    64c0:	89 e4       	ldi	r24, 0x49	; 73
    64c2:	9e e0       	ldi	r25, 0x0E	; 14
    64c4:	0e 94 b8 39 	call	0x7370	; 0x7370 <memb_init>
#if QUEUEBUF_STATS
  queuebuf_max_len = QUEUEBUF_NUM;
#endif /* QUEUEBUF_STATS */
}
    64c8:	08 95       	ret

000064ca <queuebuf_new_from_packetbuf>:
queuebuf_new_from_packetbuf_debug(const char *file, int line)
#else /* QUEUEBUF_DEBUG */
struct queuebuf *
queuebuf_new_from_packetbuf(void)
#endif /* QUEUEBUF_DEBUG */
{
    64ca:	ef 92       	push	r14
    64cc:	ff 92       	push	r15
    64ce:	0f 93       	push	r16
    64d0:	1f 93       	push	r17
    64d2:	cf 93       	push	r28
    64d4:	df 93       	push	r29
  struct queuebuf *buf;
  struct queuebuf_ref *rbuf;

  if(packetbuf_is_reference()) {
    64d6:	0e 94 18 31 	call	0x6230	; 0x6230 <packetbuf_is_reference>
    64da:	00 97       	sbiw	r24, 0x00	; 0
    64dc:	c9 f0       	breq	.+50     	; 0x6510 <queuebuf_new_from_packetbuf+0x46>
    rbuf = memb_alloc(&refbufmem);
    64de:	89 e4       	ldi	r24, 0x49	; 73
    64e0:	9e e0       	ldi	r25, 0x0E	; 14
    64e2:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <memb_alloc>
    64e6:	e8 2e       	mov	r14, r24
    64e8:	e7 01       	movw	r28, r14
    64ea:	7e 01       	movw	r14, r28
    64ec:	f9 2e       	mov	r15, r25
    64ee:	e7 01       	movw	r28, r14
    if(rbuf != NULL) {
    64f0:	20 97       	sbiw	r28, 0x00	; 0
    64f2:	91 f1       	breq	.+100    	; 0x6558 <queuebuf_new_from_packetbuf+0x8e>
#if QUEUEBUF_STATS
      ++queuebuf_ref_len;
#endif /* QUEUEBUF_STATS */
      rbuf->len = packetbuf_datalen();
    64f4:	0e 94 5b 31 	call	0x62b6	; 0x62b6 <packetbuf_datalen>
    64f8:	99 83       	std	Y+1, r25	; 0x01
    64fa:	88 83       	st	Y, r24
      rbuf->ref = packetbuf_reference_ptr();
    64fc:	0e 94 56 31 	call	0x62ac	; 0x62ac <packetbuf_reference_ptr>
    6500:	9b 83       	std	Y+3, r25	; 0x03
    6502:	8a 83       	std	Y+2, r24	; 0x02
      rbuf->hdrlen = packetbuf_copyto_hdr(rbuf->hdr);
    6504:	c7 01       	movw	r24, r14
    6506:	04 96       	adiw	r24, 0x04	; 4
    6508:	0e 94 84 30 	call	0x6108	; 0x6108 <packetbuf_copyto_hdr>
    650c:	8c ab       	std	Y+52, r24	; 0x34
    } else {
      PRINTF("queuebuf_new_from_packetbuf: could not allocate a reference queuebuf\n");
    }
    return (struct queuebuf *)rbuf;
    650e:	24 c0       	rjmp	.+72     	; 0x6558 <queuebuf_new_from_packetbuf+0x8e>
  } else {
    struct queuebuf_data *buframptr;
    buf = memb_alloc(&bufmem);
    6510:	81 e4       	ldi	r24, 0x41	; 65
    6512:	9e e0       	ldi	r25, 0x0E	; 14
    6514:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <memb_alloc>
    6518:	ec 01       	movw	r28, r24
    651a:	7e 01       	movw	r14, r28
    651c:	f9 2e       	mov	r15, r25
    651e:	e7 01       	movw	r28, r14
    if(buf != NULL) {
    6520:	20 97       	sbiw	r28, 0x00	; 0
    6522:	d1 f0       	breq	.+52     	; 0x6558 <queuebuf_new_from_packetbuf+0x8e>
      list_add(queuebuf_list, buf);
      buf->file = file;
      buf->line = line;
      buf->time = clock_time();
#endif /* QUEUEBUF_DEBUG */
      buf->ram_ptr = memb_alloc(&buframmem);
    6524:	81 e5       	ldi	r24, 0x51	; 81
    6526:	9e e0       	ldi	r25, 0x0E	; 14
    6528:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <memb_alloc>
    652c:	8c 01       	movw	r16, r24
    652e:	99 83       	std	Y+1, r25	; 0x01
    6530:	88 83       	st	Y, r24
        buf->swap_id = -1;
        tmpdata_qbuf = buf;
        buframptr = &tmpdata;
      }
#else
      if(buf->ram_ptr == NULL) {
    6532:	00 97       	sbiw	r24, 0x00	; 0
    6534:	79 f0       	breq	.+30     	; 0x6554 <queuebuf_new_from_packetbuf+0x8a>
        return NULL;
      }
      buframptr = buf->ram_ptr;
#endif

      buframptr->len = packetbuf_copyto(buframptr->data);
    6536:	02 96       	adiw	r24, 0x02	; 2
    6538:	0e 94 9b 30 	call	0x6136	; 0x6136 <packetbuf_copyto>
    653c:	f8 01       	movw	r30, r16
    653e:	91 83       	std	Z+1, r25	; 0x01
    6540:	80 83       	st	Z, r24
      packetbuf_attr_copyto(buframptr->attrs, buframptr->addrs);
    6542:	b8 01       	movw	r22, r16
    6544:	6e 54       	subi	r22, 0x4E	; 78
    6546:	7f 4f       	sbci	r23, 0xFF	; 255
    6548:	c8 01       	movw	r24, r16
    654a:	8e 57       	subi	r24, 0x7E	; 126
    654c:	9f 4f       	sbci	r25, 0xFF	; 255
    654e:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_attr_copyto>
    6552:	02 c0       	rjmp	.+4      	; 0x6558 <queuebuf_new_from_packetbuf+0x8e>
        buframptr = &tmpdata;
      }
#else
      if(buf->ram_ptr == NULL) {
        PRINTF("queuebuf_new_from_packetbuf: could not queuebuf data\n");
        return NULL;
    6554:	c0 e0       	ldi	r28, 0x00	; 0
    6556:	d0 e0       	ldi	r29, 0x00	; 0
    } else {
      PRINTF("queuebuf_new_from_packetbuf: could not allocate a queuebuf\n");
    }
    return buf;
  }
}
    6558:	ce 01       	movw	r24, r28
    655a:	df 91       	pop	r29
    655c:	cf 91       	pop	r28
    655e:	1f 91       	pop	r17
    6560:	0f 91       	pop	r16
    6562:	ff 90       	pop	r15
    6564:	ef 90       	pop	r14
    6566:	08 95       	ret

00006568 <queuebuf_update_attr_from_packetbuf>:
#else /* WITH_SWAP */
/*---------------------------------------------------------------------------*/
static struct queuebuf_data *
queuebuf_load_to_ram(struct queuebuf *b)
{
  return b->ram_ptr;
    6568:	fc 01       	movw	r30, r24
    656a:	80 81       	ld	r24, Z
    656c:	91 81       	ldd	r25, Z+1	; 0x01
/*---------------------------------------------------------------------------*/
void
queuebuf_update_attr_from_packetbuf(struct queuebuf *buf)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(buf);
  packetbuf_attr_copyto(buframptr->attrs, buframptr->addrs);
    656e:	bc 01       	movw	r22, r24
    6570:	6e 54       	subi	r22, 0x4E	; 78
    6572:	7f 4f       	sbci	r23, 0xFF	; 255
    6574:	8e 57       	subi	r24, 0x7E	; 126
    6576:	9f 4f       	sbci	r25, 0xFF	; 255
    6578:	0e 94 08 32 	call	0x6410	; 0x6410 <packetbuf_attr_copyto>
#if WITH_SWAP
  if(buf->location == IN_CFS) {
    queuebuf_flush_tmpdata();
  }
#endif
}
    657c:	08 95       	ret

0000657e <queuebuf_free>:
/*---------------------------------------------------------------------------*/
void
queuebuf_free(struct queuebuf *buf)
{
    657e:	cf 93       	push	r28
    6580:	df 93       	push	r29
    6582:	ec 01       	movw	r28, r24
  if(memb_inmemb(&bufmem, buf)) {
    6584:	81 e4       	ldi	r24, 0x41	; 65
    6586:	9e e0       	ldi	r25, 0x0E	; 14
    6588:	be 01       	movw	r22, r28
    658a:	0e 94 23 3a 	call	0x7446	; 0x7446 <memb_inmemb>
    658e:	00 97       	sbiw	r24, 0x00	; 0
    6590:	49 f0       	breq	.+18     	; 0x65a4 <queuebuf_free+0x26>
      memb_free(&buframmem, buf->ram_ptr);
    } else {
      queuebuf_remove_from_file(buf->swap_id);
    }
#else
    memb_free(&buframmem, buf->ram_ptr);
    6592:	68 81       	ld	r22, Y
    6594:	79 81       	ldd	r23, Y+1	; 0x01
    6596:	81 e5       	ldi	r24, 0x51	; 81
    6598:	9e e0       	ldi	r25, 0x0E	; 14
    659a:	0e 94 fe 39 	call	0x73fc	; 0x73fc <memb_free>
#endif
    memb_free(&bufmem, buf);
    659e:	81 e4       	ldi	r24, 0x41	; 65
    65a0:	9e e0       	ldi	r25, 0x0E	; 14
    65a2:	09 c0       	rjmp	.+18     	; 0x65b6 <queuebuf_free+0x38>
    printf("#A q=%d\n", queuebuf_len);
#endif /* QUEUEBUF_STATS */
#if QUEUEBUF_DEBUG
    list_remove(queuebuf_list, buf);
#endif /* QUEUEBUF_DEBUG */
  } else if(memb_inmemb(&refbufmem, buf)) {
    65a4:	89 e4       	ldi	r24, 0x49	; 73
    65a6:	9e e0       	ldi	r25, 0x0E	; 14
    65a8:	be 01       	movw	r22, r28
    65aa:	0e 94 23 3a 	call	0x7446	; 0x7446 <memb_inmemb>
    65ae:	00 97       	sbiw	r24, 0x00	; 0
    65b0:	29 f0       	breq	.+10     	; 0x65bc <queuebuf_free+0x3e>
    memb_free(&refbufmem, buf);
    65b2:	89 e4       	ldi	r24, 0x49	; 73
    65b4:	9e e0       	ldi	r25, 0x0E	; 14
    65b6:	be 01       	movw	r22, r28
    65b8:	0e 94 fe 39 	call	0x73fc	; 0x73fc <memb_free>
#if QUEUEBUF_STATS
    --queuebuf_ref_len;
#endif /* QUEUEBUF_STATS */
  }
}
    65bc:	df 91       	pop	r29
    65be:	cf 91       	pop	r28
    65c0:	08 95       	ret

000065c2 <queuebuf_to_packetbuf>:
/*---------------------------------------------------------------------------*/
void
queuebuf_to_packetbuf(struct queuebuf *b)
{
    65c2:	ef 92       	push	r14
    65c4:	ff 92       	push	r15
    65c6:	cf 93       	push	r28
    65c8:	df 93       	push	r29
    65ca:	ec 01       	movw	r28, r24
  struct queuebuf_ref *r;
  if(memb_inmemb(&bufmem, b)) {
    65cc:	81 e4       	ldi	r24, 0x41	; 65
    65ce:	9e e0       	ldi	r25, 0x0E	; 14
    65d0:	be 01       	movw	r22, r28
    65d2:	0e 94 23 3a 	call	0x7446	; 0x7446 <memb_inmemb>
    65d6:	00 97       	sbiw	r24, 0x00	; 0
    65d8:	91 f0       	breq	.+36     	; 0x65fe <queuebuf_to_packetbuf+0x3c>
#else /* WITH_SWAP */
/*---------------------------------------------------------------------------*/
static struct queuebuf_data *
queuebuf_load_to_ram(struct queuebuf *b)
{
  return b->ram_ptr;
    65da:	09 90       	ld	r0, Y+
    65dc:	d8 81       	ld	r29, Y
    65de:	c0 2d       	mov	r28, r0
queuebuf_to_packetbuf(struct queuebuf *b)
{
  struct queuebuf_ref *r;
  if(memb_inmemb(&bufmem, b)) {
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    packetbuf_copyfrom(buframptr->data, buframptr->len);
    65e0:	68 81       	ld	r22, Y
    65e2:	79 81       	ldd	r23, Y+1	; 0x01
    65e4:	ce 01       	movw	r24, r28
    65e6:	02 96       	adiw	r24, 0x02	; 2
    65e8:	0e 94 d5 31 	call	0x63aa	; 0x63aa <packetbuf_copyfrom>
    packetbuf_attr_copyfrom(buframptr->attrs, buframptr->addrs);
    65ec:	be 01       	movw	r22, r28
    65ee:	6e 54       	subi	r22, 0x4E	; 78
    65f0:	7f 4f       	sbci	r23, 0xFF	; 255
    65f2:	ce 01       	movw	r24, r28
    65f4:	8e 57       	subi	r24, 0x7E	; 126
    65f6:	9f 4f       	sbci	r25, 0xFF	; 255
    65f8:	0e 94 1d 32 	call	0x643a	; 0x643a <packetbuf_attr_copyfrom>
    65fc:	1b c0       	rjmp	.+54     	; 0x6634 <queuebuf_to_packetbuf+0x72>
  } else if(memb_inmemb(&refbufmem, b)) {
    65fe:	89 e4       	ldi	r24, 0x49	; 73
    6600:	9e e0       	ldi	r25, 0x0E	; 14
    6602:	be 01       	movw	r22, r28
    6604:	0e 94 23 3a 	call	0x7446	; 0x7446 <memb_inmemb>
    6608:	00 97       	sbiw	r24, 0x00	; 0
    660a:	a1 f0       	breq	.+40     	; 0x6634 <queuebuf_to_packetbuf+0x72>
    r = (struct queuebuf_ref *)b;
    packetbuf_clear();
    660c:	0e 94 ac 31 	call	0x6358	; 0x6358 <packetbuf_clear>
    packetbuf_copyfrom(r->ref, r->len);
    6610:	68 81       	ld	r22, Y
    6612:	79 81       	ldd	r23, Y+1	; 0x01
    6614:	8a 81       	ldd	r24, Y+2	; 0x02
    6616:	9b 81       	ldd	r25, Y+3	; 0x03
    6618:	0e 94 d5 31 	call	0x63aa	; 0x63aa <packetbuf_copyfrom>
    packetbuf_hdralloc(r->hdrlen);
    661c:	8c a9       	ldd	r24, Y+52	; 0x34
    661e:	90 e0       	ldi	r25, 0x00	; 0
    6620:	0e 94 71 31 	call	0x62e2	; 0x62e2 <packetbuf_hdralloc>
    memcpy(packetbuf_hdrptr(), r->hdr, r->hdrlen);
    6624:	0e 94 11 31 	call	0x6222	; 0x6222 <packetbuf_hdrptr>
    6628:	4c a9       	ldd	r20, Y+52	; 0x34
    662a:	24 96       	adiw	r28, 0x04	; 4
    662c:	be 01       	movw	r22, r28
    662e:	50 e0       	ldi	r21, 0x00	; 0
    6630:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
  }
}
    6634:	df 91       	pop	r29
    6636:	cf 91       	pop	r28
    6638:	ff 90       	pop	r15
    663a:	ef 90       	pop	r14
    663c:	08 95       	ret

0000663e <queuebuf_dataptr>:
/*---------------------------------------------------------------------------*/
void *
queuebuf_dataptr(struct queuebuf *b)
{
    663e:	cf 93       	push	r28
    6640:	df 93       	push	r29
    6642:	ec 01       	movw	r28, r24
  struct queuebuf_ref *r;

  if(memb_inmemb(&bufmem, b)) {
    6644:	81 e4       	ldi	r24, 0x41	; 65
    6646:	9e e0       	ldi	r25, 0x0E	; 14
    6648:	be 01       	movw	r22, r28
    664a:	0e 94 23 3a 	call	0x7446	; 0x7446 <memb_inmemb>
    664e:	00 97       	sbiw	r24, 0x00	; 0
    6650:	29 f0       	breq	.+10     	; 0x665c <queuebuf_dataptr+0x1e>
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    return buframptr->data;
    6652:	28 81       	ld	r18, Y
    6654:	39 81       	ldd	r19, Y+1	; 0x01
    6656:	2e 5f       	subi	r18, 0xFE	; 254
    6658:	3f 4f       	sbci	r19, 0xFF	; 255
    665a:	0c c0       	rjmp	.+24     	; 0x6674 <queuebuf_dataptr+0x36>
  } else if(memb_inmemb(&refbufmem, b)) {
    665c:	89 e4       	ldi	r24, 0x49	; 73
    665e:	9e e0       	ldi	r25, 0x0E	; 14
    6660:	be 01       	movw	r22, r28
    6662:	0e 94 23 3a 	call	0x7446	; 0x7446 <memb_inmemb>
    6666:	00 97       	sbiw	r24, 0x00	; 0
    6668:	19 f0       	breq	.+6      	; 0x6670 <queuebuf_dataptr+0x32>
    r = (struct queuebuf_ref *)b;
    return r->ref;
    666a:	2a 81       	ldd	r18, Y+2	; 0x02
    666c:	3b 81       	ldd	r19, Y+3	; 0x03
    666e:	02 c0       	rjmp	.+4      	; 0x6674 <queuebuf_dataptr+0x36>
  }
  return NULL;
    6670:	20 e0       	ldi	r18, 0x00	; 0
    6672:	30 e0       	ldi	r19, 0x00	; 0
}
    6674:	c9 01       	movw	r24, r18
    6676:	df 91       	pop	r29
    6678:	cf 91       	pop	r28
    667a:	08 95       	ret

0000667c <queuebuf_datalen>:
/*---------------------------------------------------------------------------*/
int
queuebuf_datalen(struct queuebuf *b)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return buframptr->len;
    667c:	dc 01       	movw	r26, r24
    667e:	ed 91       	ld	r30, X+
    6680:	fc 91       	ld	r31, X
    6682:	11 97       	sbiw	r26, 0x01	; 1
}
    6684:	80 81       	ld	r24, Z
    6686:	91 81       	ldd	r25, Z+1	; 0x01
    6688:	08 95       	ret

0000668a <queuebuf_addr>:
/*---------------------------------------------------------------------------*/
rimeaddr_t *
queuebuf_addr(struct queuebuf *b, uint8_t type)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return &buframptr->addrs[type - PACKETBUF_ADDR_FIRST].addr;
    668a:	70 e0       	ldi	r23, 0x00	; 0
    668c:	6f 5b       	subi	r22, 0xBF	; 191
    668e:	7f 4f       	sbci	r23, 0xFF	; 255
    6690:	66 0f       	add	r22, r22
    6692:	77 1f       	adc	r23, r23
    6694:	fc 01       	movw	r30, r24
    6696:	20 81       	ld	r18, Z
    6698:	31 81       	ldd	r19, Z+1	; 0x01
    669a:	26 0f       	add	r18, r22
    669c:	37 1f       	adc	r19, r23
}
    669e:	c9 01       	movw	r24, r18
    66a0:	08 95       	ret

000066a2 <queuebuf_attr>:
/*---------------------------------------------------------------------------*/
packetbuf_attr_t
queuebuf_attr(struct queuebuf *b, uint8_t type)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  return buframptr->attrs[type].val;
    66a2:	dc 01       	movw	r26, r24
    66a4:	ed 91       	ld	r30, X+
    66a6:	fc 91       	ld	r31, X
    66a8:	11 97       	sbiw	r26, 0x01	; 1
    66aa:	70 e0       	ldi	r23, 0x00	; 0
    66ac:	6f 5b       	subi	r22, 0xBF	; 191
    66ae:	7f 4f       	sbci	r23, 0xFF	; 255
    66b0:	66 0f       	add	r22, r22
    66b2:	77 1f       	adc	r23, r23
    66b4:	e6 0f       	add	r30, r22
    66b6:	f7 1f       	adc	r31, r23
}
    66b8:	80 81       	ld	r24, Z
    66ba:	91 81       	ldd	r25, Z+1	; 0x01
    66bc:	08 95       	ret

000066be <queuebuf_debug_print>:
      q = list_item_next(q)) {
    printf("%s,%d,%lu ", q->file, q->line, q->time);
  }
  printf("\n");
#endif /* QUEUEBUF_DEBUG */
}
    66be:	08 95       	ret

000066c0 <start_periodic_tcp_timer>:

/*---------------------------------------------------------------------------*/
static void
start_periodic_tcp_timer(void)
{
  if(etimer_expired(&periodic)) {
    66c0:	8e ee       	ldi	r24, 0xEE	; 238
    66c2:	9d e2       	ldi	r25, 0x2D	; 45
    66c4:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <etimer_expired>
    66c8:	00 97       	sbiw	r24, 0x00	; 0
    66ca:	21 f0       	breq	.+8      	; 0x66d4 <start_periodic_tcp_timer+0x14>
    etimer_restart(&periodic);
    66cc:	8e ee       	ldi	r24, 0xEE	; 238
    66ce:	9d e2       	ldi	r25, 0x2D	; 45
    66d0:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <etimer_restart>
    66d4:	08 95       	ret

000066d6 <tcpip_output>:

static uint8_t (* outputfunc)(void);
uint8_t
tcpip_output(void)
{
  if(outputfunc != NULL) {
    66d6:	e0 91 fb 2d 	lds	r30, 0x2DFB
    66da:	f0 91 fc 2d 	lds	r31, 0x2DFC
    66de:	30 97       	sbiw	r30, 0x00	; 0
    66e0:	11 f0       	breq	.+4      	; 0x66e6 <tcpip_output+0x10>
    return outputfunc();
    66e2:	09 95       	icall
    66e4:	08 95       	ret
  }
  UIP_LOG("tcpip_output: Use tcpip_set_outputfunc() to set an output function");
  return 0;
    66e6:	80 e0       	ldi	r24, 0x00	; 0
}
    66e8:	08 95       	ret

000066ea <process_thread_tcpip_process>:
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
{
    66ea:	ef 92       	push	r14
    66ec:	ff 92       	push	r15
    66ee:	0f 93       	push	r16
    66f0:	1f 93       	push	r17
    66f2:	cf 93       	push	r28
    66f4:	df 93       	push	r29
    66f6:	ec 01       	movw	r28, r24
    66f8:	8a 01       	movw	r16, r20
  PROCESS_BEGIN();
    66fa:	88 81       	ld	r24, Y
    66fc:	99 81       	ldd	r25, Y+1	; 0x01
    66fe:	00 97       	sbiw	r24, 0x00	; 0
    6700:	31 f0       	breq	.+12     	; 0x670e <process_thread_tcpip_process+0x24>
    6702:	23 e0       	ldi	r18, 0x03	; 3
    6704:	80 30       	cpi	r24, 0x00	; 0
    6706:	92 07       	cpc	r25, r18
    6708:	09 f0       	breq	.+2      	; 0x670c <process_thread_tcpip_process+0x22>
    670a:	06 c1       	rjmp	.+524    	; 0x6918 <process_thread_tcpip_process+0x22e>
    670c:	2b c0       	rjmp	.+86     	; 0x6764 <process_thread_tcpip_process+0x7a>
  
#if UIP_TCP
 {
   static unsigned char i;
   
   for(i = 0; i < UIP_LISTENPORTS; ++i) {
    670e:	80 e0       	ldi	r24, 0x00	; 0
    6710:	0b c0       	rjmp	.+22     	; 0x6728 <process_thread_tcpip_process+0x3e>
     s.listenports[i].port = 0;
    6712:	e8 2f       	mov	r30, r24
    6714:	f0 e0       	ldi	r31, 0x00	; 0
    6716:	ee 0f       	add	r30, r30
    6718:	ff 1f       	adc	r31, r31
    671a:	ee 0f       	add	r30, r30
    671c:	ff 1f       	adc	r31, r31
    671e:	e4 52       	subi	r30, 0x24	; 36
    6720:	f2 4d       	sbci	r31, 0xD2	; 210
    6722:	11 82       	std	Z+1, r1	; 0x01
    6724:	10 82       	st	Z, r1
    6726:	8f 5f       	subi	r24, 0xFF	; 255
  
#if UIP_TCP
 {
   static unsigned char i;
   
   for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6728:	84 30       	cpi	r24, 0x04	; 4
    672a:	98 f3       	brcs	.-26     	; 0x6712 <process_thread_tcpip_process+0x28>
    672c:	80 93 f6 2d 	sts	0x2DF6, r24
     s.listenports[i].port = 0;
   }
   s.p = PROCESS_CURRENT();
    6730:	80 91 46 25 	lds	r24, 0x2546
    6734:	90 91 47 25 	lds	r25, 0x2547
    6738:	90 93 ed 2d 	sts	0x2DED, r25
    673c:	80 93 ec 2d 	sts	0x2DEC, r24
 }
#endif

  tcpip_event = process_alloc_event();
    6740:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <process_alloc_event>
    6744:	80 93 9c 30 	sts	0x309C, r24
#if UIP_CONF_ICMP6
  tcpip_icmp6_event = process_alloc_event();
#endif /* UIP_CONF_ICMP6 */
  etimer_set(&periodic, CLOCK_SECOND / 2);
    6748:	8e ee       	ldi	r24, 0xEE	; 238
    674a:	9d e2       	ldi	r25, 0x2D	; 45
    674c:	60 e4       	ldi	r22, 0x40	; 64
    674e:	70 e0       	ldi	r23, 0x00	; 0
    6750:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <etimer_set>

  uip_init();
    6754:	0e 94 08 3b 	call	0x7610	; 0x7610 <uip_init>
#if UIP_CONF_IPV6_RPL
  rpl_init();
#endif /* UIP_CONF_IPV6_RPL */

  while(1) {
    PROCESS_YIELD();
    6758:	80 e0       	ldi	r24, 0x00	; 0
    675a:	93 e0       	ldi	r25, 0x03	; 3
    675c:	99 83       	std	Y+1, r25	; 0x01
    675e:	88 83       	st	Y, r24
    6760:	81 e0       	ldi	r24, 0x01	; 1
    6762:	dd c0       	rjmp	.+442    	; 0x691e <process_thread_tcpip_process+0x234>
  static unsigned char i;
  register struct listenport *l;
#endif /*UIP_TCP*/
  struct process *p;
   
  switch(ev) {
    6764:	62 30       	cpi	r22, 0x02	; 2
    6766:	09 f4       	brne	.+2      	; 0x676a <process_thread_tcpip_process+0x80>
    6768:	b9 c0       	rjmp	.+370    	; 0x68dc <process_thread_tcpip_process+0x1f2>
    676a:	63 30       	cpi	r22, 0x03	; 3
    676c:	30 f4       	brcc	.+12     	; 0x677a <process_thread_tcpip_process+0x90>
    676e:	66 23       	and	r22, r22
    6770:	09 f4       	brne	.+2      	; 0x6774 <process_thread_tcpip_process+0x8a>
    6772:	89 c0       	rjmp	.+274    	; 0x6886 <process_thread_tcpip_process+0x19c>
    6774:	61 30       	cpi	r22, 0x01	; 1
    6776:	81 f7       	brne	.-32     	; 0x6758 <process_thread_tcpip_process+0x6e>
    6778:	9c c0       	rjmp	.+312    	; 0x68b2 <process_thread_tcpip_process+0x1c8>
    677a:	67 38       	cpi	r22, 0x87	; 135
    677c:	19 f0       	breq	.+6      	; 0x6784 <process_thread_tcpip_process+0x9a>
    677e:	68 38       	cpi	r22, 0x88	; 136
    6780:	59 f7       	brne	.-42     	; 0x6758 <process_thread_tcpip_process+0x6e>
    6782:	41 c0       	rjmp	.+130    	; 0x6806 <process_thread_tcpip_process+0x11c>
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6784:	10 92 f7 2d 	sts	0x2DF7, r1
         connections or listening TCP ports. If so, we'll close those
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
    6788:	4c ed       	ldi	r20, 0xDC	; 220
    678a:	e4 2e       	mov	r14, r20
    678c:	4d e2       	ldi	r20, 0x2D	; 45
    678e:	f4 2e       	mov	r15, r20
    6790:	18 c0       	rjmp	.+48     	; 0x67c2 <process_thread_tcpip_process+0xd8>
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
        if(l->p == p) {
    6792:	f7 01       	movw	r30, r14
    6794:	82 81       	ldd	r24, Z+2	; 0x02
    6796:	93 81       	ldd	r25, Z+3	; 0x03
    6798:	80 17       	cp	r24, r16
    679a:	91 07       	cpc	r25, r17
    679c:	49 f4       	brne	.+18     	; 0x67b0 <process_thread_tcpip_process+0xc6>
          uip_unlisten(l->port);
    679e:	80 81       	ld	r24, Z
    67a0:	91 81       	ldd	r25, Z+1	; 0x01
    67a2:	0e 94 4f 3c 	call	0x789e	; 0x789e <uip_unlisten>
          l->port = 0;
    67a6:	f7 01       	movw	r30, r14
    67a8:	11 82       	std	Z+1, r1	; 0x01
    67aa:	10 82       	st	Z, r1
          l->p = PROCESS_NONE;
    67ac:	13 82       	std	Z+3, r1	; 0x03
    67ae:	12 82       	std	Z+2, r1	; 0x02
        }
        ++l;
    67b0:	84 e0       	ldi	r24, 0x04	; 4
    67b2:	90 e0       	ldi	r25, 0x00	; 0
    67b4:	e8 0e       	add	r14, r24
    67b6:	f9 1e       	adc	r15, r25
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
    67b8:	80 91 f7 2d 	lds	r24, 0x2DF7
    67bc:	8f 5f       	subi	r24, 0xFF	; 255
    67be:	80 93 f7 2d 	sts	0x2DF7, r24
    67c2:	80 91 f7 2d 	lds	r24, 0x2DF7
    67c6:	84 30       	cpi	r24, 0x04	; 4
    67c8:	20 f3       	brcs	.-56     	; 0x6792 <process_thread_tcpip_process+0xa8>
  if(ts->p != NULL) {
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
    67ca:	ec ea       	ldi	r30, 0xAC	; 172
    67cc:	f5 e3       	ldi	r31, 0x35	; 53
	 
      {
        register struct uip_conn *cptr;
	    
        for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_CONNS]; ++cptr) {
          if(cptr->appstate.p == p) {
    67ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    67d0:	95 8d       	ldd	r25, Z+29	; 0x1d
    67d2:	80 17       	cp	r24, r16
    67d4:	91 07       	cpc	r25, r17
    67d6:	19 f4       	brne	.+6      	; 0x67de <process_thread_tcpip_process+0xf4>
            cptr->appstate.p = PROCESS_NONE;
    67d8:	15 8e       	std	Z+29, r1	; 0x1d
    67da:	14 8e       	std	Z+28, r1	; 0x1c
            cptr->tcpstateflags = UIP_CLOSED;
    67dc:	11 8e       	std	Z+25, r1	; 0x19
      }
	 
      {
        register struct uip_conn *cptr;
	    
        for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_CONNS]; ++cptr) {
    67de:	b0 96       	adiw	r30, 0x20	; 32
    67e0:	96 e3       	ldi	r25, 0x36	; 54
    67e2:	ec 32       	cpi	r30, 0x2C	; 44
    67e4:	f9 07       	cpc	r31, r25
    67e6:	99 f7       	brne	.-26     	; 0x67ce <process_thread_tcpip_process+0xe4>
  if(ts->p != NULL) {
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
    67e8:	e2 e4       	ldi	r30, 0x42	; 66
    67ea:	f6 e3       	ldi	r31, 0x36	; 54
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
            cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
          if(cptr->appstate.p == p) {
    67ec:	81 85       	ldd	r24, Z+9	; 0x09
    67ee:	92 85       	ldd	r25, Z+10	; 0x0a
    67f0:	80 17       	cp	r24, r16
    67f2:	91 07       	cpc	r25, r17
    67f4:	11 f4       	brne	.+4      	; 0x67fa <process_thread_tcpip_process+0x110>
            cptr->lport = 0;
    67f6:	15 82       	std	Z+5, r1	; 0x05
    67f8:	14 82       	std	Z+4, r1	; 0x04
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
            cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
    67fa:	3d 96       	adiw	r30, 0x0d	; 13
#endif /* UIP_TCP */
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
    67fc:	26 e3       	ldi	r18, 0x36	; 54
    67fe:	e4 3c       	cpi	r30, 0xC4	; 196
    6800:	f2 07       	cpc	r31, r18
    6802:	a1 f7       	brne	.-24     	; 0x67ec <process_thread_tcpip_process+0x102>
    6804:	a9 cf       	rjmp	.-174    	; 0x6758 <process_thread_tcpip_process+0x6e>
    case PROCESS_EVENT_TIMER:
      /* We get this event if one of our timers have expired. */
      {
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
    6806:	8d e2       	ldi	r24, 0x2D	; 45
    6808:	4e 3e       	cpi	r20, 0xEE	; 238
    680a:	58 07       	cpc	r21, r24
    680c:	09 f0       	breq	.+2      	; 0x6810 <process_thread_tcpip_process+0x126>
    680e:	a4 cf       	rjmp	.-184    	; 0x6758 <process_thread_tcpip_process+0x6e>
           etimer_expired(&periodic)) {
    6810:	ca 01       	movw	r24, r20
    6812:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <etimer_expired>
    case PROCESS_EVENT_TIMER:
      /* We get this event if one of our timers have expired. */
      {
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
    6816:	00 97       	sbiw	r24, 0x00	; 0
    6818:	09 f4       	brne	.+2      	; 0x681c <process_thread_tcpip_process+0x132>
    681a:	9e cf       	rjmp	.-196    	; 0x6758 <process_thread_tcpip_process+0x6e>
           etimer_expired(&periodic)) {
#if UIP_TCP
          for(i = 0; i < UIP_CONNS; ++i) {
    681c:	10 92 f7 2d 	sts	0x2DF7, r1
    6820:	2d c0       	rjmp	.+90     	; 0x687c <process_thread_tcpip_process+0x192>
            if(uip_conn_active(i)) {
    6822:	f0 e0       	ldi	r31, 0x00	; 0
    6824:	35 e0       	ldi	r19, 0x05	; 5
    6826:	ee 0f       	add	r30, r30
    6828:	ff 1f       	adc	r31, r31
    682a:	3a 95       	dec	r19
    682c:	e1 f7       	brne	.-8      	; 0x6826 <process_thread_tcpip_process+0x13c>
    682e:	e4 55       	subi	r30, 0x54	; 84
    6830:	fa 4c       	sbci	r31, 0xCA	; 202
    6832:	81 8d       	ldd	r24, Z+25	; 0x19
    6834:	88 23       	and	r24, r24
    6836:	e9 f0       	breq	.+58     	; 0x6872 <process_thread_tcpip_process+0x188>
              /* Only restart the timer if there are active
                 connections. */
              etimer_restart(&periodic);
    6838:	8e ee       	ldi	r24, 0xEE	; 238
    683a:	9d e2       	ldi	r25, 0x2D	; 45
    683c:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <etimer_restart>
              uip_periodic(i);
    6840:	80 91 f7 2d 	lds	r24, 0x2DF7
    6844:	90 e0       	ldi	r25, 0x00	; 0
    6846:	25 e0       	ldi	r18, 0x05	; 5
    6848:	88 0f       	add	r24, r24
    684a:	99 1f       	adc	r25, r25
    684c:	2a 95       	dec	r18
    684e:	e1 f7       	brne	.-8      	; 0x6848 <process_thread_tcpip_process+0x15e>
    6850:	84 55       	subi	r24, 0x54	; 84
    6852:	9a 4c       	sbci	r25, 0xCA	; 202
    6854:	90 93 ab 35 	sts	0x35AB, r25
    6858:	80 93 aa 35 	sts	0x35AA, r24
    685c:	82 e0       	ldi	r24, 0x02	; 2
    685e:	0e 94 83 3c 	call	0x7906	; 0x7906 <uip_process>
#if UIP_CONF_IPV6
              tcpip_ipv6_output();
#else
              if(uip_len > 0) {
    6862:	80 91 9d 30 	lds	r24, 0x309D
    6866:	90 91 9e 30 	lds	r25, 0x309E
    686a:	00 97       	sbiw	r24, 0x00	; 0
    686c:	11 f0       	breq	.+4      	; 0x6872 <process_thread_tcpip_process+0x188>
		PRINTF("tcpip_output from periodic len %d\n", uip_len);
                tcpip_output();
    686e:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <tcpip_output>
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
           etimer_expired(&periodic)) {
#if UIP_TCP
          for(i = 0; i < UIP_CONNS; ++i) {
    6872:	80 91 f7 2d 	lds	r24, 0x2DF7
    6876:	8f 5f       	subi	r24, 0xFF	; 255
    6878:	80 93 f7 2d 	sts	0x2DF7, r24
    687c:	e0 91 f7 2d 	lds	r30, 0x2DF7
    6880:	e4 30       	cpi	r30, 0x04	; 4
    6882:	78 f2       	brcs	.-98     	; 0x6822 <process_thread_tcpip_process+0x138>
    6884:	69 cf       	rjmp	.-302    	; 0x6758 <process_thread_tcpip_process+0x6e>
      }
      break;
	 
#if UIP_TCP
    case TCP_POLL:
      if(data != NULL) {
    6886:	41 15       	cp	r20, r1
    6888:	51 05       	cpc	r21, r1
    688a:	09 f4       	brne	.+2      	; 0x688e <process_thread_tcpip_process+0x1a4>
    688c:	65 cf       	rjmp	.-310    	; 0x6758 <process_thread_tcpip_process+0x6e>
        uip_poll_conn(data);
    688e:	50 93 ab 35 	sts	0x35AB, r21
    6892:	40 93 aa 35 	sts	0x35AA, r20
    6896:	83 e0       	ldi	r24, 0x03	; 3
    6898:	0e 94 83 3c 	call	0x7906	; 0x7906 <uip_process>
#if UIP_CONF_IPV6
        tcpip_ipv6_output();
#else /* UIP_CONF_IPV6 */
        if(uip_len > 0) {
    689c:	80 91 9d 30 	lds	r24, 0x309D
    68a0:	90 91 9e 30 	lds	r25, 0x309E
    68a4:	00 97       	sbiw	r24, 0x00	; 0
    68a6:	11 f0       	breq	.+4      	; 0x68ac <process_thread_tcpip_process+0x1c2>
	  PRINTF("tcpip_output from tcp poll len %d\n", uip_len);
          tcpip_output();
    68a8:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <tcpip_output>
        }
#endif /* UIP_CONF_IPV6 */
        /* Start the periodic polling, if it isn't already active. */
        start_periodic_tcp_timer();
    68ac:	0e 94 60 33 	call	0x66c0	; 0x66c0 <start_periodic_tcp_timer>
    68b0:	53 cf       	rjmp	.-346    	; 0x6758 <process_thread_tcpip_process+0x6e>
      }
      break;
#endif /* UIP_TCP */
#if UIP_UDP
    case UDP_POLL:
      if(data != NULL) {
    68b2:	41 15       	cp	r20, r1
    68b4:	51 05       	cpc	r21, r1
    68b6:	09 f4       	brne	.+2      	; 0x68ba <process_thread_tcpip_process+0x1d0>
    68b8:	4f cf       	rjmp	.-354    	; 0x6758 <process_thread_tcpip_process+0x6e>
        uip_udp_periodic_conn(data);
    68ba:	50 93 a7 35 	sts	0x35A7, r21
    68be:	40 93 a6 35 	sts	0x35A6, r20
    68c2:	85 e0       	ldi	r24, 0x05	; 5
    68c4:	0e 94 83 3c 	call	0x7906	; 0x7906 <uip_process>
#if UIP_CONF_IPV6
        tcpip_ipv6_output();
#else
        if(uip_len > 0) {
    68c8:	80 91 9d 30 	lds	r24, 0x309D
    68cc:	90 91 9e 30 	lds	r25, 0x309E
    68d0:	00 97       	sbiw	r24, 0x00	; 0
    68d2:	09 f4       	brne	.+2      	; 0x68d6 <process_thread_tcpip_process+0x1ec>
    68d4:	41 cf       	rjmp	.-382    	; 0x6758 <process_thread_tcpip_process+0x6e>
          tcpip_output();
    68d6:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <tcpip_output>
    68da:	3e cf       	rjmp	.-388    	; 0x6758 <process_thread_tcpip_process+0x6e>
      }
    }
    tcpip_is_forwarding = 0;
  }
#else /* UIP_CONF_IP_FORWARD */
  if(uip_len > 0) {
    68dc:	80 91 9d 30 	lds	r24, 0x309D
    68e0:	90 91 9e 30 	lds	r25, 0x309E
    68e4:	00 97       	sbiw	r24, 0x00	; 0
    68e6:	09 f4       	brne	.+2      	; 0x68ea <process_thread_tcpip_process+0x200>
    68e8:	37 cf       	rjmp	.-402    	; 0x6758 <process_thread_tcpip_process+0x6e>
     an incoming packet contains a SYN: since uIP does not inform the
     application if a SYN arrives, we have no other way of starting
     this timer.  This function is called for every incoming IP packet
     to check for such SYNs. */
#define TCP_SYN 0x02
  if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
    68ea:	80 91 ae 30 	lds	r24, 0x30AE
    68ee:	86 30       	cpi	r24, 0x06	; 6
    68f0:	31 f4       	brne	.+12     	; 0x68fe <process_thread_tcpip_process+0x214>
     (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
    68f2:	80 91 c6 30 	lds	r24, 0x30C6
     an incoming packet contains a SYN: since uIP does not inform the
     application if a SYN arrives, we have no other way of starting
     this timer.  This function is called for every incoming IP packet
     to check for such SYNs. */
#define TCP_SYN 0x02
  if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
    68f6:	81 ff       	sbrs	r24, 1
    68f8:	02 c0       	rjmp	.+4      	; 0x68fe <process_thread_tcpip_process+0x214>
     (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
    start_periodic_tcp_timer();
    68fa:	0e 94 60 33 	call	0x66c0	; 0x66c0 <start_periodic_tcp_timer>
    tcpip_is_forwarding = 0;
  }
#else /* UIP_CONF_IP_FORWARD */
  if(uip_len > 0) {
    check_for_tcp_syn();
    uip_input();
    68fe:	81 e0       	ldi	r24, 0x01	; 1
    6900:	0e 94 83 3c 	call	0x7906	; 0x7906 <uip_process>
    if(uip_len > 0) {
    6904:	80 91 9d 30 	lds	r24, 0x309D
    6908:	90 91 9e 30 	lds	r25, 0x309E
    690c:	00 97       	sbiw	r24, 0x00	; 0
    690e:	09 f4       	brne	.+2      	; 0x6912 <process_thread_tcpip_process+0x228>
    6910:	23 cf       	rjmp	.-442    	; 0x6758 <process_thread_tcpip_process+0x6e>
#if UIP_CONF_TCP_SPLIT
      uip_split_output();
    6912:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <uip_split_output>
    6916:	20 cf       	rjmp	.-448    	; 0x6758 <process_thread_tcpip_process+0x6e>
  while(1) {
    PROCESS_YIELD();
    eventhandler(ev, data);
  }
  
  PROCESS_END();
    6918:	19 82       	std	Y+1, r1	; 0x01
    691a:	18 82       	st	Y, r1
    691c:	83 e0       	ldi	r24, 0x03	; 3
}
    691e:	df 91       	pop	r29
    6920:	cf 91       	pop	r28
    6922:	1f 91       	pop	r17
    6924:	0f 91       	pop	r16
    6926:	ff 90       	pop	r15
    6928:	ef 90       	pop	r14
    692a:	08 95       	ret

0000692c <tcpip_set_outputfunc>:
}

void
tcpip_set_outputfunc(uint8_t (*f)(void))
{
  outputfunc = f;
    692c:	90 93 fc 2d 	sts	0x2DFC, r25
    6930:	80 93 fb 2d 	sts	0x2DFB, r24
}
    6934:	08 95       	ret

00006936 <tcp_unlisten>:
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    if(l->port == port &&
       l->p == PROCESS_CURRENT()) {
    6936:	20 91 46 25 	lds	r18, 0x2546
    693a:	30 91 47 25 	lds	r19, 0x2547
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    693e:	60 e0       	ldi	r22, 0x00	; 0
tcp_unlisten(uint16_t port)
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
    6940:	ec ed       	ldi	r30, 0xDC	; 220
    6942:	fd e2       	ldi	r31, 0x2D	; 45
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6944:	13 c0       	rjmp	.+38     	; 0x696c <tcp_unlisten+0x36>
    if(l->port == port &&
    6946:	40 81       	ld	r20, Z
    6948:	51 81       	ldd	r21, Z+1	; 0x01
    694a:	48 17       	cp	r20, r24
    694c:	59 07       	cpc	r21, r25
    694e:	61 f4       	brne	.+24     	; 0x6968 <tcp_unlisten+0x32>
    6950:	42 81       	ldd	r20, Z+2	; 0x02
    6952:	53 81       	ldd	r21, Z+3	; 0x03
    6954:	42 17       	cp	r20, r18
    6956:	53 07       	cpc	r21, r19
    6958:	39 f4       	brne	.+14     	; 0x6968 <tcp_unlisten+0x32>
    695a:	60 93 fa 2d 	sts	0x2DFA, r22
       l->p == PROCESS_CURRENT()) {
      l->port = 0;
    695e:	11 82       	std	Z+1, r1	; 0x01
    6960:	10 82       	st	Z, r1
      uip_unlisten(port);
    6962:	0e 94 4f 3c 	call	0x789e	; 0x789e <uip_unlisten>
      break;
    6966:	08 95       	ret
    }
    ++l;
    6968:	34 96       	adiw	r30, 0x04	; 4
    696a:	6f 5f       	subi	r22, 0xFF	; 255
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    696c:	64 30       	cpi	r22, 0x04	; 4
    696e:	58 f3       	brcs	.-42     	; 0x6946 <tcp_unlisten+0x10>
    6970:	60 93 fa 2d 	sts	0x2DFA, r22
    6974:	08 95       	ret

00006976 <tcp_listen>:
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6976:	40 e0       	ldi	r20, 0x00	; 0
tcp_listen(uint16_t port)
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
    6978:	ec ed       	ldi	r30, 0xDC	; 220
    697a:	fd e2       	ldi	r31, 0x2D	; 45
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    697c:	16 c0       	rjmp	.+44     	; 0x69aa <tcp_listen+0x34>
    697e:	54 2f       	mov	r21, r20
    6980:	5f 5f       	subi	r21, 0xFF	; 255
    if(l->port == 0) {
    6982:	20 81       	ld	r18, Z
    6984:	31 81       	ldd	r19, Z+1	; 0x01
    6986:	21 15       	cp	r18, r1
    6988:	31 05       	cpc	r19, r1
    698a:	69 f4       	brne	.+26     	; 0x69a6 <tcp_listen+0x30>
    698c:	40 93 f9 2d 	sts	0x2DF9, r20
      l->port = port;
    6990:	91 83       	std	Z+1, r25	; 0x01
    6992:	80 83       	st	Z, r24
      l->p = PROCESS_CURRENT();
    6994:	20 91 46 25 	lds	r18, 0x2546
    6998:	30 91 47 25 	lds	r19, 0x2547
    699c:	33 83       	std	Z+3, r19	; 0x03
    699e:	22 83       	std	Z+2, r18	; 0x02
      uip_listen(port);
    69a0:	0e 94 69 3c 	call	0x78d2	; 0x78d2 <uip_listen>
      break;
    69a4:	08 95       	ret
    }
    ++l;
    69a6:	34 96       	adiw	r30, 0x04	; 4
    69a8:	45 2f       	mov	r20, r21
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    69aa:	44 30       	cpi	r20, 0x04	; 4
    69ac:	40 f3       	brcs	.-48     	; 0x697e <tcp_listen+0x8>
    69ae:	40 93 f9 2d 	sts	0x2DF9, r20
    69b2:	08 95       	ret

000069b4 <tcp_attach>:
}
/*---------------------------------------------------------------------------*/
void
tcp_attach(struct uip_conn *conn,
	   void *appstate)
{
    69b4:	fc 01       	movw	r30, r24
  register uip_tcp_appstate_t *s;

  s = &conn->appstate;
  s->p = PROCESS_CURRENT();
    69b6:	80 91 46 25 	lds	r24, 0x2546
    69ba:	90 91 47 25 	lds	r25, 0x2547
    69be:	95 8f       	std	Z+29, r25	; 0x1d
    69c0:	84 8f       	std	Z+28, r24	; 0x1c
  s->state = appstate;
    69c2:	77 8f       	std	Z+31, r23	; 0x1f
    69c4:	66 8f       	std	Z+30, r22	; 0x1e
}
    69c6:	08 95       	ret

000069c8 <udp_attach>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP
void
udp_attach(struct uip_udp_conn *conn,
	   void *appstate)
{
    69c8:	fc 01       	movw	r30, r24
  register uip_udp_appstate_t *s;

  s = &conn->appstate;
  s->p = PROCESS_CURRENT();
    69ca:	80 91 46 25 	lds	r24, 0x2546
    69ce:	90 91 47 25 	lds	r25, 0x2547
    69d2:	92 87       	std	Z+10, r25	; 0x0a
    69d4:	81 87       	std	Z+9, r24	; 0x09
  s->state = appstate;
    69d6:	74 87       	std	Z+12, r23	; 0x0c
    69d8:	63 87       	std	Z+11, r22	; 0x0b
}
    69da:	08 95       	ret

000069dc <udp_new>:
/*---------------------------------------------------------------------------*/
struct uip_udp_conn *
udp_new(const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)
{
    69dc:	cf 93       	push	r28
    69de:	df 93       	push	r29
    69e0:	ea 01       	movw	r28, r20
  struct uip_udp_conn *c;
  uip_udp_appstate_t *s;
  
  c = uip_udp_new(ripaddr, port);
    69e2:	0e 94 cb 3b 	call	0x7796	; 0x7796 <uip_udp_new>
    69e6:	fc 01       	movw	r30, r24
  if(c == NULL) {
    69e8:	00 97       	sbiw	r24, 0x00	; 0
    69ea:	41 f0       	breq	.+16     	; 0x69fc <udp_new+0x20>
    return NULL;
  }

  s = &c->appstate;
  s->p = PROCESS_CURRENT();
    69ec:	80 91 46 25 	lds	r24, 0x2546
    69f0:	90 91 47 25 	lds	r25, 0x2547
    69f4:	92 87       	std	Z+10, r25	; 0x0a
    69f6:	81 87       	std	Z+9, r24	; 0x09
  s->state = appstate;
    69f8:	d4 87       	std	Z+12, r29	; 0x0c
    69fa:	c3 87       	std	Z+11, r28	; 0x0b

  return c;
}
    69fc:	cf 01       	movw	r24, r30
    69fe:	df 91       	pop	r29
    6a00:	cf 91       	pop	r28
    6a02:	08 95       	ret

00006a04 <udp_broadcast_new>:
/*---------------------------------------------------------------------------*/
struct uip_udp_conn *
udp_broadcast_new(uint16_t port, void *appstate)
{
    6a04:	0f 93       	push	r16
    6a06:	1f 93       	push	r17
    6a08:	df 93       	push	r29
    6a0a:	cf 93       	push	r28
    6a0c:	00 d0       	rcall	.+0      	; 0x6a0e <udp_broadcast_new+0xa>
    6a0e:	00 d0       	rcall	.+0      	; 0x6a10 <udp_broadcast_new+0xc>
    6a10:	cd b7       	in	r28, 0x3d	; 61
    6a12:	de b7       	in	r29, 0x3e	; 62
    6a14:	8c 01       	movw	r16, r24
    6a16:	ab 01       	movw	r20, r22
  struct uip_udp_conn *conn;

#if UIP_CONF_IPV6
  uip_create_linklocal_allnodes_mcast(&addr);
#else
  uip_ipaddr(&addr, 255,255,255,255);
    6a18:	8f ef       	ldi	r24, 0xFF	; 255
    6a1a:	89 83       	std	Y+1, r24	; 0x01
    6a1c:	8a 83       	std	Y+2, r24	; 0x02
    6a1e:	8b 83       	std	Y+3, r24	; 0x03
    6a20:	8c 83       	std	Y+4, r24	; 0x04
#endif /* UIP_CONF_IPV6 */
  conn = udp_new(&addr, port, appstate);
    6a22:	ce 01       	movw	r24, r28
    6a24:	01 96       	adiw	r24, 0x01	; 1
    6a26:	b8 01       	movw	r22, r16
    6a28:	0e 94 ee 34 	call	0x69dc	; 0x69dc <udp_new>
    6a2c:	fc 01       	movw	r30, r24
  if(conn != NULL) {
    6a2e:	00 97       	sbiw	r24, 0x00	; 0
    6a30:	11 f0       	breq	.+4      	; 0x6a36 <udp_broadcast_new+0x32>
    udp_bind(conn, port);
    6a32:	15 83       	std	Z+5, r17	; 0x05
    6a34:	04 83       	std	Z+4, r16	; 0x04
  }
  return conn;
}
    6a36:	cf 01       	movw	r24, r30
    6a38:	0f 90       	pop	r0
    6a3a:	0f 90       	pop	r0
    6a3c:	0f 90       	pop	r0
    6a3e:	0f 90       	pop	r0
    6a40:	cf 91       	pop	r28
    6a42:	df 91       	pop	r29
    6a44:	1f 91       	pop	r17
    6a46:	0f 91       	pop	r16
    6a48:	08 95       	ret

00006a4a <tcpip_input>:
}
/*---------------------------------------------------------------------------*/
void
tcpip_input(void)
{
  process_post_synch(&tcpip_process, PACKET_INPUT, NULL);
    6a4a:	86 e6       	ldi	r24, 0x66	; 102
    6a4c:	9e e0       	ldi	r25, 0x0E	; 14
    6a4e:	62 e0       	ldi	r22, 0x02	; 2
    6a50:	40 e0       	ldi	r20, 0x00	; 0
    6a52:	50 e0       	ldi	r21, 0x00	; 0
    6a54:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <process_post_synch>
  uip_len = 0;
    6a58:	10 92 9e 30 	sts	0x309E, r1
    6a5c:	10 92 9d 30 	sts	0x309D, r1
#if UIP_CONF_IPV6
  uip_ext_len = 0;
#endif /*UIP_CONF_IPV6*/
}
    6a60:	08 95       	ret

00006a62 <tcpip_poll_udp>:
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
void
tcpip_poll_udp(struct uip_udp_conn *conn)
{
    6a62:	ac 01       	movw	r20, r24
  process_post(&tcpip_process, UDP_POLL, conn);
    6a64:	86 e6       	ldi	r24, 0x66	; 102
    6a66:	9e e0       	ldi	r25, 0x0E	; 14
    6a68:	61 e0       	ldi	r22, 0x01	; 1
    6a6a:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <process_post>
}
    6a6e:	08 95       	ret

00006a70 <tcpip_poll_tcp>:
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
#if UIP_TCP
void
tcpip_poll_tcp(struct uip_conn *conn)
{
    6a70:	ac 01       	movw	r20, r24
  process_post(&tcpip_process, TCP_POLL, conn);
    6a72:	86 e6       	ldi	r24, 0x66	; 102
    6a74:	9e e0       	ldi	r25, 0x0E	; 14
    6a76:	60 e0       	ldi	r22, 0x00	; 0
    6a78:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <process_post>
}
    6a7c:	08 95       	ret

00006a7e <tcp_connect>:
/*---------------------------------------------------------------------------*/
#if UIP_TCP
#if UIP_ACTIVE_OPEN
struct uip_conn *
tcp_connect(uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)
{
    6a7e:	0f 93       	push	r16
    6a80:	1f 93       	push	r17
    6a82:	cf 93       	push	r28
    6a84:	df 93       	push	r29
    6a86:	ea 01       	movw	r28, r20
  struct uip_conn *c;
  
  c = uip_connect(ripaddr, port);
    6a88:	0e 94 41 3b 	call	0x7682	; 0x7682 <uip_connect>
    6a8c:	8c 01       	movw	r16, r24
  if(c == NULL) {
    6a8e:	00 97       	sbiw	r24, 0x00	; 0
    6a90:	61 f0       	breq	.+24     	; 0x6aaa <tcp_connect+0x2c>
    return NULL;
  }

  c->appstate.p = PROCESS_CURRENT();
    6a92:	80 91 46 25 	lds	r24, 0x2546
    6a96:	90 91 47 25 	lds	r25, 0x2547
    6a9a:	f8 01       	movw	r30, r16
    6a9c:	95 8f       	std	Z+29, r25	; 0x1d
    6a9e:	84 8f       	std	Z+28, r24	; 0x1c
  c->appstate.state = appstate;
    6aa0:	d7 8f       	std	Z+31, r29	; 0x1f
    6aa2:	c6 8f       	std	Z+30, r28	; 0x1e
  
  tcpip_poll_tcp(c);
    6aa4:	c8 01       	movw	r24, r16
    6aa6:	0e 94 38 35 	call	0x6a70	; 0x6a70 <tcpip_poll_tcp>
  
  return c;
}
    6aaa:	c8 01       	movw	r24, r16
    6aac:	df 91       	pop	r29
    6aae:	cf 91       	pop	r28
    6ab0:	1f 91       	pop	r17
    6ab2:	0f 91       	pop	r16
    6ab4:	08 95       	ret

00006ab6 <tcpip_uipcall>:
}
#endif /* UIP_TCP */
/*---------------------------------------------------------------------------*/
void
tcpip_uipcall(void)
{
    6ab6:	cf 93       	push	r28
    6ab8:	df 93       	push	r29
  register uip_udp_appstate_t *ts;
  
#if UIP_UDP
  if(uip_conn != NULL) {
    6aba:	a0 91 aa 35 	lds	r26, 0x35AA
    6abe:	b0 91 ab 35 	lds	r27, 0x35AB
    6ac2:	10 97       	sbiw	r26, 0x00	; 0
    6ac4:	19 f0       	breq	.+6      	; 0x6acc <tcpip_uipcall+0x16>
    ts = &uip_conn->appstate;
    6ac6:	ed 01       	movw	r28, r26
    6ac8:	6c 96       	adiw	r28, 0x1c	; 28
    6aca:	05 c0       	rjmp	.+10     	; 0x6ad6 <tcpip_uipcall+0x20>
  } else {
    ts = &uip_udp_conn->appstate;
    6acc:	c0 91 a6 35 	lds	r28, 0x35A6
    6ad0:	d0 91 a7 35 	lds	r29, 0x35A7
    6ad4:	29 96       	adiw	r28, 0x09	; 9
   static unsigned char i;
   register struct listenport *l;
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
    6ad6:	80 91 a5 35 	lds	r24, 0x35A5
    6ada:	86 ff       	sbrs	r24, 6
    6adc:	22 c0       	rjmp	.+68     	; 0x6b22 <tcpip_uipcall+0x6c>
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6ade:	10 92 f8 2d 	sts	0x2DF8, r1
    6ae2:	40 e0       	ldi	r20, 0x00	; 0
   register struct listenport *l;
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
    6ae4:	ec ed       	ldi	r30, 0xDC	; 220
    6ae6:	fd e2       	ldi	r31, 0x2D	; 45
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6ae8:	16 c0       	rjmp	.+44     	; 0x6b16 <tcpip_uipcall+0x60>
       if(l->port == uip_conn->lport &&
    6aea:	20 81       	ld	r18, Z
    6aec:	31 81       	ldd	r19, Z+1	; 0x01
    6aee:	14 96       	adiw	r26, 0x04	; 4
    6af0:	8d 91       	ld	r24, X+
    6af2:	9c 91       	ld	r25, X
    6af4:	15 97       	sbiw	r26, 0x05	; 5
    6af6:	28 17       	cp	r18, r24
    6af8:	39 07       	cpc	r19, r25
    6afa:	59 f4       	brne	.+22     	; 0x6b12 <tcpip_uipcall+0x5c>
	  l->p != PROCESS_NONE) {
    6afc:	82 81       	ldd	r24, Z+2	; 0x02
    6afe:	93 81       	ldd	r25, Z+3	; 0x03
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
       if(l->port == uip_conn->lport &&
    6b00:	00 97       	sbiw	r24, 0x00	; 0
    6b02:	39 f0       	breq	.+14     	; 0x6b12 <tcpip_uipcall+0x5c>
    6b04:	40 93 f8 2d 	sts	0x2DF8, r20
	  l->p != PROCESS_NONE) {
	 ts->p = l->p;
    6b08:	99 83       	std	Y+1, r25	; 0x01
    6b0a:	88 83       	st	Y, r24
	 ts->state = NULL;
    6b0c:	1b 82       	std	Y+3, r1	; 0x03
    6b0e:	1a 82       	std	Y+2, r1	; 0x02
	 break;
    6b10:	06 c0       	rjmp	.+12     	; 0x6b1e <tcpip_uipcall+0x68>
       }
       ++l;
    6b12:	34 96       	adiw	r30, 0x04	; 4
    6b14:	4f 5f       	subi	r20, 0xFF	; 255
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
    6b16:	44 30       	cpi	r20, 0x04	; 4
    6b18:	40 f3       	brcs	.-48     	; 0x6aea <tcpip_uipcall+0x34>
    6b1a:	40 93 f8 2d 	sts	0x2DF8, r20
       }
       ++l;
     }
     
     /* Start the periodic polling, if it isn't already active. */
     start_periodic_tcp_timer();
    6b1e:	0e 94 60 33 	call	0x66c0	; 0x66c0 <start_periodic_tcp_timer>
   }
 }
#endif /* UIP_TCP */
  
  if(ts->p != NULL) {
    6b22:	88 81       	ld	r24, Y
    6b24:	99 81       	ldd	r25, Y+1	; 0x01
    6b26:	00 97       	sbiw	r24, 0x00	; 0
    6b28:	31 f0       	breq	.+12     	; 0x6b36 <tcpip_uipcall+0x80>
    process_post_synch(ts->p, tcpip_event, ts->state);
    6b2a:	4a 81       	ldd	r20, Y+2	; 0x02
    6b2c:	5b 81       	ldd	r21, Y+3	; 0x03
    6b2e:	60 91 9c 30 	lds	r22, 0x309C
    6b32:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <process_post_synch>
  }
}
    6b36:	df 91       	pop	r29
    6b38:	cf 91       	pop	r28
    6b3a:	08 95       	ret

00006b3c <uip_split_output>:
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])

/*-----------------------------------------------------------------------------*/
void
uip_split_output(void)
{
    6b3c:	0f 93       	push	r16
    6b3e:	1f 93       	push	r17
    6b40:	cf 93       	push	r28
    6b42:	df 93       	push	r29
#if UIP_TCP
  uint16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP &&
    6b44:	80 91 ae 30 	lds	r24, 0x30AE
    6b48:	86 30       	cpi	r24, 0x06	; 6
    6b4a:	09 f0       	breq	.+2      	; 0x6b4e <uip_split_output+0x12>
    6b4c:	74 c0       	rjmp	.+232    	; 0x6c36 <uip_split_output+0xfa>
    6b4e:	80 91 9d 30 	lds	r24, 0x309D
    6b52:	90 91 9e 30 	lds	r25, 0x309E
    6b56:	25 e0       	ldi	r18, 0x05	; 5
    6b58:	80 30       	cpi	r24, 0x00	; 0
    6b5a:	92 07       	cpc	r25, r18
    6b5c:	09 f0       	breq	.+2      	; 0x6b60 <uip_split_output+0x24>
    6b5e:	6b c0       	rjmp	.+214    	; 0x6c36 <uip_split_output+0xfa>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN;
    6b60:	c4 e9       	ldi	r28, 0x94	; 148
    6b62:	d2 e0       	ldi	r29, 0x02	; 2
    6b64:	d0 93 9e 30 	sts	0x309E, r29
    6b68:	c0 93 9d 30 	sts	0x309D, r28
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = uip_len >> 8;
    6b6c:	02 e0       	ldi	r16, 0x02	; 2
    6b6e:	00 93 a7 30 	sts	0x30A7, r16
    BUF->len[1] = uip_len & 0xff;
    6b72:	14 e9       	ldi	r17, 0x94	; 148
    6b74:	10 93 a8 30 	sts	0x30A8, r17
#endif /* UIP_CONF_IPV6 */
    
    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    6b78:	10 92 ca 30 	sts	0x30CA, r1
    6b7c:	10 92 c9 30 	sts	0x30C9, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    6b80:	0e 94 00 3b 	call	0x7600	; 0x7600 <uip_tcpchksum>
    6b84:	80 95       	com	r24
    6b86:	90 95       	com	r25
    6b88:	90 93 ca 30 	sts	0x30CA, r25
    6b8c:	80 93 c9 30 	sts	0x30C9, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    6b90:	10 92 b0 30 	sts	0x30B0, r1
    6b94:	10 92 af 30 	sts	0x30AF, r1
    BUF->ipchksum = ~(uip_ipchksum());
    6b98:	0e 94 ef 3a 	call	0x75de	; 0x75de <uip_ipchksum>
    6b9c:	80 95       	com	r24
    6b9e:	90 95       	com	r25
    6ba0:	90 93 b0 30 	sts	0x30B0, r25
    6ba4:	80 93 af 30 	sts	0x30AF, r24
    /* Transmit the first packet. */
    /*    uip_fw_output();*/
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
    tcpip_output();
    6ba8:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <tcpip_output>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is detemined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN;
    6bac:	d0 93 9e 30 	sts	0x309E, r29
    6bb0:	c0 93 9d 30 	sts	0x309D, r28
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = uip_len >> 8;
    6bb4:	00 93 a7 30 	sts	0x30A7, r16
    BUF->len[1] = uip_len & 0xff;
    6bb8:	10 93 a8 30 	sts	0x30A8, r17
#endif /* UIP_CONF_IPV6 */
    
    /*    uip_appdata += len1;*/
    memcpy(uip_appdata, (uint8_t *)uip_appdata + len1, len2);
    6bbc:	90 91 a8 35 	lds	r25, 0x35A8
    6bc0:	80 91 a9 35 	lds	r24, 0x35A9
    6bc4:	e9 2f       	mov	r30, r25
    6bc6:	f8 2f       	mov	r31, r24
    6bc8:	df 01       	movw	r26, r30
    6bca:	a4 59       	subi	r26, 0x94	; 148
    6bcc:	bd 4f       	sbci	r27, 0xFD	; 253
    6bce:	8c e6       	ldi	r24, 0x6C	; 108
    6bd0:	92 e0       	ldi	r25, 0x02	; 2
    6bd2:	0d 90       	ld	r0, X+
    6bd4:	01 92       	st	Z+, r0
    6bd6:	01 97       	sbiw	r24, 0x01	; 1
    6bd8:	e1 f7       	brne	.-8      	; 0x6bd2 <uip_split_output+0x96>

    uip_add32(BUF->seqno, len1);
    6bda:	8d eb       	ldi	r24, 0xBD	; 189
    6bdc:	90 e3       	ldi	r25, 0x30	; 48
    6bde:	6c e6       	ldi	r22, 0x6C	; 108
    6be0:	72 e0       	ldi	r23, 0x02	; 2
    6be2:	0e 94 93 3a 	call	0x7526	; 0x7526 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    6be6:	80 91 a1 30 	lds	r24, 0x30A1
    6bea:	80 93 bd 30 	sts	0x30BD, r24
    BUF->seqno[1] = uip_acc32[1];
    6bee:	80 91 a2 30 	lds	r24, 0x30A2
    6bf2:	80 93 be 30 	sts	0x30BE, r24
    BUF->seqno[2] = uip_acc32[2];
    6bf6:	80 91 a3 30 	lds	r24, 0x30A3
    6bfa:	80 93 bf 30 	sts	0x30BF, r24
    BUF->seqno[3] = uip_acc32[3];
    6bfe:	80 91 a4 30 	lds	r24, 0x30A4
    6c02:	80 93 c0 30 	sts	0x30C0, r24
    
    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    6c06:	10 92 ca 30 	sts	0x30CA, r1
    6c0a:	10 92 c9 30 	sts	0x30C9, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    6c0e:	0e 94 00 3b 	call	0x7600	; 0x7600 <uip_tcpchksum>
    6c12:	80 95       	com	r24
    6c14:	90 95       	com	r25
    6c16:	90 93 ca 30 	sts	0x30CA, r25
    6c1a:	80 93 c9 30 	sts	0x30C9, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    6c1e:	10 92 b0 30 	sts	0x30B0, r1
    6c22:	10 92 af 30 	sts	0x30AF, r1
    BUF->ipchksum = ~(uip_ipchksum());
    6c26:	0e 94 ef 3a 	call	0x75de	; 0x75de <uip_ipchksum>
    6c2a:	80 95       	com	r24
    6c2c:	90 95       	com	r25
    6c2e:	90 93 b0 30 	sts	0x30B0, r25
    6c32:	80 93 af 30 	sts	0x30AF, r24

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
     tcpip_ipv6_output();
#else
     tcpip_output();
    6c36:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <tcpip_output>
#endif /* UIP_CONF_IPV6 */
}
    6c3a:	df 91       	pop	r29
    6c3c:	cf 91       	pop	r28
    6c3e:	1f 91       	pop	r17
    6c40:	0f 91       	pop	r16
    6c42:	08 95       	ret

00006c44 <__vector_32>:
#define DEBUGFLOW(c)
#endif

/*---------------------------------------------------------------------------*/
#if defined(TCNT3) && RTIMER_ARCH_PRESCALER
ISR (TIMER3_COMPA_vect) {
    6c44:	1f 92       	push	r1
    6c46:	0f 92       	push	r0
    6c48:	0f b6       	in	r0, 0x3f	; 63
    6c4a:	0f 92       	push	r0
    6c4c:	0b b6       	in	r0, 0x3b	; 59
    6c4e:	0f 92       	push	r0
    6c50:	11 24       	eor	r1, r1
    6c52:	2f 93       	push	r18
    6c54:	3f 93       	push	r19
    6c56:	4f 93       	push	r20
    6c58:	5f 93       	push	r21
    6c5a:	6f 93       	push	r22
    6c5c:	7f 93       	push	r23
    6c5e:	8f 93       	push	r24
    6c60:	9f 93       	push	r25
    6c62:	af 93       	push	r26
    6c64:	bf 93       	push	r27
    6c66:	ef 93       	push	r30
    6c68:	ff 93       	push	r31
  DEBUGFLOW('/');
  ENERGEST_ON(ENERGEST_TYPE_IRQ);
    6c6a:	80 91 94 00 	lds	r24, 0x0094
    6c6e:	90 91 95 00 	lds	r25, 0x0095
    6c72:	90 93 51 30 	sts	0x3051, r25
    6c76:	80 93 50 30 	sts	0x3050, r24
    6c7a:	81 e0       	ldi	r24, 0x01	; 1
    6c7c:	80 93 42 30 	sts	0x3042, r24

  /* Disable rtimer interrupts */
  ETIMSK &= ~((1 << OCIE3A) | (1 << OCIE3B) | (1 << TOIE3) |
    6c80:	80 91 71 00 	lds	r24, 0x0071
    6c84:	80 7d       	andi	r24, 0xD0	; 208
    6c86:	80 93 71 00 	sts	0x0071, r24
  /* All interrupts are enabled including recursive rtimer, so use with caution */
  sei();
#endif

  /* Call rtimer callback */
  rtimer_run_next();
    6c8a:	0e 94 9c 2e 	call	0x5d38	; 0x5d38 <rtimer_run_next>

  ENERGEST_OFF(ENERGEST_TYPE_IRQ);
    6c8e:	80 91 42 30 	lds	r24, 0x3042
    6c92:	88 23       	and	r24, r24
    6c94:	e9 f1       	breq	.+122    	; 0x6d10 <__vector_32+0xcc>
    6c96:	80 91 94 00 	lds	r24, 0x0094
    6c9a:	90 91 95 00 	lds	r25, 0x0095
    6c9e:	20 91 50 30 	lds	r18, 0x3050
    6ca2:	30 91 51 30 	lds	r19, 0x3051
    6ca6:	82 17       	cp	r24, r18
    6ca8:	93 07       	cpc	r25, r19
    6caa:	a0 f4       	brcc	.+40     	; 0x6cd4 <__vector_32+0x90>
    6cac:	80 91 16 30 	lds	r24, 0x3016
    6cb0:	90 91 17 30 	lds	r25, 0x3017
    6cb4:	a0 91 18 30 	lds	r26, 0x3018
    6cb8:	b0 91 19 30 	lds	r27, 0x3019
    6cbc:	8c 57       	subi	r24, 0x7C	; 124
    6cbe:	91 4e       	sbci	r25, 0xE1	; 225
    6cc0:	af 4f       	sbci	r26, 0xFF	; 255
    6cc2:	bf 4f       	sbci	r27, 0xFF	; 255
    6cc4:	80 93 16 30 	sts	0x3016, r24
    6cc8:	90 93 17 30 	sts	0x3017, r25
    6ccc:	a0 93 18 30 	sts	0x3018, r26
    6cd0:	b0 93 19 30 	sts	0x3019, r27
    6cd4:	80 91 94 00 	lds	r24, 0x0094
    6cd8:	90 91 95 00 	lds	r25, 0x0095
    6cdc:	82 1b       	sub	r24, r18
    6cde:	93 0b       	sbc	r25, r19
    6ce0:	a0 e0       	ldi	r26, 0x00	; 0
    6ce2:	b0 e0       	ldi	r27, 0x00	; 0
    6ce4:	20 91 16 30 	lds	r18, 0x3016
    6ce8:	30 91 17 30 	lds	r19, 0x3017
    6cec:	40 91 18 30 	lds	r20, 0x3018
    6cf0:	50 91 19 30 	lds	r21, 0x3019
    6cf4:	82 0f       	add	r24, r18
    6cf6:	93 1f       	adc	r25, r19
    6cf8:	a4 1f       	adc	r26, r20
    6cfa:	b5 1f       	adc	r27, r21
    6cfc:	80 93 16 30 	sts	0x3016, r24
    6d00:	90 93 17 30 	sts	0x3017, r25
    6d04:	a0 93 18 30 	sts	0x3018, r26
    6d08:	b0 93 19 30 	sts	0x3019, r27
    6d0c:	10 92 42 30 	sts	0x3042, r1
  DEBUGFLOW('\\');
}
    6d10:	ff 91       	pop	r31
    6d12:	ef 91       	pop	r30
    6d14:	bf 91       	pop	r27
    6d16:	af 91       	pop	r26
    6d18:	9f 91       	pop	r25
    6d1a:	8f 91       	pop	r24
    6d1c:	7f 91       	pop	r23
    6d1e:	6f 91       	pop	r22
    6d20:	5f 91       	pop	r21
    6d22:	4f 91       	pop	r20
    6d24:	3f 91       	pop	r19
    6d26:	2f 91       	pop	r18
    6d28:	0f 90       	pop	r0
    6d2a:	0b be       	out	0x3b, r0	; 59
    6d2c:	0f 90       	pop	r0
    6d2e:	0f be       	out	0x3f, r0	; 63
    6d30:	0f 90       	pop	r0
    6d32:	1f 90       	pop	r1
    6d34:	18 95       	reti

00006d36 <rtimer_arch_init>:
rtimer_arch_init(void)
{
#if RTIMER_ARCH_PRESCALER
  /* Disable interrupts (store old state) */
  uint8_t sreg;
  sreg = SREG;
    6d36:	9f b7       	in	r25, 0x3f	; 63
  cli ();
    6d38:	f8 94       	cli

#ifdef TCNT3
  /* Disable all timer functions */
  ETIMSK &= ~((1 << OCIE3A) | (1 << OCIE3B) | (1 << TOIE3) |
    6d3a:	e1 e7       	ldi	r30, 0x71	; 113
    6d3c:	f0 e0       	ldi	r31, 0x00	; 0
    6d3e:	80 81       	ld	r24, Z
    6d40:	80 7d       	andi	r24, 0xD0	; 208
    6d42:	80 83       	st	Z, r24
      (1 << TICIE3) | (1 << OCIE3C));
  /* Write 1s to clear existing timer function flags */
  ETIFR |= (1 << ICF3) | (1 << OCF3A) | (1 << OCF3B) | (1 << TOV3) |
    6d44:	88 b3       	in	r24, 0x18	; 24
    6d46:	8f 62       	ori	r24, 0x2F	; 47
    6d48:	88 bb       	out	0x18, r24	; 24
  (1 << OCF3C); 

  /* Default timer behaviour */
  TCCR3A = 0;
    6d4a:	10 92 90 00 	sts	0x0090, r1
  TCCR3B = 0;
    6d4e:	e1 e9       	ldi	r30, 0x91	; 145
    6d50:	f0 e0       	ldi	r31, 0x00	; 0
    6d52:	10 82       	st	Z, r1
  TCCR3C = 0;
    6d54:	10 92 92 00 	sts	0x0092, r1

  /* Reset counter */
  TCNT3 = 0;
    6d58:	10 92 95 00 	sts	0x0095, r1
    6d5c:	10 92 94 00 	sts	0x0094, r1

#if RTIMER_ARCH_PRESCALER==1024
  TCCR3B |= 5;
    6d60:	80 81       	ld	r24, Z
    6d62:	85 60       	ori	r24, 0x05	; 5
    6d64:	80 83       	st	Z, r24
#endif

#endif /* TCNT3 */

  /* Restore interrupt state */
  SREG = sreg;
    6d66:	9f bf       	out	0x3f, r25	; 63
#endif /* RTIMER_ARCH_PRESCALER */
}
    6d68:	08 95       	ret

00006d6a <rtimer_arch_schedule>:
rtimer_arch_schedule(rtimer_clock_t t)
{
#if RTIMER_ARCH_PRESCALER
  /* Disable interrupts (store old state) */
  uint8_t sreg;
  sreg = SREG;
    6d6a:	2f b7       	in	r18, 0x3f	; 63
  cli ();
    6d6c:	f8 94       	cli
  DEBUGFLOW(':');
#ifdef TCNT3
  /* Set compare register */
  OCR3A = t;
    6d6e:	90 93 99 00 	sts	0x0099, r25
    6d72:	80 93 98 00 	sts	0x0098, r24
  /* Write 1s to clear all timer function flags */
  ETIFR |= (1 << ICF3) | (1 << OCF3A) | (1 << OCF3B) | (1 << TOV3) |
    6d76:	88 b3       	in	r24, 0x18	; 24
    6d78:	8f 62       	ori	r24, 0x2F	; 47
    6d7a:	88 bb       	out	0x18, r24	; 24
  (1 << OCF3C);
  /* Enable interrupt on OCR3A match */
  ETIMSK |= (1 << OCIE3A);
    6d7c:	e1 e7       	ldi	r30, 0x71	; 113
    6d7e:	f0 e0       	ldi	r31, 0x00	; 0
    6d80:	80 81       	ld	r24, Z
    6d82:	82 60       	ori	r24, 0x02	; 2
    6d84:	80 83       	st	Z, r24
  TIMSK |= (1 << OCIE1A);

#endif

  /* Restore interrupt state */
  SREG = sreg;
    6d86:	2f bf       	out	0x3f, r18	; 63
#endif /* RTIMER_ARCH_PRESCALER */
}
    6d88:	08 95       	ret

00006d8a <rtimer_arch_sleep>:

#if RDC_CONF_MCU_SLEEP
/*---------------------------------------------------------------------------*/
void
rtimer_arch_sleep(rtimer_clock_t howlong)
{
    6d8a:	ef 92       	push	r14
    6d8c:	ff 92       	push	r15
    6d8e:	0f 93       	push	r16
    6d90:	1f 93       	push	r17
    6d92:	cf 93       	push	r28
    6d94:	df 93       	push	r29
    6d96:	ec 01       	movw	r28, r24
uint32_t longhowlong;
#if AVR_CONF_USE32KCRYSTAL
/* Save TIMER2 configuration if clock.c is using it */
    uint8_t savedTCNT2=TCNT2, savedTCCR2A=TCCR2A, savedTCCR2B = TCCR2B, savedOCR2A = OCR2A;
#endif
    cli();
    6d98:	f8 94       	cli
	watchdog_stop();
    6d9a:	0e 94 96 1d 	call	0x3b2c	; 0x3b2c <watchdog_stop>
	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
    6d9e:	83 b7       	in	r24, 0x33	; 51
    6da0:	81 7f       	andi	r24, 0xF1	; 241
    6da2:	86 60       	ori	r24, 0x06	; 6
    6da4:	83 bf       	out	0x33, r24	; 51

/* Set TIMER2 clock asynchronus from external source, CTC mode */
    ASSR |= (1 << AS2);
    6da6:	80 91 b6 00 	lds	r24, 0x00B6
    6daa:	80 62       	ori	r24, 0x20	; 32
    6dac:	80 93 b6 00 	sts	0x00B6, r24
    TCCR2A =(1<<WGM21);
    6db0:	82 e0       	ldi	r24, 0x02	; 2
    6db2:	80 93 b0 00 	sts	0x00B0, r24
	longhowlong=howlong*256UL;
#elif 0  // Prescale by  64 -  512 ticks/sec, 500 msec max sleep
	TCCR2B =((1<<CS22)|(0<<CS21)|(0<<CS20));
	longhowlong=howlong*512UL;
#elif 1  // Prescale by  32 - 1024 ticks/sec, 250 msec max sleep
	TCCR2B =((0<<CS22)|(1<<CS21)|(1<<CS20));
    6db6:	83 e0       	ldi	r24, 0x03	; 3
    6db8:	80 93 b1 00 	sts	0x00B1, r24
	longhowlong=howlong*1024UL;
    6dbc:	7e 01       	movw	r14, r28
    6dbe:	00 e0       	ldi	r16, 0x00	; 0
    6dc0:	10 e0       	ldi	r17, 0x00	; 0
    6dc2:	c8 01       	movw	r24, r16
    6dc4:	b7 01       	movw	r22, r14
    6dc6:	3a e0       	ldi	r19, 0x0A	; 10
    6dc8:	66 0f       	add	r22, r22
    6dca:	77 1f       	adc	r23, r23
    6dcc:	88 1f       	adc	r24, r24
    6dce:	99 1f       	adc	r25, r25
    6dd0:	3a 95       	dec	r19
    6dd2:	d1 f7       	brne	.-12     	; 0x6dc8 <rtimer_arch_sleep+0x3e>
	longhowlong=howlong*4096UL;
#else    // No Prescale -    32768 ticks/sec, 7.8 msec max sleep
	TCCR2B =((0<<CS22)|(0<<CS21)|(1<<CS20));
	longhowlong=howlong*32768UL;
#endif
	OCR2A = longhowlong/RTIMER_ARCH_SECOND;
    6dd4:	24 e8       	ldi	r18, 0x84	; 132
    6dd6:	3e e1       	ldi	r19, 0x1E	; 30
    6dd8:	40 e0       	ldi	r20, 0x00	; 0
    6dda:	50 e0       	ldi	r21, 0x00	; 0
    6ddc:	0e 94 8a 4a 	call	0x9514	; 0x9514 <__udivmodsi4>
    6de0:	20 93 b3 00 	sts	0x00B3, r18

/* Reset timer count, wait for the write (which assures TCCR2x and OCR2A are finished) */
    TCNT2 = 0; 
    6de4:	10 92 b2 00 	sts	0x00B2, r1
    while(ASSR & (1 << TCN2UB));
    6de8:	80 91 b6 00 	lds	r24, 0x00B6
    6dec:	84 fd       	sbrc	r24, 4
    6dee:	fc cf       	rjmp	.-8      	; 0x6de8 <rtimer_arch_sleep+0x5e>

/* Enable TIMER2 output compare interrupt, sleep mode and sleep */
    TIMSK2 |= (1 << OCIE2A);
    6df0:	80 91 70 00 	lds	r24, 0x0070
    6df4:	82 60       	ori	r24, 0x02	; 2
    6df6:	80 93 70 00 	sts	0x0070, r24
    SMCR |= (1 <<  SE);
    6dfa:	83 b7       	in	r24, 0x33	; 51
    6dfc:	81 60       	ori	r24, 0x01	; 1
    6dfe:	83 bf       	out	0x33, r24	; 51
	sei();
    6e00:	78 94       	sei
	ENERGEST_OFF(ENERGEST_TYPE_CPU);
    6e02:	80 91 40 30 	lds	r24, 0x3040
    6e06:	88 23       	and	r24, r24
    6e08:	e9 f1       	breq	.+122    	; 0x6e84 <rtimer_arch_sleep+0xfa>
    6e0a:	80 91 94 00 	lds	r24, 0x0094
    6e0e:	90 91 95 00 	lds	r25, 0x0095
    6e12:	20 91 4c 30 	lds	r18, 0x304C
    6e16:	30 91 4d 30 	lds	r19, 0x304D
    6e1a:	82 17       	cp	r24, r18
    6e1c:	93 07       	cpc	r25, r19
    6e1e:	a0 f4       	brcc	.+40     	; 0x6e48 <rtimer_arch_sleep+0xbe>
    6e20:	80 91 0e 30 	lds	r24, 0x300E
    6e24:	90 91 0f 30 	lds	r25, 0x300F
    6e28:	a0 91 10 30 	lds	r26, 0x3010
    6e2c:	b0 91 11 30 	lds	r27, 0x3011
    6e30:	8c 57       	subi	r24, 0x7C	; 124
    6e32:	91 4e       	sbci	r25, 0xE1	; 225
    6e34:	af 4f       	sbci	r26, 0xFF	; 255
    6e36:	bf 4f       	sbci	r27, 0xFF	; 255
    6e38:	80 93 0e 30 	sts	0x300E, r24
    6e3c:	90 93 0f 30 	sts	0x300F, r25
    6e40:	a0 93 10 30 	sts	0x3010, r26
    6e44:	b0 93 11 30 	sts	0x3011, r27
    6e48:	80 91 94 00 	lds	r24, 0x0094
    6e4c:	90 91 95 00 	lds	r25, 0x0095
    6e50:	82 1b       	sub	r24, r18
    6e52:	93 0b       	sbc	r25, r19
    6e54:	a0 e0       	ldi	r26, 0x00	; 0
    6e56:	b0 e0       	ldi	r27, 0x00	; 0
    6e58:	20 91 0e 30 	lds	r18, 0x300E
    6e5c:	30 91 0f 30 	lds	r19, 0x300F
    6e60:	40 91 10 30 	lds	r20, 0x3010
    6e64:	50 91 11 30 	lds	r21, 0x3011
    6e68:	82 0f       	add	r24, r18
    6e6a:	93 1f       	adc	r25, r19
    6e6c:	a4 1f       	adc	r26, r20
    6e6e:	b5 1f       	adc	r27, r21
    6e70:	80 93 0e 30 	sts	0x300E, r24
    6e74:	90 93 0f 30 	sts	0x300F, r25
    6e78:	a0 93 10 30 	sts	0x3010, r26
    6e7c:	b0 93 11 30 	sts	0x3011, r27
    6e80:	10 92 40 30 	sts	0x3040, r1
	if (OCR2A) sleep_mode();
    6e84:	80 91 b3 00 	lds	r24, 0x00B3
    6e88:	88 23       	and	r24, r24
    6e8a:	39 f0       	breq	.+14     	; 0x6e9a <rtimer_arch_sleep+0x110>
    6e8c:	83 b7       	in	r24, 0x33	; 51
    6e8e:	81 60       	ori	r24, 0x01	; 1
    6e90:	83 bf       	out	0x33, r24	; 51
    6e92:	88 95       	sleep
    6e94:	83 b7       	in	r24, 0x33	; 51
    6e96:	8e 7f       	andi	r24, 0xFE	; 254
    6e98:	83 bf       	out	0x33, r24	; 51
	  //...zzZZZzz...Ding!//

/* Disable sleep mode after wakeup, so random code cant trigger sleep */
    SMCR  &= ~(1 << SE);
    6e9a:	83 b7       	in	r24, 0x33	; 51
    6e9c:	8e 7f       	andi	r24, 0xFE	; 254
    6e9e:	83 bf       	out	0x33, r24	; 51

/* Adjust rtimer ticks if rtimer is enabled. TIMER3 is preferred, else TIMER1 */
#if RTIMER_ARCH_PRESCALER
#ifdef TCNT3
    TCNT3 += howlong;
    6ea0:	80 91 94 00 	lds	r24, 0x0094
    6ea4:	90 91 95 00 	lds	r25, 0x0095
    6ea8:	8c 0f       	add	r24, r28
    6eaa:	9d 1f       	adc	r25, r29
    6eac:	90 93 95 00 	sts	0x0095, r25
    6eb0:	80 93 94 00 	sts	0x0094, r24
#else
    TCNT1 += howlong;
#endif
#endif
	ENERGEST_ON(ENERGEST_TYPE_CPU);
    6eb4:	80 91 94 00 	lds	r24, 0x0094
    6eb8:	90 91 95 00 	lds	r25, 0x0095
    6ebc:	90 93 4d 30 	sts	0x304D, r25
    6ec0:	80 93 4c 30 	sts	0x304C, r24
    6ec4:	81 e0       	ldi	r24, 0x01	; 1
    6ec6:	80 93 40 30 	sts	0x3040, r24
    OCR2A  = savedOCR2A;
    TCNT2  = savedTCNT2;
    sei();
#else
/* Disable TIMER2 interrupt */
    TIMSK2 &= ~(1 << OCIE2A);
    6eca:	80 91 70 00 	lds	r24, 0x0070
    6ece:	8d 7f       	andi	r24, 0xFD	; 253
    6ed0:	80 93 70 00 	sts	0x0070, r24
#endif
    watchdog_start();
    6ed4:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <watchdog_start>

/* Adjust clock.c for the time spent sleeping */
	longhowlong=CLOCK_CONF_SECOND;
	longhowlong*=howlong;
    6ed8:	c8 01       	movw	r24, r16
    6eda:	b7 01       	movw	r22, r14
    6edc:	27 e0       	ldi	r18, 0x07	; 7
    6ede:	66 0f       	add	r22, r22
    6ee0:	77 1f       	adc	r23, r23
    6ee2:	88 1f       	adc	r24, r24
    6ee4:	99 1f       	adc	r25, r25
    6ee6:	2a 95       	dec	r18
    6ee8:	d1 f7       	brne	.-12     	; 0x6ede <rtimer_arch_sleep+0x154>
    clock_adjust_ticks(longhowlong/RTIMER_ARCH_SECOND);
    6eea:	24 e8       	ldi	r18, 0x84	; 132
    6eec:	3e e1       	ldi	r19, 0x1E	; 30
    6eee:	40 e0       	ldi	r20, 0x00	; 0
    6ef0:	50 e0       	ldi	r21, 0x00	; 0
    6ef2:	0e 94 8a 4a 	call	0x9514	; 0x9514 <__udivmodsi4>
    6ef6:	c9 01       	movw	r24, r18
    6ef8:	0e 94 bb 1b 	call	0x3776	; 0x3776 <clock_adjust_ticks>

}
    6efc:	df 91       	pop	r29
    6efe:	cf 91       	pop	r28
    6f00:	1f 91       	pop	r17
    6f02:	0f 91       	pop	r16
    6f04:	ff 90       	pop	r15
    6f06:	ef 90       	pop	r14
    6f08:	08 95       	ret

00006f0a <__vector_13>:
#if !AVR_CONF_USE32KCRYSTAL
/*---------------------------------------------------------------------------*/
/* TIMER2 Interrupt service */

ISR(TIMER2_COMPA_vect)
{
    6f0a:	1f 92       	push	r1
    6f0c:	0f 92       	push	r0
    6f0e:	0f b6       	in	r0, 0x3f	; 63
    6f10:	0f 92       	push	r0
    6f12:	11 24       	eor	r1, r1
//    TIMSK2 &= ~(1 << OCIE2A);       //Just one interrupt needed for waking
}
    6f14:	0f 90       	pop	r0
    6f16:	0f be       	out	0x3f, r0	; 63
    6f18:	0f 90       	pop	r0
    6f1a:	1f 90       	pop	r1
    6f1c:	18 95       	reti

00006f1e <field_len>:
  }
}
/*----------------------------------------------------------------------------*/
static void
field_len(frame802154_t *p, field_length_t *flen)
{
    6f1e:	ef 92       	push	r14
    6f20:	ff 92       	push	r15
    6f22:	cf 93       	push	r28
    6f24:	df 93       	push	r29
    6f26:	fc 01       	movw	r30, r24
    6f28:	db 01       	movw	r26, r22
  /* init flen to zeros */
  memset(flen, 0, sizeof(field_length_t));
    6f2a:	85 e0       	ldi	r24, 0x05	; 5
    6f2c:	eb 01       	movw	r28, r22
    6f2e:	19 92       	st	Y+, r1
    6f30:	8a 95       	dec	r24
    6f32:	e9 f7       	brne	.-6      	; 0x6f2e <field_len+0x10>

  /* Determine lengths of each field based on fcf and other args */
  if(p->fcf.dest_addr_mode & 3) {
    6f34:	85 81       	ldd	r24, Z+5	; 0x05
    6f36:	90 e0       	ldi	r25, 0x00	; 0
    6f38:	83 70       	andi	r24, 0x03	; 3
    6f3a:	90 70       	andi	r25, 0x00	; 0
    6f3c:	00 97       	sbiw	r24, 0x00	; 0
    6f3e:	11 f0       	breq	.+4      	; 0x6f44 <field_len+0x26>
    flen->dest_pid_len = 2;
    6f40:	82 e0       	ldi	r24, 0x02	; 2
    6f42:	8c 93       	st	X, r24
  }
  if(p->fcf.src_addr_mode & 3) {
    6f44:	87 81       	ldd	r24, Z+7	; 0x07
    6f46:	90 e0       	ldi	r25, 0x00	; 0
    6f48:	83 70       	andi	r24, 0x03	; 3
    6f4a:	90 70       	andi	r25, 0x00	; 0
    6f4c:	00 97       	sbiw	r24, 0x00	; 0
    6f4e:	21 f0       	breq	.+8      	; 0x6f58 <field_len+0x3a>
    flen->src_pid_len = 2;
    6f50:	82 e0       	ldi	r24, 0x02	; 2
    6f52:	12 96       	adiw	r26, 0x02	; 2
    6f54:	8c 93       	st	X, r24
    6f56:	12 97       	sbiw	r26, 0x02	; 2
  }

  /* Set PAN ID compression bit if src pan id matches dest pan id. */
  if(p->fcf.dest_addr_mode & 3 && p->fcf.src_addr_mode & 3 &&
    6f58:	85 81       	ldd	r24, Z+5	; 0x05
    6f5a:	90 e0       	ldi	r25, 0x00	; 0
    6f5c:	83 70       	andi	r24, 0x03	; 3
    6f5e:	90 70       	andi	r25, 0x00	; 0
    6f60:	00 97       	sbiw	r24, 0x00	; 0
    6f62:	99 f0       	breq	.+38     	; 0x6f8a <field_len+0x6c>
    6f64:	87 81       	ldd	r24, Z+7	; 0x07
    6f66:	90 e0       	ldi	r25, 0x00	; 0
    6f68:	83 70       	andi	r24, 0x03	; 3
    6f6a:	90 70       	andi	r25, 0x00	; 0
    6f6c:	00 97       	sbiw	r24, 0x00	; 0
    6f6e:	69 f0       	breq	.+26     	; 0x6f8a <field_len+0x6c>
    6f70:	23 89       	ldd	r18, Z+19	; 0x13
    6f72:	34 89       	ldd	r19, Z+20	; 0x14
    6f74:	81 85       	ldd	r24, Z+9	; 0x09
    6f76:	92 85       	ldd	r25, Z+10	; 0x0a
    6f78:	28 17       	cp	r18, r24
    6f7a:	39 07       	cpc	r19, r25
    6f7c:	31 f4       	brne	.+12     	; 0x6f8a <field_len+0x6c>
     p->src_pid == p->dest_pid) {
    p->fcf.panid_compression = 1;
    6f7e:	81 e0       	ldi	r24, 0x01	; 1
    6f80:	84 83       	std	Z+4, r24	; 0x04

    /* compressed header, only do dest pid */
    flen->src_pid_len = 0;
    6f82:	12 96       	adiw	r26, 0x02	; 2
    6f84:	1c 92       	st	X, r1
    6f86:	12 97       	sbiw	r26, 0x02	; 2
    6f88:	01 c0       	rjmp	.+2      	; 0x6f8c <field_len+0x6e>
  } else {
    p->fcf.panid_compression = 0;
    6f8a:	14 82       	std	Z+4, r1	; 0x04
  }

  /* determine address lengths */
  flen->dest_addr_len = addr_len(p->fcf.dest_addr_mode & 3);
    6f8c:	85 81       	ldd	r24, Z+5	; 0x05
    6f8e:	83 70       	andi	r24, 0x03	; 3
    6f90:	82 50       	subi	r24, 0x02	; 2
    6f92:	82 30       	cpi	r24, 0x02	; 2
    6f94:	30 f4       	brcc	.+12     	; 0x6fa2 <field_len+0x84>
    6f96:	c8 2f       	mov	r28, r24
    6f98:	d0 e0       	ldi	r29, 0x00	; 0
    6f9a:	c0 59       	subi	r28, 0x90	; 144
    6f9c:	d1 4f       	sbci	r29, 0xF1	; 241
    6f9e:	88 81       	ld	r24, Y
    6fa0:	01 c0       	rjmp	.+2      	; 0x6fa4 <field_len+0x86>
    6fa2:	80 e0       	ldi	r24, 0x00	; 0
    6fa4:	11 96       	adiw	r26, 0x01	; 1
    6fa6:	8c 93       	st	X, r24
    6fa8:	11 97       	sbiw	r26, 0x01	; 1
  flen->src_addr_len = addr_len(p->fcf.src_addr_mode & 3);
    6faa:	e7 81       	ldd	r30, Z+7	; 0x07
    6fac:	e3 70       	andi	r30, 0x03	; 3
    6fae:	e2 50       	subi	r30, 0x02	; 2
    6fb0:	e2 30       	cpi	r30, 0x02	; 2
    6fb2:	28 f4       	brcc	.+10     	; 0x6fbe <field_len+0xa0>
    6fb4:	f0 e0       	ldi	r31, 0x00	; 0
    6fb6:	e0 59       	subi	r30, 0x90	; 144
    6fb8:	f1 4f       	sbci	r31, 0xF1	; 241
    6fba:	80 81       	ld	r24, Z
    6fbc:	01 c0       	rjmp	.+2      	; 0x6fc0 <field_len+0xa2>
    6fbe:	80 e0       	ldi	r24, 0x00	; 0
    6fc0:	13 96       	adiw	r26, 0x03	; 3
    6fc2:	8c 93       	st	X, r24
    6fc4:	13 97       	sbiw	r26, 0x03	; 3
    default:
      break;
    }
#endif
  }
}
    6fc6:	df 91       	pop	r29
    6fc8:	cf 91       	pop	r28
    6fca:	ff 90       	pop	r15
    6fcc:	ef 90       	pop	r14
    6fce:	08 95       	ret

00006fd0 <frame802154_hdrlen>:
 *
 *   \return The length of the frame header.
*/
uint8_t
frame802154_hdrlen(frame802154_t *p)
{
    6fd0:	df 93       	push	r29
    6fd2:	cf 93       	push	r28
    6fd4:	00 d0       	rcall	.+0      	; 0x6fd6 <frame802154_hdrlen+0x6>
    6fd6:	00 d0       	rcall	.+0      	; 0x6fd8 <frame802154_hdrlen+0x8>
    6fd8:	0f 92       	push	r0
    6fda:	cd b7       	in	r28, 0x3d	; 61
    6fdc:	de b7       	in	r29, 0x3e	; 62
  field_length_t flen;
  field_len(p, &flen);
    6fde:	be 01       	movw	r22, r28
    6fe0:	6f 5f       	subi	r22, 0xFF	; 255
    6fe2:	7f 4f       	sbci	r23, 0xFF	; 255
    6fe4:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <field_len>
  return 3 + flen.dest_pid_len + flen.dest_addr_len +
    6fe8:	89 81       	ldd	r24, Y+1	; 0x01
    6fea:	9a 81       	ldd	r25, Y+2	; 0x02
    6fec:	89 0f       	add	r24, r25
    6fee:	8d 5f       	subi	r24, 0xFD	; 253
    6ff0:	9b 81       	ldd	r25, Y+3	; 0x03
    6ff2:	89 0f       	add	r24, r25
    6ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    6ff6:	89 0f       	add	r24, r25
    6ff8:	9d 81       	ldd	r25, Y+5	; 0x05
    flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len;
}
    6ffa:	89 0f       	add	r24, r25
    6ffc:	0f 90       	pop	r0
    6ffe:	0f 90       	pop	r0
    7000:	0f 90       	pop	r0
    7002:	0f 90       	pop	r0
    7004:	0f 90       	pop	r0
    7006:	cf 91       	pop	r28
    7008:	df 91       	pop	r29
    700a:	08 95       	ret

0000700c <frame802154_create>:
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
{
    700c:	af 92       	push	r10
    700e:	bf 92       	push	r11
    7010:	cf 92       	push	r12
    7012:	df 92       	push	r13
    7014:	ef 92       	push	r14
    7016:	ff 92       	push	r15
    7018:	0f 93       	push	r16
    701a:	1f 93       	push	r17
    701c:	df 93       	push	r29
    701e:	cf 93       	push	r28
    7020:	00 d0       	rcall	.+0      	; 0x7022 <frame802154_create+0x16>
    7022:	00 d0       	rcall	.+0      	; 0x7024 <frame802154_create+0x18>
    7024:	00 d0       	rcall	.+0      	; 0x7026 <frame802154_create+0x1a>
    7026:	cd b7       	in	r28, 0x3d	; 61
    7028:	de b7       	in	r29, 0x3e	; 62
    702a:	8c 01       	movw	r16, r24
    702c:	7b 01       	movw	r14, r22
  int c;
  field_length_t flen;
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);
    702e:	be 01       	movw	r22, r28
    7030:	6f 5f       	subi	r22, 0xFF	; 255
    7032:	7f 4f       	sbci	r23, 0xFF	; 255
    7034:	4e 83       	std	Y+6, r20	; 0x06
    7036:	0e 94 8f 37 	call	0x6f1e	; 0x6f1e <field_len>

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    703a:	c9 80       	ldd	r12, Y+1	; 0x01
    703c:	9a 81       	ldd	r25, Y+2	; 0x02
    703e:	a9 2e       	mov	r10, r25
    7040:	bb 24       	eor	r11, r11
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    7042:	db 80       	ldd	r13, Y+3	; 0x03
    7044:	8c 81       	ldd	r24, Y+4	; 0x04
    7046:	68 2f       	mov	r22, r24
    7048:	70 e0       	ldi	r23, 0x00	; 0
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    704a:	95 01       	movw	r18, r10
    704c:	2c 0d       	add	r18, r12
    704e:	31 1d       	adc	r19, r1
    7050:	2d 5f       	subi	r18, 0xFD	; 253
    7052:	3f 4f       	sbci	r19, 0xFF	; 255
    7054:	2d 0d       	add	r18, r13
    7056:	31 1d       	adc	r19, r1
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    7058:	26 0f       	add	r18, r22
    705a:	37 1f       	adc	r19, r23
    705c:	5d 81       	ldd	r21, Y+5	; 0x05
    705e:	25 0f       	add	r18, r21
    7060:	31 1d       	adc	r19, r1
    7062:	4e 81       	ldd	r20, Y+6	; 0x06
    7064:	50 e0       	ldi	r21, 0x00	; 0
  uint8_t *tx_frame_buffer;
  uint8_t pos;

  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
    7066:	42 17       	cp	r20, r18
    7068:	53 07       	cpc	r21, r19
    706a:	0c f4       	brge	.+2      	; 0x706e <frame802154_create+0x62>
    706c:	a8 c0       	rjmp	.+336    	; 0x71be <frame802154_create+0x1b2>

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    706e:	d8 01       	movw	r26, r16
    7070:	11 96       	adiw	r26, 0x01	; 1
    7072:	4c 91       	ld	r20, X
    7074:	11 97       	sbiw	r26, 0x01	; 1
    7076:	50 e0       	ldi	r21, 0x00	; 0
    7078:	41 70       	andi	r20, 0x01	; 1
    707a:	50 70       	andi	r21, 0x00	; 0
    707c:	e3 e0       	ldi	r30, 0x03	; 3
    707e:	44 0f       	add	r20, r20
    7080:	55 1f       	adc	r21, r21
    7082:	ea 95       	dec	r30
    7084:	e1 f7       	brne	.-8      	; 0x707e <frame802154_create+0x72>
    ((p->fcf.frame_pending & 1) << 4) |
    7086:	12 96       	adiw	r26, 0x02	; 2
    7088:	2c 91       	ld	r18, X
    708a:	12 97       	sbiw	r26, 0x02	; 2
    708c:	30 e0       	ldi	r19, 0x00	; 0
    708e:	21 70       	andi	r18, 0x01	; 1
    7090:	30 70       	andi	r19, 0x00	; 0
    7092:	54 e0       	ldi	r21, 0x04	; 4
    7094:	22 0f       	add	r18, r18
    7096:	33 1f       	adc	r19, r19
    7098:	5a 95       	dec	r21
    709a:	e1 f7       	brne	.-8      	; 0x7094 <frame802154_create+0x88>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    709c:	24 2b       	or	r18, r20
    709e:	3c 91       	ld	r19, X
    70a0:	37 70       	andi	r19, 0x07	; 7
    70a2:	23 2b       	or	r18, r19
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    70a4:	13 96       	adiw	r26, 0x03	; 3
    70a6:	3c 91       	ld	r19, X
    70a8:	13 97       	sbiw	r26, 0x03	; 3
    70aa:	e3 2f       	mov	r30, r19
    70ac:	f0 e0       	ldi	r31, 0x00	; 0
    70ae:	e1 70       	andi	r30, 0x01	; 1
    70b0:	f0 70       	andi	r31, 0x00	; 0
    70b2:	45 e0       	ldi	r20, 0x05	; 5
    70b4:	ee 0f       	add	r30, r30
    70b6:	ff 1f       	adc	r31, r31
    70b8:	4a 95       	dec	r20
    70ba:	e1 f7       	brne	.-8      	; 0x70b4 <frame802154_create+0xa8>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    70bc:	2e 2b       	or	r18, r30
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
    70be:	14 96       	adiw	r26, 0x04	; 4
    70c0:	3c 91       	ld	r19, X
    70c2:	14 97       	sbiw	r26, 0x04	; 4
    70c4:	e3 2f       	mov	r30, r19
    70c6:	f0 e0       	ldi	r31, 0x00	; 0
    70c8:	e1 70       	andi	r30, 0x01	; 1
    70ca:	f0 70       	andi	r31, 0x00	; 0
    70cc:	36 e0       	ldi	r19, 0x06	; 6
    70ce:	ee 0f       	add	r30, r30
    70d0:	ff 1f       	adc	r31, r31
    70d2:	3a 95       	dec	r19
    70d4:	e1 f7       	brne	.-8      	; 0x70ce <frame802154_create+0xc2>
  }

  /* OK, now we have field lengths.  Time to actually construct */
  /* the outgoing frame, and store it in tx_frame_buffer */
  tx_frame_buffer = buf;
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    70d6:	2e 2b       	or	r18, r30
    70d8:	f7 01       	movw	r30, r14
    70da:	20 83       	st	Z, r18
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    70dc:	15 96       	adiw	r26, 0x05	; 5
    70de:	4c 91       	ld	r20, X
    70e0:	15 97       	sbiw	r26, 0x05	; 5
    70e2:	50 e0       	ldi	r21, 0x00	; 0
    70e4:	43 70       	andi	r20, 0x03	; 3
    70e6:	50 70       	andi	r21, 0x00	; 0
    70e8:	44 0f       	add	r20, r20
    70ea:	55 1f       	adc	r21, r21
    70ec:	44 0f       	add	r20, r20
    70ee:	55 1f       	adc	r21, r21
    ((p->fcf.frame_version & 3) << 4) |
    70f0:	16 96       	adiw	r26, 0x06	; 6
    70f2:	2c 91       	ld	r18, X
    70f4:	16 97       	sbiw	r26, 0x06	; 6
    70f6:	30 e0       	ldi	r19, 0x00	; 0
    70f8:	23 70       	andi	r18, 0x03	; 3
    70fa:	30 70       	andi	r19, 0x00	; 0
    70fc:	54 e0       	ldi	r21, 0x04	; 4
    70fe:	22 0f       	add	r18, r18
    7100:	33 1f       	adc	r19, r19
    7102:	5a 95       	dec	r21
    7104:	e1 f7       	brne	.-8      	; 0x70fe <frame802154_create+0xf2>
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    7106:	24 2b       	or	r18, r20
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);
    7108:	17 96       	adiw	r26, 0x07	; 7
    710a:	3c 91       	ld	r19, X
    710c:	17 97       	sbiw	r26, 0x07	; 7
    710e:	32 95       	swap	r19
    7110:	33 0f       	add	r19, r19
    7112:	33 0f       	add	r19, r19
    7114:	30 7c       	andi	r19, 0xC0	; 192
  tx_frame_buffer[0] = (p->fcf.frame_type & 7) |
    ((p->fcf.security_enabled & 1) << 3) |
    ((p->fcf.frame_pending & 1) << 4) |
    ((p->fcf.ack_required & 1) << 5) |
    ((p->fcf.panid_compression & 1) << 6);
  tx_frame_buffer[1] = ((p->fcf.dest_addr_mode & 3) << 2) |
    7116:	32 2b       	or	r19, r18
    7118:	31 83       	std	Z+1, r19	; 0x01
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);

  /* sequence number */
  tx_frame_buffer[2] = p->seq;
    711a:	18 96       	adiw	r26, 0x08	; 8
    711c:	2c 91       	ld	r18, X
    711e:	18 97       	sbiw	r26, 0x08	; 8
    7120:	22 83       	std	Z+2, r18	; 0x02
  pos = 3;

  /* Destination PAN ID */
  if(flen.dest_pid_len == 2) {
    7122:	fc 2d       	mov	r31, r12
    7124:	f2 30       	cpi	r31, 0x02	; 2
    7126:	69 f4       	brne	.+26     	; 0x7142 <frame802154_create+0x136>
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    7128:	19 96       	adiw	r26, 0x09	; 9
    712a:	2c 91       	ld	r18, X
    712c:	d7 01       	movw	r26, r14
    712e:	13 96       	adiw	r26, 0x03	; 3
    7130:	2c 93       	st	X, r18
    7132:	13 97       	sbiw	r26, 0x03	; 3
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
    7134:	f8 01       	movw	r30, r16
    7136:	22 85       	ldd	r18, Z+10	; 0x0a
    7138:	14 96       	adiw	r26, 0x04	; 4
    713a:	2c 93       	st	X, r18
    713c:	14 97       	sbiw	r26, 0x04	; 4
    713e:	45 e0       	ldi	r20, 0x05	; 5
    7140:	01 c0       	rjmp	.+2      	; 0x7144 <frame802154_create+0x138>
    ((p->fcf.frame_version & 3) << 4) |
    ((p->fcf.src_addr_mode & 3) << 6);

  /* sequence number */
  tx_frame_buffer[2] = p->seq;
  pos = 3;
    7142:	43 e0       	ldi	r20, 0x03	; 3
 *
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
    7144:	e9 2f       	mov	r30, r25
    7146:	f0 e0       	ldi	r31, 0x00	; 0
    7148:	3b 96       	adiw	r30, 0x0b	; 11
    714a:	e0 0f       	add	r30, r16
    714c:	f1 1f       	adc	r31, r17
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
  }

  /* Destination address */
  for(c = flen.dest_addr_len; c > 0; c--) {
    714e:	54 2f       	mov	r21, r20
    7150:	0a c0       	rjmp	.+20     	; 0x7166 <frame802154_create+0x15a>
    tx_frame_buffer[pos++] = p->dest_addr[c - 1];
    7152:	97 01       	movw	r18, r14
    7154:	25 0f       	add	r18, r21
    7156:	31 1d       	adc	r19, r1
    7158:	c2 90       	ld	r12, -Z
    715a:	d9 01       	movw	r26, r18
    715c:	cc 92       	st	X, r12
    715e:	5f 5f       	subi	r21, 0xFF	; 255
    tx_frame_buffer[pos++] = p->dest_pid & 0xff;
    tx_frame_buffer[pos++] = (p->dest_pid >> 8) & 0xff;
  }

  /* Destination address */
  for(c = flen.dest_addr_len; c > 0; c--) {
    7160:	08 94       	sec
    7162:	a1 08       	sbc	r10, r1
    7164:	b1 08       	sbc	r11, r1
    7166:	a1 14       	cp	r10, r1
    7168:	b1 04       	cpc	r11, r1
    716a:	99 f7       	brne	.-26     	; 0x7152 <frame802154_create+0x146>
    716c:	94 0f       	add	r25, r20
    tx_frame_buffer[pos++] = p->dest_addr[c - 1];
  }

  /* Source PAN ID */
  if(flen.src_pid_len == 2) {
    716e:	bd 2d       	mov	r27, r13
    7170:	b2 30       	cpi	r27, 0x02	; 2
    7172:	89 f4       	brne	.+34     	; 0x7196 <frame802154_create+0x18a>
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    7174:	f7 01       	movw	r30, r14
    7176:	e9 0f       	add	r30, r25
    7178:	f1 1d       	adc	r31, r1
    717a:	d8 01       	movw	r26, r16
    717c:	53 96       	adiw	r26, 0x13	; 19
    717e:	2c 91       	ld	r18, X
    7180:	53 97       	sbiw	r26, 0x13	; 19
    7182:	20 83       	st	Z, r18
    7184:	9f 5f       	subi	r25, 0xFF	; 255
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
    7186:	f7 01       	movw	r30, r14
    7188:	e9 0f       	add	r30, r25
    718a:	f1 1d       	adc	r31, r1
    718c:	54 96       	adiw	r26, 0x14	; 20
    718e:	2c 91       	ld	r18, X
    7190:	54 97       	sbiw	r26, 0x14	; 20
    7192:	20 83       	st	Z, r18
    7194:	9f 5f       	subi	r25, 0xFF	; 255
 *
 *   \return The length of the frame header or 0 if there was
 *   insufficient space in the buffer for the frame headers.
*/
uint8_t
frame802154_create(frame802154_t *p, uint8_t *buf, uint8_t buf_len)
    7196:	e8 2f       	mov	r30, r24
    7198:	f0 e0       	ldi	r31, 0x00	; 0
    719a:	75 96       	adiw	r30, 0x15	; 21
    719c:	e0 0f       	add	r30, r16
    719e:	f1 1f       	adc	r31, r17
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
  }

  /* Source address */
  for(c = flen.src_addr_len; c > 0; c--) {
    71a0:	29 2f       	mov	r18, r25
    71a2:	08 c0       	rjmp	.+16     	; 0x71b4 <frame802154_create+0x1a8>
    tx_frame_buffer[pos++] = p->src_addr[c - 1];
    71a4:	d7 01       	movw	r26, r14
    71a6:	a2 0f       	add	r26, r18
    71a8:	b1 1d       	adc	r27, r1
    71aa:	32 91       	ld	r19, -Z
    71ac:	3c 93       	st	X, r19
    71ae:	2f 5f       	subi	r18, 0xFF	; 255
    tx_frame_buffer[pos++] = p->src_pid & 0xff;
    tx_frame_buffer[pos++] = (p->src_pid >> 8) & 0xff;
  }

  /* Source address */
  for(c = flen.src_addr_len; c > 0; c--) {
    71b0:	61 50       	subi	r22, 0x01	; 1
    71b2:	70 40       	sbci	r23, 0x00	; 0
    71b4:	61 15       	cp	r22, r1
    71b6:	71 05       	cpc	r23, r1
    71b8:	a9 f7       	brne	.-22     	; 0x71a4 <frame802154_create+0x198>
    71ba:	89 0f       	add	r24, r25
    71bc:	01 c0       	rjmp	.+2      	; 0x71c0 <frame802154_create+0x1b4>
  field_len(p, &flen);

  if(3 + flen.dest_pid_len + flen.dest_addr_len +
     flen.src_pid_len + flen.src_addr_len + flen.aux_sec_len > buf_len) {
    /* Too little space for headers. */
    return 0;
    71be:	80 e0       	ldi	r24, 0x00	; 0
    /* TODO Aux security header not yet implemented */
/*     pos += flen.aux_sec_len; */
  }

  return pos;
}
    71c0:	26 96       	adiw	r28, 0x06	; 6
    71c2:	0f b6       	in	r0, 0x3f	; 63
    71c4:	f8 94       	cli
    71c6:	de bf       	out	0x3e, r29	; 62
    71c8:	0f be       	out	0x3f, r0	; 63
    71ca:	cd bf       	out	0x3d, r28	; 61
    71cc:	cf 91       	pop	r28
    71ce:	df 91       	pop	r29
    71d0:	1f 91       	pop	r17
    71d2:	0f 91       	pop	r16
    71d4:	ff 90       	pop	r15
    71d6:	ef 90       	pop	r14
    71d8:	df 90       	pop	r13
    71da:	cf 90       	pop	r12
    71dc:	bf 90       	pop	r11
    71de:	af 90       	pop	r10
    71e0:	08 95       	ret

000071e2 <frame802154_parse>:
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
{
    71e2:	bf 92       	push	r11
    71e4:	cf 92       	push	r12
    71e6:	df 92       	push	r13
    71e8:	ef 92       	push	r14
    71ea:	ff 92       	push	r15
    71ec:	0f 93       	push	r16
    71ee:	1f 93       	push	r17
    71f0:	cf 93       	push	r28
    71f2:	df 93       	push	r29
    71f4:	7c 01       	movw	r14, r24
    71f6:	d6 2e       	mov	r13, r22
    71f8:	ea 01       	movw	r28, r20
  uint8_t *p;
  frame802154_fcf_t fcf;
  uint8_t c;

  if(len < 3) {
    71fa:	63 30       	cpi	r22, 0x03	; 3
    71fc:	08 f4       	brcc	.+2      	; 0x7200 <frame802154_parse+0x1e>
    71fe:	ad c0       	rjmp	.+346    	; 0x735a <frame802154_parse+0x178>
  }

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
    7200:	fc 01       	movw	r30, r24
    7202:	80 81       	ld	r24, Z
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;
    7204:	b8 2e       	mov	r11, r24
    7206:	b2 94       	swap	r11
    7208:	b6 94       	lsr	r11
    720a:	b6 94       	lsr	r11
    720c:	b3 e0       	ldi	r27, 0x03	; 3
    720e:	bb 22       	and	r11, r27
    7210:	f1 e0       	ldi	r31, 0x01	; 1
    7212:	bf 22       	and	r11, r31

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
    7214:	f7 01       	movw	r30, r14
    7216:	91 81       	ldd	r25, Z+1	; 0x01
    7218:	29 2f       	mov	r18, r25
    721a:	26 95       	lsr	r18
    721c:	26 95       	lsr	r18
    721e:	23 70       	andi	r18, 0x03	; 3
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    7220:	c9 2e       	mov	r12, r25
    7222:	c2 94       	swap	r12
    7224:	c6 94       	lsr	r12
    7226:	c6 94       	lsr	r12
    7228:	a3 e0       	ldi	r26, 0x03	; 3
    722a:	ca 22       	and	r12, r26
  }

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
    722c:	38 2f       	mov	r19, r24
    722e:	37 70       	andi	r19, 0x07	; 7
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    7230:	38 83       	st	Y, r19

  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
    7232:	38 2f       	mov	r19, r24
    7234:	36 95       	lsr	r19
    7236:	36 95       	lsr	r19
    7238:	36 95       	lsr	r19
    723a:	31 70       	andi	r19, 0x01	; 1
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    723c:	39 83       	std	Y+1, r19	; 0x01
  p = data;

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
    723e:	38 2f       	mov	r19, r24
    7240:	32 95       	swap	r19
    7242:	31 70       	andi	r19, 0x01	; 1
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    7244:	3a 83       	std	Y+2, r19	; 0x02

  /* decode the FCF */
  fcf.frame_type = p[0] & 7;
  fcf.security_enabled = (p[0] >> 3) & 1;
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
    7246:	82 95       	swap	r24
    7248:	86 95       	lsr	r24
    724a:	81 70       	andi	r24, 0x01	; 1
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    724c:	8b 83       	std	Y+3, r24	; 0x03
    724e:	bc 82       	std	Y+4, r11	; 0x04
    7250:	2d 83       	std	Y+5, r18	; 0x05
  fcf.frame_pending = (p[0] >> 4) & 1;
  fcf.ack_required = (p[0] >> 5) & 1;
  fcf.panid_compression = (p[0] >> 6) & 1;

  fcf.dest_addr_mode = (p[1] >> 2) & 3;
  fcf.frame_version = (p[1] >> 4) & 3;
    7252:	89 2f       	mov	r24, r25
    7254:	82 95       	swap	r24
    7256:	83 70       	andi	r24, 0x03	; 3
  fcf.src_addr_mode = (p[1] >> 6) & 3;
    7258:	8e 83       	std	Y+6, r24	; 0x06
    725a:	cf 82       	std	Y+7, r12	; 0x07

  /* copy fcf and seqNum */
  memcpy(&pf->fcf, &fcf, sizeof(frame802154_fcf_t));
  pf->seq = p[2];
    725c:	82 81       	ldd	r24, Z+2	; 0x02
    725e:	88 87       	std	Y+8, r24	; 0x08
  p += 3;                             /* Skip first three bytes */
    7260:	87 01       	movw	r16, r14
    7262:	0d 5f       	subi	r16, 0xFD	; 253
    7264:	1f 4f       	sbci	r17, 0xFF	; 255

  /* Destination address, if any */
  if(fcf.dest_addr_mode) {
    7266:	22 23       	and	r18, r18
    7268:	61 f1       	breq	.+88     	; 0x72c2 <frame802154_parse+0xe0>
    /* Destination PAN */
    pf->dest_pid = p[0] + (p[1] << 8);
    726a:	f8 01       	movw	r30, r16
    726c:	91 81       	ldd	r25, Z+1	; 0x01
    726e:	80 e0       	ldi	r24, 0x00	; 0
    7270:	f7 01       	movw	r30, r14
    7272:	33 81       	ldd	r19, Z+3	; 0x03
    7274:	83 0f       	add	r24, r19
    7276:	91 1d       	adc	r25, r1
    7278:	9a 87       	std	Y+10, r25	; 0x0a
    727a:	89 87       	std	Y+9, r24	; 0x09
    p += 2;
    727c:	87 01       	movw	r16, r14
    727e:	0b 5f       	subi	r16, 0xFB	; 251
    7280:	1f 4f       	sbci	r17, 0xFF	; 255
/*     l = addr_len(fcf.dest_addr_mode); */
/*     for(c = 0; c < l; c++) { */
/*       pf->dest_addr.u8[c] = p[l - c - 1]; */
/*     } */
/*     p += l; */
    if(fcf.dest_addr_mode == FRAME802154_SHORTADDRMODE) {
    7282:	22 30       	cpi	r18, 0x02	; 2
    7284:	81 f4       	brne	.+32     	; 0x72a6 <frame802154_parse+0xc4>
      rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
    7286:	ca 01       	movw	r24, r20
    7288:	0b 96       	adiw	r24, 0x0b	; 11
    728a:	66 ee       	ldi	r22, 0xE6	; 230
    728c:	7d e0       	ldi	r23, 0x0D	; 13
    728e:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
      pf->dest_addr[0] = p[1];
    7292:	f8 01       	movw	r30, r16
    7294:	81 81       	ldd	r24, Z+1	; 0x01
    7296:	8b 87       	std	Y+11, r24	; 0x0b
      pf->dest_addr[1] = p[0];
    7298:	f7 01       	movw	r30, r14
    729a:	85 81       	ldd	r24, Z+5	; 0x05
    729c:	8c 87       	std	Y+12, r24	; 0x0c
      p += 2;
    729e:	87 01       	movw	r16, r14
    72a0:	09 5f       	subi	r16, 0xF9	; 249
    72a2:	1f 4f       	sbci	r17, 0xFF	; 255
    72a4:	16 c0       	rjmp	.+44     	; 0x72d2 <frame802154_parse+0xf0>
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
    72a6:	23 30       	cpi	r18, 0x03	; 3
    72a8:	a1 f4       	brne	.+40     	; 0x72d2 <frame802154_parse+0xf0>
 *   \param data The input data from the radio chip.
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
    72aa:	f7 01       	movw	r30, r14
    72ac:	3d 96       	adiw	r30, 0x0d	; 13
    72ae:	da 01       	movw	r26, r20
    72b0:	1b 96       	adiw	r26, 0x0b	; 11
      pf->dest_addr[0] = p[1];
      pf->dest_addr[1] = p[0];
      p += 2;
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
        pf->dest_addr[c] = p[7 - c];
    72b2:	82 91       	ld	r24, -Z
    72b4:	8d 93       	st	X+, r24
      rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
      pf->dest_addr[0] = p[1];
      pf->dest_addr[1] = p[0];
      p += 2;
    } else if(fcf.dest_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
    72b6:	e0 17       	cp	r30, r16
    72b8:	f1 07       	cpc	r31, r17
    72ba:	d9 f7       	brne	.-10     	; 0x72b2 <frame802154_parse+0xd0>
        pf->dest_addr[c] = p[7 - c];
      }
      p += 8;
    72bc:	08 5f       	subi	r16, 0xF8	; 248
    72be:	1f 4f       	sbci	r17, 0xFF	; 255
    72c0:	08 c0       	rjmp	.+16     	; 0x72d2 <frame802154_parse+0xf0>
    }
  } else {
    rimeaddr_copy((rimeaddr_t *)&(pf->dest_addr), &rimeaddr_null);
    72c2:	ca 01       	movw	r24, r20
    72c4:	0b 96       	adiw	r24, 0x0b	; 11
    72c6:	66 ee       	ldi	r22, 0xE6	; 230
    72c8:	7d e0       	ldi	r23, 0x0D	; 13
    72ca:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
    pf->dest_pid = 0;
    72ce:	1a 86       	std	Y+10, r1	; 0x0a
    72d0:	19 86       	std	Y+9, r1	; 0x09
  }

  /* Source address, if any */
  if(fcf.src_addr_mode) {
    72d2:	cc 20       	and	r12, r12
    72d4:	89 f1       	breq	.+98     	; 0x7338 <frame802154_parse+0x156>
    /* Source PAN */
    if(!fcf.panid_compression) {
    72d6:	bb 20       	and	r11, r11
    72d8:	59 f4       	brne	.+22     	; 0x72f0 <frame802154_parse+0x10e>
      pf->src_pid = p[0] + (p[1] << 8);
    72da:	f8 01       	movw	r30, r16
    72dc:	91 81       	ldd	r25, Z+1	; 0x01
    72de:	80 e0       	ldi	r24, 0x00	; 0
    72e0:	20 81       	ld	r18, Z
    72e2:	82 0f       	add	r24, r18
    72e4:	91 1d       	adc	r25, r1
    72e6:	9c 8b       	std	Y+20, r25	; 0x14
    72e8:	8b 8b       	std	Y+19, r24	; 0x13
      p += 2;
    72ea:	0e 5f       	subi	r16, 0xFE	; 254
    72ec:	1f 4f       	sbci	r17, 0xFF	; 255
    72ee:	04 c0       	rjmp	.+8      	; 0x72f8 <frame802154_parse+0x116>
    } else {
      pf->src_pid = pf->dest_pid;
    72f0:	89 85       	ldd	r24, Y+9	; 0x09
    72f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    72f4:	9c 8b       	std	Y+20, r25	; 0x14
    72f6:	8b 8b       	std	Y+19, r24	; 0x13
/*     l = addr_len(fcf.src_addr_mode); */
/*     for(c = 0; c < l; c++) { */
/*       pf->src_addr.u8[c] = p[l - c - 1]; */
/*     } */
/*     p += l; */
    if(fcf.src_addr_mode == FRAME802154_SHORTADDRMODE) {
    72f8:	fc 2d       	mov	r31, r12
    72fa:	f2 30       	cpi	r31, 0x02	; 2
    72fc:	71 f4       	brne	.+28     	; 0x731a <frame802154_parse+0x138>
      rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
    72fe:	ce 01       	movw	r24, r28
    7300:	45 96       	adiw	r24, 0x15	; 21
    7302:	66 ee       	ldi	r22, 0xE6	; 230
    7304:	7d e0       	ldi	r23, 0x0D	; 13
    7306:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
      pf->src_addr[0] = p[1];
    730a:	f8 01       	movw	r30, r16
    730c:	81 81       	ldd	r24, Z+1	; 0x01
    730e:	8d 8b       	std	Y+21, r24	; 0x15
      pf->src_addr[1] = p[0];
    7310:	80 81       	ld	r24, Z
    7312:	8e 8b       	std	Y+22, r24	; 0x16
      p += 2;
    7314:	0e 5f       	subi	r16, 0xFE	; 254
    7316:	1f 4f       	sbci	r17, 0xFF	; 255
    7318:	17 c0       	rjmp	.+46     	; 0x7348 <frame802154_parse+0x166>
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
    731a:	fc 2d       	mov	r31, r12
    731c:	f3 30       	cpi	r31, 0x03	; 3
    731e:	a1 f4       	brne	.+40     	; 0x7348 <frame802154_parse+0x166>
 *   \param data The input data from the radio chip.
 *   \param len The size of the input data
 *   \param pf The frame802154_t struct to store the parsed frame information.
 */
uint8_t
frame802154_parse(uint8_t *data, uint8_t len, frame802154_t *pf)
    7320:	08 5f       	subi	r16, 0xF8	; 248
    7322:	1f 4f       	sbci	r17, 0xFF	; 255
    7324:	d8 01       	movw	r26, r16
    7326:	fe 01       	movw	r30, r28
    7328:	75 96       	adiw	r30, 0x15	; 21
    732a:	80 e0       	ldi	r24, 0x00	; 0
      pf->src_addr[0] = p[1];
      pf->src_addr[1] = p[0];
      p += 2;
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
        pf->src_addr[c] = p[7 - c];
    732c:	9e 91       	ld	r25, -X
    732e:	91 93       	st	Z+, r25
      rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
      pf->src_addr[0] = p[1];
      pf->src_addr[1] = p[0];
      p += 2;
    } else if(fcf.src_addr_mode == FRAME802154_LONGADDRMODE) {
      for(c = 0; c < 8; c++) {
    7330:	8f 5f       	subi	r24, 0xFF	; 255
    7332:	88 30       	cpi	r24, 0x08	; 8
    7334:	d9 f7       	brne	.-10     	; 0x732c <frame802154_parse+0x14a>
    7336:	08 c0       	rjmp	.+16     	; 0x7348 <frame802154_parse+0x166>
        pf->src_addr[c] = p[7 - c];
      }
      p += 8;
    }
  } else {
    rimeaddr_copy((rimeaddr_t *)&(pf->src_addr), &rimeaddr_null);
    7338:	ce 01       	movw	r24, r28
    733a:	45 96       	adiw	r24, 0x15	; 21
    733c:	66 ee       	ldi	r22, 0xE6	; 230
    733e:	7d e0       	ldi	r23, 0x0D	; 13
    7340:	0e 94 10 25 	call	0x4a20	; 0x4a20 <rimeaddr_copy>
    pf->src_pid = 0;
    7344:	1c 8a       	std	Y+20, r1	; 0x14
    7346:	1b 8a       	std	Y+19, r1	; 0x13
    /* TODO aux security header, not yet implemented */
/*     return 0; */
  }

  /* header length */
  c = p - data;
    7348:	80 2f       	mov	r24, r16
    734a:	8e 19       	sub	r24, r14
  /* payload length */
  pf->payload_len = len - c;
    734c:	9d 2d       	mov	r25, r13
    734e:	98 1b       	sub	r25, r24
    7350:	9f a7       	std	Y+47, r25	; 0x2f
  /* payload */
  pf->payload = p;
    7352:	1e a7       	std	Y+46, r17	; 0x2e
    7354:	0d a7       	std	Y+45, r16	; 0x2d

  /* return header length if successful */
  return c > len ? 0 : c;
    7356:	d8 16       	cp	r13, r24
    7358:	08 f4       	brcc	.+2      	; 0x735c <frame802154_parse+0x17a>
  uint8_t *p;
  frame802154_fcf_t fcf;
  uint8_t c;

  if(len < 3) {
    return 0;
    735a:	80 e0       	ldi	r24, 0x00	; 0
  /* payload */
  pf->payload = p;

  /* return header length if successful */
  return c > len ? 0 : c;
}
    735c:	df 91       	pop	r29
    735e:	cf 91       	pop	r28
    7360:	1f 91       	pop	r17
    7362:	0f 91       	pop	r16
    7364:	ff 90       	pop	r15
    7366:	ef 90       	pop	r14
    7368:	df 90       	pop	r13
    736a:	cf 90       	pop	r12
    736c:	bf 90       	pop	r11
    736e:	08 95       	ret

00007370 <memb_init>:
#include "lib/memb.h"

/*---------------------------------------------------------------------------*/
void
memb_init(struct memb *m)
{
    7370:	cf 93       	push	r28
    7372:	df 93       	push	r29
    7374:	ec 01       	movw	r28, r24
  memset(m->count, 0, m->num);
    7376:	4a 81       	ldd	r20, Y+2	; 0x02
    7378:	5b 81       	ldd	r21, Y+3	; 0x03
    737a:	8c 81       	ldd	r24, Y+4	; 0x04
    737c:	9d 81       	ldd	r25, Y+5	; 0x05
    737e:	60 e0       	ldi	r22, 0x00	; 0
    7380:	70 e0       	ldi	r23, 0x00	; 0
    7382:	0e 94 57 4b 	call	0x96ae	; 0x96ae <memset>
  memset(m->mem, 0, m->size * m->num);
    7386:	4a 81       	ldd	r20, Y+2	; 0x02
    7388:	5b 81       	ldd	r21, Y+3	; 0x03
    738a:	88 81       	ld	r24, Y
    738c:	99 81       	ldd	r25, Y+1	; 0x01
    738e:	48 9f       	mul	r20, r24
    7390:	90 01       	movw	r18, r0
    7392:	49 9f       	mul	r20, r25
    7394:	30 0d       	add	r19, r0
    7396:	58 9f       	mul	r21, r24
    7398:	30 0d       	add	r19, r0
    739a:	11 24       	eor	r1, r1
    739c:	8e 81       	ldd	r24, Y+6	; 0x06
    739e:	9f 81       	ldd	r25, Y+7	; 0x07
    73a0:	60 e0       	ldi	r22, 0x00	; 0
    73a2:	70 e0       	ldi	r23, 0x00	; 0
    73a4:	a9 01       	movw	r20, r18
    73a6:	0e 94 57 4b 	call	0x96ae	; 0x96ae <memset>
}
    73aa:	df 91       	pop	r29
    73ac:	cf 91       	pop	r28
    73ae:	08 95       	ret

000073b0 <memb_alloc>:
/*---------------------------------------------------------------------------*/
void *
memb_alloc(struct memb *m)
{
    73b0:	fc 01       	movw	r30, r24
  int i;

  for(i = 0; i < m->num; ++i) {
    73b2:	82 81       	ldd	r24, Z+2	; 0x02
    73b4:	93 81       	ldd	r25, Z+3	; 0x03
    73b6:	20 e0       	ldi	r18, 0x00	; 0
    73b8:	30 e0       	ldi	r19, 0x00	; 0
    73ba:	19 c0       	rjmp	.+50     	; 0x73ee <memb_alloc+0x3e>
    if(m->count[i] == 0) {
    73bc:	a4 81       	ldd	r26, Z+4	; 0x04
    73be:	b5 81       	ldd	r27, Z+5	; 0x05
    73c0:	a2 0f       	add	r26, r18
    73c2:	b3 1f       	adc	r27, r19
    73c4:	4c 91       	ld	r20, X
    73c6:	44 23       	and	r20, r20
    73c8:	81 f4       	brne	.+32     	; 0x73ea <memb_alloc+0x3a>
      /* If this block was unused, we increase the reference count to
	 indicate that it now is used and return a pointer to the
	 memory block. */
      ++(m->count[i]);
    73ca:	81 e0       	ldi	r24, 0x01	; 1
    73cc:	8c 93       	st	X, r24
      return (void *)((char *)m->mem + (i * m->size));
    73ce:	40 81       	ld	r20, Z
    73d0:	51 81       	ldd	r21, Z+1	; 0x01
    73d2:	24 9f       	mul	r18, r20
    73d4:	c0 01       	movw	r24, r0
    73d6:	25 9f       	mul	r18, r21
    73d8:	90 0d       	add	r25, r0
    73da:	34 9f       	mul	r19, r20
    73dc:	90 0d       	add	r25, r0
    73de:	11 24       	eor	r1, r1
    73e0:	26 81       	ldd	r18, Z+6	; 0x06
    73e2:	37 81       	ldd	r19, Z+7	; 0x07
    73e4:	28 0f       	add	r18, r24
    73e6:	39 1f       	adc	r19, r25
    73e8:	07 c0       	rjmp	.+14     	; 0x73f8 <memb_alloc+0x48>
void *
memb_alloc(struct memb *m)
{
  int i;

  for(i = 0; i < m->num; ++i) {
    73ea:	2f 5f       	subi	r18, 0xFF	; 255
    73ec:	3f 4f       	sbci	r19, 0xFF	; 255
    73ee:	28 17       	cp	r18, r24
    73f0:	39 07       	cpc	r19, r25
    73f2:	20 f3       	brcs	.-56     	; 0x73bc <memb_alloc+0xc>
    }
  }

  /* No free block was found, so we return NULL to indicate failure to
     allocate block. */
  return NULL;
    73f4:	20 e0       	ldi	r18, 0x00	; 0
    73f6:	30 e0       	ldi	r19, 0x00	; 0
}
    73f8:	c9 01       	movw	r24, r18
    73fa:	08 95       	ret

000073fc <memb_free>:
/*---------------------------------------------------------------------------*/
char
memb_free(struct memb *m, void *ptr)
{
    73fc:	fc 01       	movw	r30, r24
  int i;
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
    73fe:	26 81       	ldd	r18, Z+6	; 0x06
    7400:	37 81       	ldd	r19, Z+7	; 0x07
  for(i = 0; i < m->num; ++i) {
    7402:	42 81       	ldd	r20, Z+2	; 0x02
    7404:	53 81       	ldd	r21, Z+3	; 0x03
    7406:	80 e0       	ldi	r24, 0x00	; 0
    7408:	90 e0       	ldi	r25, 0x00	; 0
    740a:	18 c0       	rjmp	.+48     	; 0x743c <memb_free+0x40>
    
    if(ptr2 == (char *)ptr) {
    740c:	26 17       	cp	r18, r22
    740e:	37 07       	cpc	r19, r23
    7410:	81 f4       	brne	.+32     	; 0x7432 <memb_free+0x36>
      /* We've found to block to which "ptr" points so we decrease the
	 reference count and return the new value of it. */
      if(m->count[i] > 0) {
    7412:	a4 81       	ldd	r26, Z+4	; 0x04
    7414:	b5 81       	ldd	r27, Z+5	; 0x05
    7416:	a8 0f       	add	r26, r24
    7418:	b9 1f       	adc	r27, r25
    741a:	2c 91       	ld	r18, X
    741c:	12 16       	cp	r1, r18
    741e:	14 f4       	brge	.+4      	; 0x7424 <memb_free+0x28>
	/* Make sure that we don't deallocate free memory. */
	--(m->count[i]);
    7420:	21 50       	subi	r18, 0x01	; 1
    7422:	2c 93       	st	X, r18
      }
      return m->count[i];
    7424:	04 80       	ldd	r0, Z+4	; 0x04
    7426:	f5 81       	ldd	r31, Z+5	; 0x05
    7428:	e0 2d       	mov	r30, r0
    742a:	e8 0f       	add	r30, r24
    742c:	f9 1f       	adc	r31, r25
    742e:	80 81       	ld	r24, Z
    7430:	08 95       	ret
    }
    ptr2 += m->size;
    7432:	a0 81       	ld	r26, Z
    7434:	b1 81       	ldd	r27, Z+1	; 0x01
    7436:	2a 0f       	add	r18, r26
    7438:	3b 1f       	adc	r19, r27
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
  for(i = 0; i < m->num; ++i) {
    743a:	01 96       	adiw	r24, 0x01	; 1
    743c:	84 17       	cp	r24, r20
    743e:	95 07       	cpc	r25, r21
    7440:	28 f3       	brcs	.-54     	; 0x740c <memb_free+0x10>
      }
      return m->count[i];
    }
    ptr2 += m->size;
  }
  return -1;
    7442:	8f ef       	ldi	r24, 0xFF	; 255
}
    7444:	08 95       	ret

00007446 <memb_inmemb>:
/*---------------------------------------------------------------------------*/
int
memb_inmemb(struct memb *m, void *ptr)
{
    7446:	fc 01       	movw	r30, r24
  return (char *)ptr >= (char *)m->mem &&
    7448:	cb 01       	movw	r24, r22
    744a:	26 81       	ldd	r18, Z+6	; 0x06
    744c:	37 81       	ldd	r19, Z+7	; 0x07
    744e:	62 17       	cp	r22, r18
    7450:	73 07       	cpc	r23, r19
    7452:	90 f0       	brcs	.+36     	; 0x7478 <memb_inmemb+0x32>
    (char *)ptr < (char *)m->mem + (m->num * m->size);
    7454:	a0 81       	ld	r26, Z
    7456:	b1 81       	ldd	r27, Z+1	; 0x01
    7458:	62 81       	ldd	r22, Z+2	; 0x02
    745a:	73 81       	ldd	r23, Z+3	; 0x03
    745c:	a6 9f       	mul	r26, r22
    745e:	a0 01       	movw	r20, r0
    7460:	a7 9f       	mul	r26, r23
    7462:	50 0d       	add	r21, r0
    7464:	b6 9f       	mul	r27, r22
    7466:	50 0d       	add	r21, r0
    7468:	11 24       	eor	r1, r1
    746a:	42 0f       	add	r20, r18
    746c:	53 1f       	adc	r21, r19
  }
  return -1;
}
/*---------------------------------------------------------------------------*/
int
memb_inmemb(struct memb *m, void *ptr)
    746e:	21 e0       	ldi	r18, 0x01	; 1
    7470:	30 e0       	ldi	r19, 0x00	; 0
    7472:	84 17       	cp	r24, r20
    7474:	95 07       	cpc	r25, r21
    7476:	10 f0       	brcs	.+4      	; 0x747c <memb_inmemb+0x36>
{
  return (char *)ptr >= (char *)m->mem &&
    7478:	20 e0       	ldi	r18, 0x00	; 0
    747a:	30 e0       	ldi	r19, 0x00	; 0
    (char *)ptr < (char *)m->mem + (m->num * m->size);
}
    747c:	c9 01       	movw	r24, r18
    747e:	08 95       	ret

00007480 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static uint16_t
chksum(uint16_t sum, const uint8_t *data, uint16_t len)
{
    7480:	9c 01       	movw	r18, r24
  uint16_t t;
  const uint8_t *dataptr;
  const uint8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    7482:	41 50       	subi	r20, 0x01	; 1
    7484:	50 40       	sbci	r21, 0x00	; 0
    7486:	46 0f       	add	r20, r22
    7488:	57 1f       	adc	r21, r23
{
  uint16_t t;
  const uint8_t *dataptr;
  const uint8_t *last_byte;

  dataptr = data;
    748a:	db 01       	movw	r26, r22
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    748c:	10 c0       	rjmp	.+32     	; 0x74ae <chksum+0x2e>
    t = (dataptr[0] << 8) + dataptr[1];
    748e:	fc 91       	ld	r31, X
    7490:	e0 e0       	ldi	r30, 0x00	; 0
    7492:	11 96       	adiw	r26, 0x01	; 1
    7494:	8c 91       	ld	r24, X
    7496:	11 97       	sbiw	r26, 0x01	; 1
    7498:	bf 01       	movw	r22, r30
    749a:	68 0f       	add	r22, r24
    749c:	71 1d       	adc	r23, r1
    sum += t;
    749e:	26 0f       	add	r18, r22
    74a0:	37 1f       	adc	r19, r23
    if(sum < t) {
    74a2:	26 17       	cp	r18, r22
    74a4:	37 07       	cpc	r19, r23
    74a6:	10 f4       	brcc	.+4      	; 0x74ac <chksum+0x2c>
      sum++;		/* carry */
    74a8:	2f 5f       	subi	r18, 0xFF	; 255
    74aa:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    74ac:	12 96       	adiw	r26, 0x02	; 2
  const uint8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    74ae:	a4 17       	cp	r26, r20
    74b0:	b5 07       	cpc	r27, r21
    74b2:	68 f3       	brcs	.-38     	; 0x748e <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    74b4:	a4 17       	cp	r26, r20
    74b6:	b5 07       	cpc	r27, r21
    74b8:	49 f4       	brne	.+18     	; 0x74cc <chksum+0x4c>
    t = (dataptr[0] << 8) + 0;
    74ba:	9c 91       	ld	r25, X
    74bc:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    74be:	28 0f       	add	r18, r24
    74c0:	39 1f       	adc	r19, r25
    if(sum < t) {
    74c2:	28 17       	cp	r18, r24
    74c4:	39 07       	cpc	r19, r25
    74c6:	10 f4       	brcc	.+4      	; 0x74cc <chksum+0x4c>
      sum++;		/* carry */
    74c8:	2f 5f       	subi	r18, 0xFF	; 255
    74ca:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    74cc:	c9 01       	movw	r24, r18
    74ce:	08 95       	ret

000074d0 <upper_layer_chksum>:
}
#endif
/*---------------------------------------------------------------------------*/
static uint16_t
upper_layer_chksum(uint8_t proto)
{
    74d0:	cf 93       	push	r28
    74d2:	df 93       	push	r29
  uint16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    74d4:	90 91 a8 30 	lds	r25, 0x30A8
    74d8:	c9 2f       	mov	r28, r25
    74da:	d0 e0       	ldi	r29, 0x00	; 0
    74dc:	64 97       	sbiw	r28, 0x14	; 20
    74de:	30 91 a7 30 	lds	r19, 0x30A7
    74e2:	20 e0       	ldi	r18, 0x00	; 0
    74e4:	c2 0f       	add	r28, r18
    74e6:	d3 1f       	adc	r29, r19
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (uint8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    74e8:	9e 01       	movw	r18, r28
    74ea:	28 0f       	add	r18, r24
    74ec:	31 1d       	adc	r19, r1
    74ee:	c9 01       	movw	r24, r18
    74f0:	61 eb       	ldi	r22, 0xB1	; 177
    74f2:	70 e3       	ldi	r23, 0x30	; 48
    74f4:	48 e0       	ldi	r20, 0x08	; 8
    74f6:	50 e0       	ldi	r21, 0x00	; 0
    74f8:	0e 94 40 3a 	call	0x7480	; 0x7480 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    74fc:	69 eb       	ldi	r22, 0xB9	; 185
    74fe:	70 e3       	ldi	r23, 0x30	; 48
    7500:	ae 01       	movw	r20, r28
    7502:	0e 94 40 3a 	call	0x7480	; 0x7480 <chksum>
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : uip_htons(sum);
    7506:	00 97       	sbiw	r24, 0x00	; 0
    7508:	19 f0       	breq	.+6      	; 0x7510 <upper_layer_chksum+0x40>
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    750a:	38 2f       	mov	r19, r24
    750c:	29 2f       	mov	r18, r25
    750e:	02 c0       	rjmp	.+4      	; 0x7514 <upper_layer_chksum+0x44>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : uip_htons(sum);
    7510:	2f ef       	ldi	r18, 0xFF	; 255
    7512:	3f ef       	ldi	r19, 0xFF	; 255
}
    7514:	c9 01       	movw	r24, r18
    7516:	df 91       	pop	r29
    7518:	cf 91       	pop	r28
    751a:	08 95       	ret

0000751c <uip_setipid>:

static uint16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(uint16_t id) { ipid = id; }
    751c:	90 93 0c 2e 	sts	0x2E0C, r25
    7520:	80 93 0b 2e 	sts	0x2E0B, r24
    7524:	08 95       	ret

00007526 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(uint8_t *op32, uint16_t op16)
{
    7526:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    7528:	43 81       	ldd	r20, Z+3	; 0x03
    752a:	46 0f       	add	r20, r22
    752c:	40 93 a4 30 	sts	0x30A4, r20
  uip_acc32[2] = op32[2] + (op16 >> 8);
    7530:	87 2f       	mov	r24, r23
    7532:	99 27       	eor	r25, r25
    7534:	22 81       	ldd	r18, Z+2	; 0x02
    7536:	28 0f       	add	r18, r24
    7538:	20 93 a3 30 	sts	0x30A3, r18
  uip_acc32[1] = op32[1];
    753c:	a1 81       	ldd	r26, Z+1	; 0x01
    753e:	a0 93 a2 30 	sts	0x30A2, r26
  uip_acc32[0] = op32[0];
    7542:	50 81       	ld	r21, Z
    7544:	50 93 a1 30 	sts	0x30A1, r21
  
  if(uip_acc32[2] < (op16 >> 8)) {
    7548:	30 e0       	ldi	r19, 0x00	; 0
    754a:	28 17       	cp	r18, r24
    754c:	39 07       	cpc	r19, r25
    754e:	48 f4       	brcc	.+18     	; 0x7562 <uip_add32+0x3c>
    ++uip_acc32[1];
    7550:	8a 2f       	mov	r24, r26
    7552:	8f 5f       	subi	r24, 0xFF	; 255
    7554:	80 93 a2 30 	sts	0x30A2, r24
    if(uip_acc32[1] == 0) {
    7558:	88 23       	and	r24, r24
    755a:	19 f4       	brne	.+6      	; 0x7562 <uip_add32+0x3c>
      ++uip_acc32[0];
    755c:	5f 5f       	subi	r21, 0xFF	; 255
    755e:	50 93 a1 30 	sts	0x30A1, r21
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
    7562:	84 2f       	mov	r24, r20
    7564:	90 e0       	ldi	r25, 0x00	; 0
    7566:	70 70       	andi	r23, 0x00	; 0
    7568:	86 17       	cp	r24, r22
    756a:	97 07       	cpc	r25, r23
    756c:	98 f4       	brcc	.+38     	; 0x7594 <uip_add32+0x6e>
    ++uip_acc32[2];
    756e:	80 91 a3 30 	lds	r24, 0x30A3
    7572:	8f 5f       	subi	r24, 0xFF	; 255
    7574:	80 93 a3 30 	sts	0x30A3, r24
    if(uip_acc32[2] == 0) {
    7578:	88 23       	and	r24, r24
    757a:	61 f4       	brne	.+24     	; 0x7594 <uip_add32+0x6e>
      ++uip_acc32[1];
    757c:	80 91 a2 30 	lds	r24, 0x30A2
    7580:	8f 5f       	subi	r24, 0xFF	; 255
    7582:	80 93 a2 30 	sts	0x30A2, r24
      if(uip_acc32[1] == 0) {
    7586:	88 23       	and	r24, r24
    7588:	29 f4       	brne	.+10     	; 0x7594 <uip_add32+0x6e>
	++uip_acc32[0];
    758a:	80 91 a1 30 	lds	r24, 0x30A1
    758e:	8f 5f       	subi	r24, 0xFF	; 255
    7590:	80 93 a1 30 	sts	0x30A1, r24
    7594:	08 95       	ret

00007596 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(uint16_t n)
{
    7596:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    7598:	80 91 aa 35 	lds	r24, 0x35AA
    759c:	90 91 ab 35 	lds	r25, 0x35AB
    75a0:	08 96       	adiw	r24, 0x08	; 8
    75a2:	0e 94 93 3a 	call	0x7526	; 0x7526 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    75a6:	e0 91 aa 35 	lds	r30, 0x35AA
    75aa:	f0 91 ab 35 	lds	r31, 0x35AB
    75ae:	80 91 a1 30 	lds	r24, 0x30A1
    75b2:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    75b4:	80 91 a2 30 	lds	r24, 0x30A2
    75b8:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    75ba:	80 91 a3 30 	lds	r24, 0x30A3
    75be:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    75c0:	80 91 a4 30 	lds	r24, 0x30A4
    75c4:	83 87       	std	Z+11, r24	; 0x0b
}
    75c6:	08 95       	ret

000075c8 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_chksum(uint16_t *data, uint16_t len)
{
    75c8:	9c 01       	movw	r18, r24
    75ca:	ab 01       	movw	r20, r22
  return uip_htons(chksum(0, (uint8_t *)data, len));
    75cc:	80 e0       	ldi	r24, 0x00	; 0
    75ce:	90 e0       	ldi	r25, 0x00	; 0
    75d0:	b9 01       	movw	r22, r18
    75d2:	0e 94 40 3a 	call	0x7480	; 0x7480 <chksum>
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    75d6:	38 2f       	mov	r19, r24
    75d8:	29 2f       	mov	r18, r25
/*---------------------------------------------------------------------------*/
uint16_t
uip_chksum(uint16_t *data, uint16_t len)
{
  return uip_htons(chksum(0, (uint8_t *)data, len));
}
    75da:	c9 01       	movw	r24, r18
    75dc:	08 95       	ret

000075de <uip_ipchksum>:
uint16_t
uip_ipchksum(void)
{
  uint16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    75de:	80 e0       	ldi	r24, 0x00	; 0
    75e0:	90 e0       	ldi	r25, 0x00	; 0
    75e2:	65 ea       	ldi	r22, 0xA5	; 165
    75e4:	70 e3       	ldi	r23, 0x30	; 48
    75e6:	44 e1       	ldi	r20, 0x14	; 20
    75e8:	50 e0       	ldi	r21, 0x00	; 0
    75ea:	0e 94 40 3a 	call	0x7480	; 0x7480 <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : uip_htons(sum);
    75ee:	00 97       	sbiw	r24, 0x00	; 0
    75f0:	19 f0       	breq	.+6      	; 0x75f8 <uip_ipchksum+0x1a>
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    75f2:	38 2f       	mov	r19, r24
    75f4:	29 2f       	mov	r18, r25
    75f6:	02 c0       	rjmp	.+4      	; 0x75fc <uip_ipchksum+0x1e>
{
  uint16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : uip_htons(sum);
    75f8:	2f ef       	ldi	r18, 0xFF	; 255
    75fa:	3f ef       	ldi	r19, 0xFF	; 255
}
    75fc:	c9 01       	movw	r24, r18
    75fe:	08 95       	ret

00007600 <uip_tcpchksum>:
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
uint16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
    7600:	86 e0       	ldi	r24, 0x06	; 6
    7602:	0e 94 68 3a 	call	0x74d0	; 0x74d0 <upper_layer_chksum>
}
    7606:	08 95       	ret

00007608 <uip_udpchksum>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
uint16_t
uip_udpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_UDP);
    7608:	81 e1       	ldi	r24, 0x11	; 17
    760a:	0e 94 68 3a 	call	0x74d0	; 0x74d0 <upper_layer_chksum>
}
    760e:	08 95       	ret

00007610 <uip_init>:
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7610:	80 e0       	ldi	r24, 0x00	; 0
    7612:	09 c0       	rjmp	.+18     	; 0x7626 <uip_init+0x16>
    uip_listenports[c] = 0;
    7614:	e8 2f       	mov	r30, r24
    7616:	f0 e0       	ldi	r31, 0x00	; 0
    7618:	ee 0f       	add	r30, r30
    761a:	ff 1f       	adc	r31, r31
    761c:	e4 5d       	subi	r30, 0xD4	; 212
    761e:	f9 4c       	sbci	r31, 0xC9	; 201
    7620:	11 82       	std	Z+1, r1	; 0x01
    7622:	10 82       	st	Z, r1
    7624:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7626:	84 30       	cpi	r24, 0x04	; 4
    7628:	a8 f3       	brcs	.-22     	; 0x7614 <uip_init+0x4>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    762a:	80 e0       	ldi	r24, 0x00	; 0
    762c:	0b c0       	rjmp	.+22     	; 0x7644 <uip_init+0x34>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    762e:	e8 2f       	mov	r30, r24
    7630:	f0 e0       	ldi	r31, 0x00	; 0
    7632:	95 e0       	ldi	r25, 0x05	; 5
    7634:	ee 0f       	add	r30, r30
    7636:	ff 1f       	adc	r31, r31
    7638:	9a 95       	dec	r25
    763a:	e1 f7       	brne	.-8      	; 0x7634 <uip_init+0x24>
    763c:	e4 55       	subi	r30, 0x54	; 84
    763e:	fa 4c       	sbci	r31, 0xCA	; 202
    7640:	11 8e       	std	Z+25, r1	; 0x19
    7642:	8f 5f       	subi	r24, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    7644:	84 30       	cpi	r24, 0x04	; 4
    7646:	98 f3       	brcs	.-26     	; 0x762e <uip_init+0x1e>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
    7648:	80 e0       	ldi	r24, 0x00	; 0
    764a:	94 e0       	ldi	r25, 0x04	; 4
    764c:	90 93 0e 2e 	sts	0x2E0E, r25
    7650:	80 93 0d 2e 	sts	0x2E0D, r24
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    7654:	40 e0       	ldi	r20, 0x00	; 0
    uip_udp_conns[c].lport = 0;
    7656:	8d e0       	ldi	r24, 0x0D	; 13
    7658:	90 e0       	ldi	r25, 0x00	; 0
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    765a:	0e c0       	rjmp	.+28     	; 0x7678 <uip_init+0x68>
    uip_udp_conns[c].lport = 0;
    765c:	24 2f       	mov	r18, r20
    765e:	30 e0       	ldi	r19, 0x00	; 0
    7660:	28 9f       	mul	r18, r24
    7662:	f0 01       	movw	r30, r0
    7664:	29 9f       	mul	r18, r25
    7666:	f0 0d       	add	r31, r0
    7668:	38 9f       	mul	r19, r24
    766a:	f0 0d       	add	r31, r0
    766c:	11 24       	eor	r1, r1
    766e:	ee 5b       	subi	r30, 0xBE	; 190
    7670:	f9 4c       	sbci	r31, 0xC9	; 201
    7672:	15 82       	std	Z+5, r1	; 0x05
    7674:	14 82       	std	Z+4, r1	; 0x04
    7676:	4f 5f       	subi	r20, 0xFF	; 255
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    7678:	4a 30       	cpi	r20, 0x0A	; 10
    767a:	80 f3       	brcs	.-32     	; 0x765c <uip_init+0x4c>
    767c:	40 93 09 2e 	sts	0x2E09, r20
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    7680:	08 95       	ret

00007682 <uip_connect>:
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    7682:	20 91 0d 2e 	lds	r18, 0x2E0D
    7686:	30 91 0e 2e 	lds	r19, 0x2E0E
{
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    768a:	2f 5f       	subi	r18, 0xFF	; 255
    768c:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    768e:	4d e7       	ldi	r20, 0x7D	; 125
    7690:	20 30       	cpi	r18, 0x00	; 0
    7692:	34 07       	cpc	r19, r20
    7694:	10 f0       	brcs	.+4      	; 0x769a <uip_connect+0x18>
    lastport = 4096;
    7696:	20 e0       	ldi	r18, 0x00	; 0
    7698:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    769a:	52 2f       	mov	r21, r18
    769c:	43 2f       	mov	r20, r19
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    769e:	a0 e0       	ldi	r26, 0x00	; 0
    76a0:	13 c0       	rjmp	.+38     	; 0x76c8 <uip_connect+0x46>
    conn = &uip_conns[c];
    76a2:	ea 2f       	mov	r30, r26
    76a4:	f0 e0       	ldi	r31, 0x00	; 0
    if(conn->tcpstateflags != UIP_CLOSED &&
    76a6:	b5 e0       	ldi	r27, 0x05	; 5
    76a8:	ee 0f       	add	r30, r30
    76aa:	ff 1f       	adc	r31, r31
    76ac:	ba 95       	dec	r27
    76ae:	e1 f7       	brne	.-8      	; 0x76a8 <uip_connect+0x26>
    76b0:	e4 55       	subi	r30, 0x54	; 84
    76b2:	fa 4c       	sbci	r31, 0xCA	; 202
    76b4:	b1 8d       	ldd	r27, Z+25	; 0x19
    76b6:	bb 23       	and	r27, r27
    76b8:	31 f0       	breq	.+12     	; 0x76c6 <uip_connect+0x44>
    76ba:	04 80       	ldd	r0, Z+4	; 0x04
    76bc:	f5 81       	ldd	r31, Z+5	; 0x05
    76be:	e0 2d       	mov	r30, r0
    76c0:	e4 17       	cp	r30, r20
    76c2:	f5 07       	cpc	r31, r21
    76c4:	11 f3       	breq	.-60     	; 0x768a <uip_connect+0x8>
    76c6:	af 5f       	subi	r26, 0xFF	; 255
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    76c8:	a4 30       	cpi	r26, 0x04	; 4
    76ca:	59 f7       	brne	.-42     	; 0x76a2 <uip_connect+0x20>
    76cc:	30 93 0e 2e 	sts	0x2E0E, r19
    76d0:	20 93 0d 2e 	sts	0x2E0D, r18
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    76d4:	10 92 09 2e 	sts	0x2E09, r1
    76d8:	20 e0       	ldi	r18, 0x00	; 0
       conn->lport == uip_htons(lastport)) {
      goto again;
    }
  }

  conn = 0;
    76da:	e0 e0       	ldi	r30, 0x00	; 0
    76dc:	f0 e0       	ldi	r31, 0x00	; 0
  for(c = 0; c < UIP_CONNS; ++c) {
    76de:	1e c0       	rjmp	.+60     	; 0x771c <uip_connect+0x9a>
    cconn = &uip_conns[c];
    76e0:	a2 2f       	mov	r26, r18
    76e2:	b0 e0       	ldi	r27, 0x00	; 0
    76e4:	35 e0       	ldi	r19, 0x05	; 5
    76e6:	aa 0f       	add	r26, r26
    76e8:	bb 1f       	adc	r27, r27
    76ea:	3a 95       	dec	r19
    76ec:	e1 f7       	brne	.-8      	; 0x76e6 <uip_connect+0x64>
    76ee:	a4 55       	subi	r26, 0x54	; 84
    76f0:	ba 4c       	sbci	r27, 0xCA	; 202
    if(cconn->tcpstateflags == UIP_CLOSED) {
    76f2:	59 96       	adiw	r26, 0x19	; 25
    76f4:	3c 91       	ld	r19, X
    76f6:	59 97       	sbiw	r26, 0x19	; 25
    76f8:	33 23       	and	r19, r19
    76fa:	21 f4       	brne	.+8      	; 0x7704 <uip_connect+0x82>
    76fc:	20 93 09 2e 	sts	0x2E09, r18
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    7700:	fd 01       	movw	r30, r26
    7702:	10 c0       	rjmp	.+32     	; 0x7724 <uip_connect+0xa2>
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    7704:	37 30       	cpi	r19, 0x07	; 7
    7706:	49 f4       	brne	.+18     	; 0x771a <uip_connect+0x98>
      if(conn == 0 ||
    7708:	30 97       	sbiw	r30, 0x00	; 0
    770a:	31 f0       	breq	.+12     	; 0x7718 <uip_connect+0x96>
    770c:	5a 96       	adiw	r26, 0x1a	; 26
    770e:	4c 91       	ld	r20, X
    7710:	5a 97       	sbiw	r26, 0x1a	; 26
    7712:	32 8d       	ldd	r19, Z+26	; 0x1a
    7714:	34 17       	cp	r19, r20
    7716:	08 f4       	brcc	.+2      	; 0x771a <uip_connect+0x98>
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    7718:	fd 01       	movw	r30, r26
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
      if(conn == 0 ||
    771a:	2f 5f       	subi	r18, 0xFF	; 255
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    771c:	24 30       	cpi	r18, 0x04	; 4
    771e:	00 f3       	brcs	.-64     	; 0x76e0 <uip_connect+0x5e>
    7720:	20 93 09 2e 	sts	0x2E09, r18
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    7724:	30 97       	sbiw	r30, 0x00	; 0
    7726:	a9 f1       	breq	.+106    	; 0x7792 <uip_connect+0x110>
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;
    7728:	22 e0       	ldi	r18, 0x02	; 2
    772a:	21 8f       	std	Z+25, r18	; 0x19

  conn->snd_nxt[0] = iss[0];
    772c:	20 91 03 2e 	lds	r18, 0x2E03
    7730:	24 87       	std	Z+12, r18	; 0x0c
  conn->snd_nxt[1] = iss[1];
    7732:	20 91 04 2e 	lds	r18, 0x2E04
    7736:	25 87       	std	Z+13, r18	; 0x0d
  conn->snd_nxt[2] = iss[2];
    7738:	20 91 05 2e 	lds	r18, 0x2E05
    773c:	26 87       	std	Z+14, r18	; 0x0e
  conn->snd_nxt[3] = iss[3];
    773e:	20 91 06 2e 	lds	r18, 0x2E06
    7742:	27 87       	std	Z+15, r18	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    7744:	28 ed       	ldi	r18, 0xD8	; 216
    7746:	34 e0       	ldi	r19, 0x04	; 4
    7748:	33 8b       	std	Z+19, r19	; 0x13
    774a:	22 8b       	std	Z+18, r18	; 0x12
    774c:	35 8b       	std	Z+21, r19	; 0x15
    774e:	24 8b       	std	Z+20, r18	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    7750:	21 e0       	ldi	r18, 0x01	; 1
    7752:	30 e0       	ldi	r19, 0x00	; 0
    7754:	31 8b       	std	Z+17, r19	; 0x11
    7756:	20 8b       	std	Z+16, r18	; 0x10
  conn->nrtx = 0;
    7758:	13 8e       	std	Z+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    775a:	21 e0       	ldi	r18, 0x01	; 1
    775c:	22 8f       	std	Z+26, r18	; 0x1a
  conn->rto = UIP_RTO;
    775e:	23 e0       	ldi	r18, 0x03	; 3
    7760:	20 8f       	std	Z+24, r18	; 0x18
  conn->sa = 0;
    7762:	16 8a       	std	Z+22, r1	; 0x16
  conn->sv = 16;   /* Initial value of the RTT variance. */
    7764:	20 e1       	ldi	r18, 0x10	; 16
    7766:	27 8b       	std	Z+23, r18	; 0x17
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    7768:	20 91 0d 2e 	lds	r18, 0x2E0D
    776c:	30 91 0e 2e 	lds	r19, 0x2E0E
    7770:	32 27       	eor	r19, r18
    7772:	23 27       	eor	r18, r19
    7774:	32 27       	eor	r19, r18
  conn->nrtx = 0;
  conn->timer = 1; /* Send the SYN next time around. */
  conn->rto = UIP_RTO;
  conn->sa = 0;
  conn->sv = 16;   /* Initial value of the RTT variance. */
  conn->lport = uip_htons(lastport);
    7776:	35 83       	std	Z+5, r19	; 0x05
    7778:	24 83       	std	Z+4, r18	; 0x04
  conn->rport = rport;
    777a:	77 83       	std	Z+7, r23	; 0x07
    777c:	66 83       	std	Z+6, r22	; 0x06
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    777e:	dc 01       	movw	r26, r24
    7780:	2d 91       	ld	r18, X+
    7782:	3d 91       	ld	r19, X+
    7784:	4d 91       	ld	r20, X+
    7786:	5c 91       	ld	r21, X
    7788:	13 97       	sbiw	r26, 0x03	; 3
    778a:	20 83       	st	Z, r18
    778c:	31 83       	std	Z+1, r19	; 0x01
    778e:	42 83       	std	Z+2, r20	; 0x02
    7790:	53 83       	std	Z+3, r21	; 0x03
  
  return conn;
}
    7792:	cf 01       	movw	r24, r30
    7794:	08 95       	ret

00007796 <uip_udp_new>:
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(const uip_ipaddr_t *ripaddr, uint16_t rport)
{
    7796:	0f 93       	push	r16
    7798:	1f 93       	push	r17
    779a:	cf 93       	push	r28
    779c:	df 93       	push	r29
      break;
    }
  }

  if(conn == 0) {
    return 0;
    779e:	20 91 0d 2e 	lds	r18, 0x2E0D
    77a2:	30 91 0e 2e 	lds	r19, 0x2E0E
  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == uip_htons(lastport)) {
    77a6:	4d e0       	ldi	r20, 0x0D	; 13
    77a8:	50 e0       	ldi	r21, 0x00	; 0
{
  register struct uip_udp_conn *conn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    77aa:	2f 5f       	subi	r18, 0xFF	; 255
    77ac:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    77ae:	ad e7       	ldi	r26, 0x7D	; 125
    77b0:	20 30       	cpi	r18, 0x00	; 0
    77b2:	3a 07       	cpc	r19, r26
    77b4:	10 f0       	brcs	.+4      	; 0x77ba <uip_udp_new+0x24>
    lastport = 4096;
    77b6:	20 e0       	ldi	r18, 0x00	; 0
    77b8:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    77ba:	b2 2f       	mov	r27, r18
    77bc:	a3 2f       	mov	r26, r19

  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    77be:	10 e0       	ldi	r17, 0x00	; 0
    77c0:	12 c0       	rjmp	.+36     	; 0x77e6 <uip_udp_new+0x50>
    if(uip_udp_conns[c].lport == uip_htons(lastport)) {
    77c2:	c1 2f       	mov	r28, r17
    77c4:	d0 e0       	ldi	r29, 0x00	; 0
    77c6:	c4 9f       	mul	r28, r20
    77c8:	f0 01       	movw	r30, r0
    77ca:	c5 9f       	mul	r28, r21
    77cc:	f0 0d       	add	r31, r0
    77ce:	d4 9f       	mul	r29, r20
    77d0:	f0 0d       	add	r31, r0
    77d2:	11 24       	eor	r1, r1
    77d4:	ee 5b       	subi	r30, 0xBE	; 190
    77d6:	f9 4c       	sbci	r31, 0xC9	; 201
    77d8:	04 80       	ldd	r0, Z+4	; 0x04
    77da:	f5 81       	ldd	r31, Z+5	; 0x05
    77dc:	e0 2d       	mov	r30, r0
    77de:	ea 17       	cp	r30, r26
    77e0:	fb 07       	cpc	r31, r27
    77e2:	19 f3       	breq	.-58     	; 0x77aa <uip_udp_new+0x14>
    77e4:	1f 5f       	subi	r17, 0xFF	; 255

  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    77e6:	1a 30       	cpi	r17, 0x0A	; 10
    77e8:	61 f7       	brne	.-40     	; 0x77c2 <uip_udp_new+0x2c>
    77ea:	30 93 0e 2e 	sts	0x2E0E, r19
    77ee:	20 93 0d 2e 	sts	0x2E0D, r18
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    77f2:	10 e0       	ldi	r17, 0x00	; 0
    if(uip_udp_conns[c].lport == 0) {
    77f4:	2d e0       	ldi	r18, 0x0D	; 13
    77f6:	30 e0       	ldi	r19, 0x00	; 0
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    77f8:	1a c0       	rjmp	.+52     	; 0x782e <uip_udp_new+0x98>
    77fa:	01 2f       	mov	r16, r17
    77fc:	0f 5f       	subi	r16, 0xFF	; 255
    if(uip_udp_conns[c].lport == 0) {
    77fe:	c1 2f       	mov	r28, r17
    7800:	d0 e0       	ldi	r29, 0x00	; 0
    7802:	c2 9f       	mul	r28, r18
    7804:	f0 01       	movw	r30, r0
    7806:	c3 9f       	mul	r28, r19
    7808:	f0 0d       	add	r31, r0
    780a:	d2 9f       	mul	r29, r18
    780c:	f0 0d       	add	r31, r0
    780e:	11 24       	eor	r1, r1
    7810:	ee 5b       	subi	r30, 0xBE	; 190
    7812:	f9 4c       	sbci	r31, 0xC9	; 201
    7814:	df 01       	movw	r26, r30
    7816:	14 96       	adiw	r26, 0x04	; 4
    7818:	44 81       	ldd	r20, Z+4	; 0x04
    781a:	55 81       	ldd	r21, Z+5	; 0x05
    781c:	41 15       	cp	r20, r1
    781e:	51 05       	cpc	r21, r1
    7820:	29 f4       	brne	.+10     	; 0x782c <uip_udp_new+0x96>
    7822:	10 93 09 2e 	sts	0x2E09, r17
      conn = &uip_udp_conns[c];
      break;
    }
  }

  if(conn == 0) {
    7826:	30 97       	sbiw	r30, 0x00	; 0
    7828:	49 f4       	brne	.+18     	; 0x783c <uip_udp_new+0xa6>
    782a:	33 c0       	rjmp	.+102    	; 0x7892 <uip_udp_new+0xfc>
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    782c:	10 2f       	mov	r17, r16
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    782e:	1a 30       	cpi	r17, 0x0A	; 10
    7830:	20 f3       	brcs	.-56     	; 0x77fa <uip_udp_new+0x64>
    7832:	10 93 09 2e 	sts	0x2E09, r17
      break;
    }
  }

  if(conn == 0) {
    return 0;
    7836:	e0 e0       	ldi	r30, 0x00	; 0
    7838:	f0 e0       	ldi	r31, 0x00	; 0
    783a:	2b c0       	rjmp	.+86     	; 0x7892 <uip_udp_new+0xfc>
  }
  
  conn->lport = UIP_HTONS(lastport);
    783c:	20 91 0d 2e 	lds	r18, 0x2E0D
    7840:	30 91 0e 2e 	lds	r19, 0x2E0E
    7844:	32 27       	eor	r19, r18
    7846:	23 27       	eor	r18, r19
    7848:	32 27       	eor	r19, r18
    784a:	11 96       	adiw	r26, 0x01	; 1
    784c:	3c 93       	st	X, r19
    784e:	2e 93       	st	-X, r18
  conn->rport = rport;
    7850:	77 83       	std	Z+7, r23	; 0x07
    7852:	66 83       	std	Z+6, r22	; 0x06
  if(ripaddr == NULL) {
    7854:	00 97       	sbiw	r24, 0x00	; 0
    7856:	29 f4       	brne	.+10     	; 0x7862 <uip_udp_new+0xcc>
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    7858:	10 82       	st	Z, r1
    785a:	11 82       	std	Z+1, r1	; 0x01
    785c:	12 82       	std	Z+2, r1	; 0x02
    785e:	13 82       	std	Z+3, r1	; 0x03
    7860:	09 c0       	rjmp	.+18     	; 0x7874 <uip_udp_new+0xde>
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    7862:	dc 01       	movw	r26, r24
    7864:	2d 91       	ld	r18, X+
    7866:	3d 91       	ld	r19, X+
    7868:	4d 91       	ld	r20, X+
    786a:	5c 91       	ld	r21, X
    786c:	20 83       	st	Z, r18
    786e:	31 83       	std	Z+1, r19	; 0x01
    7870:	42 83       	std	Z+2, r20	; 0x02
    7872:	53 83       	std	Z+3, r21	; 0x03
  }
  conn->ttl = UIP_TTL;
    7874:	8d e0       	ldi	r24, 0x0D	; 13
    7876:	90 e0       	ldi	r25, 0x00	; 0
    7878:	c8 9f       	mul	r28, r24
    787a:	d0 01       	movw	r26, r0
    787c:	c9 9f       	mul	r28, r25
    787e:	b0 0d       	add	r27, r0
    7880:	d8 9f       	mul	r29, r24
    7882:	b0 0d       	add	r27, r0
    7884:	11 24       	eor	r1, r1
    7886:	ae 5b       	subi	r26, 0xBE	; 190
    7888:	b9 4c       	sbci	r27, 0xC9	; 201
    788a:	80 e4       	ldi	r24, 0x40	; 64
    788c:	18 96       	adiw	r26, 0x08	; 8
    788e:	8c 93       	st	X, r24
    7890:	18 97       	sbiw	r26, 0x08	; 8
  
  return conn;
}
    7892:	cf 01       	movw	r24, r30
    7894:	df 91       	pop	r29
    7896:	cf 91       	pop	r28
    7898:	1f 91       	pop	r17
    789a:	0f 91       	pop	r16
    789c:	08 95       	ret

0000789e <uip_unlisten>:
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    789e:	40 e0       	ldi	r20, 0x00	; 0
    78a0:	13 c0       	rjmp	.+38     	; 0x78c8 <uip_unlisten+0x2a>
    if(uip_listenports[c] == port) {
    78a2:	e4 2f       	mov	r30, r20
    78a4:	f0 e0       	ldi	r31, 0x00	; 0
    78a6:	54 2f       	mov	r21, r20
    78a8:	5f 5f       	subi	r21, 0xFF	; 255
    78aa:	ee 0f       	add	r30, r30
    78ac:	ff 1f       	adc	r31, r31
    78ae:	e4 5d       	subi	r30, 0xD4	; 212
    78b0:	f9 4c       	sbci	r31, 0xC9	; 201
    78b2:	20 81       	ld	r18, Z
    78b4:	31 81       	ldd	r19, Z+1	; 0x01
    78b6:	28 17       	cp	r18, r24
    78b8:	39 07       	cpc	r19, r25
    78ba:	29 f4       	brne	.+10     	; 0x78c6 <uip_unlisten+0x28>
    78bc:	40 93 09 2e 	sts	0x2E09, r20
      uip_listenports[c] = 0;
    78c0:	11 82       	std	Z+1, r1	; 0x01
    78c2:	10 82       	st	Z, r1
      return;
    78c4:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == port) {
    78c6:	45 2f       	mov	r20, r21
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    78c8:	44 30       	cpi	r20, 0x04	; 4
    78ca:	58 f3       	brcs	.-42     	; 0x78a2 <uip_unlisten+0x4>
    78cc:	40 93 09 2e 	sts	0x2E09, r20
    78d0:	08 95       	ret

000078d2 <uip_listen>:
}
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    78d2:	40 e0       	ldi	r20, 0x00	; 0
    78d4:	13 c0       	rjmp	.+38     	; 0x78fc <uip_listen+0x2a>
    if(uip_listenports[c] == 0) {
    78d6:	e4 2f       	mov	r30, r20
    78d8:	f0 e0       	ldi	r31, 0x00	; 0
    78da:	54 2f       	mov	r21, r20
    78dc:	5f 5f       	subi	r21, 0xFF	; 255
    78de:	ee 0f       	add	r30, r30
    78e0:	ff 1f       	adc	r31, r31
    78e2:	e4 5d       	subi	r30, 0xD4	; 212
    78e4:	f9 4c       	sbci	r31, 0xC9	; 201
    78e6:	20 81       	ld	r18, Z
    78e8:	31 81       	ldd	r19, Z+1	; 0x01
    78ea:	21 15       	cp	r18, r1
    78ec:	31 05       	cpc	r19, r1
    78ee:	29 f4       	brne	.+10     	; 0x78fa <uip_listen+0x28>
    78f0:	40 93 09 2e 	sts	0x2E09, r20
      uip_listenports[c] = port;
    78f4:	91 83       	std	Z+1, r25	; 0x01
    78f6:	80 83       	st	Z, r24
      return;
    78f8:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
    78fa:	45 2f       	mov	r20, r21
}
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    78fc:	44 30       	cpi	r20, 0x04	; 4
    78fe:	58 f3       	brcs	.-42     	; 0x78d6 <uip_listen+0x4>
    7900:	40 93 09 2e 	sts	0x2E09, r20
    7904:	08 95       	ret

00007906 <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(uint8_t flag)
{
    7906:	ef 92       	push	r14
    7908:	ff 92       	push	r15
    790a:	0f 93       	push	r16
    790c:	1f 93       	push	r17
    790e:	cf 93       	push	r28
    7910:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    7912:	c0 91 aa 35 	lds	r28, 0x35AA
    7916:	d0 91 ab 35 	lds	r29, 0x35AB

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    791a:	84 30       	cpi	r24, 0x04	; 4
    791c:	09 f4       	brne	.+2      	; 0x7920 <uip_process+0x1a>
    791e:	f7 c1       	rjmp	.+1006   	; 0x7d0e <uip_process+0x408>
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    7920:	0d ec       	ldi	r16, 0xCD	; 205
    7922:	10 e3       	ldi	r17, 0x30	; 48
    7924:	10 93 a9 35 	sts	0x35A9, r17
    7928:	00 93 a8 35 	sts	0x35A8, r16
    792c:	10 93 a0 30 	sts	0x30A0, r17
    7930:	00 93 9f 30 	sts	0x309F, r16

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    7934:	83 30       	cpi	r24, 0x03	; 3
    7936:	71 f4       	brne	.+28     	; 0x7954 <uip_process+0x4e>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    7938:	89 8d       	ldd	r24, Y+25	; 0x19
    793a:	90 e0       	ldi	r25, 0x00	; 0
    793c:	8f 70       	andi	r24, 0x0F	; 15
    793e:	90 70       	andi	r25, 0x00	; 0
    7940:	83 30       	cpi	r24, 0x03	; 3
    7942:	91 05       	cpc	r25, r1
    7944:	09 f0       	breq	.+2      	; 0x7948 <uip_process+0x42>
    7946:	74 c0       	rjmp	.+232    	; 0x7a30 <uip_process+0x12a>
    7948:	88 89       	ldd	r24, Y+16	; 0x10
    794a:	99 89       	ldd	r25, Y+17	; 0x11
    794c:	00 97       	sbiw	r24, 0x00	; 0
    794e:	09 f0       	breq	.+2      	; 0x7952 <uip_process+0x4c>
    7950:	2f c7       	rjmp	.+3678   	; 0x87b0 <uip_process+0xeaa>
    7952:	8d c0       	rjmp	.+282    	; 0x7a6e <uip_process+0x168>
#endif /* UIP_ACTIVE_OPEN */
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
    7954:	82 30       	cpi	r24, 0x02	; 2
    7956:	09 f0       	breq	.+2      	; 0x795a <uip_process+0x54>
    7958:	8e c0       	rjmp	.+284    	; 0x7a76 <uip_process+0x170>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    795a:	80 91 06 2e 	lds	r24, 0x2E06
    795e:	8f 5f       	subi	r24, 0xFF	; 255
    7960:	80 93 06 2e 	sts	0x2E06, r24
    7964:	88 23       	and	r24, r24
    7966:	99 f4       	brne	.+38     	; 0x798e <uip_process+0x88>
      if(++iss[2] == 0) {
    7968:	80 91 05 2e 	lds	r24, 0x2E05
    796c:	8f 5f       	subi	r24, 0xFF	; 255
    796e:	80 93 05 2e 	sts	0x2E05, r24
    7972:	88 23       	and	r24, r24
    7974:	61 f4       	brne	.+24     	; 0x798e <uip_process+0x88>
	if(++iss[1] == 0) {
    7976:	80 91 04 2e 	lds	r24, 0x2E04
    797a:	8f 5f       	subi	r24, 0xFF	; 255
    797c:	80 93 04 2e 	sts	0x2E04, r24
    7980:	88 23       	and	r24, r24
    7982:	29 f4       	brne	.+10     	; 0x798e <uip_process+0x88>
	  ++iss[0];
    7984:	80 91 03 2e 	lds	r24, 0x2E03
    7988:	8f 5f       	subi	r24, 0xFF	; 255
    798a:	80 93 03 2e 	sts	0x2E03, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    798e:	10 92 9e 30 	sts	0x309E, r1
    7992:	10 92 9d 30 	sts	0x309D, r1
    uip_slen = 0;
    7996:	10 92 41 36 	sts	0x3641, r1
    799a:	10 92 40 36 	sts	0x3640, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    799e:	89 8d       	ldd	r24, Y+25	; 0x19
    79a0:	87 30       	cpi	r24, 0x07	; 7
    79a2:	11 f0       	breq	.+4      	; 0x79a8 <uip_process+0xa2>
    79a4:	85 30       	cpi	r24, 0x05	; 5
    79a6:	41 f4       	brne	.+16     	; 0x79b8 <uip_process+0xb2>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    79a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    79aa:	8f 5f       	subi	r24, 0xFF	; 255
    79ac:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    79ae:	84 31       	cpi	r24, 0x14	; 20
    79b0:	09 f0       	breq	.+2      	; 0x79b4 <uip_process+0xae>
    79b2:	fe c6       	rjmp	.+3580   	; 0x87b0 <uip_process+0xeaa>
	uip_connr->tcpstateflags = UIP_CLOSED;
    79b4:	19 8e       	std	Y+25, r1	; 0x19
    79b6:	fc c6       	rjmp	.+3576   	; 0x87b0 <uip_process+0xeaa>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    79b8:	88 23       	and	r24, r24
    79ba:	09 f4       	brne	.+2      	; 0x79be <uip_process+0xb8>
    79bc:	f9 c6       	rjmp	.+3570   	; 0x87b0 <uip_process+0xeaa>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
    79be:	28 89       	ldd	r18, Y+16	; 0x10
    79c0:	39 89       	ldd	r19, Y+17	; 0x11
    79c2:	21 15       	cp	r18, r1
    79c4:	31 05       	cpc	r19, r1
    79c6:	09 f4       	brne	.+2      	; 0x79ca <uip_process+0xc4>
    79c8:	4e c0       	rjmp	.+156    	; 0x7a66 <uip_process+0x160>
	if(uip_connr->timer-- == 0) {
    79ca:	9a 8d       	ldd	r25, Y+26	; 0x1a
    79cc:	29 2f       	mov	r18, r25
    79ce:	21 50       	subi	r18, 0x01	; 1
    79d0:	2a 8f       	std	Y+26, r18	; 0x1a
    79d2:	99 23       	and	r25, r25
    79d4:	09 f0       	breq	.+2      	; 0x79d8 <uip_process+0xd2>
    79d6:	ec c6       	rjmp	.+3544   	; 0x87b0 <uip_process+0xeaa>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    79d8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    79da:	98 30       	cpi	r25, 0x08	; 8
    79dc:	31 f0       	breq	.+12     	; 0x79ea <uip_process+0xe4>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    79de:	28 2f       	mov	r18, r24
    79e0:	21 50       	subi	r18, 0x01	; 1
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    79e2:	22 30       	cpi	r18, 0x02	; 2
    79e4:	48 f4       	brcc	.+18     	; 0x79f8 <uip_process+0xf2>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    79e6:	95 30       	cpi	r25, 0x05	; 5
    79e8:	39 f4       	brne	.+14     	; 0x79f8 <uip_process+0xf2>
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    79ea:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    79ec:	80 e8       	ldi	r24, 0x80	; 128
    79ee:	80 93 a5 35 	sts	0x35A5, r24
	    UIP_APPCALL();
    79f2:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>
    79f6:	95 c5       	rjmp	.+2858   	; 0x8522 <uip_process+0xc1c>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    79f8:	95 30       	cpi	r25, 0x05	; 5
    79fa:	48 f4       	brcc	.+18     	; 0x7a0e <uip_process+0x108>
    79fc:	23 e0       	ldi	r18, 0x03	; 3
    79fe:	30 e0       	ldi	r19, 0x00	; 0
    7a00:	09 2e       	mov	r0, r25
    7a02:	02 c0       	rjmp	.+4      	; 0x7a08 <uip_process+0x102>
    7a04:	22 0f       	add	r18, r18
    7a06:	33 1f       	adc	r19, r19
    7a08:	0a 94       	dec	r0
    7a0a:	e2 f7       	brpl	.-8      	; 0x7a04 <uip_process+0xfe>
    7a0c:	01 c0       	rjmp	.+2      	; 0x7a10 <uip_process+0x10a>
    7a0e:	20 e3       	ldi	r18, 0x30	; 48
    7a10:	2a 8f       	std	Y+26, r18	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    7a12:	9f 5f       	subi	r25, 0xFF	; 255
    7a14:	9b 8f       	std	Y+27, r25	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    7a16:	90 e0       	ldi	r25, 0x00	; 0
    7a18:	8f 70       	andi	r24, 0x0F	; 15
    7a1a:	90 70       	andi	r25, 0x00	; 0
    7a1c:	83 30       	cpi	r24, 0x03	; 3
    7a1e:	91 05       	cpc	r25, r1
    7a20:	e1 f0       	breq	.+56     	; 0x7a5a <uip_process+0x154>
    7a22:	84 30       	cpi	r24, 0x04	; 4
    7a24:	91 05       	cpc	r25, r1
    7a26:	4c f4       	brge	.+18     	; 0x7a3a <uip_process+0x134>
    7a28:	81 30       	cpi	r24, 0x01	; 1
    7a2a:	91 05       	cpc	r25, r1
    7a2c:	09 f4       	brne	.+2      	; 0x7a30 <uip_process+0x12a>
    7a2e:	61 c3       	rjmp	.+1730   	; 0x80f2 <uip_process+0x7ec>
    7a30:	82 30       	cpi	r24, 0x02	; 2
    7a32:	91 05       	cpc	r25, r1
    7a34:	09 f0       	breq	.+2      	; 0x7a38 <uip_process+0x132>
    7a36:	bc c6       	rjmp	.+3448   	; 0x87b0 <uip_process+0xeaa>
    7a38:	0d c0       	rjmp	.+26     	; 0x7a54 <uip_process+0x14e>
    7a3a:	86 30       	cpi	r24, 0x06	; 6
    7a3c:	91 05       	cpc	r25, r1
    7a3e:	09 f4       	brne	.+2      	; 0x7a42 <uip_process+0x13c>
    7a40:	0c c5       	rjmp	.+2584   	; 0x845a <uip_process+0xb54>
    7a42:	88 30       	cpi	r24, 0x08	; 8
    7a44:	91 05       	cpc	r25, r1
    7a46:	09 f4       	brne	.+2      	; 0x7a4a <uip_process+0x144>
    7a48:	08 c5       	rjmp	.+2576   	; 0x845a <uip_process+0xb54>
    7a4a:	84 30       	cpi	r24, 0x04	; 4
    7a4c:	91 05       	cpc	r25, r1
    7a4e:	09 f0       	breq	.+2      	; 0x7a52 <uip_process+0x14c>
    7a50:	af c6       	rjmp	.+3422   	; 0x87b0 <uip_process+0xeaa>
    7a52:	03 c5       	rjmp	.+2566   	; 0x845a <uip_process+0xb54>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    7a54:	10 92 c6 30 	sts	0x30C6, r1
	    goto tcp_send_syn;
    7a58:	4f c3       	rjmp	.+1694   	; 0x80f8 <uip_process+0x7f2>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    7a5a:	84 e0       	ldi	r24, 0x04	; 4
    7a5c:	80 93 a5 35 	sts	0x35A5, r24
	    UIP_APPCALL();
    7a60:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>
	    goto apprexmit;
    7a64:	90 c5       	rjmp	.+2848   	; 0x8586 <uip_process+0xc80>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    7a66:	8f 70       	andi	r24, 0x0F	; 15
    7a68:	83 30       	cpi	r24, 0x03	; 3
    7a6a:	09 f0       	breq	.+2      	; 0x7a6e <uip_process+0x168>
    7a6c:	a1 c6       	rjmp	.+3394   	; 0x87b0 <uip_process+0xeaa>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
    7a6e:	88 e0       	ldi	r24, 0x08	; 8
    7a70:	80 93 a5 35 	sts	0x35A5, r24
    7a74:	4b c5       	rjmp	.+2710   	; 0x850c <uip_process+0xc06>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    7a76:	85 30       	cpi	r24, 0x05	; 5
    7a78:	19 f5       	brne	.+70     	; 0x7ac0 <uip_process+0x1ba>
    if(uip_udp_conn->lport != 0) {
    7a7a:	e0 91 a6 35 	lds	r30, 0x35A6
    7a7e:	f0 91 a7 35 	lds	r31, 0x35A7
    7a82:	84 81       	ldd	r24, Z+4	; 0x04
    7a84:	95 81       	ldd	r25, Z+5	; 0x05
    7a86:	00 97       	sbiw	r24, 0x00	; 0
    7a88:	09 f4       	brne	.+2      	; 0x7a8c <uip_process+0x186>
    7a8a:	92 c6       	rjmp	.+3364   	; 0x87b0 <uip_process+0xeaa>
      uip_conn = NULL;
    7a8c:	10 92 ab 35 	sts	0x35AB, r1
    7a90:	10 92 aa 35 	sts	0x35AA, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    7a94:	0c 50       	subi	r16, 0x0C	; 12
    7a96:	10 40       	sbci	r17, 0x00	; 0
    7a98:	10 93 a9 35 	sts	0x35A9, r17
    7a9c:	00 93 a8 35 	sts	0x35A8, r16
    7aa0:	10 93 a0 30 	sts	0x30A0, r17
    7aa4:	00 93 9f 30 	sts	0x309F, r16
      uip_len = uip_slen = 0;
    7aa8:	10 92 41 36 	sts	0x3641, r1
    7aac:	10 92 40 36 	sts	0x3640, r1
    7ab0:	10 92 9e 30 	sts	0x309E, r1
    7ab4:	10 92 9d 30 	sts	0x309D, r1
      uip_flags = UIP_POLL;
    7ab8:	88 e0       	ldi	r24, 0x08	; 8
    7aba:	80 93 a5 35 	sts	0x35A5, r24
    7abe:	25 c1       	rjmp	.+586    	; 0x7d0a <uip_process+0x404>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    7ac0:	08 52       	subi	r16, 0x28	; 40
    7ac2:	10 40       	sbci	r17, 0x00	; 0
    7ac4:	80 91 a5 30 	lds	r24, 0x30A5
    7ac8:	85 34       	cpi	r24, 0x45	; 69
    7aca:	09 f0       	breq	.+2      	; 0x7ace <uip_process+0x1c8>
    7acc:	71 c6       	rjmp	.+3298   	; 0x87b0 <uip_process+0xeaa>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    7ace:	90 91 a7 30 	lds	r25, 0x30A7
    7ad2:	80 e0       	ldi	r24, 0x00	; 0
    7ad4:	20 91 a8 30 	lds	r18, 0x30A8
    7ad8:	7c 01       	movw	r14, r24
    7ada:	e2 0e       	add	r14, r18
    7adc:	f1 1c       	adc	r15, r1
    7ade:	80 91 9d 30 	lds	r24, 0x309D
    7ae2:	90 91 9e 30 	lds	r25, 0x309E
    7ae6:	8e 15       	cp	r24, r14
    7ae8:	9f 05       	cpc	r25, r15
    7aea:	08 f4       	brcc	.+2      	; 0x7aee <uip_process+0x1e8>
    7aec:	61 c6       	rjmp	.+3266   	; 0x87b0 <uip_process+0xeaa>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    7aee:	f0 92 9e 30 	sts	0x309E, r15
    7af2:	e0 92 9d 30 	sts	0x309D, r14
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    7af6:	80 91 ab 30 	lds	r24, 0x30AB
    7afa:	90 e0       	ldi	r25, 0x00	; 0
    7afc:	8f 73       	andi	r24, 0x3F	; 63
    7afe:	90 70       	andi	r25, 0x00	; 0
    7b00:	00 97       	sbiw	r24, 0x00	; 0
    7b02:	09 f0       	breq	.+2      	; 0x7b06 <uip_process+0x200>
    7b04:	55 c6       	rjmp	.+3242   	; 0x87b0 <uip_process+0xeaa>
    7b06:	80 91 ac 30 	lds	r24, 0x30AC
    7b0a:	88 23       	and	r24, r24
    7b0c:	09 f0       	breq	.+2      	; 0x7b10 <uip_process+0x20a>
    7b0e:	50 c6       	rjmp	.+3232   	; 0x87b0 <uip_process+0xeaa>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    7b10:	80 91 3c 36 	lds	r24, 0x363C
    7b14:	90 91 3d 36 	lds	r25, 0x363D
    7b18:	c0 91 76 0e 	lds	r28, 0x0E76
    7b1c:	d0 91 77 0e 	lds	r29, 0x0E77
    7b20:	8c 17       	cp	r24, r28
    7b22:	9d 07       	cpc	r25, r29
    7b24:	59 f4       	brne	.+22     	; 0x7b3c <uip_process+0x236>
    7b26:	40 91 3e 36 	lds	r20, 0x363E
    7b2a:	50 91 3f 36 	lds	r21, 0x363F
    7b2e:	20 91 78 0e 	lds	r18, 0x0E78
    7b32:	30 91 79 0e 	lds	r19, 0x0E79
    7b36:	42 17       	cp	r20, r18
    7b38:	53 07       	cpc	r21, r19
    7b3a:	a1 f0       	breq	.+40     	; 0x7b64 <uip_process+0x25e>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    7b3c:	20 91 b5 30 	lds	r18, 0x30B5
    7b40:	30 91 b6 30 	lds	r19, 0x30B6
    7b44:	28 17       	cp	r18, r24
    7b46:	39 07       	cpc	r19, r25
    7b48:	09 f0       	breq	.+2      	; 0x7b4c <uip_process+0x246>
    7b4a:	32 c6       	rjmp	.+3172   	; 0x87b0 <uip_process+0xeaa>
    7b4c:	20 91 b7 30 	lds	r18, 0x30B7
    7b50:	30 91 b8 30 	lds	r19, 0x30B8
    7b54:	80 91 3e 36 	lds	r24, 0x363E
    7b58:	90 91 3f 36 	lds	r25, 0x363F
    7b5c:	28 17       	cp	r18, r24
    7b5e:	39 07       	cpc	r19, r25
    7b60:	09 f0       	breq	.+2      	; 0x7b64 <uip_process+0x25e>
    7b62:	26 c6       	rjmp	.+3148   	; 0x87b0 <uip_process+0xeaa>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    7b64:	0e 94 ef 3a 	call	0x75de	; 0x75de <uip_ipchksum>
    7b68:	2f ef       	ldi	r18, 0xFF	; 255
    7b6a:	8f 3f       	cpi	r24, 0xFF	; 255
    7b6c:	92 07       	cpc	r25, r18
    7b6e:	09 f0       	breq	.+2      	; 0x7b72 <uip_process+0x26c>
    7b70:	1f c6       	rjmp	.+3134   	; 0x87b0 <uip_process+0xeaa>
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    7b72:	80 91 ae 30 	lds	r24, 0x30AE
    7b76:	86 30       	cpi	r24, 0x06	; 6
    7b78:	09 f4       	brne	.+2      	; 0x7b7c <uip_process+0x276>
    7b7a:	31 c1       	rjmp	.+610    	; 0x7dde <uip_process+0x4d8>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    7b7c:	81 31       	cpi	r24, 0x11	; 17
    7b7e:	e9 f1       	breq	.+122    	; 0x7bfa <uip_process+0x2f4>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    7b80:	81 30       	cpi	r24, 0x01	; 1
    7b82:	09 f0       	breq	.+2      	; 0x7b86 <uip_process+0x280>
    7b84:	15 c6       	rjmp	.+3114   	; 0x87b0 <uip_process+0xeaa>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    7b86:	80 91 b9 30 	lds	r24, 0x30B9
    7b8a:	88 30       	cpi	r24, 0x08	; 8
    7b8c:	09 f0       	breq	.+2      	; 0x7b90 <uip_process+0x28a>
    7b8e:	10 c6       	rjmp	.+3104   	; 0x87b0 <uip_process+0xeaa>
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    7b90:	10 92 b9 30 	sts	0x30B9, r1

  if(ICMPBUF->icmpchksum >= UIP_HTONS(0xffff - (ICMP_ECHO << 8))) {
    7b94:	80 91 bb 30 	lds	r24, 0x30BB
    7b98:	90 91 bc 30 	lds	r25, 0x30BC
    7b9c:	4f ef       	ldi	r20, 0xFF	; 255
    7b9e:	87 3f       	cpi	r24, 0xF7	; 247
    7ba0:	94 07       	cpc	r25, r20
    7ba2:	10 f0       	brcs	.+4      	; 0x7ba8 <uip_process+0x2a2>
    ICMPBUF->icmpchksum += UIP_HTONS(ICMP_ECHO << 8) + 1;
    7ba4:	09 96       	adiw	r24, 0x09	; 9
    7ba6:	01 c0       	rjmp	.+2      	; 0x7baa <uip_process+0x2a4>
  } else {
    ICMPBUF->icmpchksum += UIP_HTONS(ICMP_ECHO << 8);
    7ba8:	08 96       	adiw	r24, 0x08	; 8
    7baa:	90 93 bc 30 	sts	0x30BC, r25
    7bae:	80 93 bb 30 	sts	0x30BB, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    7bb2:	80 91 b1 30 	lds	r24, 0x30B1
    7bb6:	90 91 b2 30 	lds	r25, 0x30B2
    7bba:	a0 91 b3 30 	lds	r26, 0x30B3
    7bbe:	b0 91 b4 30 	lds	r27, 0x30B4
    7bc2:	80 93 b5 30 	sts	0x30B5, r24
    7bc6:	90 93 b6 30 	sts	0x30B6, r25
    7bca:	a0 93 b7 30 	sts	0x30B7, r26
    7bce:	b0 93 b8 30 	sts	0x30B8, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    7bd2:	80 91 3c 36 	lds	r24, 0x363C
    7bd6:	90 91 3d 36 	lds	r25, 0x363D
    7bda:	a0 91 3e 36 	lds	r26, 0x363E
    7bde:	b0 91 3f 36 	lds	r27, 0x363F
    7be2:	80 93 b1 30 	sts	0x30B1, r24
    7be6:	90 93 b2 30 	sts	0x30B2, r25
    7bea:	a0 93 b3 30 	sts	0x30B3, r26
    7bee:	b0 93 b4 30 	sts	0x30B4, r27

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    7bf2:	80 e4       	ldi	r24, 0x40	; 64
    7bf4:	f8 01       	movw	r30, r16
    7bf6:	80 87       	std	Z+8, r24	; 0x08
  goto ip_send_nolen;
    7bf8:	b8 c5       	rjmp	.+2928   	; 0x876a <uip_process+0xe64>
  /* UDP processing is really just a hack. We don't do anything to the
     UDP/IP headers, but let the UDP application do all the hard
     work. If the application sets uip_slen, it has a packet to
     send. */
#if UIP_UDP_CHECKSUMS
  uip_len = uip_len - UIP_IPUDPH_LEN;
    7bfa:	c7 01       	movw	r24, r14
    7bfc:	4c 97       	sbiw	r24, 0x1c	; 28
    7bfe:	90 93 9e 30 	sts	0x309E, r25
    7c02:	80 93 9d 30 	sts	0x309D, r24
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    7c06:	81 ec       	ldi	r24, 0xC1	; 193
    7c08:	90 e3       	ldi	r25, 0x30	; 48
    7c0a:	90 93 a9 35 	sts	0x35A9, r25
    7c0e:	80 93 a8 35 	sts	0x35A8, r24
  if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
    7c12:	80 91 bf 30 	lds	r24, 0x30BF
    7c16:	90 91 c0 30 	lds	r25, 0x30C0
    7c1a:	00 97       	sbiw	r24, 0x00	; 0
    7c1c:	39 f0       	breq	.+14     	; 0x7c2c <uip_process+0x326>
    7c1e:	0e 94 04 3b 	call	0x7608	; 0x7608 <uip_udpchksum>
    7c22:	ff ef       	ldi	r31, 0xFF	; 255
    7c24:	8f 3f       	cpi	r24, 0xFF	; 255
    7c26:	9f 07       	cpc	r25, r31
    7c28:	09 f0       	breq	.+2      	; 0x7c2c <uip_process+0x326>
    7c2a:	c2 c5       	rjmp	.+2948   	; 0x87b0 <uip_process+0xeaa>
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Make sure that the UDP destination port number is not zero. */
  if(UDPBUF->destport == 0) {
    7c2c:	20 91 bb 30 	lds	r18, 0x30BB
    7c30:	30 91 bc 30 	lds	r19, 0x30BC
    7c34:	21 15       	cp	r18, r1
    7c36:	31 05       	cpc	r19, r1
    7c38:	09 f4       	brne	.+2      	; 0x7c3c <uip_process+0x336>
    7c3a:	ba c5       	rjmp	.+2932   	; 0x87b0 <uip_process+0xeaa>
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    7c3c:	82 e4       	ldi	r24, 0x42	; 66
    7c3e:	96 e3       	ldi	r25, 0x36	; 54
    7c40:	90 93 a7 35 	sts	0x35A7, r25
    7c44:	80 93 a6 35 	sts	0x35A6, r24
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    7c48:	60 91 78 0e 	lds	r22, 0x0E78
    7c4c:	70 91 79 0e 	lds	r23, 0x0E79
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    7c50:	40 91 72 0e 	lds	r20, 0x0E72
    7c54:	50 91 73 0e 	lds	r21, 0x0E73
    7c58:	00 91 74 0e 	lds	r16, 0x0E74
    7c5c:	10 91 75 0e 	lds	r17, 0x0E75
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    7c60:	39 c0       	rjmp	.+114    	; 0x7cd4 <uip_process+0x3ce>
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    7c62:	84 81       	ldd	r24, Z+4	; 0x04
    7c64:	95 81       	ldd	r25, Z+5	; 0x05
    7c66:	00 97       	sbiw	r24, 0x00	; 0
    7c68:	81 f1       	breq	.+96     	; 0x7cca <uip_process+0x3c4>
    7c6a:	28 17       	cp	r18, r24
    7c6c:	39 07       	cpc	r19, r25
    7c6e:	69 f5       	brne	.+90     	; 0x7cca <uip_process+0x3c4>
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
    7c70:	86 81       	ldd	r24, Z+6	; 0x06
    7c72:	97 81       	ldd	r25, Z+7	; 0x07
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    7c74:	00 97       	sbiw	r24, 0x00	; 0
    7c76:	39 f0       	breq	.+14     	; 0x7c86 <uip_process+0x380>
       (uip_udp_conn->rport == 0 ||
    7c78:	a0 91 b9 30 	lds	r26, 0x30B9
    7c7c:	b0 91 ba 30 	lds	r27, 0x30BA
    7c80:	a8 17       	cp	r26, r24
    7c82:	b9 07       	cpc	r27, r25
    7c84:	11 f5       	brne	.+68     	; 0x7cca <uip_process+0x3c4>
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    7c86:	80 81       	ld	r24, Z
    7c88:	91 81       	ldd	r25, Z+1	; 0x01
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    7c8a:	8c 17       	cp	r24, r28
    7c8c:	9d 07       	cpc	r25, r29
    7c8e:	29 f4       	brne	.+10     	; 0x7c9a <uip_process+0x394>
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    7c90:	a2 81       	ldd	r26, Z+2	; 0x02
    7c92:	b3 81       	ldd	r27, Z+3	; 0x03
    7c94:	a6 17       	cp	r26, r22
    7c96:	b7 07       	cpc	r27, r23
    7c98:	39 f1       	breq	.+78     	; 0x7ce8 <uip_process+0x3e2>
    7c9a:	84 17       	cp	r24, r20
    7c9c:	95 07       	cpc	r25, r21
    7c9e:	29 f4       	brne	.+10     	; 0x7caa <uip_process+0x3a4>
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    7ca0:	a2 81       	ldd	r26, Z+2	; 0x02
    7ca2:	b3 81       	ldd	r27, Z+3	; 0x03
    7ca4:	a0 17       	cp	r26, r16
    7ca6:	b1 07       	cpc	r27, r17
    7ca8:	f9 f0       	breq	.+62     	; 0x7ce8 <uip_process+0x3e2>
    7caa:	a0 91 b1 30 	lds	r26, 0x30B1
    7cae:	b0 91 b2 30 	lds	r27, 0x30B2
    7cb2:	a8 17       	cp	r26, r24
    7cb4:	b9 07       	cpc	r27, r25
    7cb6:	49 f4       	brne	.+18     	; 0x7cca <uip_process+0x3c4>
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    7cb8:	a0 91 b3 30 	lds	r26, 0x30B3
    7cbc:	b0 91 b4 30 	lds	r27, 0x30B4
    7cc0:	82 81       	ldd	r24, Z+2	; 0x02
    7cc2:	93 81       	ldd	r25, Z+3	; 0x03
    7cc4:	a8 17       	cp	r26, r24
    7cc6:	b9 07       	cpc	r27, r25
    7cc8:	79 f0       	breq	.+30     	; 0x7ce8 <uip_process+0x3e2>
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    7cca:	3d 96       	adiw	r30, 0x0d	; 13
    7ccc:	f0 93 a7 35 	sts	0x35A7, r31
    7cd0:	e0 93 a6 35 	sts	0x35A6, r30
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    7cd4:	e0 91 a6 35 	lds	r30, 0x35A6
    7cd8:	f0 91 a7 35 	lds	r31, 0x35A7
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    7cdc:	86 e3       	ldi	r24, 0x36	; 54
    7cde:	e4 3c       	cpi	r30, 0xC4	; 196
    7ce0:	f8 07       	cpc	r31, r24
    7ce2:	08 f4       	brcc	.+2      	; 0x7ce6 <uip_process+0x3e0>
    7ce4:	be cf       	rjmp	.-132    	; 0x7c62 <uip_process+0x35c>
    7ce6:	64 c5       	rjmp	.+2760   	; 0x87b0 <uip_process+0xeaa>
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */
  
 udp_found:
  uip_conn = NULL;
    7ce8:	10 92 ab 35 	sts	0x35AB, r1
    7cec:	10 92 aa 35 	sts	0x35AA, r1
  uip_flags = UIP_NEWDATA;
    7cf0:	82 e0       	ldi	r24, 0x02	; 2
    7cf2:	80 93 a5 35 	sts	0x35A5, r24
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    7cf6:	81 ec       	ldi	r24, 0xC1	; 193
    7cf8:	90 e3       	ldi	r25, 0x30	; 48
    7cfa:	90 93 a0 30 	sts	0x30A0, r25
    7cfe:	80 93 9f 30 	sts	0x309F, r24
  uip_slen = 0;
    7d02:	10 92 41 36 	sts	0x3641, r1
    7d06:	10 92 40 36 	sts	0x3640, r1
  UIP_UDP_APPCALL();
    7d0a:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>

 udp_send:
  if(uip_slen == 0) {
    7d0e:	80 91 40 36 	lds	r24, 0x3640
    7d12:	90 91 41 36 	lds	r25, 0x3641
    7d16:	00 97       	sbiw	r24, 0x00	; 0
    7d18:	09 f4       	brne	.+2      	; 0x7d1c <uip_process+0x416>
    7d1a:	4a c5       	rjmp	.+2708   	; 0x87b0 <uip_process+0xeaa>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    7d1c:	9c 01       	movw	r18, r24
    7d1e:	24 5e       	subi	r18, 0xE4	; 228
    7d20:	3f 4f       	sbci	r19, 0xFF	; 255
    7d22:	30 93 9e 30 	sts	0x309E, r19
    7d26:	20 93 9d 30 	sts	0x309D, r18
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    7d2a:	30 93 a7 30 	sts	0x30A7, r19
  BUF->len[1] = (uip_len & 0xff);
    7d2e:	20 93 a8 30 	sts	0x30A8, r18
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    7d32:	e0 91 a6 35 	lds	r30, 0x35A6
    7d36:	f0 91 a7 35 	lds	r31, 0x35A7
    7d3a:	20 85       	ldd	r18, Z+8	; 0x08
    7d3c:	20 93 ad 30 	sts	0x30AD, r18
  BUF->proto = UIP_PROTO_UDP;
    7d40:	21 e1       	ldi	r18, 0x11	; 17
    7d42:	20 93 ae 30 	sts	0x30AE, r18

  UDPBUF->udplen = UIP_HTONS(uip_slen + UIP_UDPH_LEN);
    7d46:	08 96       	adiw	r24, 0x08	; 8
    7d48:	98 27       	eor	r25, r24
    7d4a:	89 27       	eor	r24, r25
    7d4c:	98 27       	eor	r25, r24
    7d4e:	90 93 be 30 	sts	0x30BE, r25
    7d52:	80 93 bd 30 	sts	0x30BD, r24
  UDPBUF->udpchksum = 0;
    7d56:	10 92 c0 30 	sts	0x30C0, r1
    7d5a:	10 92 bf 30 	sts	0x30BF, r1

  BUF->srcport  = uip_udp_conn->lport;
    7d5e:	84 81       	ldd	r24, Z+4	; 0x04
    7d60:	95 81       	ldd	r25, Z+5	; 0x05
    7d62:	90 93 ba 30 	sts	0x30BA, r25
    7d66:	80 93 b9 30 	sts	0x30B9, r24
  BUF->destport = uip_udp_conn->rport;
    7d6a:	86 81       	ldd	r24, Z+6	; 0x06
    7d6c:	97 81       	ldd	r25, Z+7	; 0x07
    7d6e:	90 93 bc 30 	sts	0x30BC, r25
    7d72:	80 93 bb 30 	sts	0x30BB, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    7d76:	80 91 3c 36 	lds	r24, 0x363C
    7d7a:	90 91 3d 36 	lds	r25, 0x363D
    7d7e:	a0 91 3e 36 	lds	r26, 0x363E
    7d82:	b0 91 3f 36 	lds	r27, 0x363F
    7d86:	80 93 b1 30 	sts	0x30B1, r24
    7d8a:	90 93 b2 30 	sts	0x30B2, r25
    7d8e:	a0 93 b3 30 	sts	0x30B3, r26
    7d92:	b0 93 b4 30 	sts	0x30B4, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    7d96:	80 81       	ld	r24, Z
    7d98:	91 81       	ldd	r25, Z+1	; 0x01
    7d9a:	a2 81       	ldd	r26, Z+2	; 0x02
    7d9c:	b3 81       	ldd	r27, Z+3	; 0x03
    7d9e:	80 93 b5 30 	sts	0x30B5, r24
    7da2:	90 93 b6 30 	sts	0x30B6, r25
    7da6:	a0 93 b7 30 	sts	0x30B7, r26
    7daa:	b0 93 b8 30 	sts	0x30B8, r27
   
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    7dae:	8d ec       	ldi	r24, 0xCD	; 205
    7db0:	90 e3       	ldi	r25, 0x30	; 48
    7db2:	90 93 a9 35 	sts	0x35A9, r25
    7db6:	80 93 a8 35 	sts	0x35A8, r24

#if UIP_UDP_CHECKSUMS
  /* Calculate UDP checksum. */
  UDPBUF->udpchksum = ~(uip_udpchksum());
    7dba:	0e 94 04 3b 	call	0x7608	; 0x7608 <uip_udpchksum>
    7dbe:	80 95       	com	r24
    7dc0:	90 95       	com	r25
    7dc2:	90 93 c0 30 	sts	0x30C0, r25
    7dc6:	80 93 bf 30 	sts	0x30BF, r24
  if(UDPBUF->udpchksum == 0) {
    7dca:	00 97       	sbiw	r24, 0x00	; 0
    7dcc:	09 f0       	breq	.+2      	; 0x7dd0 <uip_process+0x4ca>
    7dce:	cd c4       	rjmp	.+2458   	; 0x876a <uip_process+0xe64>
    UDPBUF->udpchksum = 0xffff;
    7dd0:	8f ef       	ldi	r24, 0xFF	; 255
    7dd2:	9f ef       	ldi	r25, 0xFF	; 255
    7dd4:	90 93 c0 30 	sts	0x30C0, r25
    7dd8:	80 93 bf 30 	sts	0x30BF, r24
    7ddc:	c6 c4       	rjmp	.+2444   	; 0x876a <uip_process+0xe64>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    7dde:	0e 94 00 3b 	call	0x7600	; 0x7600 <uip_tcpchksum>
    7de2:	ef ef       	ldi	r30, 0xFF	; 255
    7de4:	8f 3f       	cpi	r24, 0xFF	; 255
    7de6:	9e 07       	cpc	r25, r30
    7de8:	09 f0       	breq	.+2      	; 0x7dec <uip_process+0x4e6>
    7dea:	e2 c4       	rjmp	.+2500   	; 0x87b0 <uip_process+0xeaa>
    UIP_LOG("tcp: bad checksum.");
    goto drop;
  }

  /* Make sure that the TCP port number is not zero. */
  if(BUF->destport == 0 || BUF->srcport == 0) {
    7dec:	80 91 bb 30 	lds	r24, 0x30BB
    7df0:	90 91 bc 30 	lds	r25, 0x30BC
    7df4:	00 97       	sbiw	r24, 0x00	; 0
    7df6:	09 f4       	brne	.+2      	; 0x7dfa <uip_process+0x4f4>
    7df8:	db c4       	rjmp	.+2486   	; 0x87b0 <uip_process+0xeaa>
    7dfa:	20 91 b9 30 	lds	r18, 0x30B9
    7dfe:	30 91 ba 30 	lds	r19, 0x30BA
    7e02:	21 15       	cp	r18, r1
    7e04:	31 05       	cpc	r19, r1
    7e06:	09 f4       	brne	.+2      	; 0x7e0a <uip_process+0x504>
    7e08:	d3 c4       	rjmp	.+2470   	; 0x87b0 <uip_process+0xeaa>
  uip_conn->rcv_nxt[2] = uip_acc32[2];
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(uint8_t flag)
    7e0a:	cc ea       	ldi	r28, 0xAC	; 172
    7e0c:	d5 e3       	ldi	r29, 0x35	; 53
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    7e0e:	49 8d       	ldd	r20, Y+25	; 0x19
    7e10:	44 23       	and	r20, r20
    7e12:	e9 f0       	breq	.+58     	; 0x7e4e <uip_process+0x548>
    7e14:	6c 81       	ldd	r22, Y+4	; 0x04
    7e16:	7d 81       	ldd	r23, Y+5	; 0x05
    7e18:	86 17       	cp	r24, r22
    7e1a:	97 07       	cpc	r25, r23
    7e1c:	c1 f4       	brne	.+48     	; 0x7e4e <uip_process+0x548>
       BUF->destport == uip_connr->lport &&
    7e1e:	6e 81       	ldd	r22, Y+6	; 0x06
    7e20:	7f 81       	ldd	r23, Y+7	; 0x07
    7e22:	26 17       	cp	r18, r22
    7e24:	37 07       	cpc	r19, r23
    7e26:	99 f4       	brne	.+38     	; 0x7e4e <uip_process+0x548>
       BUF->srcport == uip_connr->rport &&
    7e28:	e0 91 b1 30 	lds	r30, 0x30B1
    7e2c:	f0 91 b2 30 	lds	r31, 0x30B2
    7e30:	68 81       	ld	r22, Y
    7e32:	79 81       	ldd	r23, Y+1	; 0x01
    7e34:	e6 17       	cp	r30, r22
    7e36:	f7 07       	cpc	r31, r23
    7e38:	51 f4       	brne	.+20     	; 0x7e4e <uip_process+0x548>
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    7e3a:	e0 91 b3 30 	lds	r30, 0x30B3
    7e3e:	f0 91 b4 30 	lds	r31, 0x30B4
    7e42:	6a 81       	ldd	r22, Y+2	; 0x02
    7e44:	7b 81       	ldd	r23, Y+3	; 0x03
    7e46:	e6 17       	cp	r30, r22
    7e48:	f7 07       	cpc	r31, r23
    7e4a:	09 f4       	brne	.+2      	; 0x7e4e <uip_process+0x548>
    7e4c:	6d c1       	rjmp	.+730    	; 0x8128 <uip_process+0x822>
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    7e4e:	a0 96       	adiw	r28, 0x20	; 32
    goto drop;
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    7e50:	f6 e3       	ldi	r31, 0x36	; 54
    7e52:	cc 32       	cpi	r28, 0x2C	; 44
    7e54:	df 07       	cpc	r29, r31
    7e56:	d9 f6       	brne	.-74     	; 0x7e0e <uip_process+0x508>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    7e58:	20 91 c6 30 	lds	r18, 0x30C6
    7e5c:	2f 73       	andi	r18, 0x3F	; 63
    7e5e:	22 30       	cpi	r18, 0x02	; 2
    7e60:	b9 f4       	brne	.+46     	; 0x7e90 <uip_process+0x58a>
    goto reset;
  }
  
  tmp16 = BUF->destport;
    7e62:	90 93 08 2e 	sts	0x2E08, r25
    7e66:	80 93 07 2e 	sts	0x2E07, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7e6a:	40 e0       	ldi	r20, 0x00	; 0
    7e6c:	0d c0       	rjmp	.+26     	; 0x7e88 <uip_process+0x582>
    if(tmp16 == uip_listenports[c]) {
    7e6e:	e4 2f       	mov	r30, r20
    7e70:	f0 e0       	ldi	r31, 0x00	; 0
    7e72:	ee 0f       	add	r30, r30
    7e74:	ff 1f       	adc	r31, r31
    7e76:	e4 5d       	subi	r30, 0xD4	; 212
    7e78:	f9 4c       	sbci	r31, 0xC9	; 201
    7e7a:	20 81       	ld	r18, Z
    7e7c:	31 81       	ldd	r19, Z+1	; 0x01
    7e7e:	4f 5f       	subi	r20, 0xFF	; 255
    7e80:	82 17       	cp	r24, r18
    7e82:	93 07       	cpc	r25, r19
    7e84:	09 f4       	brne	.+2      	; 0x7e88 <uip_process+0x582>
    7e86:	6e c0       	rjmp	.+220    	; 0x7f64 <uip_process+0x65e>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    7e88:	44 30       	cpi	r20, 0x04	; 4
    7e8a:	88 f3       	brcs	.-30     	; 0x7e6e <uip_process+0x568>
    7e8c:	40 93 09 2e 	sts	0x2E09, r20
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    7e90:	80 91 c6 30 	lds	r24, 0x30C6
    7e94:	82 fd       	sbrc	r24, 2
    7e96:	8c c4       	rjmp	.+2328   	; 0x87b0 <uip_process+0xeaa>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
  
  BUF->flags = TCP_RST | TCP_ACK;
    7e98:	84 e1       	ldi	r24, 0x14	; 20
    7e9a:	f8 01       	movw	r30, r16
    7e9c:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    7e9e:	88 e2       	ldi	r24, 0x28	; 40
    7ea0:	90 e0       	ldi	r25, 0x00	; 0
    7ea2:	90 93 9e 30 	sts	0x309E, r25
    7ea6:	80 93 9d 30 	sts	0x309D, r24
  BUF->tcpoffset = 5 << 4;
    7eaa:	80 e5       	ldi	r24, 0x50	; 80
    7eac:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    7eae:	80 91 c0 30 	lds	r24, 0x30C0
  BUF->seqno[3] = BUF->ackno[3];
    7eb2:	90 91 c4 30 	lds	r25, 0x30C4
    7eb6:	93 8f       	std	Z+27, r25	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    7eb8:	30 91 bf 30 	lds	r19, 0x30BF
  BUF->seqno[2] = BUF->ackno[2];
    7ebc:	90 91 c3 30 	lds	r25, 0x30C3
    7ec0:	92 8f       	std	Z+26, r25	; 0x1a
  BUF->ackno[2] = c;
    7ec2:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    7ec4:	20 91 be 30 	lds	r18, 0x30BE
  BUF->seqno[1] = BUF->ackno[1];
    7ec8:	90 91 c2 30 	lds	r25, 0x30C2
    7ecc:	91 8f       	std	Z+25, r25	; 0x19
  BUF->ackno[1] = c;
    7ece:	25 8f       	std	Z+29, r18	; 0x1d
  
  c = BUF->seqno[0];
    7ed0:	90 91 bd 30 	lds	r25, 0x30BD
    7ed4:	90 93 09 2e 	sts	0x2E09, r25
  BUF->seqno[0] = BUF->ackno[0];
    7ed8:	40 91 c1 30 	lds	r20, 0x30C1
    7edc:	40 8f       	std	Z+24, r20	; 0x18
  BUF->ackno[0] = c;
    7ede:	94 8f       	std	Z+28, r25	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    7ee0:	8f 5f       	subi	r24, 0xFF	; 255
    7ee2:	87 8f       	std	Z+31, r24	; 0x1f
    7ee4:	88 23       	and	r24, r24
    7ee6:	61 f4       	brne	.+24     	; 0x7f00 <uip_process+0x5fa>
    if(++BUF->ackno[2] == 0) {
    7ee8:	83 2f       	mov	r24, r19
    7eea:	8f 5f       	subi	r24, 0xFF	; 255
    7eec:	86 8f       	std	Z+30, r24	; 0x1e
    7eee:	88 23       	and	r24, r24
    7ef0:	39 f4       	brne	.+14     	; 0x7f00 <uip_process+0x5fa>
      if(++BUF->ackno[1] == 0) {
    7ef2:	82 2f       	mov	r24, r18
    7ef4:	8f 5f       	subi	r24, 0xFF	; 255
    7ef6:	85 8f       	std	Z+29, r24	; 0x1d
    7ef8:	88 23       	and	r24, r24
    7efa:	11 f4       	brne	.+4      	; 0x7f00 <uip_process+0x5fa>
	++BUF->ackno[0];
    7efc:	9f 5f       	subi	r25, 0xFF	; 255
    7efe:	94 8f       	std	Z+28, r25	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    7f00:	80 91 b9 30 	lds	r24, 0x30B9
    7f04:	90 91 ba 30 	lds	r25, 0x30BA
    7f08:	90 93 08 2e 	sts	0x2E08, r25
    7f0c:	80 93 07 2e 	sts	0x2E07, r24
  BUF->srcport = BUF->destport;
    7f10:	20 91 bb 30 	lds	r18, 0x30BB
    7f14:	30 91 bc 30 	lds	r19, 0x30BC
    7f18:	f8 01       	movw	r30, r16
    7f1a:	35 8b       	std	Z+21, r19	; 0x15
    7f1c:	24 8b       	std	Z+20, r18	; 0x14
  BUF->destport = tmp16;
    7f1e:	97 8b       	std	Z+23, r25	; 0x17
    7f20:	86 8b       	std	Z+22, r24	; 0x16
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    7f22:	80 91 b1 30 	lds	r24, 0x30B1
    7f26:	90 91 b2 30 	lds	r25, 0x30B2
    7f2a:	a0 91 b3 30 	lds	r26, 0x30B3
    7f2e:	b0 91 b4 30 	lds	r27, 0x30B4
    7f32:	80 93 b5 30 	sts	0x30B5, r24
    7f36:	90 93 b6 30 	sts	0x30B6, r25
    7f3a:	a0 93 b7 30 	sts	0x30B7, r26
    7f3e:	b0 93 b8 30 	sts	0x30B8, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    7f42:	80 91 3c 36 	lds	r24, 0x363C
    7f46:	90 91 3d 36 	lds	r25, 0x363D
    7f4a:	a0 91 3e 36 	lds	r26, 0x363E
    7f4e:	b0 91 3f 36 	lds	r27, 0x363F
    7f52:	80 93 b1 30 	sts	0x30B1, r24
    7f56:	90 93 b2 30 	sts	0x30B2, r25
    7f5a:	a0 93 b3 30 	sts	0x30B3, r26
    7f5e:	b0 93 b4 30 	sts	0x30B4, r27
  
  /* And send out the RST packet! */
  goto tcp_send_noconn;
    7f62:	e8 c3       	rjmp	.+2000   	; 0x8734 <uip_process+0xe2e>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    7f64:	10 92 09 2e 	sts	0x2E09, r1
    7f68:	80 e0       	ldi	r24, 0x00	; 0
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
    7f6a:	c0 e0       	ldi	r28, 0x00	; 0
    7f6c:	d0 e0       	ldi	r29, 0x00	; 0
  for(c = 0; c < UIP_CONNS; ++c) {
    7f6e:	22 c0       	rjmp	.+68     	; 0x7fb4 <uip_process+0x6ae>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    7f70:	e8 2f       	mov	r30, r24
    7f72:	f0 e0       	ldi	r31, 0x00	; 0
    7f74:	75 e0       	ldi	r23, 0x05	; 5
    7f76:	ee 0f       	add	r30, r30
    7f78:	ff 1f       	adc	r31, r31
    7f7a:	7a 95       	dec	r23
    7f7c:	e1 f7       	brne	.-8      	; 0x7f76 <uip_process+0x670>
    7f7e:	e4 55       	subi	r30, 0x54	; 84
    7f80:	fa 4c       	sbci	r31, 0xCA	; 202
    7f82:	91 8d       	ldd	r25, Z+25	; 0x19
    7f84:	99 23       	and	r25, r25
    7f86:	21 f4       	brne	.+8      	; 0x7f90 <uip_process+0x68a>
    7f88:	80 93 09 2e 	sts	0x2E09, r24
      uip_connr = &uip_conns[c];
    7f8c:	ef 01       	movw	r28, r30
      break;
    7f8e:	16 c0       	rjmp	.+44     	; 0x7fbc <uip_process+0x6b6>
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    7f90:	97 30       	cpi	r25, 0x07	; 7
    7f92:	79 f4       	brne	.+30     	; 0x7fb2 <uip_process+0x6ac>
      if(uip_connr == 0 ||
    7f94:	20 97       	sbiw	r28, 0x00	; 0
    7f96:	21 f0       	breq	.+8      	; 0x7fa0 <uip_process+0x69a>
    7f98:	22 8d       	ldd	r18, Z+26	; 0x1a
    7f9a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7f9c:	92 17       	cp	r25, r18
    7f9e:	48 f4       	brcc	.+18     	; 0x7fb2 <uip_process+0x6ac>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    7fa0:	c8 2f       	mov	r28, r24
    7fa2:	d0 e0       	ldi	r29, 0x00	; 0
    7fa4:	65 e0       	ldi	r22, 0x05	; 5
    7fa6:	cc 0f       	add	r28, r28
    7fa8:	dd 1f       	adc	r29, r29
    7faa:	6a 95       	dec	r22
    7fac:	e1 f7       	brne	.-8      	; 0x7fa6 <uip_process+0x6a0>
    7fae:	c4 55       	subi	r28, 0x54	; 84
    7fb0:	da 4c       	sbci	r29, 0xCA	; 202
    7fb2:	8f 5f       	subi	r24, 0xFF	; 255
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    7fb4:	84 30       	cpi	r24, 0x04	; 4
    7fb6:	e0 f2       	brcs	.-72     	; 0x7f70 <uip_process+0x66a>
    7fb8:	80 93 09 2e 	sts	0x2E09, r24
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    7fbc:	20 97       	sbiw	r28, 0x00	; 0
    7fbe:	09 f4       	brne	.+2      	; 0x7fc2 <uip_process+0x6bc>
    7fc0:	f7 c3       	rjmp	.+2030   	; 0x87b0 <uip_process+0xeaa>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    7fc2:	d0 93 ab 35 	sts	0x35AB, r29
    7fc6:	c0 93 aa 35 	sts	0x35AA, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    7fca:	83 e0       	ldi	r24, 0x03	; 3
    7fcc:	8a 8f       	std	Y+26, r24	; 0x1a
    7fce:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    7fd0:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    7fd2:	84 e0       	ldi	r24, 0x04	; 4
    7fd4:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    7fd6:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    7fd8:	80 91 bb 30 	lds	r24, 0x30BB
    7fdc:	90 91 bc 30 	lds	r25, 0x30BC
    7fe0:	9d 83       	std	Y+5, r25	; 0x05
    7fe2:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    7fe4:	80 91 b9 30 	lds	r24, 0x30B9
    7fe8:	90 91 ba 30 	lds	r25, 0x30BA
    7fec:	9f 83       	std	Y+7, r25	; 0x07
    7fee:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    7ff0:	80 91 b1 30 	lds	r24, 0x30B1
    7ff4:	90 91 b2 30 	lds	r25, 0x30B2
    7ff8:	a0 91 b3 30 	lds	r26, 0x30B3
    7ffc:	b0 91 b4 30 	lds	r27, 0x30B4
    8000:	88 83       	st	Y, r24
    8002:	99 83       	std	Y+1, r25	; 0x01
    8004:	aa 83       	std	Y+2, r26	; 0x02
    8006:	bb 83       	std	Y+3, r27	; 0x03
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    8008:	81 e0       	ldi	r24, 0x01	; 1
    800a:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    800c:	80 91 03 2e 	lds	r24, 0x2E03
    8010:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    8012:	80 91 04 2e 	lds	r24, 0x2E04
    8016:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    8018:	80 91 05 2e 	lds	r24, 0x2E05
    801c:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    801e:	80 91 06 2e 	lds	r24, 0x2E06
    8022:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    8024:	81 e0       	ldi	r24, 0x01	; 1
    8026:	90 e0       	ldi	r25, 0x00	; 0
    8028:	99 8b       	std	Y+17, r25	; 0x11
    802a:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    802c:	80 91 c0 30 	lds	r24, 0x30C0
    8030:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    8032:	80 91 bf 30 	lds	r24, 0x30BF
    8036:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    8038:	80 91 be 30 	lds	r24, 0x30BE
    803c:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    803e:	80 91 bd 30 	lds	r24, 0x30BD
    8042:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    8044:	81 e0       	ldi	r24, 0x01	; 1
    8046:	90 e0       	ldi	r25, 0x00	; 0
    8048:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    804c:	80 91 c5 30 	lds	r24, 0x30C5
    8050:	28 2f       	mov	r18, r24
    8052:	30 e0       	ldi	r19, 0x00	; 0
    8054:	20 7f       	andi	r18, 0xF0	; 240
    8056:	30 70       	andi	r19, 0x00	; 0
    8058:	21 35       	cpi	r18, 0x51	; 81
    805a:	31 05       	cpc	r19, r1
    805c:	0c f4       	brge	.+2      	; 0x8060 <uip_process+0x75a>
    805e:	49 c0       	rjmp	.+146    	; 0x80f2 <uip_process+0x7ec>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    8060:	82 95       	swap	r24
    8062:	8f 70       	andi	r24, 0x0F	; 15
    8064:	90 e0       	ldi	r25, 0x00	; 0
    8066:	05 97       	sbiw	r24, 0x05	; 5
    8068:	88 0f       	add	r24, r24
    806a:	99 1f       	adc	r25, r25
    806c:	88 0f       	add	r24, r24
    806e:	99 1f       	adc	r25, r25
    8070:	50 91 0a 2e 	lds	r21, 0x2E0A
    8074:	40 e0       	ldi	r20, 0x00	; 0
    8076:	34 c0       	rjmp	.+104    	; 0x80e0 <uip_process+0x7da>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    8078:	f9 01       	movw	r30, r18
    807a:	eb 55       	subi	r30, 0x5B	; 91
    807c:	ff 4c       	sbci	r31, 0xCF	; 207
    807e:	50 a5       	ldd	r21, Z+40	; 0x28
      if(opt == TCP_OPT_END) {
    8080:	55 23       	and	r21, r21
    8082:	29 f4       	brne	.+10     	; 0x808e <uip_process+0x788>
    8084:	40 93 09 2e 	sts	0x2E09, r20
    8088:	10 92 0a 2e 	sts	0x2E0A, r1
    808c:	32 c0       	rjmp	.+100    	; 0x80f2 <uip_process+0x7ec>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    808e:	51 30       	cpi	r21, 0x01	; 1
    8090:	11 f4       	brne	.+4      	; 0x8096 <uip_process+0x790>
	++c;
    8092:	4f 5f       	subi	r20, 0xFF	; 255
    8094:	25 c0       	rjmp	.+74     	; 0x80e0 <uip_process+0x7da>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    8096:	52 30       	cpi	r21, 0x02	; 2
    8098:	e1 f4       	brne	.+56     	; 0x80d2 <uip_process+0x7cc>
    809a:	61 a5       	ldd	r22, Z+41	; 0x29
    809c:	64 30       	cpi	r22, 0x04	; 4
    809e:	c9 f4       	brne	.+50     	; 0x80d2 <uip_process+0x7cc>
    80a0:	40 93 09 2e 	sts	0x2E09, r20
    80a4:	50 93 0a 2e 	sts	0x2E0A, r21
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    80a8:	32 a5       	ldd	r19, Z+42	; 0x2a
    80aa:	20 e0       	ldi	r18, 0x00	; 0
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    80ac:	83 a5       	ldd	r24, Z+43	; 0x2b
    80ae:	90 e0       	ldi	r25, 0x00	; 0
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    80b0:	82 2b       	or	r24, r18
    80b2:	93 2b       	or	r25, r19
    80b4:	90 93 08 2e 	sts	0x2E08, r25
    80b8:	80 93 07 2e 	sts	0x2E07, r24
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    80bc:	f4 e0       	ldi	r31, 0x04	; 4
    80be:	89 3d       	cpi	r24, 0xD9	; 217
    80c0:	9f 07       	cpc	r25, r31
    80c2:	10 f0       	brcs	.+4      	; 0x80c8 <uip_process+0x7c2>
    80c4:	88 ed       	ldi	r24, 0xD8	; 216
    80c6:	94 e0       	ldi	r25, 0x04	; 4
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    80c8:	9b 8b       	std	Y+19, r25	; 0x13
    80ca:	8a 8b       	std	Y+18, r24	; 0x12
    80cc:	9d 8b       	std	Y+21, r25	; 0x15
    80ce:	8c 8b       	std	Y+20, r24	; 0x14
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
	
	/* And we are done processing options. */
	break;
    80d0:	10 c0       	rjmp	.+32     	; 0x80f2 <uip_process+0x7ec>
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    80d2:	2b 55       	subi	r18, 0x5B	; 91
    80d4:	3f 4c       	sbci	r19, 0xCF	; 207
    80d6:	f9 01       	movw	r30, r18
    80d8:	21 a5       	ldd	r18, Z+41	; 0x29
    80da:	22 23       	and	r18, r18
    80dc:	31 f0       	breq	.+12     	; 0x80ea <uip_process+0x7e4>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    80de:	42 0f       	add	r20, r18
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    80e0:	24 2f       	mov	r18, r20
    80e2:	30 e0       	ldi	r19, 0x00	; 0
    80e4:	28 17       	cp	r18, r24
    80e6:	39 07       	cpc	r19, r25
    80e8:	3c f2       	brlt	.-114    	; 0x8078 <uip_process+0x772>
    80ea:	40 93 09 2e 	sts	0x2E09, r20
    80ee:	50 93 0a 2e 	sts	0x2E0A, r21
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    80f2:	80 e1       	ldi	r24, 0x10	; 16
    80f4:	80 93 c6 30 	sts	0x30C6, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    80f8:	80 91 c6 30 	lds	r24, 0x30C6
    80fc:	82 60       	ori	r24, 0x02	; 2
    80fe:	80 93 c6 30 	sts	0x30C6, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    8102:	82 e0       	ldi	r24, 0x02	; 2
    8104:	80 93 cd 30 	sts	0x30CD, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    8108:	84 e0       	ldi	r24, 0x04	; 4
    810a:	80 93 ce 30 	sts	0x30CE, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    810e:	80 93 cf 30 	sts	0x30CF, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    8112:	88 ed       	ldi	r24, 0xD8	; 216
    8114:	80 93 d0 30 	sts	0x30D0, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    8118:	8c e2       	ldi	r24, 0x2C	; 44
    811a:	90 e0       	ldi	r25, 0x00	; 0
    811c:	90 93 9e 30 	sts	0x309E, r25
    8120:	80 93 9d 30 	sts	0x309D, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    8124:	80 e6       	ldi	r24, 0x60	; 96
    8126:	b3 c2       	rjmp	.+1382   	; 0x868e <uip_process+0xd88>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    8128:	d0 93 ab 35 	sts	0x35AB, r29
    812c:	c0 93 aa 35 	sts	0x35AA, r28
  uip_flags = 0;
    8130:	10 92 a5 35 	sts	0x35A5, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    8134:	80 91 c6 30 	lds	r24, 0x30C6
    8138:	90 e0       	ldi	r25, 0x00	; 0
    813a:	82 ff       	sbrs	r24, 2
    813c:	03 c0       	rjmp	.+6      	; 0x8144 <uip_process+0x83e>
    uip_connr->tcpstateflags = UIP_CLOSED;
    813e:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    8140:	80 e2       	ldi	r24, 0x20	; 32
    8142:	4e c2       	rjmp	.+1180   	; 0x85e0 <uip_process+0xcda>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    8144:	20 91 c5 30 	lds	r18, 0x30C5
    8148:	22 95       	swap	r18
    814a:	2f 70       	andi	r18, 0x0F	; 15
    814c:	22 0f       	add	r18, r18
    814e:	22 0f       	add	r18, r18
    8150:	20 93 09 2e 	sts	0x2E09, r18
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    8154:	b7 01       	movw	r22, r14
    8156:	62 1b       	sub	r22, r18
    8158:	71 09       	sbc	r23, r1
    815a:	9b 01       	movw	r18, r22
    815c:	24 51       	subi	r18, 0x14	; 20
    815e:	30 40       	sbci	r19, 0x00	; 0
    8160:	30 93 9e 30 	sts	0x309E, r19
    8164:	20 93 9d 30 	sts	0x309D, r18
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    8168:	50 e0       	ldi	r21, 0x00	; 0
    816a:	4f 70       	andi	r20, 0x0F	; 15
    816c:	50 70       	andi	r21, 0x00	; 0
    816e:	42 30       	cpi	r20, 0x02	; 2
    8170:	51 05       	cpc	r21, r1
    8172:	39 f4       	brne	.+14     	; 0x8182 <uip_process+0x87c>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
    8174:	ac 01       	movw	r20, r24
    8176:	4f 73       	andi	r20, 0x3F	; 63
    8178:	50 70       	andi	r21, 0x00	; 0
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    817a:	42 31       	cpi	r20, 0x12	; 18
    817c:	51 05       	cpc	r21, r1
    817e:	51 f4       	brne	.+20     	; 0x8194 <uip_process+0x88e>
    8180:	2a c0       	rjmp	.+84     	; 0x81d6 <uip_process+0x8d0>
    8182:	41 30       	cpi	r20, 0x01	; 1
    8184:	51 05       	cpc	r21, r1
    8186:	31 f4       	brne	.+12     	; 0x8194 <uip_process+0x88e>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    8188:	ac 01       	movw	r20, r24
    818a:	4f 73       	andi	r20, 0x3F	; 63
    818c:	50 70       	andi	r21, 0x00	; 0
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
    818e:	42 30       	cpi	r20, 0x02	; 2
    8190:	51 05       	cpc	r21, r1
    8192:	09 f1       	breq	.+66     	; 0x81d6 <uip_process+0x8d0>
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    8194:	21 15       	cp	r18, r1
    8196:	31 05       	cpc	r19, r1
    8198:	31 f4       	brne	.+12     	; 0x81a6 <uip_process+0x8a0>
    819a:	9c 01       	movw	r18, r24
    819c:	23 70       	andi	r18, 0x03	; 3
    819e:	30 70       	andi	r19, 0x00	; 0
    81a0:	21 15       	cp	r18, r1
    81a2:	31 05       	cpc	r19, r1
    81a4:	c1 f0       	breq	.+48     	; 0x81d6 <uip_process+0x8d0>
    81a6:	30 91 bd 30 	lds	r19, 0x30BD
    81aa:	28 85       	ldd	r18, Y+8	; 0x08
    81ac:	32 17       	cp	r19, r18
    81ae:	09 f0       	breq	.+2      	; 0x81b2 <uip_process+0x8ac>
    81b0:	64 c2       	rjmp	.+1224   	; 0x867a <uip_process+0xd74>
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
    81b2:	30 91 be 30 	lds	r19, 0x30BE
    81b6:	29 85       	ldd	r18, Y+9	; 0x09
    81b8:	32 17       	cp	r19, r18
    81ba:	09 f0       	breq	.+2      	; 0x81be <uip_process+0x8b8>
    81bc:	5e c2       	rjmp	.+1212   	; 0x867a <uip_process+0xd74>
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
    81be:	30 91 bf 30 	lds	r19, 0x30BF
    81c2:	2a 85       	ldd	r18, Y+10	; 0x0a
    81c4:	32 17       	cp	r19, r18
    81c6:	09 f0       	breq	.+2      	; 0x81ca <uip_process+0x8c4>
    81c8:	58 c2       	rjmp	.+1200   	; 0x867a <uip_process+0xd74>
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
    81ca:	30 91 c0 30 	lds	r19, 0x30C0
    81ce:	2b 85       	ldd	r18, Y+11	; 0x0b
    81d0:	32 17       	cp	r19, r18
    81d2:	09 f0       	breq	.+2      	; 0x81d6 <uip_process+0x8d0>
    81d4:	52 c2       	rjmp	.+1188   	; 0x867a <uip_process+0xd74>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    81d6:	84 ff       	sbrs	r24, 4
    81d8:	4a c0       	rjmp	.+148    	; 0x826e <uip_process+0x968>
    81da:	68 89       	ldd	r22, Y+16	; 0x10
    81dc:	79 89       	ldd	r23, Y+17	; 0x11
    81de:	61 15       	cp	r22, r1
    81e0:	71 05       	cpc	r23, r1
    81e2:	09 f4       	brne	.+2      	; 0x81e6 <uip_process+0x8e0>
    81e4:	44 c0       	rjmp	.+136    	; 0x826e <uip_process+0x968>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    81e6:	ce 01       	movw	r24, r28
    81e8:	0c 96       	adiw	r24, 0x0c	; 12
    81ea:	0e 94 93 3a 	call	0x7526	; 0x7526 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    81ee:	30 91 c1 30 	lds	r19, 0x30C1
    81f2:	80 91 a1 30 	lds	r24, 0x30A1
    81f6:	38 17       	cp	r19, r24
    81f8:	d1 f5       	brne	.+116    	; 0x826e <uip_process+0x968>
       BUF->ackno[1] == uip_acc32[1] &&
    81fa:	20 91 c2 30 	lds	r18, 0x30C2
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
    81fe:	80 91 a2 30 	lds	r24, 0x30A2
    8202:	28 17       	cp	r18, r24
    8204:	a1 f5       	brne	.+104    	; 0x826e <uip_process+0x968>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    8206:	90 91 c3 30 	lds	r25, 0x30C3
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
    820a:	80 91 a3 30 	lds	r24, 0x30A3
    820e:	98 17       	cp	r25, r24
    8210:	71 f5       	brne	.+92     	; 0x826e <uip_process+0x968>
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
    8212:	80 91 c4 30 	lds	r24, 0x30C4
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    8216:	40 91 a4 30 	lds	r20, 0x30A4
    821a:	84 17       	cp	r24, r20
    821c:	41 f5       	brne	.+80     	; 0x826e <uip_process+0x968>
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    821e:	3c 87       	std	Y+12, r19	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    8220:	2d 87       	std	Y+13, r18	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    8222:	9e 87       	std	Y+14, r25	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    8224:	8f 87       	std	Y+15, r24	; 0x0f
	
      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    8226:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8228:	88 23       	and	r24, r24
    822a:	d1 f4       	brne	.+52     	; 0x8260 <uip_process+0x95a>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    822c:	2e 89       	ldd	r18, Y+22	; 0x16
      uip_connr->snd_nxt[3] = uip_acc32[3];
	
      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
    822e:	88 8d       	ldd	r24, Y+24	; 0x18
    8230:	9a 8d       	ldd	r25, Y+26	; 0x1a
    8232:	89 1b       	sub	r24, r25
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    8234:	92 2f       	mov	r25, r18
    8236:	96 95       	lsr	r25
    8238:	96 95       	lsr	r25
    823a:	96 95       	lsr	r25
    823c:	89 1b       	sub	r24, r25
	uip_connr->sa += m;
    823e:	28 0f       	add	r18, r24
    8240:	2e 8b       	std	Y+22, r18	; 0x16
	if(m < 0) {
	  m = -m;
    8242:	87 fd       	sbrc	r24, 7
    8244:	81 95       	neg	r24
	}
	m = m - (uip_connr->sv >> 2);
    8246:	9f 89       	ldd	r25, Y+23	; 0x17
    8248:	39 2f       	mov	r19, r25
    824a:	36 95       	lsr	r19
    824c:	36 95       	lsr	r19
    824e:	93 1b       	sub	r25, r19
	uip_connr->sv += m;
    8250:	98 0f       	add	r25, r24
    8252:	9f 8b       	std	Y+23, r25	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    8254:	82 2f       	mov	r24, r18
    8256:	86 95       	lsr	r24
    8258:	86 95       	lsr	r24
    825a:	86 95       	lsr	r24
    825c:	89 0f       	add	r24, r25
    825e:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    8260:	81 e0       	ldi	r24, 0x01	; 1
    8262:	80 93 a5 35 	sts	0x35A5, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    8266:	88 8d       	ldd	r24, Y+24	; 0x18
    8268:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    826a:	19 8a       	std	Y+17, r1	; 0x11
    826c:	18 8a       	std	Y+16, r1	; 0x10
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    826e:	29 8d       	ldd	r18, Y+25	; 0x19
    8270:	30 e0       	ldi	r19, 0x00	; 0
    8272:	c9 01       	movw	r24, r18
    8274:	8f 70       	andi	r24, 0x0F	; 15
    8276:	90 70       	andi	r25, 0x00	; 0
    8278:	84 30       	cpi	r24, 0x04	; 4
    827a:	91 05       	cpc	r25, r1
    827c:	09 f4       	brne	.+2      	; 0x8280 <uip_process+0x97a>
    827e:	b5 c1       	rjmp	.+874    	; 0x85ea <uip_process+0xce4>
    8280:	85 30       	cpi	r24, 0x05	; 5
    8282:	91 05       	cpc	r25, r1
    8284:	64 f4       	brge	.+24     	; 0x829e <uip_process+0x998>
    8286:	82 30       	cpi	r24, 0x02	; 2
    8288:	91 05       	cpc	r25, r1
    828a:	c9 f1       	breq	.+114    	; 0x82fe <uip_process+0x9f8>
    828c:	83 30       	cpi	r24, 0x03	; 3
    828e:	91 05       	cpc	r25, r1
    8290:	0c f0       	brlt	.+2      	; 0x8294 <uip_process+0x98e>
    8292:	b9 c0       	rjmp	.+370    	; 0x8406 <uip_process+0xb00>
    8294:	81 30       	cpi	r24, 0x01	; 1
    8296:	91 05       	cpc	r25, r1
    8298:	09 f0       	breq	.+2      	; 0x829c <uip_process+0x996>
    829a:	8a c2       	rjmp	.+1300   	; 0x87b0 <uip_process+0xeaa>
    829c:	11 c0       	rjmp	.+34     	; 0x82c0 <uip_process+0x9ba>
    829e:	86 30       	cpi	r24, 0x06	; 6
    82a0:	91 05       	cpc	r25, r1
    82a2:	09 f4       	brne	.+2      	; 0x82a6 <uip_process+0x9a0>
    82a4:	e2 c1       	rjmp	.+964    	; 0x866a <uip_process+0xd64>
    82a6:	86 30       	cpi	r24, 0x06	; 6
    82a8:	91 05       	cpc	r25, r1
    82aa:	0c f4       	brge	.+2      	; 0x82ae <uip_process+0x9a8>
    82ac:	be c1       	rjmp	.+892    	; 0x862a <uip_process+0xd24>
    82ae:	87 30       	cpi	r24, 0x07	; 7
    82b0:	91 05       	cpc	r25, r1
    82b2:	09 f4       	brne	.+2      	; 0x82b6 <uip_process+0x9b0>
    82b4:	e2 c1       	rjmp	.+964    	; 0x867a <uip_process+0xd74>
    82b6:	88 30       	cpi	r24, 0x08	; 8
    82b8:	91 05       	cpc	r25, r1
    82ba:	09 f0       	breq	.+2      	; 0x82be <uip_process+0x9b8>
    82bc:	79 c2       	rjmp	.+1266   	; 0x87b0 <uip_process+0xeaa>
    82be:	8a c1       	rjmp	.+788    	; 0x85d4 <uip_process+0xcce>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    82c0:	80 91 a5 35 	lds	r24, 0x35A5
    82c4:	80 ff       	sbrs	r24, 0
    82c6:	14 c0       	rjmp	.+40     	; 0x82f0 <uip_process+0x9ea>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    82c8:	83 e0       	ldi	r24, 0x03	; 3
    82ca:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    82cc:	80 e4       	ldi	r24, 0x40	; 64
    82ce:	80 93 a5 35 	sts	0x35A5, r24
      uip_connr->len = 0;
    82d2:	19 8a       	std	Y+17, r1	; 0x11
    82d4:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    82d6:	80 91 9d 30 	lds	r24, 0x309D
    82da:	90 91 9e 30 	lds	r25, 0x309E
    82de:	00 97       	sbiw	r24, 0x00	; 0
    82e0:	09 f4       	brne	.+2      	; 0x82e4 <uip_process+0x9de>
    82e2:	10 c1       	rjmp	.+544    	; 0x8504 <uip_process+0xbfe>
        uip_flags |= UIP_NEWDATA;
    82e4:	22 e4       	ldi	r18, 0x42	; 66
    82e6:	20 93 a5 35 	sts	0x35A5, r18
        uip_add_rcv_nxt(uip_len);
    82ea:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
    82ee:	0a c1       	rjmp	.+532    	; 0x8504 <uip_process+0xbfe>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* We need to retransmit the SYNACK */
    if((BUF->flags & TCP_CTL) == TCP_SYN) {
    82f0:	80 91 c6 30 	lds	r24, 0x30C6
    82f4:	8f 73       	andi	r24, 0x3F	; 63
    82f6:	82 30       	cpi	r24, 0x02	; 2
    82f8:	09 f0       	breq	.+2      	; 0x82fc <uip_process+0x9f6>
    82fa:	5a c2       	rjmp	.+1204   	; 0x87b0 <uip_process+0xeaa>
    82fc:	fa ce       	rjmp	.-524    	; 0x80f2 <uip_process+0x7ec>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    82fe:	80 91 a5 35 	lds	r24, 0x35A5
    8302:	80 ff       	sbrs	r24, 0
    8304:	75 c0       	rjmp	.+234    	; 0x83f0 <uip_process+0xaea>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
    8306:	80 91 c6 30 	lds	r24, 0x30C6
    830a:	8f 73       	andi	r24, 0x3F	; 63
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    830c:	82 31       	cpi	r24, 0x12	; 18
    830e:	09 f0       	breq	.+2      	; 0x8312 <uip_process+0xa0c>
    8310:	6f c0       	rjmp	.+222    	; 0x83f0 <uip_process+0xaea>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    8312:	80 91 c5 30 	lds	r24, 0x30C5
    8316:	28 2f       	mov	r18, r24
    8318:	30 e0       	ldi	r19, 0x00	; 0
    831a:	20 7f       	andi	r18, 0xF0	; 240
    831c:	30 70       	andi	r19, 0x00	; 0
    831e:	21 35       	cpi	r18, 0x51	; 81
    8320:	31 05       	cpc	r19, r1
    8322:	0c f4       	brge	.+2      	; 0x8326 <uip_process+0xa20>
    8324:	49 c0       	rjmp	.+146    	; 0x83b8 <uip_process+0xab2>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    8326:	82 95       	swap	r24
    8328:	8f 70       	andi	r24, 0x0F	; 15
    832a:	90 e0       	ldi	r25, 0x00	; 0
    832c:	05 97       	sbiw	r24, 0x05	; 5
    832e:	88 0f       	add	r24, r24
    8330:	99 1f       	adc	r25, r25
    8332:	88 0f       	add	r24, r24
    8334:	99 1f       	adc	r25, r25
    8336:	50 91 0a 2e 	lds	r21, 0x2E0A
    833a:	40 e0       	ldi	r20, 0x00	; 0
    833c:	34 c0       	rjmp	.+104    	; 0x83a6 <uip_process+0xaa0>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    833e:	f9 01       	movw	r30, r18
    8340:	eb 55       	subi	r30, 0x5B	; 91
    8342:	ff 4c       	sbci	r31, 0xCF	; 207
    8344:	50 a5       	ldd	r21, Z+40	; 0x28
	  if(opt == TCP_OPT_END) {
    8346:	55 23       	and	r21, r21
    8348:	29 f4       	brne	.+10     	; 0x8354 <uip_process+0xa4e>
    834a:	40 93 09 2e 	sts	0x2E09, r20
    834e:	10 92 0a 2e 	sts	0x2E0A, r1
    8352:	32 c0       	rjmp	.+100    	; 0x83b8 <uip_process+0xab2>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    8354:	51 30       	cpi	r21, 0x01	; 1
    8356:	11 f4       	brne	.+4      	; 0x835c <uip_process+0xa56>
	    ++c;
    8358:	4f 5f       	subi	r20, 0xFF	; 255
    835a:	25 c0       	rjmp	.+74     	; 0x83a6 <uip_process+0xaa0>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    835c:	52 30       	cpi	r21, 0x02	; 2
    835e:	e1 f4       	brne	.+56     	; 0x8398 <uip_process+0xa92>
    8360:	61 a5       	ldd	r22, Z+41	; 0x29
    8362:	64 30       	cpi	r22, 0x04	; 4
    8364:	c9 f4       	brne	.+50     	; 0x8398 <uip_process+0xa92>
    8366:	40 93 09 2e 	sts	0x2E09, r20
    836a:	50 93 0a 2e 	sts	0x2E0A, r21
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    836e:	32 a5       	ldd	r19, Z+42	; 0x2a
    8370:	20 e0       	ldi	r18, 0x00	; 0
    8372:	83 a5       	ldd	r24, Z+43	; 0x2b
    8374:	90 e0       	ldi	r25, 0x00	; 0
    8376:	82 2b       	or	r24, r18
    8378:	93 2b       	or	r25, r19
    837a:	90 93 08 2e 	sts	0x2E08, r25
    837e:	80 93 07 2e 	sts	0x2E07, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    8382:	74 e0       	ldi	r23, 0x04	; 4
    8384:	89 3d       	cpi	r24, 0xD9	; 217
    8386:	97 07       	cpc	r25, r23
    8388:	10 f0       	brcs	.+4      	; 0x838e <uip_process+0xa88>
    838a:	88 ed       	ldi	r24, 0xD8	; 216
    838c:	94 e0       	ldi	r25, 0x04	; 4
    838e:	9b 8b       	std	Y+19, r25	; 0x13
    8390:	8a 8b       	std	Y+18, r24	; 0x12
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    8392:	9d 8b       	std	Y+21, r25	; 0x15
    8394:	8c 8b       	std	Y+20, r24	; 0x14
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
    8396:	10 c0       	rjmp	.+32     	; 0x83b8 <uip_process+0xab2>
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    8398:	2b 55       	subi	r18, 0x5B	; 91
    839a:	3f 4c       	sbci	r19, 0xCF	; 207
    839c:	f9 01       	movw	r30, r18
    839e:	21 a5       	ldd	r18, Z+41	; 0x29
    83a0:	22 23       	and	r18, r18
    83a2:	31 f0       	breq	.+12     	; 0x83b0 <uip_process+0xaaa>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    83a4:	42 0f       	add	r20, r18
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    83a6:	24 2f       	mov	r18, r20
    83a8:	30 e0       	ldi	r19, 0x00	; 0
    83aa:	28 17       	cp	r18, r24
    83ac:	39 07       	cpc	r19, r25
    83ae:	3c f2       	brlt	.-114    	; 0x833e <uip_process+0xa38>
    83b0:	40 93 09 2e 	sts	0x2E09, r20
    83b4:	50 93 0a 2e 	sts	0x2E0A, r21
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    83b8:	83 e0       	ldi	r24, 0x03	; 3
    83ba:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    83bc:	80 91 bd 30 	lds	r24, 0x30BD
    83c0:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    83c2:	80 91 be 30 	lds	r24, 0x30BE
    83c6:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    83c8:	80 91 bf 30 	lds	r24, 0x30BF
    83cc:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    83ce:	80 91 c0 30 	lds	r24, 0x30C0
    83d2:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    83d4:	81 e0       	ldi	r24, 0x01	; 1
    83d6:	90 e0       	ldi	r25, 0x00	; 0
    83d8:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    83dc:	82 e4       	ldi	r24, 0x42	; 66
    83de:	80 93 a5 35 	sts	0x35A5, r24
      uip_connr->len = 0;
    83e2:	19 8a       	std	Y+17, r1	; 0x11
    83e4:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    83e6:	10 92 9e 30 	sts	0x309E, r1
    83ea:	10 92 9d 30 	sts	0x309D, r1
    83ee:	8a c0       	rjmp	.+276    	; 0x8504 <uip_process+0xbfe>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    83f0:	80 e2       	ldi	r24, 0x20	; 32
    83f2:	80 93 a5 35 	sts	0x35A5, r24
    UIP_APPCALL();
    83f6:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    83fa:	e0 91 aa 35 	lds	r30, 0x35AA
    83fe:	f0 91 ab 35 	lds	r31, 0x35AB
    8402:	11 8e       	std	Z+25, r1	; 0x19
    goto reset;
    8404:	45 cd       	rjmp	.-1398   	; 0x7e90 <uip_process+0x58a>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    8406:	80 91 c6 30 	lds	r24, 0x30C6
    840a:	80 ff       	sbrs	r24, 0
    840c:	2a c0       	rjmp	.+84     	; 0x8462 <uip_process+0xb5c>
    840e:	24 fd       	sbrc	r18, 4
    8410:	28 c0       	rjmp	.+80     	; 0x8462 <uip_process+0xb5c>
      if(uip_outstanding(uip_connr)) {
    8412:	88 89       	ldd	r24, Y+16	; 0x10
    8414:	99 89       	ldd	r25, Y+17	; 0x11
    8416:	00 97       	sbiw	r24, 0x00	; 0
    8418:	09 f0       	breq	.+2      	; 0x841c <uip_process+0xb16>
    841a:	ca c1       	rjmp	.+916    	; 0x87b0 <uip_process+0xeaa>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    841c:	80 91 9d 30 	lds	r24, 0x309D
    8420:	90 91 9e 30 	lds	r25, 0x309E
    8424:	01 96       	adiw	r24, 0x01	; 1
    8426:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    842a:	20 91 a5 35 	lds	r18, 0x35A5
    842e:	82 2f       	mov	r24, r18
    8430:	80 61       	ori	r24, 0x10	; 16
    8432:	80 93 a5 35 	sts	0x35A5, r24
      if(uip_len > 0) {
    8436:	80 91 9d 30 	lds	r24, 0x309D
    843a:	90 91 9e 30 	lds	r25, 0x309E
    843e:	00 97       	sbiw	r24, 0x00	; 0
    8440:	19 f0       	breq	.+6      	; 0x8448 <uip_process+0xb42>
	uip_flags |= UIP_NEWDATA;
    8442:	22 61       	ori	r18, 0x12	; 18
    8444:	20 93 a5 35 	sts	0x35A5, r18
      }
      UIP_APPCALL();
    8448:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>
      uip_connr->len = 1;
    844c:	81 e0       	ldi	r24, 0x01	; 1
    844e:	90 e0       	ldi	r25, 0x00	; 0
    8450:	99 8b       	std	Y+17, r25	; 0x11
    8452:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    8454:	88 e0       	ldi	r24, 0x08	; 8
    8456:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    8458:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    845a:	81 e1       	ldi	r24, 0x11	; 17
    845c:	80 93 c6 30 	sts	0x30C6, r24
      goto tcp_send_nodata;
    8460:	0f c1       	rjmp	.+542    	; 0x8680 <uip_process+0xd7a>
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    8462:	85 ff       	sbrs	r24, 5
    8464:	1c c0       	rjmp	.+56     	; 0x849e <uip_process+0xb98>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    8466:	50 91 cb 30 	lds	r21, 0x30CB
    846a:	40 e0       	ldi	r20, 0x00	; 0
    846c:	80 91 cc 30 	lds	r24, 0x30CC
    8470:	90 e0       	ldi	r25, 0x00	; 0
    8472:	84 2b       	or	r24, r20
    8474:	95 2b       	or	r25, r21
    8476:	40 91 a8 35 	lds	r20, 0x35A8
    847a:	50 91 a9 35 	lds	r21, 0x35A9
    847e:	48 0f       	add	r20, r24
    8480:	59 1f       	adc	r21, r25
    8482:	50 93 a9 35 	sts	0x35A9, r21
    8486:	40 93 a8 35 	sts	0x35A8, r20
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    848a:	40 91 9d 30 	lds	r20, 0x309D
    848e:	50 91 9e 30 	lds	r21, 0x309E
    8492:	48 1b       	sub	r20, r24
    8494:	59 0b       	sbc	r21, r25
    8496:	50 93 9e 30 	sts	0x309E, r21
    849a:	40 93 9d 30 	sts	0x309D, r20
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    849e:	80 91 9d 30 	lds	r24, 0x309D
    84a2:	90 91 9e 30 	lds	r25, 0x309E
    84a6:	00 97       	sbiw	r24, 0x00	; 0
    84a8:	49 f0       	breq	.+18     	; 0x84bc <uip_process+0xbb6>
    84aa:	24 fd       	sbrc	r18, 4
    84ac:	07 c0       	rjmp	.+14     	; 0x84bc <uip_process+0xbb6>
      uip_flags |= UIP_NEWDATA;
    84ae:	20 91 a5 35 	lds	r18, 0x35A5
    84b2:	22 60       	ori	r18, 0x02	; 2
    84b4:	20 93 a5 35 	sts	0x35A5, r18
      uip_add_rcv_nxt(uip_len);
    84b8:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((uint16_t)BUF->wnd[0] << 8) + (uint16_t)BUF->wnd[1];
    84bc:	90 91 c7 30 	lds	r25, 0x30C7
    84c0:	80 e0       	ldi	r24, 0x00	; 0
    84c2:	20 91 c8 30 	lds	r18, 0x30C8
    84c6:	82 0f       	add	r24, r18
    84c8:	91 1d       	adc	r25, r1
    84ca:	90 93 08 2e 	sts	0x2E08, r25
    84ce:	80 93 07 2e 	sts	0x2E07, r24
    if(tmp16 > uip_connr->initialmss ||
    84d2:	2c 89       	ldd	r18, Y+20	; 0x14
    84d4:	3d 89       	ldd	r19, Y+21	; 0x15
    84d6:	28 17       	cp	r18, r24
    84d8:	39 07       	cpc	r19, r25
    84da:	10 f0       	brcs	.+4      	; 0x84e0 <uip_process+0xbda>
    84dc:	00 97       	sbiw	r24, 0x00	; 0
    84de:	21 f4       	brne	.+8      	; 0x84e8 <uip_process+0xbe2>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    84e0:	30 93 08 2e 	sts	0x2E08, r19
    84e4:	20 93 07 2e 	sts	0x2E07, r18
    }
    uip_connr->mss = tmp16;
    84e8:	80 91 07 2e 	lds	r24, 0x2E07
    84ec:	90 91 08 2e 	lds	r25, 0x2E08
    84f0:	9b 8b       	std	Y+19, r25	; 0x13
    84f2:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    84f4:	80 91 a5 35 	lds	r24, 0x35A5
    84f8:	90 e0       	ldi	r25, 0x00	; 0
    84fa:	83 70       	andi	r24, 0x03	; 3
    84fc:	90 70       	andi	r25, 0x00	; 0
    84fe:	00 97       	sbiw	r24, 0x00	; 0
    8500:	09 f4       	brne	.+2      	; 0x8504 <uip_process+0xbfe>
    8502:	56 c1       	rjmp	.+684    	; 0x87b0 <uip_process+0xeaa>
      uip_slen = 0;
    8504:	10 92 41 36 	sts	0x3641, r1
    8508:	10 92 40 36 	sts	0x3640, r1
      UIP_APPCALL();
    850c:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    8510:	80 91 a5 35 	lds	r24, 0x35A5
    8514:	85 ff       	sbrs	r24, 5
    8516:	07 c0       	rjmp	.+14     	; 0x8526 <uip_process+0xc20>
	uip_slen = 0;
    8518:	10 92 41 36 	sts	0x3641, r1
    851c:	10 92 40 36 	sts	0x3640, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    8520:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    8522:	84 e1       	ldi	r24, 0x14	; 20
    8524:	9b cf       	rjmp	.-202    	; 0x845c <uip_process+0xb56>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    8526:	84 ff       	sbrs	r24, 4
    8528:	0a c0       	rjmp	.+20     	; 0x853e <uip_process+0xc38>
	uip_slen = 0;
    852a:	10 92 41 36 	sts	0x3641, r1
    852e:	10 92 40 36 	sts	0x3640, r1
	uip_connr->len = 1;
    8532:	81 e0       	ldi	r24, 0x01	; 1
    8534:	90 e0       	ldi	r25, 0x00	; 0
    8536:	99 8b       	std	Y+17, r25	; 0x11
    8538:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    853a:	84 e0       	ldi	r24, 0x04	; 4
    853c:	8c cf       	rjmp	.-232    	; 0x8456 <uip_process+0xb50>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    853e:	20 91 40 36 	lds	r18, 0x3640
    8542:	30 91 41 36 	lds	r19, 0x3641
    8546:	21 15       	cp	r18, r1
    8548:	31 05       	cpc	r19, r1
    854a:	e1 f0       	breq	.+56     	; 0x8584 <uip_process+0xc7e>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    854c:	80 ff       	sbrs	r24, 0
    854e:	02 c0       	rjmp	.+4      	; 0x8554 <uip_process+0xc4e>
	  uip_connr->len = 0;
    8550:	19 8a       	std	Y+17, r1	; 0x11
    8552:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    8554:	88 89       	ldd	r24, Y+16	; 0x10
    8556:	99 89       	ldd	r25, Y+17	; 0x11
    8558:	00 97       	sbiw	r24, 0x00	; 0
    855a:	81 f4       	brne	.+32     	; 0x857c <uip_process+0xc76>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    855c:	8a 89       	ldd	r24, Y+18	; 0x12
    855e:	9b 89       	ldd	r25, Y+19	; 0x13
    8560:	82 17       	cp	r24, r18
    8562:	93 07       	cpc	r25, r19
    8564:	20 f4       	brcc	.+8      	; 0x856e <uip_process+0xc68>
	    uip_slen = uip_connr->mss;
    8566:	90 93 41 36 	sts	0x3641, r25
    856a:	80 93 40 36 	sts	0x3640, r24
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    856e:	80 91 40 36 	lds	r24, 0x3640
    8572:	90 91 41 36 	lds	r25, 0x3641
    8576:	99 8b       	std	Y+17, r25	; 0x11
    8578:	88 8b       	std	Y+16, r24	; 0x10
    857a:	04 c0       	rjmp	.+8      	; 0x8584 <uip_process+0xc7e>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    857c:	90 93 41 36 	sts	0x3641, r25
    8580:	80 93 40 36 	sts	0x3640, r24
	}
      }
      uip_connr->nrtx = 0;
    8584:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    8586:	80 91 9f 30 	lds	r24, 0x309F
    858a:	90 91 a0 30 	lds	r25, 0x30A0
    858e:	90 93 a9 35 	sts	0x35A9, r25
    8592:	80 93 a8 35 	sts	0x35A8, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    8596:	80 91 40 36 	lds	r24, 0x3640
    859a:	90 91 41 36 	lds	r25, 0x3641
    859e:	00 97       	sbiw	r24, 0x00	; 0
    85a0:	59 f0       	breq	.+22     	; 0x85b8 <uip_process+0xcb2>
    85a2:	88 89       	ldd	r24, Y+16	; 0x10
    85a4:	99 89       	ldd	r25, Y+17	; 0x11
    85a6:	00 97       	sbiw	r24, 0x00	; 0
    85a8:	39 f0       	breq	.+14     	; 0x85b8 <uip_process+0xcb2>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    85aa:	88 96       	adiw	r24, 0x28	; 40
    85ac:	90 93 9e 30 	sts	0x309E, r25
    85b0:	80 93 9d 30 	sts	0x309D, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    85b4:	88 e1       	ldi	r24, 0x18	; 24
    85b6:	0b c0       	rjmp	.+22     	; 0x85ce <uip_process+0xcc8>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    85b8:	80 91 a5 35 	lds	r24, 0x35A5
    85bc:	81 ff       	sbrs	r24, 1
    85be:	f8 c0       	rjmp	.+496    	; 0x87b0 <uip_process+0xeaa>
	uip_len = UIP_TCPIP_HLEN;
    85c0:	88 e2       	ldi	r24, 0x28	; 40
    85c2:	90 e0       	ldi	r25, 0x00	; 0
    85c4:	90 93 9e 30 	sts	0x309E, r25
    85c8:	80 93 9d 30 	sts	0x309D, r24
	BUF->flags = TCP_ACK;
    85cc:	80 e1       	ldi	r24, 0x10	; 16
    85ce:	80 93 c6 30 	sts	0x30C6, r24
	goto tcp_send_noopts;
    85d2:	5c c0       	rjmp	.+184    	; 0x868c <uip_process+0xd86>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    85d4:	80 91 a5 35 	lds	r24, 0x35A5
    85d8:	80 ff       	sbrs	r24, 0
    85da:	ea c0       	rjmp	.+468    	; 0x87b0 <uip_process+0xeaa>
      uip_connr->tcpstateflags = UIP_CLOSED;
    85dc:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    85de:	80 e1       	ldi	r24, 0x10	; 16
    85e0:	80 93 a5 35 	sts	0x35A5, r24
      UIP_APPCALL();
    85e4:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>
    85e8:	e3 c0       	rjmp	.+454    	; 0x87b0 <uip_process+0xeaa>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    85ea:	80 91 9d 30 	lds	r24, 0x309D
    85ee:	90 91 9e 30 	lds	r25, 0x309E
    85f2:	00 97       	sbiw	r24, 0x00	; 0
    85f4:	11 f0       	breq	.+4      	; 0x85fa <uip_process+0xcf4>
      uip_add_rcv_nxt(uip_len);
    85f6:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    85fa:	90 91 c6 30 	lds	r25, 0x30C6
    85fe:	80 91 a5 35 	lds	r24, 0x35A5
    8602:	90 ff       	sbrs	r25, 0
    8604:	0b c0       	rjmp	.+22     	; 0x861c <uip_process+0xd16>
      if(uip_flags & UIP_ACKDATA) {
    8606:	80 ff       	sbrs	r24, 0
    8608:	06 c0       	rjmp	.+12     	; 0x8616 <uip_process+0xd10>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    860a:	87 e0       	ldi	r24, 0x07	; 7
    860c:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    860e:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    8610:	19 8a       	std	Y+17, r1	; 0x11
    8612:	18 8a       	std	Y+16, r1	; 0x10
    8614:	19 c0       	rjmp	.+50     	; 0x8648 <uip_process+0xd42>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    8616:	86 e0       	ldi	r24, 0x06	; 6
    8618:	89 8f       	std	Y+25, r24	; 0x19
    861a:	16 c0       	rjmp	.+44     	; 0x8648 <uip_process+0xd42>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    861c:	80 ff       	sbrs	r24, 0
    861e:	1e c0       	rjmp	.+60     	; 0x865c <uip_process+0xd56>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    8620:	85 e0       	ldi	r24, 0x05	; 5
    8622:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    8624:	19 8a       	std	Y+17, r1	; 0x11
    8626:	18 8a       	std	Y+16, r1	; 0x10
      goto drop;
    8628:	c3 c0       	rjmp	.+390    	; 0x87b0 <uip_process+0xeaa>
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    862a:	80 91 9d 30 	lds	r24, 0x309D
    862e:	90 91 9e 30 	lds	r25, 0x309E
    8632:	00 97       	sbiw	r24, 0x00	; 0
    8634:	11 f0       	breq	.+4      	; 0x863a <uip_process+0xd34>
      uip_add_rcv_nxt(uip_len);
    8636:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    863a:	80 91 c6 30 	lds	r24, 0x30C6
    863e:	80 ff       	sbrs	r24, 0
    8640:	0d c0       	rjmp	.+26     	; 0x865c <uip_process+0xd56>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    8642:	87 e0       	ldi	r24, 0x07	; 7
    8644:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    8646:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    8648:	81 e0       	ldi	r24, 0x01	; 1
    864a:	90 e0       	ldi	r25, 0x00	; 0
    864c:	0e 94 cb 3a 	call	0x7596	; 0x7596 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    8650:	80 e1       	ldi	r24, 0x10	; 16
    8652:	80 93 a5 35 	sts	0x35A5, r24
      UIP_APPCALL();
    8656:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <tcpip_uipcall>
      goto tcp_send_ack;
    865a:	0f c0       	rjmp	.+30     	; 0x867a <uip_process+0xd74>
    }
    if(uip_len > 0) {
    865c:	80 91 9d 30 	lds	r24, 0x309D
    8660:	90 91 9e 30 	lds	r25, 0x309E
    8664:	00 97       	sbiw	r24, 0x00	; 0
    8666:	49 f4       	brne	.+18     	; 0x867a <uip_process+0xd74>
    8668:	a3 c0       	rjmp	.+326    	; 0x87b0 <uip_process+0xeaa>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    866a:	80 91 a5 35 	lds	r24, 0x35A5
    866e:	80 ff       	sbrs	r24, 0
    8670:	9f c0       	rjmp	.+318    	; 0x87b0 <uip_process+0xeaa>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    8672:	87 e0       	ldi	r24, 0x07	; 7
    8674:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    8676:	1a 8e       	std	Y+26, r1	; 0x1a
    8678:	9b c0       	rjmp	.+310    	; 0x87b0 <uip_process+0xeaa>
  goto drop;
  
  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    867a:	80 e1       	ldi	r24, 0x10	; 16
    867c:	f8 01       	movw	r30, r16
    867e:	81 a3       	std	Z+33, r24	; 0x21
  
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    8680:	88 e2       	ldi	r24, 0x28	; 40
    8682:	90 e0       	ldi	r25, 0x00	; 0
    8684:	90 93 9e 30 	sts	0x309E, r25
    8688:	80 93 9d 30 	sts	0x309D, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    868c:	80 e5       	ldi	r24, 0x50	; 80
    868e:	80 93 c5 30 	sts	0x30C5, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    8692:	88 85       	ldd	r24, Y+8	; 0x08
    8694:	80 93 c1 30 	sts	0x30C1, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    8698:	89 85       	ldd	r24, Y+9	; 0x09
    869a:	80 93 c2 30 	sts	0x30C2, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    869e:	8a 85       	ldd	r24, Y+10	; 0x0a
    86a0:	80 93 c3 30 	sts	0x30C3, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    86a4:	8b 85       	ldd	r24, Y+11	; 0x0b
    86a6:	80 93 c4 30 	sts	0x30C4, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    86aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    86ac:	80 93 bd 30 	sts	0x30BD, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    86b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    86b2:	80 93 be 30 	sts	0x30BE, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    86b6:	8e 85       	ldd	r24, Y+14	; 0x0e
    86b8:	80 93 bf 30 	sts	0x30BF, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    86bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    86be:	80 93 c0 30 	sts	0x30C0, r24

  BUF->proto = UIP_PROTO_TCP;
    86c2:	86 e0       	ldi	r24, 0x06	; 6
    86c4:	80 93 ae 30 	sts	0x30AE, r24
  
  BUF->srcport  = uip_connr->lport;
    86c8:	8c 81       	ldd	r24, Y+4	; 0x04
    86ca:	9d 81       	ldd	r25, Y+5	; 0x05
    86cc:	90 93 ba 30 	sts	0x30BA, r25
    86d0:	80 93 b9 30 	sts	0x30B9, r24
  BUF->destport = uip_connr->rport;
    86d4:	8e 81       	ldd	r24, Y+6	; 0x06
    86d6:	9f 81       	ldd	r25, Y+7	; 0x07
    86d8:	90 93 bc 30 	sts	0x30BC, r25
    86dc:	80 93 bb 30 	sts	0x30BB, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    86e0:	80 91 3c 36 	lds	r24, 0x363C
    86e4:	90 91 3d 36 	lds	r25, 0x363D
    86e8:	a0 91 3e 36 	lds	r26, 0x363E
    86ec:	b0 91 3f 36 	lds	r27, 0x363F
    86f0:	80 93 b1 30 	sts	0x30B1, r24
    86f4:	90 93 b2 30 	sts	0x30B2, r25
    86f8:	a0 93 b3 30 	sts	0x30B3, r26
    86fc:	b0 93 b4 30 	sts	0x30B4, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    8700:	88 81       	ld	r24, Y
    8702:	99 81       	ldd	r25, Y+1	; 0x01
    8704:	aa 81       	ldd	r26, Y+2	; 0x02
    8706:	bb 81       	ldd	r27, Y+3	; 0x03
    8708:	80 93 b5 30 	sts	0x30B5, r24
    870c:	90 93 b6 30 	sts	0x30B6, r25
    8710:	a0 93 b7 30 	sts	0x30B7, r26
    8714:	b0 93 b8 30 	sts	0x30B8, r27

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    8718:	89 8d       	ldd	r24, Y+25	; 0x19
    871a:	84 ff       	sbrs	r24, 4
    871c:	05 c0       	rjmp	.+10     	; 0x8728 <uip_process+0xe22>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    871e:	10 92 c8 30 	sts	0x30C8, r1
    8722:	10 92 c7 30 	sts	0x30C7, r1
    8726:	06 c0       	rjmp	.+12     	; 0x8734 <uip_process+0xe2e>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    8728:	84 e0       	ldi	r24, 0x04	; 4
    872a:	80 93 c7 30 	sts	0x30C7, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    872e:	88 ed       	ldi	r24, 0xD8	; 216
    8730:	80 93 c8 30 	sts	0x30C8, r24
  }
  
 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    8734:	80 e4       	ldi	r24, 0x40	; 64
    8736:	80 93 ad 30 	sts	0x30AD, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    873a:	80 91 9d 30 	lds	r24, 0x309D
    873e:	90 91 9e 30 	lds	r25, 0x309E
    8742:	90 93 a7 30 	sts	0x30A7, r25
  BUF->len[1] = (uip_len & 0xff);
    8746:	80 93 a8 30 	sts	0x30A8, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    874a:	10 92 cc 30 	sts	0x30CC, r1
    874e:	10 92 cb 30 	sts	0x30CB, r1
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    8752:	10 92 ca 30 	sts	0x30CA, r1
    8756:	10 92 c9 30 	sts	0x30C9, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    875a:	0e 94 00 3b 	call	0x7600	; 0x7600 <uip_tcpchksum>
    875e:	80 95       	com	r24
    8760:	90 95       	com	r25
    8762:	90 93 ca 30 	sts	0x30CA, r25
    8766:	80 93 c9 30 	sts	0x30C9, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    876a:	85 e4       	ldi	r24, 0x45	; 69
    876c:	80 93 a5 30 	sts	0x30A5, r24
  BUF->tos = 0;
    8770:	10 92 a6 30 	sts	0x30A6, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    8774:	10 92 ac 30 	sts	0x30AC, r1
    8778:	10 92 ab 30 	sts	0x30AB, r1
  ++ipid;
    877c:	80 91 0b 2e 	lds	r24, 0x2E0B
    8780:	90 91 0c 2e 	lds	r25, 0x2E0C
    8784:	01 96       	adiw	r24, 0x01	; 1
    8786:	90 93 0c 2e 	sts	0x2E0C, r25
    878a:	80 93 0b 2e 	sts	0x2E0B, r24
  BUF->ipid[0] = ipid >> 8;
    878e:	90 93 a9 30 	sts	0x30A9, r25
  BUF->ipid[1] = ipid & 0xff;
    8792:	80 93 aa 30 	sts	0x30AA, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    8796:	10 92 b0 30 	sts	0x30B0, r1
    879a:	10 92 af 30 	sts	0x30AF, r1
  BUF->ipchksum = ~(uip_ipchksum());
    879e:	0e 94 ef 3a 	call	0x75de	; 0x75de <uip_ipchksum>
    87a2:	80 95       	com	r24
    87a4:	90 95       	com	r25
    87a6:	90 93 b0 30 	sts	0x30B0, r25
    87aa:	80 93 af 30 	sts	0x30AF, r24
    87ae:	04 c0       	rjmp	.+8      	; 0x87b8 <uip_process+0xeb2>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    87b0:	10 92 9e 30 	sts	0x309E, r1
    87b4:	10 92 9d 30 	sts	0x309D, r1
  uip_flags = 0;
    87b8:	10 92 a5 35 	sts	0x35A5, r1
  return;
}
    87bc:	df 91       	pop	r29
    87be:	cf 91       	pop	r28
    87c0:	1f 91       	pop	r17
    87c2:	0f 91       	pop	r16
    87c4:	ff 90       	pop	r15
    87c6:	ef 90       	pop	r14
    87c8:	08 95       	ret

000087ca <uip_htons>:
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
    87ca:	38 2f       	mov	r19, r24
    87cc:	29 2f       	mov	r18, r25
}
    87ce:	c9 01       	movw	r24, r18
    87d0:	08 95       	ret

000087d2 <uip_htonl>:

uint32_t
uip_htonl(uint32_t val)
{
  return UIP_HTONL(val);
    87d2:	38 2f       	mov	r19, r24
    87d4:	29 2f       	mov	r18, r25
    87d6:	40 e0       	ldi	r20, 0x00	; 0
    87d8:	50 e0       	ldi	r21, 0x00	; 0
    87da:	76 27       	eor	r23, r22
    87dc:	67 27       	eor	r22, r23
    87de:	76 27       	eor	r23, r22
    87e0:	80 e0       	ldi	r24, 0x00	; 0
    87e2:	90 e0       	ldi	r25, 0x00	; 0
    87e4:	cb 01       	movw	r24, r22
    87e6:	77 27       	eor	r23, r23
    87e8:	66 27       	eor	r22, r22
    87ea:	26 2b       	or	r18, r22
    87ec:	37 2b       	or	r19, r23
    87ee:	48 2b       	or	r20, r24
    87f0:	59 2b       	or	r21, r25
}
    87f2:	b9 01       	movw	r22, r18
    87f4:	ca 01       	movw	r24, r20
    87f6:	08 95       	ret

000087f8 <uip_send>:
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    87f8:	ac 01       	movw	r20, r24
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    87fa:	e0 91 9f 30 	lds	r30, 0x309F
    87fe:	f0 91 a0 30 	lds	r31, 0x30A0
    8802:	22 27       	eor	r18, r18
    8804:	33 27       	eor	r19, r19
    8806:	2e 1b       	sub	r18, r30
    8808:	3f 0b       	sbc	r19, r31
    880a:	2b 55       	subi	r18, 0x5B	; 91
    880c:	3a 4c       	sbci	r19, 0xCA	; 202
    880e:	62 17       	cp	r22, r18
    8810:	73 07       	cpc	r23, r19
    8812:	0c f4       	brge	.+2      	; 0x8816 <uip_send+0x1e>
    8814:	9b 01       	movw	r18, r22
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    8816:	12 16       	cp	r1, r18
    8818:	13 06       	cpc	r1, r19
    881a:	64 f4       	brge	.+24     	; 0x8834 <uip_send+0x3c>
    uip_slen = copylen;
    881c:	20 93 40 36 	sts	0x3640, r18
    8820:	30 93 41 36 	sts	0x3641, r19
    if(data != uip_sappdata) {
    8824:	4e 17       	cp	r20, r30
    8826:	5f 07       	cpc	r21, r31
    8828:	29 f0       	breq	.+10     	; 0x8834 <uip_send+0x3c>
      memcpy(uip_sappdata, (data), uip_slen);
    882a:	cf 01       	movw	r24, r30
    882c:	ba 01       	movw	r22, r20
    882e:	a9 01       	movw	r20, r18
    8830:	0e 94 4e 4b 	call	0x969c	; 0x969c <memcpy>
    8834:	08 95       	ret

00008836 <__fixunssfsi>:
    8836:	ef 92       	push	r14
    8838:	ff 92       	push	r15
    883a:	0f 93       	push	r16
    883c:	1f 93       	push	r17
    883e:	7b 01       	movw	r14, r22
    8840:	8c 01       	movw	r16, r24
    8842:	20 e0       	ldi	r18, 0x00	; 0
    8844:	30 e0       	ldi	r19, 0x00	; 0
    8846:	40 e0       	ldi	r20, 0x00	; 0
    8848:	5f e4       	ldi	r21, 0x4F	; 79
    884a:	0e 94 97 47 	call	0x8f2e	; 0x8f2e <__gesf2>
    884e:	87 fd       	sbrc	r24, 7
    8850:	11 c0       	rjmp	.+34     	; 0x8874 <__fixunssfsi+0x3e>
    8852:	c8 01       	movw	r24, r16
    8854:	b7 01       	movw	r22, r14
    8856:	20 e0       	ldi	r18, 0x00	; 0
    8858:	30 e0       	ldi	r19, 0x00	; 0
    885a:	40 e0       	ldi	r20, 0x00	; 0
    885c:	5f e4       	ldi	r21, 0x4F	; 79
    885e:	0e 94 be 45 	call	0x8b7c	; 0x8b7c <__subsf3>
    8862:	0e 94 27 48 	call	0x904e	; 0x904e <__fixsfsi>
    8866:	9b 01       	movw	r18, r22
    8868:	ac 01       	movw	r20, r24
    886a:	20 50       	subi	r18, 0x00	; 0
    886c:	30 40       	sbci	r19, 0x00	; 0
    886e:	40 40       	sbci	r20, 0x00	; 0
    8870:	50 48       	sbci	r21, 0x80	; 128
    8872:	06 c0       	rjmp	.+12     	; 0x8880 <__fixunssfsi+0x4a>
    8874:	c8 01       	movw	r24, r16
    8876:	b7 01       	movw	r22, r14
    8878:	0e 94 27 48 	call	0x904e	; 0x904e <__fixsfsi>
    887c:	9b 01       	movw	r18, r22
    887e:	ac 01       	movw	r20, r24
    8880:	b9 01       	movw	r22, r18
    8882:	ca 01       	movw	r24, r20
    8884:	1f 91       	pop	r17
    8886:	0f 91       	pop	r16
    8888:	ff 90       	pop	r15
    888a:	ef 90       	pop	r14
    888c:	08 95       	ret

0000888e <_fpadd_parts>:
    888e:	a0 e0       	ldi	r26, 0x00	; 0
    8890:	b0 e0       	ldi	r27, 0x00	; 0
    8892:	ed e4       	ldi	r30, 0x4D	; 77
    8894:	f4 e4       	ldi	r31, 0x44	; 68
    8896:	0c 94 b0 4a 	jmp	0x9560	; 0x9560 <__prologue_saves__+0x8>
    889a:	fc 01       	movw	r30, r24
    889c:	ea 01       	movw	r28, r20
    889e:	80 81       	ld	r24, Z
    88a0:	82 30       	cpi	r24, 0x02	; 2
    88a2:	08 f4       	brcc	.+2      	; 0x88a6 <_fpadd_parts+0x18>
    88a4:	38 c1       	rjmp	.+624    	; 0x8b16 <_fpadd_parts+0x288>
    88a6:	db 01       	movw	r26, r22
    88a8:	9c 91       	ld	r25, X
    88aa:	92 30       	cpi	r25, 0x02	; 2
    88ac:	08 f4       	brcc	.+2      	; 0x88b0 <_fpadd_parts+0x22>
    88ae:	30 c1       	rjmp	.+608    	; 0x8b10 <_fpadd_parts+0x282>
    88b0:	84 30       	cpi	r24, 0x04	; 4
    88b2:	59 f4       	brne	.+22     	; 0x88ca <_fpadd_parts+0x3c>
    88b4:	94 30       	cpi	r25, 0x04	; 4
    88b6:	09 f0       	breq	.+2      	; 0x88ba <_fpadd_parts+0x2c>
    88b8:	2e c1       	rjmp	.+604    	; 0x8b16 <_fpadd_parts+0x288>
    88ba:	91 81       	ldd	r25, Z+1	; 0x01
    88bc:	11 96       	adiw	r26, 0x01	; 1
    88be:	8c 91       	ld	r24, X
    88c0:	11 97       	sbiw	r26, 0x01	; 1
    88c2:	98 17       	cp	r25, r24
    88c4:	09 f0       	breq	.+2      	; 0x88c8 <_fpadd_parts+0x3a>
    88c6:	21 c1       	rjmp	.+578    	; 0x8b0a <_fpadd_parts+0x27c>
    88c8:	26 c1       	rjmp	.+588    	; 0x8b16 <_fpadd_parts+0x288>
    88ca:	94 30       	cpi	r25, 0x04	; 4
    88cc:	09 f4       	brne	.+2      	; 0x88d0 <_fpadd_parts+0x42>
    88ce:	20 c1       	rjmp	.+576    	; 0x8b10 <_fpadd_parts+0x282>
    88d0:	92 30       	cpi	r25, 0x02	; 2
    88d2:	b1 f4       	brne	.+44     	; 0x8900 <_fpadd_parts+0x72>
    88d4:	82 30       	cpi	r24, 0x02	; 2
    88d6:	09 f0       	breq	.+2      	; 0x88da <_fpadd_parts+0x4c>
    88d8:	1e c1       	rjmp	.+572    	; 0x8b16 <_fpadd_parts+0x288>
    88da:	ca 01       	movw	r24, r20
    88dc:	af 01       	movw	r20, r30
    88de:	28 e0       	ldi	r18, 0x08	; 8
    88e0:	da 01       	movw	r26, r20
    88e2:	0d 90       	ld	r0, X+
    88e4:	ad 01       	movw	r20, r26
    88e6:	dc 01       	movw	r26, r24
    88e8:	0d 92       	st	X+, r0
    88ea:	cd 01       	movw	r24, r26
    88ec:	21 50       	subi	r18, 0x01	; 1
    88ee:	c1 f7       	brne	.-16     	; 0x88e0 <_fpadd_parts+0x52>
    88f0:	db 01       	movw	r26, r22
    88f2:	11 96       	adiw	r26, 0x01	; 1
    88f4:	8c 91       	ld	r24, X
    88f6:	11 97       	sbiw	r26, 0x01	; 1
    88f8:	91 81       	ldd	r25, Z+1	; 0x01
    88fa:	89 23       	and	r24, r25
    88fc:	89 83       	std	Y+1, r24	; 0x01
    88fe:	0a c1       	rjmp	.+532    	; 0x8b14 <_fpadd_parts+0x286>
    8900:	82 30       	cpi	r24, 0x02	; 2
    8902:	09 f4       	brne	.+2      	; 0x8906 <_fpadd_parts+0x78>
    8904:	05 c1       	rjmp	.+522    	; 0x8b10 <_fpadd_parts+0x282>
    8906:	c2 80       	ldd	r12, Z+2	; 0x02
    8908:	d3 80       	ldd	r13, Z+3	; 0x03
    890a:	db 01       	movw	r26, r22
    890c:	12 96       	adiw	r26, 0x02	; 2
    890e:	6d 90       	ld	r6, X+
    8910:	7c 90       	ld	r7, X
    8912:	13 97       	sbiw	r26, 0x03	; 3
    8914:	24 81       	ldd	r18, Z+4	; 0x04
    8916:	35 81       	ldd	r19, Z+5	; 0x05
    8918:	46 81       	ldd	r20, Z+6	; 0x06
    891a:	57 81       	ldd	r21, Z+7	; 0x07
    891c:	14 96       	adiw	r26, 0x04	; 4
    891e:	ed 90       	ld	r14, X+
    8920:	fd 90       	ld	r15, X+
    8922:	0d 91       	ld	r16, X+
    8924:	1c 91       	ld	r17, X
    8926:	17 97       	sbiw	r26, 0x07	; 7
    8928:	c6 01       	movw	r24, r12
    892a:	86 19       	sub	r24, r6
    892c:	97 09       	sbc	r25, r7
    892e:	5c 01       	movw	r10, r24
    8930:	97 ff       	sbrs	r25, 7
    8932:	04 c0       	rjmp	.+8      	; 0x893c <_fpadd_parts+0xae>
    8934:	aa 24       	eor	r10, r10
    8936:	bb 24       	eor	r11, r11
    8938:	a8 1a       	sub	r10, r24
    893a:	b9 0a       	sbc	r11, r25
    893c:	b0 e2       	ldi	r27, 0x20	; 32
    893e:	ab 16       	cp	r10, r27
    8940:	b1 04       	cpc	r11, r1
    8942:	0c f0       	brlt	.+2      	; 0x8946 <_fpadd_parts+0xb8>
    8944:	61 c0       	rjmp	.+194    	; 0x8a08 <_fpadd_parts+0x17a>
    8946:	18 16       	cp	r1, r24
    8948:	19 06       	cpc	r1, r25
    894a:	6c f5       	brge	.+90     	; 0x89a6 <_fpadd_parts+0x118>
    894c:	37 01       	movw	r6, r14
    894e:	48 01       	movw	r8, r16
    8950:	0a 2c       	mov	r0, r10
    8952:	04 c0       	rjmp	.+8      	; 0x895c <_fpadd_parts+0xce>
    8954:	96 94       	lsr	r9
    8956:	87 94       	ror	r8
    8958:	77 94       	ror	r7
    895a:	67 94       	ror	r6
    895c:	0a 94       	dec	r0
    895e:	d2 f7       	brpl	.-12     	; 0x8954 <_fpadd_parts+0xc6>
    8960:	81 e0       	ldi	r24, 0x01	; 1
    8962:	90 e0       	ldi	r25, 0x00	; 0
    8964:	a0 e0       	ldi	r26, 0x00	; 0
    8966:	b0 e0       	ldi	r27, 0x00	; 0
    8968:	0a 2c       	mov	r0, r10
    896a:	04 c0       	rjmp	.+8      	; 0x8974 <_fpadd_parts+0xe6>
    896c:	88 0f       	add	r24, r24
    896e:	99 1f       	adc	r25, r25
    8970:	aa 1f       	adc	r26, r26
    8972:	bb 1f       	adc	r27, r27
    8974:	0a 94       	dec	r0
    8976:	d2 f7       	brpl	.-12     	; 0x896c <_fpadd_parts+0xde>
    8978:	01 97       	sbiw	r24, 0x01	; 1
    897a:	a1 09       	sbc	r26, r1
    897c:	b1 09       	sbc	r27, r1
    897e:	8e 21       	and	r24, r14
    8980:	9f 21       	and	r25, r15
    8982:	a0 23       	and	r26, r16
    8984:	b1 23       	and	r27, r17
    8986:	ee 24       	eor	r14, r14
    8988:	ff 24       	eor	r15, r15
    898a:	87 01       	movw	r16, r14
    898c:	e3 94       	inc	r14
    898e:	00 97       	sbiw	r24, 0x00	; 0
    8990:	a1 05       	cpc	r26, r1
    8992:	b1 05       	cpc	r27, r1
    8994:	19 f4       	brne	.+6      	; 0x899c <_fpadd_parts+0x10e>
    8996:	ee 24       	eor	r14, r14
    8998:	ff 24       	eor	r15, r15
    899a:	87 01       	movw	r16, r14
    899c:	e6 28       	or	r14, r6
    899e:	f7 28       	or	r15, r7
    89a0:	08 29       	or	r16, r8
    89a2:	19 29       	or	r17, r9
    89a4:	3c c0       	rjmp	.+120    	; 0x8a1e <_fpadd_parts+0x190>
    89a6:	00 97       	sbiw	r24, 0x00	; 0
    89a8:	d1 f1       	breq	.+116    	; 0x8a1e <_fpadd_parts+0x190>
    89aa:	ca 0c       	add	r12, r10
    89ac:	db 1c       	adc	r13, r11
    89ae:	39 01       	movw	r6, r18
    89b0:	4a 01       	movw	r8, r20
    89b2:	0a 2c       	mov	r0, r10
    89b4:	04 c0       	rjmp	.+8      	; 0x89be <_fpadd_parts+0x130>
    89b6:	96 94       	lsr	r9
    89b8:	87 94       	ror	r8
    89ba:	77 94       	ror	r7
    89bc:	67 94       	ror	r6
    89be:	0a 94       	dec	r0
    89c0:	d2 f7       	brpl	.-12     	; 0x89b6 <_fpadd_parts+0x128>
    89c2:	81 e0       	ldi	r24, 0x01	; 1
    89c4:	90 e0       	ldi	r25, 0x00	; 0
    89c6:	a0 e0       	ldi	r26, 0x00	; 0
    89c8:	b0 e0       	ldi	r27, 0x00	; 0
    89ca:	0a 2c       	mov	r0, r10
    89cc:	04 c0       	rjmp	.+8      	; 0x89d6 <_fpadd_parts+0x148>
    89ce:	88 0f       	add	r24, r24
    89d0:	99 1f       	adc	r25, r25
    89d2:	aa 1f       	adc	r26, r26
    89d4:	bb 1f       	adc	r27, r27
    89d6:	0a 94       	dec	r0
    89d8:	d2 f7       	brpl	.-12     	; 0x89ce <_fpadd_parts+0x140>
    89da:	01 97       	sbiw	r24, 0x01	; 1
    89dc:	a1 09       	sbc	r26, r1
    89de:	b1 09       	sbc	r27, r1
    89e0:	82 23       	and	r24, r18
    89e2:	93 23       	and	r25, r19
    89e4:	a4 23       	and	r26, r20
    89e6:	b5 23       	and	r27, r21
    89e8:	21 e0       	ldi	r18, 0x01	; 1
    89ea:	30 e0       	ldi	r19, 0x00	; 0
    89ec:	40 e0       	ldi	r20, 0x00	; 0
    89ee:	50 e0       	ldi	r21, 0x00	; 0
    89f0:	00 97       	sbiw	r24, 0x00	; 0
    89f2:	a1 05       	cpc	r26, r1
    89f4:	b1 05       	cpc	r27, r1
    89f6:	19 f4       	brne	.+6      	; 0x89fe <_fpadd_parts+0x170>
    89f8:	20 e0       	ldi	r18, 0x00	; 0
    89fa:	30 e0       	ldi	r19, 0x00	; 0
    89fc:	a9 01       	movw	r20, r18
    89fe:	26 29       	or	r18, r6
    8a00:	37 29       	or	r19, r7
    8a02:	48 29       	or	r20, r8
    8a04:	59 29       	or	r21, r9
    8a06:	0b c0       	rjmp	.+22     	; 0x8a1e <_fpadd_parts+0x190>
    8a08:	6c 14       	cp	r6, r12
    8a0a:	7d 04       	cpc	r7, r13
    8a0c:	24 f4       	brge	.+8      	; 0x8a16 <_fpadd_parts+0x188>
    8a0e:	ee 24       	eor	r14, r14
    8a10:	ff 24       	eor	r15, r15
    8a12:	87 01       	movw	r16, r14
    8a14:	04 c0       	rjmp	.+8      	; 0x8a1e <_fpadd_parts+0x190>
    8a16:	63 01       	movw	r12, r6
    8a18:	20 e0       	ldi	r18, 0x00	; 0
    8a1a:	30 e0       	ldi	r19, 0x00	; 0
    8a1c:	a9 01       	movw	r20, r18
    8a1e:	81 81       	ldd	r24, Z+1	; 0x01
    8a20:	fb 01       	movw	r30, r22
    8a22:	91 81       	ldd	r25, Z+1	; 0x01
    8a24:	89 17       	cp	r24, r25
    8a26:	09 f4       	brne	.+2      	; 0x8a2a <_fpadd_parts+0x19c>
    8a28:	45 c0       	rjmp	.+138    	; 0x8ab4 <_fpadd_parts+0x226>
    8a2a:	88 23       	and	r24, r24
    8a2c:	49 f0       	breq	.+18     	; 0x8a40 <_fpadd_parts+0x1b2>
    8a2e:	d8 01       	movw	r26, r16
    8a30:	c7 01       	movw	r24, r14
    8a32:	82 1b       	sub	r24, r18
    8a34:	93 0b       	sbc	r25, r19
    8a36:	a4 0b       	sbc	r26, r20
    8a38:	b5 0b       	sbc	r27, r21
    8a3a:	9c 01       	movw	r18, r24
    8a3c:	ad 01       	movw	r20, r26
    8a3e:	04 c0       	rjmp	.+8      	; 0x8a48 <_fpadd_parts+0x1ba>
    8a40:	2e 19       	sub	r18, r14
    8a42:	3f 09       	sbc	r19, r15
    8a44:	40 0b       	sbc	r20, r16
    8a46:	51 0b       	sbc	r21, r17
    8a48:	57 fd       	sbrc	r21, 7
    8a4a:	04 c0       	rjmp	.+8      	; 0x8a54 <_fpadd_parts+0x1c6>
    8a4c:	19 82       	std	Y+1, r1	; 0x01
    8a4e:	db 82       	std	Y+3, r13	; 0x03
    8a50:	ca 82       	std	Y+2, r12	; 0x02
    8a52:	0b c0       	rjmp	.+22     	; 0x8a6a <_fpadd_parts+0x1dc>
    8a54:	81 e0       	ldi	r24, 0x01	; 1
    8a56:	89 83       	std	Y+1, r24	; 0x01
    8a58:	db 82       	std	Y+3, r13	; 0x03
    8a5a:	ca 82       	std	Y+2, r12	; 0x02
    8a5c:	50 95       	com	r21
    8a5e:	40 95       	com	r20
    8a60:	30 95       	com	r19
    8a62:	21 95       	neg	r18
    8a64:	3f 4f       	sbci	r19, 0xFF	; 255
    8a66:	4f 4f       	sbci	r20, 0xFF	; 255
    8a68:	5f 4f       	sbci	r21, 0xFF	; 255
    8a6a:	2c 83       	std	Y+4, r18	; 0x04
    8a6c:	3d 83       	std	Y+5, r19	; 0x05
    8a6e:	4e 83       	std	Y+6, r20	; 0x06
    8a70:	5f 83       	std	Y+7, r21	; 0x07
    8a72:	0d c0       	rjmp	.+26     	; 0x8a8e <_fpadd_parts+0x200>
    8a74:	88 0f       	add	r24, r24
    8a76:	99 1f       	adc	r25, r25
    8a78:	aa 1f       	adc	r26, r26
    8a7a:	bb 1f       	adc	r27, r27
    8a7c:	8c 83       	std	Y+4, r24	; 0x04
    8a7e:	9d 83       	std	Y+5, r25	; 0x05
    8a80:	ae 83       	std	Y+6, r26	; 0x06
    8a82:	bf 83       	std	Y+7, r27	; 0x07
    8a84:	8a 81       	ldd	r24, Y+2	; 0x02
    8a86:	9b 81       	ldd	r25, Y+3	; 0x03
    8a88:	01 97       	sbiw	r24, 0x01	; 1
    8a8a:	9b 83       	std	Y+3, r25	; 0x03
    8a8c:	8a 83       	std	Y+2, r24	; 0x02
    8a8e:	8c 81       	ldd	r24, Y+4	; 0x04
    8a90:	9d 81       	ldd	r25, Y+5	; 0x05
    8a92:	ae 81       	ldd	r26, Y+6	; 0x06
    8a94:	bf 81       	ldd	r27, Y+7	; 0x07
    8a96:	9c 01       	movw	r18, r24
    8a98:	ad 01       	movw	r20, r26
    8a9a:	21 50       	subi	r18, 0x01	; 1
    8a9c:	30 40       	sbci	r19, 0x00	; 0
    8a9e:	40 40       	sbci	r20, 0x00	; 0
    8aa0:	50 40       	sbci	r21, 0x00	; 0
    8aa2:	2f 3f       	cpi	r18, 0xFF	; 255
    8aa4:	ef ef       	ldi	r30, 0xFF	; 255
    8aa6:	3e 07       	cpc	r19, r30
    8aa8:	ef ef       	ldi	r30, 0xFF	; 255
    8aaa:	4e 07       	cpc	r20, r30
    8aac:	ef e3       	ldi	r30, 0x3F	; 63
    8aae:	5e 07       	cpc	r21, r30
    8ab0:	08 f3       	brcs	.-62     	; 0x8a74 <_fpadd_parts+0x1e6>
    8ab2:	0b c0       	rjmp	.+22     	; 0x8aca <_fpadd_parts+0x23c>
    8ab4:	89 83       	std	Y+1, r24	; 0x01
    8ab6:	db 82       	std	Y+3, r13	; 0x03
    8ab8:	ca 82       	std	Y+2, r12	; 0x02
    8aba:	2e 0d       	add	r18, r14
    8abc:	3f 1d       	adc	r19, r15
    8abe:	40 1f       	adc	r20, r16
    8ac0:	51 1f       	adc	r21, r17
    8ac2:	2c 83       	std	Y+4, r18	; 0x04
    8ac4:	3d 83       	std	Y+5, r19	; 0x05
    8ac6:	4e 83       	std	Y+6, r20	; 0x06
    8ac8:	5f 83       	std	Y+7, r21	; 0x07
    8aca:	83 e0       	ldi	r24, 0x03	; 3
    8acc:	88 83       	st	Y, r24
    8ace:	2c 81       	ldd	r18, Y+4	; 0x04
    8ad0:	3d 81       	ldd	r19, Y+5	; 0x05
    8ad2:	4e 81       	ldd	r20, Y+6	; 0x06
    8ad4:	5f 81       	ldd	r21, Y+7	; 0x07
    8ad6:	57 ff       	sbrs	r21, 7
    8ad8:	1d c0       	rjmp	.+58     	; 0x8b14 <_fpadd_parts+0x286>
    8ada:	da 01       	movw	r26, r20
    8adc:	c9 01       	movw	r24, r18
    8ade:	81 70       	andi	r24, 0x01	; 1
    8ae0:	90 70       	andi	r25, 0x00	; 0
    8ae2:	a0 70       	andi	r26, 0x00	; 0
    8ae4:	b0 70       	andi	r27, 0x00	; 0
    8ae6:	56 95       	lsr	r21
    8ae8:	47 95       	ror	r20
    8aea:	37 95       	ror	r19
    8aec:	27 95       	ror	r18
    8aee:	82 2b       	or	r24, r18
    8af0:	93 2b       	or	r25, r19
    8af2:	a4 2b       	or	r26, r20
    8af4:	b5 2b       	or	r27, r21
    8af6:	8c 83       	std	Y+4, r24	; 0x04
    8af8:	9d 83       	std	Y+5, r25	; 0x05
    8afa:	ae 83       	std	Y+6, r26	; 0x06
    8afc:	bf 83       	std	Y+7, r27	; 0x07
    8afe:	8a 81       	ldd	r24, Y+2	; 0x02
    8b00:	9b 81       	ldd	r25, Y+3	; 0x03
    8b02:	01 96       	adiw	r24, 0x01	; 1
    8b04:	9b 83       	std	Y+3, r25	; 0x03
    8b06:	8a 83       	std	Y+2, r24	; 0x02
    8b08:	05 c0       	rjmp	.+10     	; 0x8b14 <_fpadd_parts+0x286>
    8b0a:	ea e7       	ldi	r30, 0x7A	; 122
    8b0c:	fe e0       	ldi	r31, 0x0E	; 14
    8b0e:	03 c0       	rjmp	.+6      	; 0x8b16 <_fpadd_parts+0x288>
    8b10:	fb 01       	movw	r30, r22
    8b12:	01 c0       	rjmp	.+2      	; 0x8b16 <_fpadd_parts+0x288>
    8b14:	fe 01       	movw	r30, r28
    8b16:	cf 01       	movw	r24, r30
    8b18:	cd b7       	in	r28, 0x3d	; 61
    8b1a:	de b7       	in	r29, 0x3e	; 62
    8b1c:	ee e0       	ldi	r30, 0x0E	; 14
    8b1e:	0c 94 cc 4a 	jmp	0x9598	; 0x9598 <__epilogue_restores__+0x8>

00008b22 <__addsf3>:
    8b22:	a0 e2       	ldi	r26, 0x20	; 32
    8b24:	b0 e0       	ldi	r27, 0x00	; 0
    8b26:	e7 e9       	ldi	r30, 0x97	; 151
    8b28:	f5 e4       	ldi	r31, 0x45	; 69
    8b2a:	0c 94 b8 4a 	jmp	0x9570	; 0x9570 <__prologue_saves__+0x18>
    8b2e:	69 83       	std	Y+1, r22	; 0x01
    8b30:	7a 83       	std	Y+2, r23	; 0x02
    8b32:	8b 83       	std	Y+3, r24	; 0x03
    8b34:	9c 83       	std	Y+4, r25	; 0x04
    8b36:	2d 83       	std	Y+5, r18	; 0x05
    8b38:	3e 83       	std	Y+6, r19	; 0x06
    8b3a:	4f 83       	std	Y+7, r20	; 0x07
    8b3c:	58 87       	std	Y+8, r21	; 0x08
    8b3e:	89 e0       	ldi	r24, 0x09	; 9
    8b40:	e8 2e       	mov	r14, r24
    8b42:	f1 2c       	mov	r15, r1
    8b44:	ec 0e       	add	r14, r28
    8b46:	fd 1e       	adc	r15, r29
    8b48:	ce 01       	movw	r24, r28
    8b4a:	01 96       	adiw	r24, 0x01	; 1
    8b4c:	b7 01       	movw	r22, r14
    8b4e:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8b52:	8e 01       	movw	r16, r28
    8b54:	0f 5e       	subi	r16, 0xEF	; 239
    8b56:	1f 4f       	sbci	r17, 0xFF	; 255
    8b58:	ce 01       	movw	r24, r28
    8b5a:	05 96       	adiw	r24, 0x05	; 5
    8b5c:	b8 01       	movw	r22, r16
    8b5e:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8b62:	c7 01       	movw	r24, r14
    8b64:	b8 01       	movw	r22, r16
    8b66:	ae 01       	movw	r20, r28
    8b68:	47 5e       	subi	r20, 0xE7	; 231
    8b6a:	5f 4f       	sbci	r21, 0xFF	; 255
    8b6c:	0e 94 47 44 	call	0x888e	; 0x888e <_fpadd_parts>
    8b70:	0e 94 d3 48 	call	0x91a6	; 0x91a6 <__pack_f>
    8b74:	a0 96       	adiw	r28, 0x20	; 32
    8b76:	e6 e0       	ldi	r30, 0x06	; 6
    8b78:	0c 94 d4 4a 	jmp	0x95a8	; 0x95a8 <__epilogue_restores__+0x18>

00008b7c <__subsf3>:
    8b7c:	a0 e2       	ldi	r26, 0x20	; 32
    8b7e:	b0 e0       	ldi	r27, 0x00	; 0
    8b80:	e4 ec       	ldi	r30, 0xC4	; 196
    8b82:	f5 e4       	ldi	r31, 0x45	; 69
    8b84:	0c 94 b8 4a 	jmp	0x9570	; 0x9570 <__prologue_saves__+0x18>
    8b88:	69 83       	std	Y+1, r22	; 0x01
    8b8a:	7a 83       	std	Y+2, r23	; 0x02
    8b8c:	8b 83       	std	Y+3, r24	; 0x03
    8b8e:	9c 83       	std	Y+4, r25	; 0x04
    8b90:	2d 83       	std	Y+5, r18	; 0x05
    8b92:	3e 83       	std	Y+6, r19	; 0x06
    8b94:	4f 83       	std	Y+7, r20	; 0x07
    8b96:	58 87       	std	Y+8, r21	; 0x08
    8b98:	8e 01       	movw	r16, r28
    8b9a:	07 5f       	subi	r16, 0xF7	; 247
    8b9c:	1f 4f       	sbci	r17, 0xFF	; 255
    8b9e:	ce 01       	movw	r24, r28
    8ba0:	01 96       	adiw	r24, 0x01	; 1
    8ba2:	b8 01       	movw	r22, r16
    8ba4:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8ba8:	91 e1       	ldi	r25, 0x11	; 17
    8baa:	e9 2e       	mov	r14, r25
    8bac:	f1 2c       	mov	r15, r1
    8bae:	ec 0e       	add	r14, r28
    8bb0:	fd 1e       	adc	r15, r29
    8bb2:	ce 01       	movw	r24, r28
    8bb4:	05 96       	adiw	r24, 0x05	; 5
    8bb6:	b7 01       	movw	r22, r14
    8bb8:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8bbc:	8a 89       	ldd	r24, Y+18	; 0x12
    8bbe:	91 e0       	ldi	r25, 0x01	; 1
    8bc0:	89 27       	eor	r24, r25
    8bc2:	8a 8b       	std	Y+18, r24	; 0x12
    8bc4:	c8 01       	movw	r24, r16
    8bc6:	b7 01       	movw	r22, r14
    8bc8:	ae 01       	movw	r20, r28
    8bca:	47 5e       	subi	r20, 0xE7	; 231
    8bcc:	5f 4f       	sbci	r21, 0xFF	; 255
    8bce:	0e 94 47 44 	call	0x888e	; 0x888e <_fpadd_parts>
    8bd2:	0e 94 d3 48 	call	0x91a6	; 0x91a6 <__pack_f>
    8bd6:	a0 96       	adiw	r28, 0x20	; 32
    8bd8:	e6 e0       	ldi	r30, 0x06	; 6
    8bda:	0c 94 d4 4a 	jmp	0x95a8	; 0x95a8 <__epilogue_restores__+0x18>

00008bde <__mulsf3>:
    8bde:	a0 e2       	ldi	r26, 0x20	; 32
    8be0:	b0 e0       	ldi	r27, 0x00	; 0
    8be2:	e5 ef       	ldi	r30, 0xF5	; 245
    8be4:	f5 e4       	ldi	r31, 0x45	; 69
    8be6:	0c 94 ac 4a 	jmp	0x9558	; 0x9558 <__prologue_saves__>
    8bea:	69 83       	std	Y+1, r22	; 0x01
    8bec:	7a 83       	std	Y+2, r23	; 0x02
    8bee:	8b 83       	std	Y+3, r24	; 0x03
    8bf0:	9c 83       	std	Y+4, r25	; 0x04
    8bf2:	2d 83       	std	Y+5, r18	; 0x05
    8bf4:	3e 83       	std	Y+6, r19	; 0x06
    8bf6:	4f 83       	std	Y+7, r20	; 0x07
    8bf8:	58 87       	std	Y+8, r21	; 0x08
    8bfa:	ce 01       	movw	r24, r28
    8bfc:	01 96       	adiw	r24, 0x01	; 1
    8bfe:	be 01       	movw	r22, r28
    8c00:	67 5f       	subi	r22, 0xF7	; 247
    8c02:	7f 4f       	sbci	r23, 0xFF	; 255
    8c04:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8c08:	ce 01       	movw	r24, r28
    8c0a:	05 96       	adiw	r24, 0x05	; 5
    8c0c:	be 01       	movw	r22, r28
    8c0e:	6f 5e       	subi	r22, 0xEF	; 239
    8c10:	7f 4f       	sbci	r23, 0xFF	; 255
    8c12:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8c16:	99 85       	ldd	r25, Y+9	; 0x09
    8c18:	92 30       	cpi	r25, 0x02	; 2
    8c1a:	78 f0       	brcs	.+30     	; 0x8c3a <__mulsf3+0x5c>
    8c1c:	89 89       	ldd	r24, Y+17	; 0x11
    8c1e:	82 30       	cpi	r24, 0x02	; 2
    8c20:	c0 f0       	brcs	.+48     	; 0x8c52 <__mulsf3+0x74>
    8c22:	94 30       	cpi	r25, 0x04	; 4
    8c24:	19 f4       	brne	.+6      	; 0x8c2c <__mulsf3+0x4e>
    8c26:	82 30       	cpi	r24, 0x02	; 2
    8c28:	41 f4       	brne	.+16     	; 0x8c3a <__mulsf3+0x5c>
    8c2a:	cb c0       	rjmp	.+406    	; 0x8dc2 <__mulsf3+0x1e4>
    8c2c:	84 30       	cpi	r24, 0x04	; 4
    8c2e:	19 f4       	brne	.+6      	; 0x8c36 <__mulsf3+0x58>
    8c30:	92 30       	cpi	r25, 0x02	; 2
    8c32:	79 f4       	brne	.+30     	; 0x8c52 <__mulsf3+0x74>
    8c34:	c6 c0       	rjmp	.+396    	; 0x8dc2 <__mulsf3+0x1e4>
    8c36:	92 30       	cpi	r25, 0x02	; 2
    8c38:	51 f4       	brne	.+20     	; 0x8c4e <__mulsf3+0x70>
    8c3a:	81 e0       	ldi	r24, 0x01	; 1
    8c3c:	2a 85       	ldd	r18, Y+10	; 0x0a
    8c3e:	9a 89       	ldd	r25, Y+18	; 0x12
    8c40:	29 17       	cp	r18, r25
    8c42:	09 f4       	brne	.+2      	; 0x8c46 <__mulsf3+0x68>
    8c44:	80 e0       	ldi	r24, 0x00	; 0
    8c46:	8a 87       	std	Y+10, r24	; 0x0a
    8c48:	ce 01       	movw	r24, r28
    8c4a:	09 96       	adiw	r24, 0x09	; 9
    8c4c:	bc c0       	rjmp	.+376    	; 0x8dc6 <__mulsf3+0x1e8>
    8c4e:	82 30       	cpi	r24, 0x02	; 2
    8c50:	51 f4       	brne	.+20     	; 0x8c66 <__mulsf3+0x88>
    8c52:	81 e0       	ldi	r24, 0x01	; 1
    8c54:	2a 85       	ldd	r18, Y+10	; 0x0a
    8c56:	9a 89       	ldd	r25, Y+18	; 0x12
    8c58:	29 17       	cp	r18, r25
    8c5a:	09 f4       	brne	.+2      	; 0x8c5e <__mulsf3+0x80>
    8c5c:	80 e0       	ldi	r24, 0x00	; 0
    8c5e:	8a 8b       	std	Y+18, r24	; 0x12
    8c60:	ce 01       	movw	r24, r28
    8c62:	41 96       	adiw	r24, 0x11	; 17
    8c64:	b0 c0       	rjmp	.+352    	; 0x8dc6 <__mulsf3+0x1e8>
    8c66:	6d 84       	ldd	r6, Y+13	; 0x0d
    8c68:	7e 84       	ldd	r7, Y+14	; 0x0e
    8c6a:	8f 84       	ldd	r8, Y+15	; 0x0f
    8c6c:	98 88       	ldd	r9, Y+16	; 0x10
    8c6e:	ed 88       	ldd	r14, Y+21	; 0x15
    8c70:	fe 88       	ldd	r15, Y+22	; 0x16
    8c72:	0f 89       	ldd	r16, Y+23	; 0x17
    8c74:	18 8d       	ldd	r17, Y+24	; 0x18
    8c76:	e0 e2       	ldi	r30, 0x20	; 32
    8c78:	f0 e0       	ldi	r31, 0x00	; 0
    8c7a:	80 e0       	ldi	r24, 0x00	; 0
    8c7c:	90 e0       	ldi	r25, 0x00	; 0
    8c7e:	dc 01       	movw	r26, r24
    8c80:	aa 24       	eor	r10, r10
    8c82:	bb 24       	eor	r11, r11
    8c84:	65 01       	movw	r12, r10
    8c86:	20 e0       	ldi	r18, 0x00	; 0
    8c88:	30 e0       	ldi	r19, 0x00	; 0
    8c8a:	a9 01       	movw	r20, r18
    8c8c:	b3 01       	movw	r22, r6
    8c8e:	61 70       	andi	r22, 0x01	; 1
    8c90:	70 70       	andi	r23, 0x00	; 0
    8c92:	61 15       	cp	r22, r1
    8c94:	71 05       	cpc	r23, r1
    8c96:	d1 f0       	breq	.+52     	; 0x8ccc <__mulsf3+0xee>
    8c98:	2e 0d       	add	r18, r14
    8c9a:	3f 1d       	adc	r19, r15
    8c9c:	40 1f       	adc	r20, r16
    8c9e:	51 1f       	adc	r21, r17
    8ca0:	15 01       	movw	r2, r10
    8ca2:	26 01       	movw	r4, r12
    8ca4:	28 0e       	add	r2, r24
    8ca6:	39 1e       	adc	r3, r25
    8ca8:	4a 1e       	adc	r4, r26
    8caa:	5b 1e       	adc	r5, r27
    8cac:	81 e0       	ldi	r24, 0x01	; 1
    8cae:	90 e0       	ldi	r25, 0x00	; 0
    8cb0:	a0 e0       	ldi	r26, 0x00	; 0
    8cb2:	b0 e0       	ldi	r27, 0x00	; 0
    8cb4:	2e 15       	cp	r18, r14
    8cb6:	3f 05       	cpc	r19, r15
    8cb8:	40 07       	cpc	r20, r16
    8cba:	51 07       	cpc	r21, r17
    8cbc:	18 f0       	brcs	.+6      	; 0x8cc4 <__mulsf3+0xe6>
    8cbe:	80 e0       	ldi	r24, 0x00	; 0
    8cc0:	90 e0       	ldi	r25, 0x00	; 0
    8cc2:	dc 01       	movw	r26, r24
    8cc4:	82 0d       	add	r24, r2
    8cc6:	93 1d       	adc	r25, r3
    8cc8:	a4 1d       	adc	r26, r4
    8cca:	b5 1d       	adc	r27, r5
    8ccc:	aa 0c       	add	r10, r10
    8cce:	bb 1c       	adc	r11, r11
    8cd0:	cc 1c       	adc	r12, r12
    8cd2:	dd 1c       	adc	r13, r13
    8cd4:	17 ff       	sbrs	r17, 7
    8cd6:	09 c0       	rjmp	.+18     	; 0x8cea <__mulsf3+0x10c>
    8cd8:	61 e0       	ldi	r22, 0x01	; 1
    8cda:	26 2e       	mov	r2, r22
    8cdc:	31 2c       	mov	r3, r1
    8cde:	41 2c       	mov	r4, r1
    8ce0:	51 2c       	mov	r5, r1
    8ce2:	a2 28       	or	r10, r2
    8ce4:	b3 28       	or	r11, r3
    8ce6:	c4 28       	or	r12, r4
    8ce8:	d5 28       	or	r13, r5
    8cea:	31 97       	sbiw	r30, 0x01	; 1
    8cec:	49 f0       	breq	.+18     	; 0x8d00 <__mulsf3+0x122>
    8cee:	ee 0c       	add	r14, r14
    8cf0:	ff 1c       	adc	r15, r15
    8cf2:	00 1f       	adc	r16, r16
    8cf4:	11 1f       	adc	r17, r17
    8cf6:	96 94       	lsr	r9
    8cf8:	87 94       	ror	r8
    8cfa:	77 94       	ror	r7
    8cfc:	67 94       	ror	r6
    8cfe:	c6 cf       	rjmp	.-116    	; 0x8c8c <__mulsf3+0xae>
    8d00:	6b 89       	ldd	r22, Y+19	; 0x13
    8d02:	7c 89       	ldd	r23, Y+20	; 0x14
    8d04:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d06:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d08:	6e 0f       	add	r22, r30
    8d0a:	7f 1f       	adc	r23, r31
    8d0c:	6e 5f       	subi	r22, 0xFE	; 254
    8d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    8d10:	7c 8f       	std	Y+28, r23	; 0x1c
    8d12:	6b 8f       	std	Y+27, r22	; 0x1b
    8d14:	61 e0       	ldi	r22, 0x01	; 1
    8d16:	ea 85       	ldd	r30, Y+10	; 0x0a
    8d18:	7a 89       	ldd	r23, Y+18	; 0x12
    8d1a:	e7 17       	cp	r30, r23
    8d1c:	09 f4       	brne	.+2      	; 0x8d20 <__mulsf3+0x142>
    8d1e:	60 e0       	ldi	r22, 0x00	; 0
    8d20:	6a 8f       	std	Y+26, r22	; 0x1a
    8d22:	6b 8d       	ldd	r22, Y+27	; 0x1b
    8d24:	7c 8d       	ldd	r23, Y+28	; 0x1c
    8d26:	10 c0       	rjmp	.+32     	; 0x8d48 <__mulsf3+0x16a>
    8d28:	fc 01       	movw	r30, r24
    8d2a:	e1 70       	andi	r30, 0x01	; 1
    8d2c:	f0 70       	andi	r31, 0x00	; 0
    8d2e:	30 97       	sbiw	r30, 0x00	; 0
    8d30:	29 f0       	breq	.+10     	; 0x8d3c <__mulsf3+0x15e>
    8d32:	56 95       	lsr	r21
    8d34:	47 95       	ror	r20
    8d36:	37 95       	ror	r19
    8d38:	27 95       	ror	r18
    8d3a:	50 68       	ori	r21, 0x80	; 128
    8d3c:	b6 95       	lsr	r27
    8d3e:	a7 95       	ror	r26
    8d40:	97 95       	ror	r25
    8d42:	87 95       	ror	r24
    8d44:	6f 5f       	subi	r22, 0xFF	; 255
    8d46:	7f 4f       	sbci	r23, 0xFF	; 255
    8d48:	b7 fd       	sbrc	r27, 7
    8d4a:	ee cf       	rjmp	.-36     	; 0x8d28 <__mulsf3+0x14a>
    8d4c:	0c c0       	rjmp	.+24     	; 0x8d66 <__mulsf3+0x188>
    8d4e:	88 0f       	add	r24, r24
    8d50:	99 1f       	adc	r25, r25
    8d52:	aa 1f       	adc	r26, r26
    8d54:	bb 1f       	adc	r27, r27
    8d56:	57 fd       	sbrc	r21, 7
    8d58:	81 60       	ori	r24, 0x01	; 1
    8d5a:	22 0f       	add	r18, r18
    8d5c:	33 1f       	adc	r19, r19
    8d5e:	44 1f       	adc	r20, r20
    8d60:	55 1f       	adc	r21, r21
    8d62:	61 50       	subi	r22, 0x01	; 1
    8d64:	70 40       	sbci	r23, 0x00	; 0
    8d66:	80 30       	cpi	r24, 0x00	; 0
    8d68:	e0 e0       	ldi	r30, 0x00	; 0
    8d6a:	9e 07       	cpc	r25, r30
    8d6c:	e0 e0       	ldi	r30, 0x00	; 0
    8d6e:	ae 07       	cpc	r26, r30
    8d70:	e0 e4       	ldi	r30, 0x40	; 64
    8d72:	be 07       	cpc	r27, r30
    8d74:	60 f3       	brcs	.-40     	; 0x8d4e <__mulsf3+0x170>
    8d76:	6b 8f       	std	Y+27, r22	; 0x1b
    8d78:	7c 8f       	std	Y+28, r23	; 0x1c
    8d7a:	6f e7       	ldi	r22, 0x7F	; 127
    8d7c:	e6 2e       	mov	r14, r22
    8d7e:	f1 2c       	mov	r15, r1
    8d80:	01 2d       	mov	r16, r1
    8d82:	11 2d       	mov	r17, r1
    8d84:	e8 22       	and	r14, r24
    8d86:	f9 22       	and	r15, r25
    8d88:	0a 23       	and	r16, r26
    8d8a:	1b 23       	and	r17, r27
    8d8c:	60 e4       	ldi	r22, 0x40	; 64
    8d8e:	e6 16       	cp	r14, r22
    8d90:	f1 04       	cpc	r15, r1
    8d92:	01 05       	cpc	r16, r1
    8d94:	11 05       	cpc	r17, r1
    8d96:	61 f4       	brne	.+24     	; 0x8db0 <__mulsf3+0x1d2>
    8d98:	87 fd       	sbrc	r24, 7
    8d9a:	0a c0       	rjmp	.+20     	; 0x8db0 <__mulsf3+0x1d2>
    8d9c:	21 15       	cp	r18, r1
    8d9e:	31 05       	cpc	r19, r1
    8da0:	41 05       	cpc	r20, r1
    8da2:	51 05       	cpc	r21, r1
    8da4:	29 f0       	breq	.+10     	; 0x8db0 <__mulsf3+0x1d2>
    8da6:	80 5c       	subi	r24, 0xC0	; 192
    8da8:	9f 4f       	sbci	r25, 0xFF	; 255
    8daa:	af 4f       	sbci	r26, 0xFF	; 255
    8dac:	bf 4f       	sbci	r27, 0xFF	; 255
    8dae:	80 78       	andi	r24, 0x80	; 128
    8db0:	8d 8f       	std	Y+29, r24	; 0x1d
    8db2:	9e 8f       	std	Y+30, r25	; 0x1e
    8db4:	af 8f       	std	Y+31, r26	; 0x1f
    8db6:	b8 a3       	std	Y+32, r27	; 0x20
    8db8:	83 e0       	ldi	r24, 0x03	; 3
    8dba:	89 8f       	std	Y+25, r24	; 0x19
    8dbc:	ce 01       	movw	r24, r28
    8dbe:	49 96       	adiw	r24, 0x19	; 25
    8dc0:	02 c0       	rjmp	.+4      	; 0x8dc6 <__mulsf3+0x1e8>
    8dc2:	8a e7       	ldi	r24, 0x7A	; 122
    8dc4:	9e e0       	ldi	r25, 0x0E	; 14
    8dc6:	0e 94 d3 48 	call	0x91a6	; 0x91a6 <__pack_f>
    8dca:	a0 96       	adiw	r28, 0x20	; 32
    8dcc:	e2 e1       	ldi	r30, 0x12	; 18
    8dce:	0c 94 c8 4a 	jmp	0x9590	; 0x9590 <__epilogue_restores__>

00008dd2 <__divsf3>:
    8dd2:	a8 e1       	ldi	r26, 0x18	; 24
    8dd4:	b0 e0       	ldi	r27, 0x00	; 0
    8dd6:	ef ee       	ldi	r30, 0xEF	; 239
    8dd8:	f6 e4       	ldi	r31, 0x46	; 70
    8dda:	0c 94 b4 4a 	jmp	0x9568	; 0x9568 <__prologue_saves__+0x10>
    8dde:	69 83       	std	Y+1, r22	; 0x01
    8de0:	7a 83       	std	Y+2, r23	; 0x02
    8de2:	8b 83       	std	Y+3, r24	; 0x03
    8de4:	9c 83       	std	Y+4, r25	; 0x04
    8de6:	2d 83       	std	Y+5, r18	; 0x05
    8de8:	3e 83       	std	Y+6, r19	; 0x06
    8dea:	4f 83       	std	Y+7, r20	; 0x07
    8dec:	58 87       	std	Y+8, r21	; 0x08
    8dee:	8e 01       	movw	r16, r28
    8df0:	07 5f       	subi	r16, 0xF7	; 247
    8df2:	1f 4f       	sbci	r17, 0xFF	; 255
    8df4:	ce 01       	movw	r24, r28
    8df6:	01 96       	adiw	r24, 0x01	; 1
    8df8:	b8 01       	movw	r22, r16
    8dfa:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8dfe:	81 e1       	ldi	r24, 0x11	; 17
    8e00:	e8 2e       	mov	r14, r24
    8e02:	f1 2c       	mov	r15, r1
    8e04:	ec 0e       	add	r14, r28
    8e06:	fd 1e       	adc	r15, r29
    8e08:	ce 01       	movw	r24, r28
    8e0a:	05 96       	adiw	r24, 0x05	; 5
    8e0c:	b7 01       	movw	r22, r14
    8e0e:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8e12:	99 85       	ldd	r25, Y+9	; 0x09
    8e14:	92 30       	cpi	r25, 0x02	; 2
    8e16:	08 f4       	brcc	.+2      	; 0x8e1a <__divsf3+0x48>
    8e18:	83 c0       	rjmp	.+262    	; 0x8f20 <__divsf3+0x14e>
    8e1a:	89 89       	ldd	r24, Y+17	; 0x11
    8e1c:	82 30       	cpi	r24, 0x02	; 2
    8e1e:	08 f4       	brcc	.+2      	; 0x8e22 <__divsf3+0x50>
    8e20:	7b c0       	rjmp	.+246    	; 0x8f18 <__divsf3+0x146>
    8e22:	2a 85       	ldd	r18, Y+10	; 0x0a
    8e24:	3a 89       	ldd	r19, Y+18	; 0x12
    8e26:	23 27       	eor	r18, r19
    8e28:	2a 87       	std	Y+10, r18	; 0x0a
    8e2a:	94 30       	cpi	r25, 0x04	; 4
    8e2c:	11 f0       	breq	.+4      	; 0x8e32 <__divsf3+0x60>
    8e2e:	92 30       	cpi	r25, 0x02	; 2
    8e30:	21 f4       	brne	.+8      	; 0x8e3a <__divsf3+0x68>
    8e32:	98 17       	cp	r25, r24
    8e34:	09 f0       	breq	.+2      	; 0x8e38 <__divsf3+0x66>
    8e36:	6c c0       	rjmp	.+216    	; 0x8f10 <__divsf3+0x13e>
    8e38:	71 c0       	rjmp	.+226    	; 0x8f1c <__divsf3+0x14a>
    8e3a:	84 30       	cpi	r24, 0x04	; 4
    8e3c:	39 f4       	brne	.+14     	; 0x8e4c <__divsf3+0x7a>
    8e3e:	1d 86       	std	Y+13, r1	; 0x0d
    8e40:	1e 86       	std	Y+14, r1	; 0x0e
    8e42:	1f 86       	std	Y+15, r1	; 0x0f
    8e44:	18 8a       	std	Y+16, r1	; 0x10
    8e46:	1c 86       	std	Y+12, r1	; 0x0c
    8e48:	1b 86       	std	Y+11, r1	; 0x0b
    8e4a:	6a c0       	rjmp	.+212    	; 0x8f20 <__divsf3+0x14e>
    8e4c:	82 30       	cpi	r24, 0x02	; 2
    8e4e:	19 f4       	brne	.+6      	; 0x8e56 <__divsf3+0x84>
    8e50:	84 e0       	ldi	r24, 0x04	; 4
    8e52:	89 87       	std	Y+9, r24	; 0x09
    8e54:	65 c0       	rjmp	.+202    	; 0x8f20 <__divsf3+0x14e>
    8e56:	8b 85       	ldd	r24, Y+11	; 0x0b
    8e58:	9c 85       	ldd	r25, Y+12	; 0x0c
    8e5a:	2b 89       	ldd	r18, Y+19	; 0x13
    8e5c:	3c 89       	ldd	r19, Y+20	; 0x14
    8e5e:	82 1b       	sub	r24, r18
    8e60:	93 0b       	sbc	r25, r19
    8e62:	9c 87       	std	Y+12, r25	; 0x0c
    8e64:	8b 87       	std	Y+11, r24	; 0x0b
    8e66:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e68:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e6a:	4f 85       	ldd	r20, Y+15	; 0x0f
    8e6c:	58 89       	ldd	r21, Y+16	; 0x10
    8e6e:	ed 88       	ldd	r14, Y+21	; 0x15
    8e70:	fe 88       	ldd	r15, Y+22	; 0x16
    8e72:	0f 89       	ldd	r16, Y+23	; 0x17
    8e74:	18 8d       	ldd	r17, Y+24	; 0x18
    8e76:	2e 15       	cp	r18, r14
    8e78:	3f 05       	cpc	r19, r15
    8e7a:	40 07       	cpc	r20, r16
    8e7c:	51 07       	cpc	r21, r17
    8e7e:	38 f4       	brcc	.+14     	; 0x8e8e <__divsf3+0xbc>
    8e80:	22 0f       	add	r18, r18
    8e82:	33 1f       	adc	r19, r19
    8e84:	44 1f       	adc	r20, r20
    8e86:	55 1f       	adc	r21, r21
    8e88:	01 97       	sbiw	r24, 0x01	; 1
    8e8a:	9c 87       	std	Y+12, r25	; 0x0c
    8e8c:	8b 87       	std	Y+11, r24	; 0x0b
    8e8e:	6f e1       	ldi	r22, 0x1F	; 31
    8e90:	70 e0       	ldi	r23, 0x00	; 0
    8e92:	a1 2c       	mov	r10, r1
    8e94:	b1 2c       	mov	r11, r1
    8e96:	c1 2c       	mov	r12, r1
    8e98:	a0 e4       	ldi	r26, 0x40	; 64
    8e9a:	da 2e       	mov	r13, r26
    8e9c:	80 e0       	ldi	r24, 0x00	; 0
    8e9e:	90 e0       	ldi	r25, 0x00	; 0
    8ea0:	dc 01       	movw	r26, r24
    8ea2:	2e 15       	cp	r18, r14
    8ea4:	3f 05       	cpc	r19, r15
    8ea6:	40 07       	cpc	r20, r16
    8ea8:	51 07       	cpc	r21, r17
    8eaa:	40 f0       	brcs	.+16     	; 0x8ebc <__divsf3+0xea>
    8eac:	8a 29       	or	r24, r10
    8eae:	9b 29       	or	r25, r11
    8eb0:	ac 29       	or	r26, r12
    8eb2:	bd 29       	or	r27, r13
    8eb4:	2e 19       	sub	r18, r14
    8eb6:	3f 09       	sbc	r19, r15
    8eb8:	40 0b       	sbc	r20, r16
    8eba:	51 0b       	sbc	r21, r17
    8ebc:	d6 94       	lsr	r13
    8ebe:	c7 94       	ror	r12
    8ec0:	b7 94       	ror	r11
    8ec2:	a7 94       	ror	r10
    8ec4:	22 0f       	add	r18, r18
    8ec6:	33 1f       	adc	r19, r19
    8ec8:	44 1f       	adc	r20, r20
    8eca:	55 1f       	adc	r21, r21
    8ecc:	61 50       	subi	r22, 0x01	; 1
    8ece:	70 40       	sbci	r23, 0x00	; 0
    8ed0:	41 f7       	brne	.-48     	; 0x8ea2 <__divsf3+0xd0>
    8ed2:	6f e7       	ldi	r22, 0x7F	; 127
    8ed4:	e6 2e       	mov	r14, r22
    8ed6:	f1 2c       	mov	r15, r1
    8ed8:	01 2d       	mov	r16, r1
    8eda:	11 2d       	mov	r17, r1
    8edc:	e8 22       	and	r14, r24
    8ede:	f9 22       	and	r15, r25
    8ee0:	0a 23       	and	r16, r26
    8ee2:	1b 23       	and	r17, r27
    8ee4:	60 e4       	ldi	r22, 0x40	; 64
    8ee6:	e6 16       	cp	r14, r22
    8ee8:	f1 04       	cpc	r15, r1
    8eea:	01 05       	cpc	r16, r1
    8eec:	11 05       	cpc	r17, r1
    8eee:	61 f4       	brne	.+24     	; 0x8f08 <__divsf3+0x136>
    8ef0:	87 fd       	sbrc	r24, 7
    8ef2:	0a c0       	rjmp	.+20     	; 0x8f08 <__divsf3+0x136>
    8ef4:	21 15       	cp	r18, r1
    8ef6:	31 05       	cpc	r19, r1
    8ef8:	41 05       	cpc	r20, r1
    8efa:	51 05       	cpc	r21, r1
    8efc:	29 f0       	breq	.+10     	; 0x8f08 <__divsf3+0x136>
    8efe:	80 5c       	subi	r24, 0xC0	; 192
    8f00:	9f 4f       	sbci	r25, 0xFF	; 255
    8f02:	af 4f       	sbci	r26, 0xFF	; 255
    8f04:	bf 4f       	sbci	r27, 0xFF	; 255
    8f06:	80 78       	andi	r24, 0x80	; 128
    8f08:	8d 87       	std	Y+13, r24	; 0x0d
    8f0a:	9e 87       	std	Y+14, r25	; 0x0e
    8f0c:	af 87       	std	Y+15, r26	; 0x0f
    8f0e:	b8 8b       	std	Y+16, r27	; 0x10
    8f10:	8e 01       	movw	r16, r28
    8f12:	07 5f       	subi	r16, 0xF7	; 247
    8f14:	1f 4f       	sbci	r17, 0xFF	; 255
    8f16:	04 c0       	rjmp	.+8      	; 0x8f20 <__divsf3+0x14e>
    8f18:	87 01       	movw	r16, r14
    8f1a:	02 c0       	rjmp	.+4      	; 0x8f20 <__divsf3+0x14e>
    8f1c:	0a e7       	ldi	r16, 0x7A	; 122
    8f1e:	1e e0       	ldi	r17, 0x0E	; 14
    8f20:	c8 01       	movw	r24, r16
    8f22:	0e 94 d3 48 	call	0x91a6	; 0x91a6 <__pack_f>
    8f26:	68 96       	adiw	r28, 0x18	; 24
    8f28:	ea e0       	ldi	r30, 0x0A	; 10
    8f2a:	0c 94 d0 4a 	jmp	0x95a0	; 0x95a0 <__epilogue_restores__+0x10>

00008f2e <__gesf2>:
    8f2e:	a8 e1       	ldi	r26, 0x18	; 24
    8f30:	b0 e0       	ldi	r27, 0x00	; 0
    8f32:	ed e9       	ldi	r30, 0x9D	; 157
    8f34:	f7 e4       	ldi	r31, 0x47	; 71
    8f36:	0c 94 b8 4a 	jmp	0x9570	; 0x9570 <__prologue_saves__+0x18>
    8f3a:	69 83       	std	Y+1, r22	; 0x01
    8f3c:	7a 83       	std	Y+2, r23	; 0x02
    8f3e:	8b 83       	std	Y+3, r24	; 0x03
    8f40:	9c 83       	std	Y+4, r25	; 0x04
    8f42:	2d 83       	std	Y+5, r18	; 0x05
    8f44:	3e 83       	std	Y+6, r19	; 0x06
    8f46:	4f 83       	std	Y+7, r20	; 0x07
    8f48:	58 87       	std	Y+8, r21	; 0x08
    8f4a:	8e 01       	movw	r16, r28
    8f4c:	07 5f       	subi	r16, 0xF7	; 247
    8f4e:	1f 4f       	sbci	r17, 0xFF	; 255
    8f50:	ce 01       	movw	r24, r28
    8f52:	01 96       	adiw	r24, 0x01	; 1
    8f54:	b8 01       	movw	r22, r16
    8f56:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8f5a:	81 e1       	ldi	r24, 0x11	; 17
    8f5c:	e8 2e       	mov	r14, r24
    8f5e:	f1 2c       	mov	r15, r1
    8f60:	ec 0e       	add	r14, r28
    8f62:	fd 1e       	adc	r15, r29
    8f64:	ce 01       	movw	r24, r28
    8f66:	05 96       	adiw	r24, 0x05	; 5
    8f68:	b7 01       	movw	r22, r14
    8f6a:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    8f6e:	89 85       	ldd	r24, Y+9	; 0x09
    8f70:	82 30       	cpi	r24, 0x02	; 2
    8f72:	40 f0       	brcs	.+16     	; 0x8f84 <__gesf2+0x56>
    8f74:	89 89       	ldd	r24, Y+17	; 0x11
    8f76:	82 30       	cpi	r24, 0x02	; 2
    8f78:	28 f0       	brcs	.+10     	; 0x8f84 <__gesf2+0x56>
    8f7a:	c8 01       	movw	r24, r16
    8f7c:	b7 01       	movw	r22, r14
    8f7e:	0e 94 0a 4a 	call	0x9414	; 0x9414 <__fpcmp_parts_f>
    8f82:	01 c0       	rjmp	.+2      	; 0x8f86 <__gesf2+0x58>
    8f84:	8f ef       	ldi	r24, 0xFF	; 255
    8f86:	68 96       	adiw	r28, 0x18	; 24
    8f88:	e6 e0       	ldi	r30, 0x06	; 6
    8f8a:	0c 94 d4 4a 	jmp	0x95a8	; 0x95a8 <__epilogue_restores__+0x18>

00008f8e <__floatsisf>:
    8f8e:	a8 e0       	ldi	r26, 0x08	; 8
    8f90:	b0 e0       	ldi	r27, 0x00	; 0
    8f92:	ed ec       	ldi	r30, 0xCD	; 205
    8f94:	f7 e4       	ldi	r31, 0x47	; 71
    8f96:	0c 94 b8 4a 	jmp	0x9570	; 0x9570 <__prologue_saves__+0x18>
    8f9a:	7b 01       	movw	r14, r22
    8f9c:	8c 01       	movw	r16, r24
    8f9e:	83 e0       	ldi	r24, 0x03	; 3
    8fa0:	89 83       	std	Y+1, r24	; 0x01
    8fa2:	d8 01       	movw	r26, r16
    8fa4:	c7 01       	movw	r24, r14
    8fa6:	88 27       	eor	r24, r24
    8fa8:	b7 fd       	sbrc	r27, 7
    8faa:	83 95       	inc	r24
    8fac:	99 27       	eor	r25, r25
    8fae:	aa 27       	eor	r26, r26
    8fb0:	bb 27       	eor	r27, r27
    8fb2:	28 2f       	mov	r18, r24
    8fb4:	8a 83       	std	Y+2, r24	; 0x02
    8fb6:	e1 14       	cp	r14, r1
    8fb8:	f1 04       	cpc	r15, r1
    8fba:	01 05       	cpc	r16, r1
    8fbc:	11 05       	cpc	r17, r1
    8fbe:	19 f4       	brne	.+6      	; 0x8fc6 <__floatsisf+0x38>
    8fc0:	82 e0       	ldi	r24, 0x02	; 2
    8fc2:	89 83       	std	Y+1, r24	; 0x01
    8fc4:	37 c0       	rjmp	.+110    	; 0x9034 <__floatsisf+0xa6>
    8fc6:	8e e1       	ldi	r24, 0x1E	; 30
    8fc8:	90 e0       	ldi	r25, 0x00	; 0
    8fca:	9c 83       	std	Y+4, r25	; 0x04
    8fcc:	8b 83       	std	Y+3, r24	; 0x03
    8fce:	22 23       	and	r18, r18
    8fd0:	89 f0       	breq	.+34     	; 0x8ff4 <__floatsisf+0x66>
    8fd2:	80 e0       	ldi	r24, 0x00	; 0
    8fd4:	e8 16       	cp	r14, r24
    8fd6:	80 e0       	ldi	r24, 0x00	; 0
    8fd8:	f8 06       	cpc	r15, r24
    8fda:	80 e0       	ldi	r24, 0x00	; 0
    8fdc:	08 07       	cpc	r16, r24
    8fde:	80 e8       	ldi	r24, 0x80	; 128
    8fe0:	18 07       	cpc	r17, r24
    8fe2:	69 f1       	breq	.+90     	; 0x903e <__floatsisf+0xb0>
    8fe4:	10 95       	com	r17
    8fe6:	00 95       	com	r16
    8fe8:	f0 94       	com	r15
    8fea:	e0 94       	com	r14
    8fec:	e1 1c       	adc	r14, r1
    8fee:	f1 1c       	adc	r15, r1
    8ff0:	01 1d       	adc	r16, r1
    8ff2:	11 1d       	adc	r17, r1
    8ff4:	ed 82       	std	Y+5, r14	; 0x05
    8ff6:	fe 82       	std	Y+6, r15	; 0x06
    8ff8:	0f 83       	std	Y+7, r16	; 0x07
    8ffa:	18 87       	std	Y+8, r17	; 0x08
    8ffc:	c8 01       	movw	r24, r16
    8ffe:	b7 01       	movw	r22, r14
    9000:	0e 94 79 48 	call	0x90f2	; 0x90f2 <__clzsi2>
    9004:	9c 01       	movw	r18, r24
    9006:	21 50       	subi	r18, 0x01	; 1
    9008:	30 40       	sbci	r19, 0x00	; 0
    900a:	12 16       	cp	r1, r18
    900c:	13 06       	cpc	r1, r19
    900e:	94 f4       	brge	.+36     	; 0x9034 <__floatsisf+0xa6>
    9010:	02 2e       	mov	r0, r18
    9012:	04 c0       	rjmp	.+8      	; 0x901c <__floatsisf+0x8e>
    9014:	ee 0c       	add	r14, r14
    9016:	ff 1c       	adc	r15, r15
    9018:	00 1f       	adc	r16, r16
    901a:	11 1f       	adc	r17, r17
    901c:	0a 94       	dec	r0
    901e:	d2 f7       	brpl	.-12     	; 0x9014 <__floatsisf+0x86>
    9020:	ed 82       	std	Y+5, r14	; 0x05
    9022:	fe 82       	std	Y+6, r15	; 0x06
    9024:	0f 83       	std	Y+7, r16	; 0x07
    9026:	18 87       	std	Y+8, r17	; 0x08
    9028:	8e e1       	ldi	r24, 0x1E	; 30
    902a:	90 e0       	ldi	r25, 0x00	; 0
    902c:	82 1b       	sub	r24, r18
    902e:	93 0b       	sbc	r25, r19
    9030:	9c 83       	std	Y+4, r25	; 0x04
    9032:	8b 83       	std	Y+3, r24	; 0x03
    9034:	ce 01       	movw	r24, r28
    9036:	01 96       	adiw	r24, 0x01	; 1
    9038:	0e 94 d3 48 	call	0x91a6	; 0x91a6 <__pack_f>
    903c:	04 c0       	rjmp	.+8      	; 0x9046 <__floatsisf+0xb8>
    903e:	60 e0       	ldi	r22, 0x00	; 0
    9040:	70 e0       	ldi	r23, 0x00	; 0
    9042:	80 e0       	ldi	r24, 0x00	; 0
    9044:	9f ec       	ldi	r25, 0xCF	; 207
    9046:	28 96       	adiw	r28, 0x08	; 8
    9048:	e6 e0       	ldi	r30, 0x06	; 6
    904a:	0c 94 d4 4a 	jmp	0x95a8	; 0x95a8 <__epilogue_restores__+0x18>

0000904e <__fixsfsi>:
    904e:	ac e0       	ldi	r26, 0x0C	; 12
    9050:	b0 e0       	ldi	r27, 0x00	; 0
    9052:	ed e2       	ldi	r30, 0x2D	; 45
    9054:	f8 e4       	ldi	r31, 0x48	; 72
    9056:	0c 94 bc 4a 	jmp	0x9578	; 0x9578 <__prologue_saves__+0x20>
    905a:	69 83       	std	Y+1, r22	; 0x01
    905c:	7a 83       	std	Y+2, r23	; 0x02
    905e:	8b 83       	std	Y+3, r24	; 0x03
    9060:	9c 83       	std	Y+4, r25	; 0x04
    9062:	ce 01       	movw	r24, r28
    9064:	01 96       	adiw	r24, 0x01	; 1
    9066:	be 01       	movw	r22, r28
    9068:	6b 5f       	subi	r22, 0xFB	; 251
    906a:	7f 4f       	sbci	r23, 0xFF	; 255
    906c:	0e 94 a1 49 	call	0x9342	; 0x9342 <__unpack_f>
    9070:	8d 81       	ldd	r24, Y+5	; 0x05
    9072:	82 30       	cpi	r24, 0x02	; 2
    9074:	81 f1       	breq	.+96     	; 0x90d6 <__fixsfsi+0x88>
    9076:	82 30       	cpi	r24, 0x02	; 2
    9078:	70 f1       	brcs	.+92     	; 0x90d6 <__fixsfsi+0x88>
    907a:	84 30       	cpi	r24, 0x04	; 4
    907c:	21 f4       	brne	.+8      	; 0x9086 <__fixsfsi+0x38>
    907e:	8e 81       	ldd	r24, Y+6	; 0x06
    9080:	88 23       	and	r24, r24
    9082:	69 f1       	breq	.+90     	; 0x90de <__fixsfsi+0x90>
    9084:	0a c0       	rjmp	.+20     	; 0x909a <__fixsfsi+0x4c>
    9086:	2f 81       	ldd	r18, Y+7	; 0x07
    9088:	38 85       	ldd	r19, Y+8	; 0x08
    908a:	37 fd       	sbrc	r19, 7
    908c:	24 c0       	rjmp	.+72     	; 0x90d6 <__fixsfsi+0x88>
    908e:	6e 81       	ldd	r22, Y+6	; 0x06
    9090:	2f 31       	cpi	r18, 0x1F	; 31
    9092:	31 05       	cpc	r19, r1
    9094:	3c f0       	brlt	.+14     	; 0x90a4 <__fixsfsi+0x56>
    9096:	66 23       	and	r22, r22
    9098:	11 f1       	breq	.+68     	; 0x90de <__fixsfsi+0x90>
    909a:	20 e0       	ldi	r18, 0x00	; 0
    909c:	30 e0       	ldi	r19, 0x00	; 0
    909e:	40 e0       	ldi	r20, 0x00	; 0
    90a0:	50 e8       	ldi	r21, 0x80	; 128
    90a2:	21 c0       	rjmp	.+66     	; 0x90e6 <__fixsfsi+0x98>
    90a4:	8e e1       	ldi	r24, 0x1E	; 30
    90a6:	90 e0       	ldi	r25, 0x00	; 0
    90a8:	82 1b       	sub	r24, r18
    90aa:	93 0b       	sbc	r25, r19
    90ac:	29 85       	ldd	r18, Y+9	; 0x09
    90ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    90b0:	4b 85       	ldd	r20, Y+11	; 0x0b
    90b2:	5c 85       	ldd	r21, Y+12	; 0x0c
    90b4:	04 c0       	rjmp	.+8      	; 0x90be <__fixsfsi+0x70>
    90b6:	56 95       	lsr	r21
    90b8:	47 95       	ror	r20
    90ba:	37 95       	ror	r19
    90bc:	27 95       	ror	r18
    90be:	8a 95       	dec	r24
    90c0:	d2 f7       	brpl	.-12     	; 0x90b6 <__fixsfsi+0x68>
    90c2:	66 23       	and	r22, r22
    90c4:	81 f0       	breq	.+32     	; 0x90e6 <__fixsfsi+0x98>
    90c6:	50 95       	com	r21
    90c8:	40 95       	com	r20
    90ca:	30 95       	com	r19
    90cc:	21 95       	neg	r18
    90ce:	3f 4f       	sbci	r19, 0xFF	; 255
    90d0:	4f 4f       	sbci	r20, 0xFF	; 255
    90d2:	5f 4f       	sbci	r21, 0xFF	; 255
    90d4:	08 c0       	rjmp	.+16     	; 0x90e6 <__fixsfsi+0x98>
    90d6:	20 e0       	ldi	r18, 0x00	; 0
    90d8:	30 e0       	ldi	r19, 0x00	; 0
    90da:	a9 01       	movw	r20, r18
    90dc:	04 c0       	rjmp	.+8      	; 0x90e6 <__fixsfsi+0x98>
    90de:	2f ef       	ldi	r18, 0xFF	; 255
    90e0:	3f ef       	ldi	r19, 0xFF	; 255
    90e2:	4f ef       	ldi	r20, 0xFF	; 255
    90e4:	5f e7       	ldi	r21, 0x7F	; 127
    90e6:	b9 01       	movw	r22, r18
    90e8:	ca 01       	movw	r24, r20
    90ea:	2c 96       	adiw	r28, 0x0c	; 12
    90ec:	e2 e0       	ldi	r30, 0x02	; 2
    90ee:	0c 94 d8 4a 	jmp	0x95b0	; 0x95b0 <__epilogue_restores__+0x20>

000090f2 <__clzsi2>:
    90f2:	af 92       	push	r10
    90f4:	bf 92       	push	r11
    90f6:	cf 92       	push	r12
    90f8:	df 92       	push	r13
    90fa:	ef 92       	push	r14
    90fc:	ff 92       	push	r15
    90fe:	0f 93       	push	r16
    9100:	1f 93       	push	r17
    9102:	7b 01       	movw	r14, r22
    9104:	8c 01       	movw	r16, r24
    9106:	80 e0       	ldi	r24, 0x00	; 0
    9108:	e8 16       	cp	r14, r24
    910a:	80 e0       	ldi	r24, 0x00	; 0
    910c:	f8 06       	cpc	r15, r24
    910e:	81 e0       	ldi	r24, 0x01	; 1
    9110:	08 07       	cpc	r16, r24
    9112:	80 e0       	ldi	r24, 0x00	; 0
    9114:	18 07       	cpc	r17, r24
    9116:	58 f4       	brcc	.+22     	; 0x912e <__clzsi2+0x3c>
    9118:	ef ef       	ldi	r30, 0xFF	; 255
    911a:	ee 16       	cp	r14, r30
    911c:	f1 04       	cpc	r15, r1
    911e:	01 05       	cpc	r16, r1
    9120:	11 05       	cpc	r17, r1
    9122:	09 f0       	breq	.+2      	; 0x9126 <__clzsi2+0x34>
    9124:	90 f4       	brcc	.+36     	; 0x914a <__clzsi2+0x58>
    9126:	80 e0       	ldi	r24, 0x00	; 0
    9128:	90 e0       	ldi	r25, 0x00	; 0
    912a:	dc 01       	movw	r26, r24
    912c:	17 c0       	rjmp	.+46     	; 0x915c <__clzsi2+0x6a>
    912e:	f0 e0       	ldi	r31, 0x00	; 0
    9130:	ef 16       	cp	r14, r31
    9132:	f0 e0       	ldi	r31, 0x00	; 0
    9134:	ff 06       	cpc	r15, r31
    9136:	f0 e0       	ldi	r31, 0x00	; 0
    9138:	0f 07       	cpc	r16, r31
    913a:	f1 e0       	ldi	r31, 0x01	; 1
    913c:	1f 07       	cpc	r17, r31
    913e:	50 f4       	brcc	.+20     	; 0x9154 <__clzsi2+0x62>
    9140:	80 e1       	ldi	r24, 0x10	; 16
    9142:	90 e0       	ldi	r25, 0x00	; 0
    9144:	a0 e0       	ldi	r26, 0x00	; 0
    9146:	b0 e0       	ldi	r27, 0x00	; 0
    9148:	09 c0       	rjmp	.+18     	; 0x915c <__clzsi2+0x6a>
    914a:	88 e0       	ldi	r24, 0x08	; 8
    914c:	90 e0       	ldi	r25, 0x00	; 0
    914e:	a0 e0       	ldi	r26, 0x00	; 0
    9150:	b0 e0       	ldi	r27, 0x00	; 0
    9152:	04 c0       	rjmp	.+8      	; 0x915c <__clzsi2+0x6a>
    9154:	88 e1       	ldi	r24, 0x18	; 24
    9156:	90 e0       	ldi	r25, 0x00	; 0
    9158:	a0 e0       	ldi	r26, 0x00	; 0
    915a:	b0 e0       	ldi	r27, 0x00	; 0
    915c:	20 e2       	ldi	r18, 0x20	; 32
    915e:	30 e0       	ldi	r19, 0x00	; 0
    9160:	40 e0       	ldi	r20, 0x00	; 0
    9162:	50 e0       	ldi	r21, 0x00	; 0
    9164:	28 1b       	sub	r18, r24
    9166:	39 0b       	sbc	r19, r25
    9168:	4a 0b       	sbc	r20, r26
    916a:	5b 0b       	sbc	r21, r27
    916c:	57 01       	movw	r10, r14
    916e:	68 01       	movw	r12, r16
    9170:	04 c0       	rjmp	.+8      	; 0x917a <__clzsi2+0x88>
    9172:	d6 94       	lsr	r13
    9174:	c7 94       	ror	r12
    9176:	b7 94       	ror	r11
    9178:	a7 94       	ror	r10
    917a:	8a 95       	dec	r24
    917c:	d2 f7       	brpl	.-12     	; 0x9172 <__clzsi2+0x80>
    917e:	d6 01       	movw	r26, r12
    9180:	c5 01       	movw	r24, r10
    9182:	8e 57       	subi	r24, 0x7E	; 126
    9184:	91 4f       	sbci	r25, 0xF1	; 241
    9186:	fc 01       	movw	r30, r24
    9188:	80 81       	ld	r24, Z
    918a:	28 1b       	sub	r18, r24
    918c:	31 09       	sbc	r19, r1
    918e:	41 09       	sbc	r20, r1
    9190:	51 09       	sbc	r21, r1
    9192:	c9 01       	movw	r24, r18
    9194:	1f 91       	pop	r17
    9196:	0f 91       	pop	r16
    9198:	ff 90       	pop	r15
    919a:	ef 90       	pop	r14
    919c:	df 90       	pop	r13
    919e:	cf 90       	pop	r12
    91a0:	bf 90       	pop	r11
    91a2:	af 90       	pop	r10
    91a4:	08 95       	ret

000091a6 <__pack_f>:
    91a6:	ef 92       	push	r14
    91a8:	ff 92       	push	r15
    91aa:	0f 93       	push	r16
    91ac:	1f 93       	push	r17
    91ae:	cf 93       	push	r28
    91b0:	df 93       	push	r29
    91b2:	fc 01       	movw	r30, r24
    91b4:	24 81       	ldd	r18, Z+4	; 0x04
    91b6:	35 81       	ldd	r19, Z+5	; 0x05
    91b8:	46 81       	ldd	r20, Z+6	; 0x06
    91ba:	57 81       	ldd	r21, Z+7	; 0x07
    91bc:	61 81       	ldd	r22, Z+1	; 0x01
    91be:	80 81       	ld	r24, Z
    91c0:	82 30       	cpi	r24, 0x02	; 2
    91c2:	20 f4       	brcc	.+8      	; 0x91cc <__pack_f+0x26>
    91c4:	40 61       	ori	r20, 0x10	; 16
    91c6:	ef ef       	ldi	r30, 0xFF	; 255
    91c8:	f0 e0       	ldi	r31, 0x00	; 0
    91ca:	a3 c0       	rjmp	.+326    	; 0x9312 <__pack_f+0x16c>
    91cc:	84 30       	cpi	r24, 0x04	; 4
    91ce:	09 f4       	brne	.+2      	; 0x91d2 <__pack_f+0x2c>
    91d0:	9b c0       	rjmp	.+310    	; 0x9308 <__pack_f+0x162>
    91d2:	82 30       	cpi	r24, 0x02	; 2
    91d4:	09 f4       	brne	.+2      	; 0x91d8 <__pack_f+0x32>
    91d6:	92 c0       	rjmp	.+292    	; 0x92fc <__pack_f+0x156>
    91d8:	21 15       	cp	r18, r1
    91da:	31 05       	cpc	r19, r1
    91dc:	41 05       	cpc	r20, r1
    91de:	51 05       	cpc	r21, r1
    91e0:	09 f4       	brne	.+2      	; 0x91e4 <__pack_f+0x3e>
    91e2:	8f c0       	rjmp	.+286    	; 0x9302 <__pack_f+0x15c>
    91e4:	02 80       	ldd	r0, Z+2	; 0x02
    91e6:	f3 81       	ldd	r31, Z+3	; 0x03
    91e8:	e0 2d       	mov	r30, r0
    91ea:	8f ef       	ldi	r24, 0xFF	; 255
    91ec:	e2 38       	cpi	r30, 0x82	; 130
    91ee:	f8 07       	cpc	r31, r24
    91f0:	0c f0       	brlt	.+2      	; 0x91f4 <__pack_f+0x4e>
    91f2:	5a c0       	rjmp	.+180    	; 0x92a8 <__pack_f+0x102>
    91f4:	c2 e8       	ldi	r28, 0x82	; 130
    91f6:	df ef       	ldi	r29, 0xFF	; 255
    91f8:	ce 1b       	sub	r28, r30
    91fa:	df 0b       	sbc	r29, r31
    91fc:	ca 31       	cpi	r28, 0x1A	; 26
    91fe:	d1 05       	cpc	r29, r1
    9200:	6c f5       	brge	.+90     	; 0x925c <__pack_f+0xb6>
    9202:	79 01       	movw	r14, r18
    9204:	8a 01       	movw	r16, r20
    9206:	0c 2e       	mov	r0, r28
    9208:	04 c0       	rjmp	.+8      	; 0x9212 <__pack_f+0x6c>
    920a:	16 95       	lsr	r17
    920c:	07 95       	ror	r16
    920e:	f7 94       	ror	r15
    9210:	e7 94       	ror	r14
    9212:	0a 94       	dec	r0
    9214:	d2 f7       	brpl	.-12     	; 0x920a <__pack_f+0x64>
    9216:	81 e0       	ldi	r24, 0x01	; 1
    9218:	90 e0       	ldi	r25, 0x00	; 0
    921a:	a0 e0       	ldi	r26, 0x00	; 0
    921c:	b0 e0       	ldi	r27, 0x00	; 0
    921e:	0c 2e       	mov	r0, r28
    9220:	04 c0       	rjmp	.+8      	; 0x922a <__pack_f+0x84>
    9222:	88 0f       	add	r24, r24
    9224:	99 1f       	adc	r25, r25
    9226:	aa 1f       	adc	r26, r26
    9228:	bb 1f       	adc	r27, r27
    922a:	0a 94       	dec	r0
    922c:	d2 f7       	brpl	.-12     	; 0x9222 <__pack_f+0x7c>
    922e:	01 97       	sbiw	r24, 0x01	; 1
    9230:	a1 09       	sbc	r26, r1
    9232:	b1 09       	sbc	r27, r1
    9234:	82 23       	and	r24, r18
    9236:	93 23       	and	r25, r19
    9238:	a4 23       	and	r26, r20
    923a:	b5 23       	and	r27, r21
    923c:	21 e0       	ldi	r18, 0x01	; 1
    923e:	30 e0       	ldi	r19, 0x00	; 0
    9240:	40 e0       	ldi	r20, 0x00	; 0
    9242:	50 e0       	ldi	r21, 0x00	; 0
    9244:	00 97       	sbiw	r24, 0x00	; 0
    9246:	a1 05       	cpc	r26, r1
    9248:	b1 05       	cpc	r27, r1
    924a:	19 f4       	brne	.+6      	; 0x9252 <__pack_f+0xac>
    924c:	20 e0       	ldi	r18, 0x00	; 0
    924e:	30 e0       	ldi	r19, 0x00	; 0
    9250:	a9 01       	movw	r20, r18
    9252:	2e 29       	or	r18, r14
    9254:	3f 29       	or	r19, r15
    9256:	40 2b       	or	r20, r16
    9258:	51 2b       	or	r21, r17
    925a:	03 c0       	rjmp	.+6      	; 0x9262 <__pack_f+0xbc>
    925c:	20 e0       	ldi	r18, 0x00	; 0
    925e:	30 e0       	ldi	r19, 0x00	; 0
    9260:	a9 01       	movw	r20, r18
    9262:	da 01       	movw	r26, r20
    9264:	c9 01       	movw	r24, r18
    9266:	8f 77       	andi	r24, 0x7F	; 127
    9268:	90 70       	andi	r25, 0x00	; 0
    926a:	a0 70       	andi	r26, 0x00	; 0
    926c:	b0 70       	andi	r27, 0x00	; 0
    926e:	80 34       	cpi	r24, 0x40	; 64
    9270:	91 05       	cpc	r25, r1
    9272:	a1 05       	cpc	r26, r1
    9274:	b1 05       	cpc	r27, r1
    9276:	39 f4       	brne	.+14     	; 0x9286 <__pack_f+0xe0>
    9278:	27 ff       	sbrs	r18, 7
    927a:	09 c0       	rjmp	.+18     	; 0x928e <__pack_f+0xe8>
    927c:	20 5c       	subi	r18, 0xC0	; 192
    927e:	3f 4f       	sbci	r19, 0xFF	; 255
    9280:	4f 4f       	sbci	r20, 0xFF	; 255
    9282:	5f 4f       	sbci	r21, 0xFF	; 255
    9284:	04 c0       	rjmp	.+8      	; 0x928e <__pack_f+0xe8>
    9286:	21 5c       	subi	r18, 0xC1	; 193
    9288:	3f 4f       	sbci	r19, 0xFF	; 255
    928a:	4f 4f       	sbci	r20, 0xFF	; 255
    928c:	5f 4f       	sbci	r21, 0xFF	; 255
    928e:	e1 e0       	ldi	r30, 0x01	; 1
    9290:	f0 e0       	ldi	r31, 0x00	; 0
    9292:	20 30       	cpi	r18, 0x00	; 0
    9294:	80 e0       	ldi	r24, 0x00	; 0
    9296:	38 07       	cpc	r19, r24
    9298:	80 e0       	ldi	r24, 0x00	; 0
    929a:	48 07       	cpc	r20, r24
    929c:	80 e4       	ldi	r24, 0x40	; 64
    929e:	58 07       	cpc	r21, r24
    92a0:	28 f5       	brcc	.+74     	; 0x92ec <__pack_f+0x146>
    92a2:	e0 e0       	ldi	r30, 0x00	; 0
    92a4:	f0 e0       	ldi	r31, 0x00	; 0
    92a6:	22 c0       	rjmp	.+68     	; 0x92ec <__pack_f+0x146>
    92a8:	e0 38       	cpi	r30, 0x80	; 128
    92aa:	f1 05       	cpc	r31, r1
    92ac:	6c f5       	brge	.+90     	; 0x9308 <__pack_f+0x162>
    92ae:	e1 58       	subi	r30, 0x81	; 129
    92b0:	ff 4f       	sbci	r31, 0xFF	; 255
    92b2:	da 01       	movw	r26, r20
    92b4:	c9 01       	movw	r24, r18
    92b6:	8f 77       	andi	r24, 0x7F	; 127
    92b8:	90 70       	andi	r25, 0x00	; 0
    92ba:	a0 70       	andi	r26, 0x00	; 0
    92bc:	b0 70       	andi	r27, 0x00	; 0
    92be:	80 34       	cpi	r24, 0x40	; 64
    92c0:	91 05       	cpc	r25, r1
    92c2:	a1 05       	cpc	r26, r1
    92c4:	b1 05       	cpc	r27, r1
    92c6:	39 f4       	brne	.+14     	; 0x92d6 <__pack_f+0x130>
    92c8:	27 ff       	sbrs	r18, 7
    92ca:	09 c0       	rjmp	.+18     	; 0x92de <__pack_f+0x138>
    92cc:	20 5c       	subi	r18, 0xC0	; 192
    92ce:	3f 4f       	sbci	r19, 0xFF	; 255
    92d0:	4f 4f       	sbci	r20, 0xFF	; 255
    92d2:	5f 4f       	sbci	r21, 0xFF	; 255
    92d4:	04 c0       	rjmp	.+8      	; 0x92de <__pack_f+0x138>
    92d6:	21 5c       	subi	r18, 0xC1	; 193
    92d8:	3f 4f       	sbci	r19, 0xFF	; 255
    92da:	4f 4f       	sbci	r20, 0xFF	; 255
    92dc:	5f 4f       	sbci	r21, 0xFF	; 255
    92de:	57 ff       	sbrs	r21, 7
    92e0:	05 c0       	rjmp	.+10     	; 0x92ec <__pack_f+0x146>
    92e2:	56 95       	lsr	r21
    92e4:	47 95       	ror	r20
    92e6:	37 95       	ror	r19
    92e8:	27 95       	ror	r18
    92ea:	31 96       	adiw	r30, 0x01	; 1
    92ec:	87 e0       	ldi	r24, 0x07	; 7
    92ee:	56 95       	lsr	r21
    92f0:	47 95       	ror	r20
    92f2:	37 95       	ror	r19
    92f4:	27 95       	ror	r18
    92f6:	8a 95       	dec	r24
    92f8:	d1 f7       	brne	.-12     	; 0x92ee <__pack_f+0x148>
    92fa:	0b c0       	rjmp	.+22     	; 0x9312 <__pack_f+0x16c>
    92fc:	e0 e0       	ldi	r30, 0x00	; 0
    92fe:	f0 e0       	ldi	r31, 0x00	; 0
    9300:	05 c0       	rjmp	.+10     	; 0x930c <__pack_f+0x166>
    9302:	e0 e0       	ldi	r30, 0x00	; 0
    9304:	f0 e0       	ldi	r31, 0x00	; 0
    9306:	05 c0       	rjmp	.+10     	; 0x9312 <__pack_f+0x16c>
    9308:	ef ef       	ldi	r30, 0xFF	; 255
    930a:	f0 e0       	ldi	r31, 0x00	; 0
    930c:	20 e0       	ldi	r18, 0x00	; 0
    930e:	30 e0       	ldi	r19, 0x00	; 0
    9310:	a9 01       	movw	r20, r18
    9312:	8e 2f       	mov	r24, r30
    9314:	87 95       	ror	r24
    9316:	88 27       	eor	r24, r24
    9318:	87 95       	ror	r24
    931a:	94 2f       	mov	r25, r20
    931c:	9f 77       	andi	r25, 0x7F	; 127
    931e:	67 95       	ror	r22
    9320:	66 27       	eor	r22, r22
    9322:	67 95       	ror	r22
    9324:	e6 95       	lsr	r30
    9326:	e2 2e       	mov	r14, r18
    9328:	a9 2f       	mov	r26, r25
    932a:	a8 2b       	or	r26, r24
    932c:	fe 2f       	mov	r31, r30
    932e:	f6 2b       	or	r31, r22
    9330:	62 2f       	mov	r22, r18
    9332:	73 2f       	mov	r23, r19
    9334:	8a 2f       	mov	r24, r26
    9336:	9f 2f       	mov	r25, r31
    9338:	cd b7       	in	r28, 0x3d	; 61
    933a:	de b7       	in	r29, 0x3e	; 62
    933c:	e6 e0       	ldi	r30, 0x06	; 6
    933e:	0c 94 d4 4a 	jmp	0x95a8	; 0x95a8 <__epilogue_restores__+0x18>

00009342 <__unpack_f>:
    9342:	dc 01       	movw	r26, r24
    9344:	fb 01       	movw	r30, r22
    9346:	2c 91       	ld	r18, X
    9348:	11 96       	adiw	r26, 0x01	; 1
    934a:	3c 91       	ld	r19, X
    934c:	11 97       	sbiw	r26, 0x01	; 1
    934e:	12 96       	adiw	r26, 0x02	; 2
    9350:	8c 91       	ld	r24, X
    9352:	12 97       	sbiw	r26, 0x02	; 2
    9354:	48 2f       	mov	r20, r24
    9356:	4f 77       	andi	r20, 0x7F	; 127
    9358:	50 e0       	ldi	r21, 0x00	; 0
    935a:	98 2f       	mov	r25, r24
    935c:	99 1f       	adc	r25, r25
    935e:	99 27       	eor	r25, r25
    9360:	99 1f       	adc	r25, r25
    9362:	13 96       	adiw	r26, 0x03	; 3
    9364:	6c 91       	ld	r22, X
    9366:	13 97       	sbiw	r26, 0x03	; 3
    9368:	86 2f       	mov	r24, r22
    936a:	88 0f       	add	r24, r24
    936c:	89 2b       	or	r24, r25
    936e:	90 e0       	ldi	r25, 0x00	; 0
    9370:	66 1f       	adc	r22, r22
    9372:	66 27       	eor	r22, r22
    9374:	66 1f       	adc	r22, r22
    9376:	61 83       	std	Z+1, r22	; 0x01
    9378:	00 97       	sbiw	r24, 0x00	; 0
    937a:	39 f5       	brne	.+78     	; 0x93ca <__unpack_f+0x88>
    937c:	21 15       	cp	r18, r1
    937e:	31 05       	cpc	r19, r1
    9380:	41 05       	cpc	r20, r1
    9382:	51 05       	cpc	r21, r1
    9384:	11 f4       	brne	.+4      	; 0x938a <__unpack_f+0x48>
    9386:	82 e0       	ldi	r24, 0x02	; 2
    9388:	29 c0       	rjmp	.+82     	; 0x93dc <__unpack_f+0x9a>
    938a:	82 e8       	ldi	r24, 0x82	; 130
    938c:	9f ef       	ldi	r25, 0xFF	; 255
    938e:	93 83       	std	Z+3, r25	; 0x03
    9390:	82 83       	std	Z+2, r24	; 0x02
    9392:	67 e0       	ldi	r22, 0x07	; 7
    9394:	22 0f       	add	r18, r18
    9396:	33 1f       	adc	r19, r19
    9398:	44 1f       	adc	r20, r20
    939a:	55 1f       	adc	r21, r21
    939c:	6a 95       	dec	r22
    939e:	d1 f7       	brne	.-12     	; 0x9394 <__unpack_f+0x52>
    93a0:	83 e0       	ldi	r24, 0x03	; 3
    93a2:	80 83       	st	Z, r24
    93a4:	09 c0       	rjmp	.+18     	; 0x93b8 <__unpack_f+0x76>
    93a6:	22 0f       	add	r18, r18
    93a8:	33 1f       	adc	r19, r19
    93aa:	44 1f       	adc	r20, r20
    93ac:	55 1f       	adc	r21, r21
    93ae:	82 81       	ldd	r24, Z+2	; 0x02
    93b0:	93 81       	ldd	r25, Z+3	; 0x03
    93b2:	01 97       	sbiw	r24, 0x01	; 1
    93b4:	93 83       	std	Z+3, r25	; 0x03
    93b6:	82 83       	std	Z+2, r24	; 0x02
    93b8:	20 30       	cpi	r18, 0x00	; 0
    93ba:	80 e0       	ldi	r24, 0x00	; 0
    93bc:	38 07       	cpc	r19, r24
    93be:	80 e0       	ldi	r24, 0x00	; 0
    93c0:	48 07       	cpc	r20, r24
    93c2:	80 e4       	ldi	r24, 0x40	; 64
    93c4:	58 07       	cpc	r21, r24
    93c6:	78 f3       	brcs	.-34     	; 0x93a6 <__unpack_f+0x64>
    93c8:	20 c0       	rjmp	.+64     	; 0x940a <__unpack_f+0xc8>
    93ca:	8f 3f       	cpi	r24, 0xFF	; 255
    93cc:	91 05       	cpc	r25, r1
    93ce:	79 f4       	brne	.+30     	; 0x93ee <__unpack_f+0xac>
    93d0:	21 15       	cp	r18, r1
    93d2:	31 05       	cpc	r19, r1
    93d4:	41 05       	cpc	r20, r1
    93d6:	51 05       	cpc	r21, r1
    93d8:	19 f4       	brne	.+6      	; 0x93e0 <__unpack_f+0x9e>
    93da:	84 e0       	ldi	r24, 0x04	; 4
    93dc:	80 83       	st	Z, r24
    93de:	08 95       	ret
    93e0:	44 ff       	sbrs	r20, 4
    93e2:	03 c0       	rjmp	.+6      	; 0x93ea <__unpack_f+0xa8>
    93e4:	81 e0       	ldi	r24, 0x01	; 1
    93e6:	80 83       	st	Z, r24
    93e8:	10 c0       	rjmp	.+32     	; 0x940a <__unpack_f+0xc8>
    93ea:	10 82       	st	Z, r1
    93ec:	0e c0       	rjmp	.+28     	; 0x940a <__unpack_f+0xc8>
    93ee:	8f 57       	subi	r24, 0x7F	; 127
    93f0:	90 40       	sbci	r25, 0x00	; 0
    93f2:	93 83       	std	Z+3, r25	; 0x03
    93f4:	82 83       	std	Z+2, r24	; 0x02
    93f6:	83 e0       	ldi	r24, 0x03	; 3
    93f8:	80 83       	st	Z, r24
    93fa:	87 e0       	ldi	r24, 0x07	; 7
    93fc:	22 0f       	add	r18, r18
    93fe:	33 1f       	adc	r19, r19
    9400:	44 1f       	adc	r20, r20
    9402:	55 1f       	adc	r21, r21
    9404:	8a 95       	dec	r24
    9406:	d1 f7       	brne	.-12     	; 0x93fc <__unpack_f+0xba>
    9408:	50 64       	ori	r21, 0x40	; 64
    940a:	24 83       	std	Z+4, r18	; 0x04
    940c:	35 83       	std	Z+5, r19	; 0x05
    940e:	46 83       	std	Z+6, r20	; 0x06
    9410:	57 83       	std	Z+7, r21	; 0x07
    9412:	08 95       	ret

00009414 <__fpcmp_parts_f>:
    9414:	fc 01       	movw	r30, r24
    9416:	db 01       	movw	r26, r22
    9418:	90 81       	ld	r25, Z
    941a:	92 30       	cpi	r25, 0x02	; 2
    941c:	08 f4       	brcc	.+2      	; 0x9420 <__fpcmp_parts_f+0xc>
    941e:	49 c0       	rjmp	.+146    	; 0x94b2 <__fpcmp_parts_f+0x9e>
    9420:	8c 91       	ld	r24, X
    9422:	82 30       	cpi	r24, 0x02	; 2
    9424:	08 f4       	brcc	.+2      	; 0x9428 <__fpcmp_parts_f+0x14>
    9426:	45 c0       	rjmp	.+138    	; 0x94b2 <__fpcmp_parts_f+0x9e>
    9428:	94 30       	cpi	r25, 0x04	; 4
    942a:	51 f4       	brne	.+20     	; 0x9440 <__fpcmp_parts_f+0x2c>
    942c:	61 81       	ldd	r22, Z+1	; 0x01
    942e:	84 30       	cpi	r24, 0x04	; 4
    9430:	b1 f5       	brne	.+108    	; 0x949e <__fpcmp_parts_f+0x8a>
    9432:	11 96       	adiw	r26, 0x01	; 1
    9434:	2c 91       	ld	r18, X
    9436:	11 97       	sbiw	r26, 0x01	; 1
    9438:	30 e0       	ldi	r19, 0x00	; 0
    943a:	26 1b       	sub	r18, r22
    943c:	31 09       	sbc	r19, r1
    943e:	41 c0       	rjmp	.+130    	; 0x94c2 <__fpcmp_parts_f+0xae>
    9440:	84 30       	cpi	r24, 0x04	; 4
    9442:	21 f0       	breq	.+8      	; 0x944c <__fpcmp_parts_f+0x38>
    9444:	92 30       	cpi	r25, 0x02	; 2
    9446:	41 f4       	brne	.+16     	; 0x9458 <__fpcmp_parts_f+0x44>
    9448:	82 30       	cpi	r24, 0x02	; 2
    944a:	b1 f1       	breq	.+108    	; 0x94b8 <__fpcmp_parts_f+0xa4>
    944c:	11 96       	adiw	r26, 0x01	; 1
    944e:	8c 91       	ld	r24, X
    9450:	11 97       	sbiw	r26, 0x01	; 1
    9452:	88 23       	and	r24, r24
    9454:	a1 f1       	breq	.+104    	; 0x94be <__fpcmp_parts_f+0xaa>
    9456:	2d c0       	rjmp	.+90     	; 0x94b2 <__fpcmp_parts_f+0x9e>
    9458:	61 81       	ldd	r22, Z+1	; 0x01
    945a:	82 30       	cpi	r24, 0x02	; 2
    945c:	01 f1       	breq	.+64     	; 0x949e <__fpcmp_parts_f+0x8a>
    945e:	11 96       	adiw	r26, 0x01	; 1
    9460:	8c 91       	ld	r24, X
    9462:	11 97       	sbiw	r26, 0x01	; 1
    9464:	68 17       	cp	r22, r24
    9466:	d9 f4       	brne	.+54     	; 0x949e <__fpcmp_parts_f+0x8a>
    9468:	22 81       	ldd	r18, Z+2	; 0x02
    946a:	33 81       	ldd	r19, Z+3	; 0x03
    946c:	12 96       	adiw	r26, 0x02	; 2
    946e:	8d 91       	ld	r24, X+
    9470:	9c 91       	ld	r25, X
    9472:	13 97       	sbiw	r26, 0x03	; 3
    9474:	82 17       	cp	r24, r18
    9476:	93 07       	cpc	r25, r19
    9478:	94 f0       	brlt	.+36     	; 0x949e <__fpcmp_parts_f+0x8a>
    947a:	28 17       	cp	r18, r24
    947c:	39 07       	cpc	r19, r25
    947e:	bc f0       	brlt	.+46     	; 0x94ae <__fpcmp_parts_f+0x9a>
    9480:	24 81       	ldd	r18, Z+4	; 0x04
    9482:	35 81       	ldd	r19, Z+5	; 0x05
    9484:	46 81       	ldd	r20, Z+6	; 0x06
    9486:	57 81       	ldd	r21, Z+7	; 0x07
    9488:	14 96       	adiw	r26, 0x04	; 4
    948a:	8d 91       	ld	r24, X+
    948c:	9d 91       	ld	r25, X+
    948e:	0d 90       	ld	r0, X+
    9490:	bc 91       	ld	r27, X
    9492:	a0 2d       	mov	r26, r0
    9494:	82 17       	cp	r24, r18
    9496:	93 07       	cpc	r25, r19
    9498:	a4 07       	cpc	r26, r20
    949a:	b5 07       	cpc	r27, r21
    949c:	18 f4       	brcc	.+6      	; 0x94a4 <__fpcmp_parts_f+0x90>
    949e:	66 23       	and	r22, r22
    94a0:	41 f0       	breq	.+16     	; 0x94b2 <__fpcmp_parts_f+0x9e>
    94a2:	0d c0       	rjmp	.+26     	; 0x94be <__fpcmp_parts_f+0xaa>
    94a4:	28 17       	cp	r18, r24
    94a6:	39 07       	cpc	r19, r25
    94a8:	4a 07       	cpc	r20, r26
    94aa:	5b 07       	cpc	r21, r27
    94ac:	28 f4       	brcc	.+10     	; 0x94b8 <__fpcmp_parts_f+0xa4>
    94ae:	66 23       	and	r22, r22
    94b0:	31 f0       	breq	.+12     	; 0x94be <__fpcmp_parts_f+0xaa>
    94b2:	21 e0       	ldi	r18, 0x01	; 1
    94b4:	30 e0       	ldi	r19, 0x00	; 0
    94b6:	05 c0       	rjmp	.+10     	; 0x94c2 <__fpcmp_parts_f+0xae>
    94b8:	20 e0       	ldi	r18, 0x00	; 0
    94ba:	30 e0       	ldi	r19, 0x00	; 0
    94bc:	02 c0       	rjmp	.+4      	; 0x94c2 <__fpcmp_parts_f+0xae>
    94be:	2f ef       	ldi	r18, 0xFF	; 255
    94c0:	3f ef       	ldi	r19, 0xFF	; 255
    94c2:	c9 01       	movw	r24, r18
    94c4:	08 95       	ret

000094c6 <__udivmodhi4>:
    94c6:	aa 1b       	sub	r26, r26
    94c8:	bb 1b       	sub	r27, r27
    94ca:	51 e1       	ldi	r21, 0x11	; 17
    94cc:	07 c0       	rjmp	.+14     	; 0x94dc <__udivmodhi4_ep>

000094ce <__udivmodhi4_loop>:
    94ce:	aa 1f       	adc	r26, r26
    94d0:	bb 1f       	adc	r27, r27
    94d2:	a6 17       	cp	r26, r22
    94d4:	b7 07       	cpc	r27, r23
    94d6:	10 f0       	brcs	.+4      	; 0x94dc <__udivmodhi4_ep>
    94d8:	a6 1b       	sub	r26, r22
    94da:	b7 0b       	sbc	r27, r23

000094dc <__udivmodhi4_ep>:
    94dc:	88 1f       	adc	r24, r24
    94de:	99 1f       	adc	r25, r25
    94e0:	5a 95       	dec	r21
    94e2:	a9 f7       	brne	.-22     	; 0x94ce <__udivmodhi4_loop>
    94e4:	80 95       	com	r24
    94e6:	90 95       	com	r25
    94e8:	bc 01       	movw	r22, r24
    94ea:	cd 01       	movw	r24, r26
    94ec:	08 95       	ret

000094ee <__divmodhi4>:
    94ee:	97 fb       	bst	r25, 7
    94f0:	09 2e       	mov	r0, r25
    94f2:	07 26       	eor	r0, r23
    94f4:	0a d0       	rcall	.+20     	; 0x950a <__divmodhi4_neg1>
    94f6:	77 fd       	sbrc	r23, 7
    94f8:	04 d0       	rcall	.+8      	; 0x9502 <__divmodhi4_neg2>
    94fa:	e5 df       	rcall	.-54     	; 0x94c6 <__udivmodhi4>
    94fc:	06 d0       	rcall	.+12     	; 0x950a <__divmodhi4_neg1>
    94fe:	00 20       	and	r0, r0
    9500:	1a f4       	brpl	.+6      	; 0x9508 <__divmodhi4_exit>

00009502 <__divmodhi4_neg2>:
    9502:	70 95       	com	r23
    9504:	61 95       	neg	r22
    9506:	7f 4f       	sbci	r23, 0xFF	; 255

00009508 <__divmodhi4_exit>:
    9508:	08 95       	ret

0000950a <__divmodhi4_neg1>:
    950a:	f6 f7       	brtc	.-4      	; 0x9508 <__divmodhi4_exit>
    950c:	90 95       	com	r25
    950e:	81 95       	neg	r24
    9510:	9f 4f       	sbci	r25, 0xFF	; 255
    9512:	08 95       	ret

00009514 <__udivmodsi4>:
    9514:	a1 e2       	ldi	r26, 0x21	; 33
    9516:	1a 2e       	mov	r1, r26
    9518:	aa 1b       	sub	r26, r26
    951a:	bb 1b       	sub	r27, r27
    951c:	fd 01       	movw	r30, r26
    951e:	0d c0       	rjmp	.+26     	; 0x953a <__udivmodsi4_ep>

00009520 <__udivmodsi4_loop>:
    9520:	aa 1f       	adc	r26, r26
    9522:	bb 1f       	adc	r27, r27
    9524:	ee 1f       	adc	r30, r30
    9526:	ff 1f       	adc	r31, r31
    9528:	a2 17       	cp	r26, r18
    952a:	b3 07       	cpc	r27, r19
    952c:	e4 07       	cpc	r30, r20
    952e:	f5 07       	cpc	r31, r21
    9530:	20 f0       	brcs	.+8      	; 0x953a <__udivmodsi4_ep>
    9532:	a2 1b       	sub	r26, r18
    9534:	b3 0b       	sbc	r27, r19
    9536:	e4 0b       	sbc	r30, r20
    9538:	f5 0b       	sbc	r31, r21

0000953a <__udivmodsi4_ep>:
    953a:	66 1f       	adc	r22, r22
    953c:	77 1f       	adc	r23, r23
    953e:	88 1f       	adc	r24, r24
    9540:	99 1f       	adc	r25, r25
    9542:	1a 94       	dec	r1
    9544:	69 f7       	brne	.-38     	; 0x9520 <__udivmodsi4_loop>
    9546:	60 95       	com	r22
    9548:	70 95       	com	r23
    954a:	80 95       	com	r24
    954c:	90 95       	com	r25
    954e:	9b 01       	movw	r18, r22
    9550:	ac 01       	movw	r20, r24
    9552:	bd 01       	movw	r22, r26
    9554:	cf 01       	movw	r24, r30
    9556:	08 95       	ret

00009558 <__prologue_saves__>:
    9558:	2f 92       	push	r2
    955a:	3f 92       	push	r3
    955c:	4f 92       	push	r4
    955e:	5f 92       	push	r5
    9560:	6f 92       	push	r6
    9562:	7f 92       	push	r7
    9564:	8f 92       	push	r8
    9566:	9f 92       	push	r9
    9568:	af 92       	push	r10
    956a:	bf 92       	push	r11
    956c:	cf 92       	push	r12
    956e:	df 92       	push	r13
    9570:	ef 92       	push	r14
    9572:	ff 92       	push	r15
    9574:	0f 93       	push	r16
    9576:	1f 93       	push	r17
    9578:	cf 93       	push	r28
    957a:	df 93       	push	r29
    957c:	cd b7       	in	r28, 0x3d	; 61
    957e:	de b7       	in	r29, 0x3e	; 62
    9580:	ca 1b       	sub	r28, r26
    9582:	db 0b       	sbc	r29, r27
    9584:	0f b6       	in	r0, 0x3f	; 63
    9586:	f8 94       	cli
    9588:	de bf       	out	0x3e, r29	; 62
    958a:	0f be       	out	0x3f, r0	; 63
    958c:	cd bf       	out	0x3d, r28	; 61
    958e:	09 94       	ijmp

00009590 <__epilogue_restores__>:
    9590:	2a 88       	ldd	r2, Y+18	; 0x12
    9592:	39 88       	ldd	r3, Y+17	; 0x11
    9594:	48 88       	ldd	r4, Y+16	; 0x10
    9596:	5f 84       	ldd	r5, Y+15	; 0x0f
    9598:	6e 84       	ldd	r6, Y+14	; 0x0e
    959a:	7d 84       	ldd	r7, Y+13	; 0x0d
    959c:	8c 84       	ldd	r8, Y+12	; 0x0c
    959e:	9b 84       	ldd	r9, Y+11	; 0x0b
    95a0:	aa 84       	ldd	r10, Y+10	; 0x0a
    95a2:	b9 84       	ldd	r11, Y+9	; 0x09
    95a4:	c8 84       	ldd	r12, Y+8	; 0x08
    95a6:	df 80       	ldd	r13, Y+7	; 0x07
    95a8:	ee 80       	ldd	r14, Y+6	; 0x06
    95aa:	fd 80       	ldd	r15, Y+5	; 0x05
    95ac:	0c 81       	ldd	r16, Y+4	; 0x04
    95ae:	1b 81       	ldd	r17, Y+3	; 0x03
    95b0:	aa 81       	ldd	r26, Y+2	; 0x02
    95b2:	b9 81       	ldd	r27, Y+1	; 0x01
    95b4:	ce 0f       	add	r28, r30
    95b6:	d1 1d       	adc	r29, r1
    95b8:	0f b6       	in	r0, 0x3f	; 63
    95ba:	f8 94       	cli
    95bc:	de bf       	out	0x3e, r29	; 62
    95be:	0f be       	out	0x3f, r0	; 63
    95c0:	cd bf       	out	0x3d, r28	; 61
    95c2:	ed 01       	movw	r28, r26
    95c4:	08 95       	ret

000095c6 <do_rand>:
    95c6:	af 92       	push	r10
    95c8:	bf 92       	push	r11
    95ca:	cf 92       	push	r12
    95cc:	df 92       	push	r13
    95ce:	ef 92       	push	r14
    95d0:	ff 92       	push	r15
    95d2:	0f 93       	push	r16
    95d4:	1f 93       	push	r17
    95d6:	cf 93       	push	r28
    95d8:	df 93       	push	r29
    95da:	ec 01       	movw	r28, r24
    95dc:	68 81       	ld	r22, Y
    95de:	79 81       	ldd	r23, Y+1	; 0x01
    95e0:	8a 81       	ldd	r24, Y+2	; 0x02
    95e2:	9b 81       	ldd	r25, Y+3	; 0x03
    95e4:	61 15       	cp	r22, r1
    95e6:	71 05       	cpc	r23, r1
    95e8:	81 05       	cpc	r24, r1
    95ea:	91 05       	cpc	r25, r1
    95ec:	21 f4       	brne	.+8      	; 0x95f6 <do_rand+0x30>
    95ee:	64 e2       	ldi	r22, 0x24	; 36
    95f0:	79 ed       	ldi	r23, 0xD9	; 217
    95f2:	8b e5       	ldi	r24, 0x5B	; 91
    95f4:	97 e0       	ldi	r25, 0x07	; 7
    95f6:	2d e1       	ldi	r18, 0x1D	; 29
    95f8:	33 ef       	ldi	r19, 0xF3	; 243
    95fa:	41 e0       	ldi	r20, 0x01	; 1
    95fc:	50 e0       	ldi	r21, 0x00	; 0
    95fe:	0e 94 96 4f 	call	0x9f2c	; 0x9f2c <__divmodsi4>
    9602:	79 01       	movw	r14, r18
    9604:	8a 01       	movw	r16, r20
    9606:	27 ea       	ldi	r18, 0xA7	; 167
    9608:	31 e4       	ldi	r19, 0x41	; 65
    960a:	40 e0       	ldi	r20, 0x00	; 0
    960c:	50 e0       	ldi	r21, 0x00	; 0
    960e:	0e 94 77 4f 	call	0x9eee	; 0x9eee <__mulsi3>
    9612:	5b 01       	movw	r10, r22
    9614:	6c 01       	movw	r12, r24
    9616:	c8 01       	movw	r24, r16
    9618:	b7 01       	movw	r22, r14
    961a:	2c ee       	ldi	r18, 0xEC	; 236
    961c:	34 ef       	ldi	r19, 0xF4	; 244
    961e:	4f ef       	ldi	r20, 0xFF	; 255
    9620:	5f ef       	ldi	r21, 0xFF	; 255
    9622:	0e 94 77 4f 	call	0x9eee	; 0x9eee <__mulsi3>
    9626:	6a 0d       	add	r22, r10
    9628:	7b 1d       	adc	r23, r11
    962a:	8c 1d       	adc	r24, r12
    962c:	9d 1d       	adc	r25, r13
    962e:	97 ff       	sbrs	r25, 7
    9630:	04 c0       	rjmp	.+8      	; 0x963a <do_rand+0x74>
    9632:	61 50       	subi	r22, 0x01	; 1
    9634:	70 40       	sbci	r23, 0x00	; 0
    9636:	80 40       	sbci	r24, 0x00	; 0
    9638:	90 48       	sbci	r25, 0x80	; 128
    963a:	68 83       	st	Y, r22
    963c:	79 83       	std	Y+1, r23	; 0x01
    963e:	8a 83       	std	Y+2, r24	; 0x02
    9640:	9b 83       	std	Y+3, r25	; 0x03
    9642:	7f 77       	andi	r23, 0x7F	; 127
    9644:	cb 01       	movw	r24, r22
    9646:	df 91       	pop	r29
    9648:	cf 91       	pop	r28
    964a:	1f 91       	pop	r17
    964c:	0f 91       	pop	r16
    964e:	ff 90       	pop	r15
    9650:	ef 90       	pop	r14
    9652:	df 90       	pop	r13
    9654:	cf 90       	pop	r12
    9656:	bf 90       	pop	r11
    9658:	af 90       	pop	r10
    965a:	08 95       	ret

0000965c <rand_r>:
    965c:	0e 94 e3 4a 	call	0x95c6	; 0x95c6 <do_rand>
    9660:	08 95       	ret

00009662 <rand>:
    9662:	82 e8       	ldi	r24, 0x82	; 130
    9664:	9f e0       	ldi	r25, 0x0F	; 15
    9666:	0e 94 e3 4a 	call	0x95c6	; 0x95c6 <do_rand>
    966a:	08 95       	ret

0000966c <srand>:
    966c:	a0 e0       	ldi	r26, 0x00	; 0
    966e:	b0 e0       	ldi	r27, 0x00	; 0
    9670:	80 93 82 0f 	sts	0x0F82, r24
    9674:	90 93 83 0f 	sts	0x0F83, r25
    9678:	a0 93 84 0f 	sts	0x0F84, r26
    967c:	b0 93 85 0f 	sts	0x0F85, r27
    9680:	08 95       	ret

00009682 <memcmp>:
    9682:	fb 01       	movw	r30, r22
    9684:	dc 01       	movw	r26, r24
    9686:	04 c0       	rjmp	.+8      	; 0x9690 <memcmp+0xe>
    9688:	8d 91       	ld	r24, X+
    968a:	01 90       	ld	r0, Z+
    968c:	80 19       	sub	r24, r0
    968e:	21 f4       	brne	.+8      	; 0x9698 <memcmp+0x16>
    9690:	41 50       	subi	r20, 0x01	; 1
    9692:	50 40       	sbci	r21, 0x00	; 0
    9694:	c8 f7       	brcc	.-14     	; 0x9688 <memcmp+0x6>
    9696:	88 1b       	sub	r24, r24
    9698:	99 0b       	sbc	r25, r25
    969a:	08 95       	ret

0000969c <memcpy>:
    969c:	fb 01       	movw	r30, r22
    969e:	dc 01       	movw	r26, r24
    96a0:	02 c0       	rjmp	.+4      	; 0x96a6 <memcpy+0xa>
    96a2:	01 90       	ld	r0, Z+
    96a4:	0d 92       	st	X+, r0
    96a6:	41 50       	subi	r20, 0x01	; 1
    96a8:	50 40       	sbci	r21, 0x00	; 0
    96aa:	d8 f7       	brcc	.-10     	; 0x96a2 <memcpy+0x6>
    96ac:	08 95       	ret

000096ae <memset>:
    96ae:	dc 01       	movw	r26, r24
    96b0:	01 c0       	rjmp	.+2      	; 0x96b4 <memset+0x6>
    96b2:	6d 93       	st	X+, r22
    96b4:	41 50       	subi	r20, 0x01	; 1
    96b6:	50 40       	sbci	r21, 0x00	; 0
    96b8:	e0 f7       	brcc	.-8      	; 0x96b2 <memset+0x4>
    96ba:	08 95       	ret

000096bc <strncmp>:
    96bc:	fb 01       	movw	r30, r22
    96be:	dc 01       	movw	r26, r24
    96c0:	41 50       	subi	r20, 0x01	; 1
    96c2:	50 40       	sbci	r21, 0x00	; 0
    96c4:	30 f0       	brcs	.+12     	; 0x96d2 <strncmp+0x16>
    96c6:	8d 91       	ld	r24, X+
    96c8:	01 90       	ld	r0, Z+
    96ca:	80 19       	sub	r24, r0
    96cc:	19 f4       	brne	.+6      	; 0x96d4 <strncmp+0x18>
    96ce:	00 20       	and	r0, r0
    96d0:	b9 f7       	brne	.-18     	; 0x96c0 <strncmp+0x4>
    96d2:	88 1b       	sub	r24, r24
    96d4:	99 0b       	sbc	r25, r25
    96d6:	08 95       	ret

000096d8 <strnlen>:
    96d8:	fc 01       	movw	r30, r24
    96da:	61 50       	subi	r22, 0x01	; 1
    96dc:	70 40       	sbci	r23, 0x00	; 0
    96de:	01 90       	ld	r0, Z+
    96e0:	01 10       	cpse	r0, r1
    96e2:	d8 f7       	brcc	.-10     	; 0x96da <strnlen+0x2>
    96e4:	80 95       	com	r24
    96e6:	90 95       	com	r25
    96e8:	8e 0f       	add	r24, r30
    96ea:	9f 1f       	adc	r25, r31
    96ec:	08 95       	ret

000096ee <fputc>:
    96ee:	0f 93       	push	r16
    96f0:	1f 93       	push	r17
    96f2:	cf 93       	push	r28
    96f4:	df 93       	push	r29
    96f6:	8c 01       	movw	r16, r24
    96f8:	eb 01       	movw	r28, r22
    96fa:	8b 81       	ldd	r24, Y+3	; 0x03
    96fc:	81 ff       	sbrs	r24, 1
    96fe:	1b c0       	rjmp	.+54     	; 0x9736 <fputc+0x48>
    9700:	82 ff       	sbrs	r24, 2
    9702:	0d c0       	rjmp	.+26     	; 0x971e <fputc+0x30>
    9704:	2e 81       	ldd	r18, Y+6	; 0x06
    9706:	3f 81       	ldd	r19, Y+7	; 0x07
    9708:	8c 81       	ldd	r24, Y+4	; 0x04
    970a:	9d 81       	ldd	r25, Y+5	; 0x05
    970c:	28 17       	cp	r18, r24
    970e:	39 07       	cpc	r19, r25
    9710:	64 f4       	brge	.+24     	; 0x972a <fputc+0x3c>
    9712:	e8 81       	ld	r30, Y
    9714:	f9 81       	ldd	r31, Y+1	; 0x01
    9716:	01 93       	st	Z+, r16
    9718:	f9 83       	std	Y+1, r31	; 0x01
    971a:	e8 83       	st	Y, r30
    971c:	06 c0       	rjmp	.+12     	; 0x972a <fputc+0x3c>
    971e:	e8 85       	ldd	r30, Y+8	; 0x08
    9720:	f9 85       	ldd	r31, Y+9	; 0x09
    9722:	80 2f       	mov	r24, r16
    9724:	09 95       	icall
    9726:	00 97       	sbiw	r24, 0x00	; 0
    9728:	31 f4       	brne	.+12     	; 0x9736 <fputc+0x48>
    972a:	8e 81       	ldd	r24, Y+6	; 0x06
    972c:	9f 81       	ldd	r25, Y+7	; 0x07
    972e:	01 96       	adiw	r24, 0x01	; 1
    9730:	9f 83       	std	Y+7, r25	; 0x07
    9732:	8e 83       	std	Y+6, r24	; 0x06
    9734:	02 c0       	rjmp	.+4      	; 0x973a <fputc+0x4c>
    9736:	0f ef       	ldi	r16, 0xFF	; 255
    9738:	1f ef       	ldi	r17, 0xFF	; 255
    973a:	c8 01       	movw	r24, r16
    973c:	df 91       	pop	r29
    973e:	cf 91       	pop	r28
    9740:	1f 91       	pop	r17
    9742:	0f 91       	pop	r16
    9744:	08 95       	ret

00009746 <fread>:
    9746:	8f 92       	push	r8
    9748:	9f 92       	push	r9
    974a:	af 92       	push	r10
    974c:	bf 92       	push	r11
    974e:	cf 92       	push	r12
    9750:	df 92       	push	r13
    9752:	ef 92       	push	r14
    9754:	ff 92       	push	r15
    9756:	0f 93       	push	r16
    9758:	1f 93       	push	r17
    975a:	cf 93       	push	r28
    975c:	df 93       	push	r29
    975e:	4b 01       	movw	r8, r22
    9760:	5a 01       	movw	r10, r20
    9762:	79 01       	movw	r14, r18
    9764:	f9 01       	movw	r30, r18
    9766:	23 81       	ldd	r18, Z+3	; 0x03
    9768:	20 ff       	sbrs	r18, 0
    976a:	1b c0       	rjmp	.+54     	; 0x97a2 <fread+0x5c>
    976c:	c8 2e       	mov	r12, r24
    976e:	d9 2e       	mov	r13, r25
    9770:	c0 e0       	ldi	r28, 0x00	; 0
    9772:	d0 e0       	ldi	r29, 0x00	; 0
    9774:	10 c0       	rjmp	.+32     	; 0x9796 <fread+0x50>
    9776:	c7 01       	movw	r24, r14
    9778:	0e 94 d7 4e 	call	0x9dae	; 0x9dae <fgetc>
    977c:	ff ef       	ldi	r31, 0xFF	; 255
    977e:	8f 3f       	cpi	r24, 0xFF	; 255
    9780:	9f 07       	cpc	r25, r31
    9782:	89 f0       	breq	.+34     	; 0x97a6 <fread+0x60>
    9784:	f6 01       	movw	r30, r12
    9786:	81 93       	st	Z+, r24
    9788:	6f 01       	movw	r12, r30
    978a:	0f 5f       	subi	r16, 0xFF	; 255
    978c:	1f 4f       	sbci	r17, 0xFF	; 255
    978e:	08 15       	cp	r16, r8
    9790:	19 05       	cpc	r17, r9
    9792:	88 f3       	brcs	.-30     	; 0x9776 <fread+0x30>
    9794:	21 96       	adiw	r28, 0x01	; 1
    9796:	ca 15       	cp	r28, r10
    9798:	db 05       	cpc	r29, r11
    979a:	28 f4       	brcc	.+10     	; 0x97a6 <fread+0x60>
    979c:	00 e0       	ldi	r16, 0x00	; 0
    979e:	10 e0       	ldi	r17, 0x00	; 0
    97a0:	f6 cf       	rjmp	.-20     	; 0x978e <fread+0x48>
    97a2:	c0 e0       	ldi	r28, 0x00	; 0
    97a4:	d0 e0       	ldi	r29, 0x00	; 0
    97a6:	ce 01       	movw	r24, r28
    97a8:	df 91       	pop	r29
    97aa:	cf 91       	pop	r28
    97ac:	1f 91       	pop	r17
    97ae:	0f 91       	pop	r16
    97b0:	ff 90       	pop	r15
    97b2:	ef 90       	pop	r14
    97b4:	df 90       	pop	r13
    97b6:	cf 90       	pop	r12
    97b8:	bf 90       	pop	r11
    97ba:	af 90       	pop	r10
    97bc:	9f 90       	pop	r9
    97be:	8f 90       	pop	r8
    97c0:	08 95       	ret

000097c2 <printf>:
    97c2:	df 93       	push	r29
    97c4:	cf 93       	push	r28
    97c6:	cd b7       	in	r28, 0x3d	; 61
    97c8:	de b7       	in	r29, 0x3e	; 62
    97ca:	fe 01       	movw	r30, r28
    97cc:	35 96       	adiw	r30, 0x05	; 5
    97ce:	61 91       	ld	r22, Z+
    97d0:	71 91       	ld	r23, Z+
    97d2:	80 91 c6 36 	lds	r24, 0x36C6
    97d6:	90 91 c7 36 	lds	r25, 0x36C7
    97da:	af 01       	movw	r20, r30
    97dc:	0e 94 81 4c 	call	0x9902	; 0x9902 <vfprintf>
    97e0:	cf 91       	pop	r28
    97e2:	df 91       	pop	r29
    97e4:	08 95       	ret

000097e6 <printf_P>:
    97e6:	df 93       	push	r29
    97e8:	cf 93       	push	r28
    97ea:	cd b7       	in	r28, 0x3d	; 61
    97ec:	de b7       	in	r29, 0x3e	; 62
    97ee:	fe 01       	movw	r30, r28
    97f0:	35 96       	adiw	r30, 0x05	; 5
    97f2:	61 91       	ld	r22, Z+
    97f4:	71 91       	ld	r23, Z+
    97f6:	80 91 c6 36 	lds	r24, 0x36C6
    97fa:	90 91 c7 36 	lds	r25, 0x36C7
    97fe:	dc 01       	movw	r26, r24
    9800:	13 96       	adiw	r26, 0x03	; 3
    9802:	2c 91       	ld	r18, X
    9804:	13 97       	sbiw	r26, 0x03	; 3
    9806:	28 60       	ori	r18, 0x08	; 8
    9808:	13 96       	adiw	r26, 0x03	; 3
    980a:	2c 93       	st	X, r18
    980c:	af 01       	movw	r20, r30
    980e:	0e 94 81 4c 	call	0x9902	; 0x9902 <vfprintf>
    9812:	e0 91 c6 36 	lds	r30, 0x36C6
    9816:	f0 91 c7 36 	lds	r31, 0x36C7
    981a:	23 81       	ldd	r18, Z+3	; 0x03
    981c:	27 7f       	andi	r18, 0xF7	; 247
    981e:	23 83       	std	Z+3, r18	; 0x03
    9820:	cf 91       	pop	r28
    9822:	df 91       	pop	r29
    9824:	08 95       	ret

00009826 <putchar>:
    9826:	60 91 c6 36 	lds	r22, 0x36C6
    982a:	70 91 c7 36 	lds	r23, 0x36C7
    982e:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9832:	08 95       	ret

00009834 <puts>:
    9834:	ef 92       	push	r14
    9836:	ff 92       	push	r15
    9838:	0f 93       	push	r16
    983a:	1f 93       	push	r17
    983c:	cf 93       	push	r28
    983e:	df 93       	push	r29
    9840:	8c 01       	movw	r16, r24
    9842:	e0 91 c6 36 	lds	r30, 0x36C6
    9846:	f0 91 c7 36 	lds	r31, 0x36C7
    984a:	83 81       	ldd	r24, Z+3	; 0x03
    984c:	81 ff       	sbrs	r24, 1
    984e:	1f c0       	rjmp	.+62     	; 0x988e <puts+0x5a>
    9850:	c0 e0       	ldi	r28, 0x00	; 0
    9852:	d0 e0       	ldi	r29, 0x00	; 0
    9854:	0a c0       	rjmp	.+20     	; 0x986a <puts+0x36>
    9856:	db 01       	movw	r26, r22
    9858:	18 96       	adiw	r26, 0x08	; 8
    985a:	ed 91       	ld	r30, X+
    985c:	fc 91       	ld	r31, X
    985e:	19 97       	sbiw	r26, 0x09	; 9
    9860:	09 95       	icall
    9862:	00 97       	sbiw	r24, 0x00	; 0
    9864:	11 f0       	breq	.+4      	; 0x986a <puts+0x36>
    9866:	cf ef       	ldi	r28, 0xFF	; 255
    9868:	df ef       	ldi	r29, 0xFF	; 255
    986a:	f8 01       	movw	r30, r16
    986c:	81 91       	ld	r24, Z+
    986e:	8f 01       	movw	r16, r30
    9870:	60 91 c6 36 	lds	r22, 0x36C6
    9874:	70 91 c7 36 	lds	r23, 0x36C7
    9878:	88 23       	and	r24, r24
    987a:	69 f7       	brne	.-38     	; 0x9856 <puts+0x22>
    987c:	db 01       	movw	r26, r22
    987e:	18 96       	adiw	r26, 0x08	; 8
    9880:	ed 91       	ld	r30, X+
    9882:	fc 91       	ld	r31, X
    9884:	19 97       	sbiw	r26, 0x09	; 9
    9886:	8a e0       	ldi	r24, 0x0A	; 10
    9888:	09 95       	icall
    988a:	00 97       	sbiw	r24, 0x00	; 0
    988c:	11 f0       	breq	.+4      	; 0x9892 <puts+0x5e>
    988e:	cf ef       	ldi	r28, 0xFF	; 255
    9890:	df ef       	ldi	r29, 0xFF	; 255
    9892:	ce 01       	movw	r24, r28
    9894:	df 91       	pop	r29
    9896:	cf 91       	pop	r28
    9898:	1f 91       	pop	r17
    989a:	0f 91       	pop	r16
    989c:	ff 90       	pop	r15
    989e:	ef 90       	pop	r14
    98a0:	08 95       	ret

000098a2 <sprintf>:
    98a2:	0f 93       	push	r16
    98a4:	1f 93       	push	r17
    98a6:	df 93       	push	r29
    98a8:	cf 93       	push	r28
    98aa:	cd b7       	in	r28, 0x3d	; 61
    98ac:	de b7       	in	r29, 0x3e	; 62
    98ae:	2e 97       	sbiw	r28, 0x0e	; 14
    98b0:	0f b6       	in	r0, 0x3f	; 63
    98b2:	f8 94       	cli
    98b4:	de bf       	out	0x3e, r29	; 62
    98b6:	0f be       	out	0x3f, r0	; 63
    98b8:	cd bf       	out	0x3d, r28	; 61
    98ba:	0d 89       	ldd	r16, Y+21	; 0x15
    98bc:	1e 89       	ldd	r17, Y+22	; 0x16
    98be:	86 e0       	ldi	r24, 0x06	; 6
    98c0:	8c 83       	std	Y+4, r24	; 0x04
    98c2:	1a 83       	std	Y+2, r17	; 0x02
    98c4:	09 83       	std	Y+1, r16	; 0x01
    98c6:	8f ef       	ldi	r24, 0xFF	; 255
    98c8:	9f e7       	ldi	r25, 0x7F	; 127
    98ca:	9e 83       	std	Y+6, r25	; 0x06
    98cc:	8d 83       	std	Y+5, r24	; 0x05
    98ce:	9e 01       	movw	r18, r28
    98d0:	27 5e       	subi	r18, 0xE7	; 231
    98d2:	3f 4f       	sbci	r19, 0xFF	; 255
    98d4:	ce 01       	movw	r24, r28
    98d6:	01 96       	adiw	r24, 0x01	; 1
    98d8:	6f 89       	ldd	r22, Y+23	; 0x17
    98da:	78 8d       	ldd	r23, Y+24	; 0x18
    98dc:	a9 01       	movw	r20, r18
    98de:	0e 94 81 4c 	call	0x9902	; 0x9902 <vfprintf>
    98e2:	ef 81       	ldd	r30, Y+7	; 0x07
    98e4:	f8 85       	ldd	r31, Y+8	; 0x08
    98e6:	e0 0f       	add	r30, r16
    98e8:	f1 1f       	adc	r31, r17
    98ea:	10 82       	st	Z, r1
    98ec:	2e 96       	adiw	r28, 0x0e	; 14
    98ee:	0f b6       	in	r0, 0x3f	; 63
    98f0:	f8 94       	cli
    98f2:	de bf       	out	0x3e, r29	; 62
    98f4:	0f be       	out	0x3f, r0	; 63
    98f6:	cd bf       	out	0x3d, r28	; 61
    98f8:	cf 91       	pop	r28
    98fa:	df 91       	pop	r29
    98fc:	1f 91       	pop	r17
    98fe:	0f 91       	pop	r16
    9900:	08 95       	ret

00009902 <vfprintf>:
    9902:	2f 92       	push	r2
    9904:	3f 92       	push	r3
    9906:	4f 92       	push	r4
    9908:	5f 92       	push	r5
    990a:	6f 92       	push	r6
    990c:	7f 92       	push	r7
    990e:	8f 92       	push	r8
    9910:	9f 92       	push	r9
    9912:	af 92       	push	r10
    9914:	bf 92       	push	r11
    9916:	cf 92       	push	r12
    9918:	df 92       	push	r13
    991a:	ef 92       	push	r14
    991c:	ff 92       	push	r15
    991e:	0f 93       	push	r16
    9920:	1f 93       	push	r17
    9922:	df 93       	push	r29
    9924:	cf 93       	push	r28
    9926:	cd b7       	in	r28, 0x3d	; 61
    9928:	de b7       	in	r29, 0x3e	; 62
    992a:	2c 97       	sbiw	r28, 0x0c	; 12
    992c:	0f b6       	in	r0, 0x3f	; 63
    992e:	f8 94       	cli
    9930:	de bf       	out	0x3e, r29	; 62
    9932:	0f be       	out	0x3f, r0	; 63
    9934:	cd bf       	out	0x3d, r28	; 61
    9936:	6c 01       	movw	r12, r24
    9938:	1b 01       	movw	r2, r22
    993a:	8a 01       	movw	r16, r20
    993c:	fc 01       	movw	r30, r24
    993e:	17 82       	std	Z+7, r1	; 0x07
    9940:	16 82       	std	Z+6, r1	; 0x06
    9942:	83 81       	ldd	r24, Z+3	; 0x03
    9944:	81 ff       	sbrs	r24, 1
    9946:	d1 c1       	rjmp	.+930    	; 0x9cea <vfprintf+0x3e8>
    9948:	2e 01       	movw	r4, r28
    994a:	08 94       	sec
    994c:	41 1c       	adc	r4, r1
    994e:	51 1c       	adc	r5, r1
    9950:	f6 01       	movw	r30, r12
    9952:	93 81       	ldd	r25, Z+3	; 0x03
    9954:	f1 01       	movw	r30, r2
    9956:	93 fd       	sbrc	r25, 3
    9958:	85 91       	lpm	r24, Z+
    995a:	93 ff       	sbrs	r25, 3
    995c:	81 91       	ld	r24, Z+
    995e:	1f 01       	movw	r2, r30
    9960:	88 23       	and	r24, r24
    9962:	09 f4       	brne	.+2      	; 0x9966 <vfprintf+0x64>
    9964:	be c1       	rjmp	.+892    	; 0x9ce2 <vfprintf+0x3e0>
    9966:	85 32       	cpi	r24, 0x25	; 37
    9968:	39 f4       	brne	.+14     	; 0x9978 <vfprintf+0x76>
    996a:	93 fd       	sbrc	r25, 3
    996c:	85 91       	lpm	r24, Z+
    996e:	93 ff       	sbrs	r25, 3
    9970:	81 91       	ld	r24, Z+
    9972:	1f 01       	movw	r2, r30
    9974:	85 32       	cpi	r24, 0x25	; 37
    9976:	29 f4       	brne	.+10     	; 0x9982 <vfprintf+0x80>
    9978:	90 e0       	ldi	r25, 0x00	; 0
    997a:	b6 01       	movw	r22, r12
    997c:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9980:	e7 cf       	rjmp	.-50     	; 0x9950 <vfprintf+0x4e>
    9982:	ee 24       	eor	r14, r14
    9984:	ff 24       	eor	r15, r15
    9986:	20 e0       	ldi	r18, 0x00	; 0
    9988:	20 32       	cpi	r18, 0x20	; 32
    998a:	b0 f4       	brcc	.+44     	; 0x99b8 <vfprintf+0xb6>
    998c:	8b 32       	cpi	r24, 0x2B	; 43
    998e:	69 f0       	breq	.+26     	; 0x99aa <vfprintf+0xa8>
    9990:	8c 32       	cpi	r24, 0x2C	; 44
    9992:	28 f4       	brcc	.+10     	; 0x999e <vfprintf+0x9c>
    9994:	80 32       	cpi	r24, 0x20	; 32
    9996:	51 f0       	breq	.+20     	; 0x99ac <vfprintf+0xaa>
    9998:	83 32       	cpi	r24, 0x23	; 35
    999a:	71 f4       	brne	.+28     	; 0x99b8 <vfprintf+0xb6>
    999c:	0b c0       	rjmp	.+22     	; 0x99b4 <vfprintf+0xb2>
    999e:	8d 32       	cpi	r24, 0x2D	; 45
    99a0:	39 f0       	breq	.+14     	; 0x99b0 <vfprintf+0xae>
    99a2:	80 33       	cpi	r24, 0x30	; 48
    99a4:	49 f4       	brne	.+18     	; 0x99b8 <vfprintf+0xb6>
    99a6:	21 60       	ori	r18, 0x01	; 1
    99a8:	2c c0       	rjmp	.+88     	; 0x9a02 <vfprintf+0x100>
    99aa:	22 60       	ori	r18, 0x02	; 2
    99ac:	24 60       	ori	r18, 0x04	; 4
    99ae:	29 c0       	rjmp	.+82     	; 0x9a02 <vfprintf+0x100>
    99b0:	28 60       	ori	r18, 0x08	; 8
    99b2:	27 c0       	rjmp	.+78     	; 0x9a02 <vfprintf+0x100>
    99b4:	20 61       	ori	r18, 0x10	; 16
    99b6:	25 c0       	rjmp	.+74     	; 0x9a02 <vfprintf+0x100>
    99b8:	27 fd       	sbrc	r18, 7
    99ba:	2c c0       	rjmp	.+88     	; 0x9a14 <vfprintf+0x112>
    99bc:	38 2f       	mov	r19, r24
    99be:	30 53       	subi	r19, 0x30	; 48
    99c0:	3a 30       	cpi	r19, 0x0A	; 10
    99c2:	98 f4       	brcc	.+38     	; 0x99ea <vfprintf+0xe8>
    99c4:	26 ff       	sbrs	r18, 6
    99c6:	08 c0       	rjmp	.+16     	; 0x99d8 <vfprintf+0xd6>
    99c8:	8e 2d       	mov	r24, r14
    99ca:	88 0f       	add	r24, r24
    99cc:	e8 2e       	mov	r14, r24
    99ce:	ee 0c       	add	r14, r14
    99d0:	ee 0c       	add	r14, r14
    99d2:	e8 0e       	add	r14, r24
    99d4:	e3 0e       	add	r14, r19
    99d6:	15 c0       	rjmp	.+42     	; 0x9a02 <vfprintf+0x100>
    99d8:	8f 2d       	mov	r24, r15
    99da:	88 0f       	add	r24, r24
    99dc:	f8 2e       	mov	r15, r24
    99de:	ff 0c       	add	r15, r15
    99e0:	ff 0c       	add	r15, r15
    99e2:	f8 0e       	add	r15, r24
    99e4:	f3 0e       	add	r15, r19
    99e6:	20 62       	ori	r18, 0x20	; 32
    99e8:	0c c0       	rjmp	.+24     	; 0x9a02 <vfprintf+0x100>
    99ea:	8e 32       	cpi	r24, 0x2E	; 46
    99ec:	21 f4       	brne	.+8      	; 0x99f6 <vfprintf+0xf4>
    99ee:	26 fd       	sbrc	r18, 6
    99f0:	78 c1       	rjmp	.+752    	; 0x9ce2 <vfprintf+0x3e0>
    99f2:	20 64       	ori	r18, 0x40	; 64
    99f4:	06 c0       	rjmp	.+12     	; 0x9a02 <vfprintf+0x100>
    99f6:	8c 36       	cpi	r24, 0x6C	; 108
    99f8:	11 f4       	brne	.+4      	; 0x99fe <vfprintf+0xfc>
    99fa:	20 68       	ori	r18, 0x80	; 128
    99fc:	02 c0       	rjmp	.+4      	; 0x9a02 <vfprintf+0x100>
    99fe:	88 36       	cpi	r24, 0x68	; 104
    9a00:	49 f4       	brne	.+18     	; 0x9a14 <vfprintf+0x112>
    9a02:	f1 01       	movw	r30, r2
    9a04:	93 fd       	sbrc	r25, 3
    9a06:	85 91       	lpm	r24, Z+
    9a08:	93 ff       	sbrs	r25, 3
    9a0a:	81 91       	ld	r24, Z+
    9a0c:	1f 01       	movw	r2, r30
    9a0e:	88 23       	and	r24, r24
    9a10:	09 f0       	breq	.+2      	; 0x9a14 <vfprintf+0x112>
    9a12:	ba cf       	rjmp	.-140    	; 0x9988 <vfprintf+0x86>
    9a14:	98 2f       	mov	r25, r24
    9a16:	95 54       	subi	r25, 0x45	; 69
    9a18:	93 30       	cpi	r25, 0x03	; 3
    9a1a:	18 f0       	brcs	.+6      	; 0x9a22 <vfprintf+0x120>
    9a1c:	90 52       	subi	r25, 0x20	; 32
    9a1e:	93 30       	cpi	r25, 0x03	; 3
    9a20:	28 f4       	brcc	.+10     	; 0x9a2c <vfprintf+0x12a>
    9a22:	0c 5f       	subi	r16, 0xFC	; 252
    9a24:	1f 4f       	sbci	r17, 0xFF	; 255
    9a26:	ff e3       	ldi	r31, 0x3F	; 63
    9a28:	f9 83       	std	Y+1, r31	; 0x01
    9a2a:	0d c0       	rjmp	.+26     	; 0x9a46 <vfprintf+0x144>
    9a2c:	83 36       	cpi	r24, 0x63	; 99
    9a2e:	31 f0       	breq	.+12     	; 0x9a3c <vfprintf+0x13a>
    9a30:	83 37       	cpi	r24, 0x73	; 115
    9a32:	71 f0       	breq	.+28     	; 0x9a50 <vfprintf+0x14e>
    9a34:	83 35       	cpi	r24, 0x53	; 83
    9a36:	09 f0       	breq	.+2      	; 0x9a3a <vfprintf+0x138>
    9a38:	60 c0       	rjmp	.+192    	; 0x9afa <vfprintf+0x1f8>
    9a3a:	22 c0       	rjmp	.+68     	; 0x9a80 <vfprintf+0x17e>
    9a3c:	f8 01       	movw	r30, r16
    9a3e:	80 81       	ld	r24, Z
    9a40:	89 83       	std	Y+1, r24	; 0x01
    9a42:	0e 5f       	subi	r16, 0xFE	; 254
    9a44:	1f 4f       	sbci	r17, 0xFF	; 255
    9a46:	42 01       	movw	r8, r4
    9a48:	71 e0       	ldi	r23, 0x01	; 1
    9a4a:	a7 2e       	mov	r10, r23
    9a4c:	b1 2c       	mov	r11, r1
    9a4e:	16 c0       	rjmp	.+44     	; 0x9a7c <vfprintf+0x17a>
    9a50:	62 e0       	ldi	r22, 0x02	; 2
    9a52:	66 2e       	mov	r6, r22
    9a54:	71 2c       	mov	r7, r1
    9a56:	60 0e       	add	r6, r16
    9a58:	71 1e       	adc	r7, r17
    9a5a:	f8 01       	movw	r30, r16
    9a5c:	80 80       	ld	r8, Z
    9a5e:	91 80       	ldd	r9, Z+1	; 0x01
    9a60:	26 ff       	sbrs	r18, 6
    9a62:	03 c0       	rjmp	.+6      	; 0x9a6a <vfprintf+0x168>
    9a64:	6e 2d       	mov	r22, r14
    9a66:	70 e0       	ldi	r23, 0x00	; 0
    9a68:	02 c0       	rjmp	.+4      	; 0x9a6e <vfprintf+0x16c>
    9a6a:	6f ef       	ldi	r22, 0xFF	; 255
    9a6c:	7f ef       	ldi	r23, 0xFF	; 255
    9a6e:	c4 01       	movw	r24, r8
    9a70:	2c 87       	std	Y+12, r18	; 0x0c
    9a72:	0e 94 6c 4b 	call	0x96d8	; 0x96d8 <strnlen>
    9a76:	5c 01       	movw	r10, r24
    9a78:	83 01       	movw	r16, r6
    9a7a:	2c 85       	ldd	r18, Y+12	; 0x0c
    9a7c:	2f 77       	andi	r18, 0x7F	; 127
    9a7e:	17 c0       	rjmp	.+46     	; 0x9aae <vfprintf+0x1ac>
    9a80:	52 e0       	ldi	r21, 0x02	; 2
    9a82:	65 2e       	mov	r6, r21
    9a84:	71 2c       	mov	r7, r1
    9a86:	60 0e       	add	r6, r16
    9a88:	71 1e       	adc	r7, r17
    9a8a:	f8 01       	movw	r30, r16
    9a8c:	80 80       	ld	r8, Z
    9a8e:	91 80       	ldd	r9, Z+1	; 0x01
    9a90:	26 ff       	sbrs	r18, 6
    9a92:	03 c0       	rjmp	.+6      	; 0x9a9a <vfprintf+0x198>
    9a94:	6e 2d       	mov	r22, r14
    9a96:	70 e0       	ldi	r23, 0x00	; 0
    9a98:	02 c0       	rjmp	.+4      	; 0x9a9e <vfprintf+0x19c>
    9a9a:	6f ef       	ldi	r22, 0xFF	; 255
    9a9c:	7f ef       	ldi	r23, 0xFF	; 255
    9a9e:	c4 01       	movw	r24, r8
    9aa0:	2c 87       	std	Y+12, r18	; 0x0c
    9aa2:	0e 94 cc 4e 	call	0x9d98	; 0x9d98 <strnlen_P>
    9aa6:	5c 01       	movw	r10, r24
    9aa8:	2c 85       	ldd	r18, Y+12	; 0x0c
    9aaa:	20 68       	ori	r18, 0x80	; 128
    9aac:	83 01       	movw	r16, r6
    9aae:	23 fd       	sbrc	r18, 3
    9ab0:	20 c0       	rjmp	.+64     	; 0x9af2 <vfprintf+0x1f0>
    9ab2:	08 c0       	rjmp	.+16     	; 0x9ac4 <vfprintf+0x1c2>
    9ab4:	80 e2       	ldi	r24, 0x20	; 32
    9ab6:	90 e0       	ldi	r25, 0x00	; 0
    9ab8:	b6 01       	movw	r22, r12
    9aba:	2c 87       	std	Y+12, r18	; 0x0c
    9abc:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9ac0:	fa 94       	dec	r15
    9ac2:	2c 85       	ldd	r18, Y+12	; 0x0c
    9ac4:	8f 2d       	mov	r24, r15
    9ac6:	90 e0       	ldi	r25, 0x00	; 0
    9ac8:	a8 16       	cp	r10, r24
    9aca:	b9 06       	cpc	r11, r25
    9acc:	98 f3       	brcs	.-26     	; 0x9ab4 <vfprintf+0x1b2>
    9ace:	11 c0       	rjmp	.+34     	; 0x9af2 <vfprintf+0x1f0>
    9ad0:	f4 01       	movw	r30, r8
    9ad2:	27 fd       	sbrc	r18, 7
    9ad4:	85 91       	lpm	r24, Z+
    9ad6:	27 ff       	sbrs	r18, 7
    9ad8:	81 91       	ld	r24, Z+
    9ada:	4f 01       	movw	r8, r30
    9adc:	90 e0       	ldi	r25, 0x00	; 0
    9ade:	b6 01       	movw	r22, r12
    9ae0:	2c 87       	std	Y+12, r18	; 0x0c
    9ae2:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9ae6:	2c 85       	ldd	r18, Y+12	; 0x0c
    9ae8:	f1 10       	cpse	r15, r1
    9aea:	fa 94       	dec	r15
    9aec:	08 94       	sec
    9aee:	a1 08       	sbc	r10, r1
    9af0:	b1 08       	sbc	r11, r1
    9af2:	a1 14       	cp	r10, r1
    9af4:	b1 04       	cpc	r11, r1
    9af6:	61 f7       	brne	.-40     	; 0x9ad0 <vfprintf+0x1ce>
    9af8:	f1 c0       	rjmp	.+482    	; 0x9cdc <vfprintf+0x3da>
    9afa:	84 36       	cpi	r24, 0x64	; 100
    9afc:	11 f0       	breq	.+4      	; 0x9b02 <vfprintf+0x200>
    9afe:	89 36       	cpi	r24, 0x69	; 105
    9b00:	49 f5       	brne	.+82     	; 0x9b54 <vfprintf+0x252>
    9b02:	27 ff       	sbrs	r18, 7
    9b04:	08 c0       	rjmp	.+16     	; 0x9b16 <vfprintf+0x214>
    9b06:	f8 01       	movw	r30, r16
    9b08:	60 81       	ld	r22, Z
    9b0a:	71 81       	ldd	r23, Z+1	; 0x01
    9b0c:	82 81       	ldd	r24, Z+2	; 0x02
    9b0e:	93 81       	ldd	r25, Z+3	; 0x03
    9b10:	0c 5f       	subi	r16, 0xFC	; 252
    9b12:	1f 4f       	sbci	r17, 0xFF	; 255
    9b14:	09 c0       	rjmp	.+18     	; 0x9b28 <vfprintf+0x226>
    9b16:	f8 01       	movw	r30, r16
    9b18:	60 81       	ld	r22, Z
    9b1a:	71 81       	ldd	r23, Z+1	; 0x01
    9b1c:	88 27       	eor	r24, r24
    9b1e:	77 fd       	sbrc	r23, 7
    9b20:	80 95       	com	r24
    9b22:	98 2f       	mov	r25, r24
    9b24:	0e 5f       	subi	r16, 0xFE	; 254
    9b26:	1f 4f       	sbci	r17, 0xFF	; 255
    9b28:	4f e6       	ldi	r20, 0x6F	; 111
    9b2a:	b4 2e       	mov	r11, r20
    9b2c:	b2 22       	and	r11, r18
    9b2e:	97 ff       	sbrs	r25, 7
    9b30:	09 c0       	rjmp	.+18     	; 0x9b44 <vfprintf+0x242>
    9b32:	90 95       	com	r25
    9b34:	80 95       	com	r24
    9b36:	70 95       	com	r23
    9b38:	61 95       	neg	r22
    9b3a:	7f 4f       	sbci	r23, 0xFF	; 255
    9b3c:	8f 4f       	sbci	r24, 0xFF	; 255
    9b3e:	9f 4f       	sbci	r25, 0xFF	; 255
    9b40:	f0 e8       	ldi	r31, 0x80	; 128
    9b42:	bf 2a       	or	r11, r31
    9b44:	a2 01       	movw	r20, r4
    9b46:	2a e0       	ldi	r18, 0x0A	; 10
    9b48:	30 e0       	ldi	r19, 0x00	; 0
    9b4a:	0e 94 19 4f 	call	0x9e32	; 0x9e32 <__ultoa_invert>
    9b4e:	78 2e       	mov	r7, r24
    9b50:	74 18       	sub	r7, r4
    9b52:	45 c0       	rjmp	.+138    	; 0x9bde <vfprintf+0x2dc>
    9b54:	85 37       	cpi	r24, 0x75	; 117
    9b56:	31 f4       	brne	.+12     	; 0x9b64 <vfprintf+0x262>
    9b58:	3f ee       	ldi	r19, 0xEF	; 239
    9b5a:	b3 2e       	mov	r11, r19
    9b5c:	b2 22       	and	r11, r18
    9b5e:	2a e0       	ldi	r18, 0x0A	; 10
    9b60:	30 e0       	ldi	r19, 0x00	; 0
    9b62:	25 c0       	rjmp	.+74     	; 0x9bae <vfprintf+0x2ac>
    9b64:	99 ef       	ldi	r25, 0xF9	; 249
    9b66:	b9 2e       	mov	r11, r25
    9b68:	b2 22       	and	r11, r18
    9b6a:	8f 36       	cpi	r24, 0x6F	; 111
    9b6c:	c1 f0       	breq	.+48     	; 0x9b9e <vfprintf+0x29c>
    9b6e:	80 37       	cpi	r24, 0x70	; 112
    9b70:	20 f4       	brcc	.+8      	; 0x9b7a <vfprintf+0x278>
    9b72:	88 35       	cpi	r24, 0x58	; 88
    9b74:	09 f0       	breq	.+2      	; 0x9b78 <vfprintf+0x276>
    9b76:	b5 c0       	rjmp	.+362    	; 0x9ce2 <vfprintf+0x3e0>
    9b78:	0d c0       	rjmp	.+26     	; 0x9b94 <vfprintf+0x292>
    9b7a:	80 37       	cpi	r24, 0x70	; 112
    9b7c:	21 f0       	breq	.+8      	; 0x9b86 <vfprintf+0x284>
    9b7e:	88 37       	cpi	r24, 0x78	; 120
    9b80:	09 f0       	breq	.+2      	; 0x9b84 <vfprintf+0x282>
    9b82:	af c0       	rjmp	.+350    	; 0x9ce2 <vfprintf+0x3e0>
    9b84:	02 c0       	rjmp	.+4      	; 0x9b8a <vfprintf+0x288>
    9b86:	20 e1       	ldi	r18, 0x10	; 16
    9b88:	b2 2a       	or	r11, r18
    9b8a:	b4 fe       	sbrs	r11, 4
    9b8c:	0b c0       	rjmp	.+22     	; 0x9ba4 <vfprintf+0x2a2>
    9b8e:	84 e0       	ldi	r24, 0x04	; 4
    9b90:	b8 2a       	or	r11, r24
    9b92:	08 c0       	rjmp	.+16     	; 0x9ba4 <vfprintf+0x2a2>
    9b94:	b4 fe       	sbrs	r11, 4
    9b96:	09 c0       	rjmp	.+18     	; 0x9baa <vfprintf+0x2a8>
    9b98:	e6 e0       	ldi	r30, 0x06	; 6
    9b9a:	be 2a       	or	r11, r30
    9b9c:	06 c0       	rjmp	.+12     	; 0x9baa <vfprintf+0x2a8>
    9b9e:	28 e0       	ldi	r18, 0x08	; 8
    9ba0:	30 e0       	ldi	r19, 0x00	; 0
    9ba2:	05 c0       	rjmp	.+10     	; 0x9bae <vfprintf+0x2ac>
    9ba4:	20 e1       	ldi	r18, 0x10	; 16
    9ba6:	30 e0       	ldi	r19, 0x00	; 0
    9ba8:	02 c0       	rjmp	.+4      	; 0x9bae <vfprintf+0x2ac>
    9baa:	20 e1       	ldi	r18, 0x10	; 16
    9bac:	32 e0       	ldi	r19, 0x02	; 2
    9bae:	b7 fe       	sbrs	r11, 7
    9bb0:	08 c0       	rjmp	.+16     	; 0x9bc2 <vfprintf+0x2c0>
    9bb2:	f8 01       	movw	r30, r16
    9bb4:	60 81       	ld	r22, Z
    9bb6:	71 81       	ldd	r23, Z+1	; 0x01
    9bb8:	82 81       	ldd	r24, Z+2	; 0x02
    9bba:	93 81       	ldd	r25, Z+3	; 0x03
    9bbc:	0c 5f       	subi	r16, 0xFC	; 252
    9bbe:	1f 4f       	sbci	r17, 0xFF	; 255
    9bc0:	07 c0       	rjmp	.+14     	; 0x9bd0 <vfprintf+0x2ce>
    9bc2:	f8 01       	movw	r30, r16
    9bc4:	60 81       	ld	r22, Z
    9bc6:	71 81       	ldd	r23, Z+1	; 0x01
    9bc8:	80 e0       	ldi	r24, 0x00	; 0
    9bca:	90 e0       	ldi	r25, 0x00	; 0
    9bcc:	0e 5f       	subi	r16, 0xFE	; 254
    9bce:	1f 4f       	sbci	r17, 0xFF	; 255
    9bd0:	a2 01       	movw	r20, r4
    9bd2:	0e 94 19 4f 	call	0x9e32	; 0x9e32 <__ultoa_invert>
    9bd6:	78 2e       	mov	r7, r24
    9bd8:	74 18       	sub	r7, r4
    9bda:	ff e7       	ldi	r31, 0x7F	; 127
    9bdc:	bf 22       	and	r11, r31
    9bde:	b6 fe       	sbrs	r11, 6
    9be0:	0b c0       	rjmp	.+22     	; 0x9bf8 <vfprintf+0x2f6>
    9be2:	2e ef       	ldi	r18, 0xFE	; 254
    9be4:	b2 22       	and	r11, r18
    9be6:	7e 14       	cp	r7, r14
    9be8:	38 f4       	brcc	.+14     	; 0x9bf8 <vfprintf+0x2f6>
    9bea:	b4 fe       	sbrs	r11, 4
    9bec:	07 c0       	rjmp	.+14     	; 0x9bfc <vfprintf+0x2fa>
    9bee:	b2 fc       	sbrc	r11, 2
    9bf0:	05 c0       	rjmp	.+10     	; 0x9bfc <vfprintf+0x2fa>
    9bf2:	8f ee       	ldi	r24, 0xEF	; 239
    9bf4:	b8 22       	and	r11, r24
    9bf6:	02 c0       	rjmp	.+4      	; 0x9bfc <vfprintf+0x2fa>
    9bf8:	a7 2c       	mov	r10, r7
    9bfa:	01 c0       	rjmp	.+2      	; 0x9bfe <vfprintf+0x2fc>
    9bfc:	ae 2c       	mov	r10, r14
    9bfe:	8b 2d       	mov	r24, r11
    9c00:	90 e0       	ldi	r25, 0x00	; 0
    9c02:	b4 fe       	sbrs	r11, 4
    9c04:	0d c0       	rjmp	.+26     	; 0x9c20 <vfprintf+0x31e>
    9c06:	fe 01       	movw	r30, r28
    9c08:	e7 0d       	add	r30, r7
    9c0a:	f1 1d       	adc	r31, r1
    9c0c:	20 81       	ld	r18, Z
    9c0e:	20 33       	cpi	r18, 0x30	; 48
    9c10:	19 f4       	brne	.+6      	; 0x9c18 <vfprintf+0x316>
    9c12:	e9 ee       	ldi	r30, 0xE9	; 233
    9c14:	be 22       	and	r11, r30
    9c16:	09 c0       	rjmp	.+18     	; 0x9c2a <vfprintf+0x328>
    9c18:	a3 94       	inc	r10
    9c1a:	b2 fe       	sbrs	r11, 2
    9c1c:	06 c0       	rjmp	.+12     	; 0x9c2a <vfprintf+0x328>
    9c1e:	04 c0       	rjmp	.+8      	; 0x9c28 <vfprintf+0x326>
    9c20:	86 78       	andi	r24, 0x86	; 134
    9c22:	90 70       	andi	r25, 0x00	; 0
    9c24:	00 97       	sbiw	r24, 0x00	; 0
    9c26:	09 f0       	breq	.+2      	; 0x9c2a <vfprintf+0x328>
    9c28:	a3 94       	inc	r10
    9c2a:	8b 2c       	mov	r8, r11
    9c2c:	99 24       	eor	r9, r9
    9c2e:	b3 fc       	sbrc	r11, 3
    9c30:	14 c0       	rjmp	.+40     	; 0x9c5a <vfprintf+0x358>
    9c32:	b0 fe       	sbrs	r11, 0
    9c34:	0f c0       	rjmp	.+30     	; 0x9c54 <vfprintf+0x352>
    9c36:	af 14       	cp	r10, r15
    9c38:	28 f4       	brcc	.+10     	; 0x9c44 <vfprintf+0x342>
    9c3a:	e7 2c       	mov	r14, r7
    9c3c:	ef 0c       	add	r14, r15
    9c3e:	ea 18       	sub	r14, r10
    9c40:	af 2c       	mov	r10, r15
    9c42:	08 c0       	rjmp	.+16     	; 0x9c54 <vfprintf+0x352>
    9c44:	e7 2c       	mov	r14, r7
    9c46:	06 c0       	rjmp	.+12     	; 0x9c54 <vfprintf+0x352>
    9c48:	80 e2       	ldi	r24, 0x20	; 32
    9c4a:	90 e0       	ldi	r25, 0x00	; 0
    9c4c:	b6 01       	movw	r22, r12
    9c4e:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9c52:	a3 94       	inc	r10
    9c54:	af 14       	cp	r10, r15
    9c56:	c0 f3       	brcs	.-16     	; 0x9c48 <vfprintf+0x346>
    9c58:	04 c0       	rjmp	.+8      	; 0x9c62 <vfprintf+0x360>
    9c5a:	af 14       	cp	r10, r15
    9c5c:	10 f4       	brcc	.+4      	; 0x9c62 <vfprintf+0x360>
    9c5e:	fa 18       	sub	r15, r10
    9c60:	01 c0       	rjmp	.+2      	; 0x9c64 <vfprintf+0x362>
    9c62:	ff 24       	eor	r15, r15
    9c64:	84 fe       	sbrs	r8, 4
    9c66:	0f c0       	rjmp	.+30     	; 0x9c86 <vfprintf+0x384>
    9c68:	80 e3       	ldi	r24, 0x30	; 48
    9c6a:	90 e0       	ldi	r25, 0x00	; 0
    9c6c:	b6 01       	movw	r22, r12
    9c6e:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9c72:	82 fe       	sbrs	r8, 2
    9c74:	1f c0       	rjmp	.+62     	; 0x9cb4 <vfprintf+0x3b2>
    9c76:	81 fe       	sbrs	r8, 1
    9c78:	03 c0       	rjmp	.+6      	; 0x9c80 <vfprintf+0x37e>
    9c7a:	88 e5       	ldi	r24, 0x58	; 88
    9c7c:	90 e0       	ldi	r25, 0x00	; 0
    9c7e:	10 c0       	rjmp	.+32     	; 0x9ca0 <vfprintf+0x39e>
    9c80:	88 e7       	ldi	r24, 0x78	; 120
    9c82:	90 e0       	ldi	r25, 0x00	; 0
    9c84:	0d c0       	rjmp	.+26     	; 0x9ca0 <vfprintf+0x39e>
    9c86:	c4 01       	movw	r24, r8
    9c88:	86 78       	andi	r24, 0x86	; 134
    9c8a:	90 70       	andi	r25, 0x00	; 0
    9c8c:	00 97       	sbiw	r24, 0x00	; 0
    9c8e:	91 f0       	breq	.+36     	; 0x9cb4 <vfprintf+0x3b2>
    9c90:	81 fc       	sbrc	r8, 1
    9c92:	02 c0       	rjmp	.+4      	; 0x9c98 <vfprintf+0x396>
    9c94:	80 e2       	ldi	r24, 0x20	; 32
    9c96:	01 c0       	rjmp	.+2      	; 0x9c9a <vfprintf+0x398>
    9c98:	8b e2       	ldi	r24, 0x2B	; 43
    9c9a:	b7 fc       	sbrc	r11, 7
    9c9c:	8d e2       	ldi	r24, 0x2D	; 45
    9c9e:	90 e0       	ldi	r25, 0x00	; 0
    9ca0:	b6 01       	movw	r22, r12
    9ca2:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9ca6:	06 c0       	rjmp	.+12     	; 0x9cb4 <vfprintf+0x3b2>
    9ca8:	80 e3       	ldi	r24, 0x30	; 48
    9caa:	90 e0       	ldi	r25, 0x00	; 0
    9cac:	b6 01       	movw	r22, r12
    9cae:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9cb2:	ea 94       	dec	r14
    9cb4:	7e 14       	cp	r7, r14
    9cb6:	c0 f3       	brcs	.-16     	; 0x9ca8 <vfprintf+0x3a6>
    9cb8:	7a 94       	dec	r7
    9cba:	f2 01       	movw	r30, r4
    9cbc:	e7 0d       	add	r30, r7
    9cbe:	f1 1d       	adc	r31, r1
    9cc0:	80 81       	ld	r24, Z
    9cc2:	90 e0       	ldi	r25, 0x00	; 0
    9cc4:	b6 01       	movw	r22, r12
    9cc6:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9cca:	77 20       	and	r7, r7
    9ccc:	a9 f7       	brne	.-22     	; 0x9cb8 <vfprintf+0x3b6>
    9cce:	06 c0       	rjmp	.+12     	; 0x9cdc <vfprintf+0x3da>
    9cd0:	80 e2       	ldi	r24, 0x20	; 32
    9cd2:	90 e0       	ldi	r25, 0x00	; 0
    9cd4:	b6 01       	movw	r22, r12
    9cd6:	0e 94 77 4b 	call	0x96ee	; 0x96ee <fputc>
    9cda:	fa 94       	dec	r15
    9cdc:	ff 20       	and	r15, r15
    9cde:	c1 f7       	brne	.-16     	; 0x9cd0 <vfprintf+0x3ce>
    9ce0:	37 ce       	rjmp	.-914    	; 0x9950 <vfprintf+0x4e>
    9ce2:	f6 01       	movw	r30, r12
    9ce4:	26 81       	ldd	r18, Z+6	; 0x06
    9ce6:	37 81       	ldd	r19, Z+7	; 0x07
    9ce8:	02 c0       	rjmp	.+4      	; 0x9cee <vfprintf+0x3ec>
    9cea:	2f ef       	ldi	r18, 0xFF	; 255
    9cec:	3f ef       	ldi	r19, 0xFF	; 255
    9cee:	c9 01       	movw	r24, r18
    9cf0:	2c 96       	adiw	r28, 0x0c	; 12
    9cf2:	0f b6       	in	r0, 0x3f	; 63
    9cf4:	f8 94       	cli
    9cf6:	de bf       	out	0x3e, r29	; 62
    9cf8:	0f be       	out	0x3f, r0	; 63
    9cfa:	cd bf       	out	0x3d, r28	; 61
    9cfc:	cf 91       	pop	r28
    9cfe:	df 91       	pop	r29
    9d00:	1f 91       	pop	r17
    9d02:	0f 91       	pop	r16
    9d04:	ff 90       	pop	r15
    9d06:	ef 90       	pop	r14
    9d08:	df 90       	pop	r13
    9d0a:	cf 90       	pop	r12
    9d0c:	bf 90       	pop	r11
    9d0e:	af 90       	pop	r10
    9d10:	9f 90       	pop	r9
    9d12:	8f 90       	pop	r8
    9d14:	7f 90       	pop	r7
    9d16:	6f 90       	pop	r6
    9d18:	5f 90       	pop	r5
    9d1a:	4f 90       	pop	r4
    9d1c:	3f 90       	pop	r3
    9d1e:	2f 90       	pop	r2
    9d20:	08 95       	ret

00009d22 <__eerd_block_m128rfa1>:
    9d22:	dc 01       	movw	r26, r24
    9d24:	cb 01       	movw	r24, r22

00009d26 <__eerd_blraw_m128rfa1>:
    9d26:	fc 01       	movw	r30, r24
    9d28:	f9 99       	sbic	0x1f, 1	; 31
    9d2a:	fe cf       	rjmp	.-4      	; 0x9d28 <__eerd_blraw_m128rfa1+0x2>
    9d2c:	06 c0       	rjmp	.+12     	; 0x9d3a <__eerd_blraw_m128rfa1+0x14>
    9d2e:	f2 bd       	out	0x22, r31	; 34
    9d30:	e1 bd       	out	0x21, r30	; 33
    9d32:	f8 9a       	sbi	0x1f, 0	; 31
    9d34:	31 96       	adiw	r30, 0x01	; 1
    9d36:	00 b4       	in	r0, 0x20	; 32
    9d38:	0d 92       	st	X+, r0
    9d3a:	41 50       	subi	r20, 0x01	; 1
    9d3c:	50 40       	sbci	r21, 0x00	; 0
    9d3e:	b8 f7       	brcc	.-18     	; 0x9d2e <__eerd_blraw_m128rfa1+0x8>
    9d40:	08 95       	ret

00009d42 <__eerd_byte_m128rfa1>:
    9d42:	f9 99       	sbic	0x1f, 1	; 31
    9d44:	fe cf       	rjmp	.-4      	; 0x9d42 <__eerd_byte_m128rfa1>
    9d46:	92 bd       	out	0x22, r25	; 34
    9d48:	81 bd       	out	0x21, r24	; 33
    9d4a:	f8 9a       	sbi	0x1f, 0	; 31
    9d4c:	99 27       	eor	r25, r25
    9d4e:	80 b5       	in	r24, 0x20	; 32
    9d50:	08 95       	ret

00009d52 <__eerd_word_m128rfa1>:
    9d52:	a8 e1       	ldi	r26, 0x18	; 24
    9d54:	b0 e0       	ldi	r27, 0x00	; 0
    9d56:	42 e0       	ldi	r20, 0x02	; 2
    9d58:	50 e0       	ldi	r21, 0x00	; 0
    9d5a:	0c 94 93 4e 	jmp	0x9d26	; 0x9d26 <__eerd_blraw_m128rfa1>

00009d5e <__eewr_block_m128rfa1>:
    9d5e:	dc 01       	movw	r26, r24
    9d60:	cb 01       	movw	r24, r22
    9d62:	03 c0       	rjmp	.+6      	; 0x9d6a <__eewr_block_m128rfa1+0xc>
    9d64:	2d 91       	ld	r18, X+
    9d66:	0e 94 ba 4e 	call	0x9d74	; 0x9d74 <__eewr_r18_m128rfa1>
    9d6a:	41 50       	subi	r20, 0x01	; 1
    9d6c:	50 40       	sbci	r21, 0x00	; 0
    9d6e:	d0 f7       	brcc	.-12     	; 0x9d64 <__eewr_block_m128rfa1+0x6>
    9d70:	08 95       	ret

00009d72 <__eewr_byte_m128rfa1>:
    9d72:	26 2f       	mov	r18, r22

00009d74 <__eewr_r18_m128rfa1>:
    9d74:	f9 99       	sbic	0x1f, 1	; 31
    9d76:	fe cf       	rjmp	.-4      	; 0x9d74 <__eewr_r18_m128rfa1>
    9d78:	1f ba       	out	0x1f, r1	; 31
    9d7a:	92 bd       	out	0x22, r25	; 34
    9d7c:	81 bd       	out	0x21, r24	; 33
    9d7e:	20 bd       	out	0x20, r18	; 32
    9d80:	0f b6       	in	r0, 0x3f	; 63
    9d82:	f8 94       	cli
    9d84:	fa 9a       	sbi	0x1f, 2	; 31
    9d86:	f9 9a       	sbi	0x1f, 1	; 31
    9d88:	0f be       	out	0x3f, r0	; 63
    9d8a:	01 96       	adiw	r24, 0x01	; 1
    9d8c:	08 95       	ret

00009d8e <__eewr_word_m128rfa1>:
    9d8e:	0e 94 b9 4e 	call	0x9d72	; 0x9d72 <__eewr_byte_m128rfa1>
    9d92:	27 2f       	mov	r18, r23
    9d94:	0c 94 ba 4e 	jmp	0x9d74	; 0x9d74 <__eewr_r18_m128rfa1>

00009d98 <strnlen_P>:
    9d98:	fc 01       	movw	r30, r24
    9d9a:	05 90       	lpm	r0, Z+
    9d9c:	61 50       	subi	r22, 0x01	; 1
    9d9e:	70 40       	sbci	r23, 0x00	; 0
    9da0:	01 10       	cpse	r0, r1
    9da2:	d8 f7       	brcc	.-10     	; 0x9d9a <strnlen_P+0x2>
    9da4:	80 95       	com	r24
    9da6:	90 95       	com	r25
    9da8:	8e 0f       	add	r24, r30
    9daa:	9f 1f       	adc	r25, r31
    9dac:	08 95       	ret

00009dae <fgetc>:
    9dae:	cf 93       	push	r28
    9db0:	df 93       	push	r29
    9db2:	ec 01       	movw	r28, r24
    9db4:	3b 81       	ldd	r19, Y+3	; 0x03
    9db6:	30 ff       	sbrs	r19, 0
    9db8:	36 c0       	rjmp	.+108    	; 0x9e26 <fgetc+0x78>
    9dba:	36 ff       	sbrs	r19, 6
    9dbc:	09 c0       	rjmp	.+18     	; 0x9dd0 <fgetc+0x22>
    9dbe:	3f 7b       	andi	r19, 0xBF	; 191
    9dc0:	3b 83       	std	Y+3, r19	; 0x03
    9dc2:	8e 81       	ldd	r24, Y+6	; 0x06
    9dc4:	9f 81       	ldd	r25, Y+7	; 0x07
    9dc6:	01 96       	adiw	r24, 0x01	; 1
    9dc8:	9f 83       	std	Y+7, r25	; 0x07
    9dca:	8e 83       	std	Y+6, r24	; 0x06
    9dcc:	2a 81       	ldd	r18, Y+2	; 0x02
    9dce:	29 c0       	rjmp	.+82     	; 0x9e22 <fgetc+0x74>
    9dd0:	32 ff       	sbrs	r19, 2
    9dd2:	0f c0       	rjmp	.+30     	; 0x9df2 <fgetc+0x44>
    9dd4:	e8 81       	ld	r30, Y
    9dd6:	f9 81       	ldd	r31, Y+1	; 0x01
    9dd8:	80 81       	ld	r24, Z
    9dda:	99 27       	eor	r25, r25
    9ddc:	87 fd       	sbrc	r24, 7
    9dde:	90 95       	com	r25
    9de0:	00 97       	sbiw	r24, 0x00	; 0
    9de2:	19 f4       	brne	.+6      	; 0x9dea <fgetc+0x3c>
    9de4:	30 62       	ori	r19, 0x20	; 32
    9de6:	3b 83       	std	Y+3, r19	; 0x03
    9de8:	1e c0       	rjmp	.+60     	; 0x9e26 <fgetc+0x78>
    9dea:	31 96       	adiw	r30, 0x01	; 1
    9dec:	f9 83       	std	Y+1, r31	; 0x01
    9dee:	e8 83       	st	Y, r30
    9df0:	11 c0       	rjmp	.+34     	; 0x9e14 <fgetc+0x66>
    9df2:	ea 85       	ldd	r30, Y+10	; 0x0a
    9df4:	fb 85       	ldd	r31, Y+11	; 0x0b
    9df6:	ce 01       	movw	r24, r28
    9df8:	09 95       	icall
    9dfa:	97 ff       	sbrs	r25, 7
    9dfc:	0b c0       	rjmp	.+22     	; 0x9e14 <fgetc+0x66>
    9dfe:	2b 81       	ldd	r18, Y+3	; 0x03
    9e00:	3f ef       	ldi	r19, 0xFF	; 255
    9e02:	8f 3f       	cpi	r24, 0xFF	; 255
    9e04:	93 07       	cpc	r25, r19
    9e06:	11 f4       	brne	.+4      	; 0x9e0c <fgetc+0x5e>
    9e08:	80 e1       	ldi	r24, 0x10	; 16
    9e0a:	01 c0       	rjmp	.+2      	; 0x9e0e <fgetc+0x60>
    9e0c:	80 e2       	ldi	r24, 0x20	; 32
    9e0e:	82 2b       	or	r24, r18
    9e10:	8b 83       	std	Y+3, r24	; 0x03
    9e12:	09 c0       	rjmp	.+18     	; 0x9e26 <fgetc+0x78>
    9e14:	2e 81       	ldd	r18, Y+6	; 0x06
    9e16:	3f 81       	ldd	r19, Y+7	; 0x07
    9e18:	2f 5f       	subi	r18, 0xFF	; 255
    9e1a:	3f 4f       	sbci	r19, 0xFF	; 255
    9e1c:	3f 83       	std	Y+7, r19	; 0x07
    9e1e:	2e 83       	std	Y+6, r18	; 0x06
    9e20:	28 2f       	mov	r18, r24
    9e22:	30 e0       	ldi	r19, 0x00	; 0
    9e24:	02 c0       	rjmp	.+4      	; 0x9e2a <fgetc+0x7c>
    9e26:	2f ef       	ldi	r18, 0xFF	; 255
    9e28:	3f ef       	ldi	r19, 0xFF	; 255
    9e2a:	c9 01       	movw	r24, r18
    9e2c:	df 91       	pop	r29
    9e2e:	cf 91       	pop	r28
    9e30:	08 95       	ret

00009e32 <__ultoa_invert>:
    9e32:	fa 01       	movw	r30, r20
    9e34:	aa 27       	eor	r26, r26
    9e36:	28 30       	cpi	r18, 0x08	; 8
    9e38:	51 f1       	breq	.+84     	; 0x9e8e <__ultoa_invert+0x5c>
    9e3a:	20 31       	cpi	r18, 0x10	; 16
    9e3c:	81 f1       	breq	.+96     	; 0x9e9e <__ultoa_invert+0x6c>
    9e3e:	e8 94       	clt
    9e40:	6f 93       	push	r22
    9e42:	6e 7f       	andi	r22, 0xFE	; 254
    9e44:	6e 5f       	subi	r22, 0xFE	; 254
    9e46:	7f 4f       	sbci	r23, 0xFF	; 255
    9e48:	8f 4f       	sbci	r24, 0xFF	; 255
    9e4a:	9f 4f       	sbci	r25, 0xFF	; 255
    9e4c:	af 4f       	sbci	r26, 0xFF	; 255
    9e4e:	b1 e0       	ldi	r27, 0x01	; 1
    9e50:	3e d0       	rcall	.+124    	; 0x9ece <__ultoa_invert+0x9c>
    9e52:	b4 e0       	ldi	r27, 0x04	; 4
    9e54:	3c d0       	rcall	.+120    	; 0x9ece <__ultoa_invert+0x9c>
    9e56:	67 0f       	add	r22, r23
    9e58:	78 1f       	adc	r23, r24
    9e5a:	89 1f       	adc	r24, r25
    9e5c:	9a 1f       	adc	r25, r26
    9e5e:	a1 1d       	adc	r26, r1
    9e60:	68 0f       	add	r22, r24
    9e62:	79 1f       	adc	r23, r25
    9e64:	8a 1f       	adc	r24, r26
    9e66:	91 1d       	adc	r25, r1
    9e68:	a1 1d       	adc	r26, r1
    9e6a:	6a 0f       	add	r22, r26
    9e6c:	71 1d       	adc	r23, r1
    9e6e:	81 1d       	adc	r24, r1
    9e70:	91 1d       	adc	r25, r1
    9e72:	a1 1d       	adc	r26, r1
    9e74:	20 d0       	rcall	.+64     	; 0x9eb6 <__ultoa_invert+0x84>
    9e76:	09 f4       	brne	.+2      	; 0x9e7a <__ultoa_invert+0x48>
    9e78:	68 94       	set
    9e7a:	3f 91       	pop	r19
    9e7c:	2a e0       	ldi	r18, 0x0A	; 10
    9e7e:	26 9f       	mul	r18, r22
    9e80:	11 24       	eor	r1, r1
    9e82:	30 19       	sub	r19, r0
    9e84:	30 5d       	subi	r19, 0xD0	; 208
    9e86:	31 93       	st	Z+, r19
    9e88:	de f6       	brtc	.-74     	; 0x9e40 <__ultoa_invert+0xe>
    9e8a:	cf 01       	movw	r24, r30
    9e8c:	08 95       	ret
    9e8e:	46 2f       	mov	r20, r22
    9e90:	47 70       	andi	r20, 0x07	; 7
    9e92:	40 5d       	subi	r20, 0xD0	; 208
    9e94:	41 93       	st	Z+, r20
    9e96:	b3 e0       	ldi	r27, 0x03	; 3
    9e98:	0f d0       	rcall	.+30     	; 0x9eb8 <__ultoa_invert+0x86>
    9e9a:	c9 f7       	brne	.-14     	; 0x9e8e <__ultoa_invert+0x5c>
    9e9c:	f6 cf       	rjmp	.-20     	; 0x9e8a <__ultoa_invert+0x58>
    9e9e:	46 2f       	mov	r20, r22
    9ea0:	4f 70       	andi	r20, 0x0F	; 15
    9ea2:	40 5d       	subi	r20, 0xD0	; 208
    9ea4:	4a 33       	cpi	r20, 0x3A	; 58
    9ea6:	18 f0       	brcs	.+6      	; 0x9eae <__ultoa_invert+0x7c>
    9ea8:	49 5d       	subi	r20, 0xD9	; 217
    9eaa:	31 fd       	sbrc	r19, 1
    9eac:	40 52       	subi	r20, 0x20	; 32
    9eae:	41 93       	st	Z+, r20
    9eb0:	02 d0       	rcall	.+4      	; 0x9eb6 <__ultoa_invert+0x84>
    9eb2:	a9 f7       	brne	.-22     	; 0x9e9e <__ultoa_invert+0x6c>
    9eb4:	ea cf       	rjmp	.-44     	; 0x9e8a <__ultoa_invert+0x58>
    9eb6:	b4 e0       	ldi	r27, 0x04	; 4
    9eb8:	a6 95       	lsr	r26
    9eba:	97 95       	ror	r25
    9ebc:	87 95       	ror	r24
    9ebe:	77 95       	ror	r23
    9ec0:	67 95       	ror	r22
    9ec2:	ba 95       	dec	r27
    9ec4:	c9 f7       	brne	.-14     	; 0x9eb8 <__ultoa_invert+0x86>
    9ec6:	00 97       	sbiw	r24, 0x00	; 0
    9ec8:	61 05       	cpc	r22, r1
    9eca:	71 05       	cpc	r23, r1
    9ecc:	08 95       	ret
    9ece:	9b 01       	movw	r18, r22
    9ed0:	ac 01       	movw	r20, r24
    9ed2:	0a 2e       	mov	r0, r26
    9ed4:	06 94       	lsr	r0
    9ed6:	57 95       	ror	r21
    9ed8:	47 95       	ror	r20
    9eda:	37 95       	ror	r19
    9edc:	27 95       	ror	r18
    9ede:	ba 95       	dec	r27
    9ee0:	c9 f7       	brne	.-14     	; 0x9ed4 <__ultoa_invert+0xa2>
    9ee2:	62 0f       	add	r22, r18
    9ee4:	73 1f       	adc	r23, r19
    9ee6:	84 1f       	adc	r24, r20
    9ee8:	95 1f       	adc	r25, r21
    9eea:	a0 1d       	adc	r26, r0
    9eec:	08 95       	ret

00009eee <__mulsi3>:
    9eee:	62 9f       	mul	r22, r18
    9ef0:	d0 01       	movw	r26, r0
    9ef2:	73 9f       	mul	r23, r19
    9ef4:	f0 01       	movw	r30, r0
    9ef6:	82 9f       	mul	r24, r18
    9ef8:	e0 0d       	add	r30, r0
    9efa:	f1 1d       	adc	r31, r1
    9efc:	64 9f       	mul	r22, r20
    9efe:	e0 0d       	add	r30, r0
    9f00:	f1 1d       	adc	r31, r1
    9f02:	92 9f       	mul	r25, r18
    9f04:	f0 0d       	add	r31, r0
    9f06:	83 9f       	mul	r24, r19
    9f08:	f0 0d       	add	r31, r0
    9f0a:	74 9f       	mul	r23, r20
    9f0c:	f0 0d       	add	r31, r0
    9f0e:	65 9f       	mul	r22, r21
    9f10:	f0 0d       	add	r31, r0
    9f12:	99 27       	eor	r25, r25
    9f14:	72 9f       	mul	r23, r18
    9f16:	b0 0d       	add	r27, r0
    9f18:	e1 1d       	adc	r30, r1
    9f1a:	f9 1f       	adc	r31, r25
    9f1c:	63 9f       	mul	r22, r19
    9f1e:	b0 0d       	add	r27, r0
    9f20:	e1 1d       	adc	r30, r1
    9f22:	f9 1f       	adc	r31, r25
    9f24:	bd 01       	movw	r22, r26
    9f26:	cf 01       	movw	r24, r30
    9f28:	11 24       	eor	r1, r1
    9f2a:	08 95       	ret

00009f2c <__divmodsi4>:
    9f2c:	97 fb       	bst	r25, 7
    9f2e:	09 2e       	mov	r0, r25
    9f30:	05 26       	eor	r0, r21
    9f32:	0e d0       	rcall	.+28     	; 0x9f50 <__divmodsi4_neg1>
    9f34:	57 fd       	sbrc	r21, 7
    9f36:	04 d0       	rcall	.+8      	; 0x9f40 <__divmodsi4_neg2>
    9f38:	ed da       	rcall	.-2598   	; 0x9514 <__udivmodsi4>
    9f3a:	0a d0       	rcall	.+20     	; 0x9f50 <__divmodsi4_neg1>
    9f3c:	00 1c       	adc	r0, r0
    9f3e:	38 f4       	brcc	.+14     	; 0x9f4e <__divmodsi4_exit>

00009f40 <__divmodsi4_neg2>:
    9f40:	50 95       	com	r21
    9f42:	40 95       	com	r20
    9f44:	30 95       	com	r19
    9f46:	21 95       	neg	r18
    9f48:	3f 4f       	sbci	r19, 0xFF	; 255
    9f4a:	4f 4f       	sbci	r20, 0xFF	; 255
    9f4c:	5f 4f       	sbci	r21, 0xFF	; 255

00009f4e <__divmodsi4_exit>:
    9f4e:	08 95       	ret

00009f50 <__divmodsi4_neg1>:
    9f50:	f6 f7       	brtc	.-4      	; 0x9f4e <__divmodsi4_exit>
    9f52:	90 95       	com	r25
    9f54:	80 95       	com	r24
    9f56:	70 95       	com	r23
    9f58:	61 95       	neg	r22
    9f5a:	7f 4f       	sbci	r23, 0xFF	; 255
    9f5c:	8f 4f       	sbci	r24, 0xFF	; 255
    9f5e:	9f 4f       	sbci	r25, 0xFF	; 255
    9f60:	08 95       	ret

00009f62 <_exit>:
    9f62:	f8 94       	cli

00009f64 <__stop_program>:
    9f64:	ff cf       	rjmp	.-2      	; 0x9f64 <__stop_program>
